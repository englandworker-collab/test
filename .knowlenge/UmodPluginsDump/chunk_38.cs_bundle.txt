PlayerList.Count < 1)
                return;
            ConsoleNetwork.BroadcastToAllClients("chat.add", (object) 2, (object) 0, args.Length != 0 ? (object) string.Format(format, args) : (object) format);
        }

        #endregion

        #region Logic

        private string PlayerEqualNull(IPlayer player, string langKey, params object[] args)
        {
            return player == null ? string.Format(lang.GetMessage(langKey, this), args) : Lang(langKey, player.Id, args);
        }

        private void ReplyOrPutLang(IPlayer player, string langKey, params object[] args)
        {
            if(player==null)
                Puts(string.Format(lang.GetMessage(langKey, this), args));
            else
                player.Reply( Lang(langKey, player.Id, args));
        }

        private void ReplyOrPutString(IPlayer player, string message)
        {
            if (player == null)
                Puts(message);
            else
                player.Reply(message);
        }

        private int GetGambleIndex(string gambleName)//-1 if it does not exist
        {
            for (int i = 0; i < storedData.gambles.Count; i++)
            {
                if (storedData.gambles[i].name.ToLower() == gambleName.ToLower())
                    return i;//return gamble index
            }

            return -1;
        }

        private bool DoesItemExist(string name)//does this item exist?
        {
            if (ItemManager.FindItemDefinition(name) != null)
                return true;

            return false;
        }

        private string GetItemName(string shortname)
        {
            return ItemManager.FindItemDefinition(shortname).displayName.english;
        }

        private string TryToBet(BasePlayer player, string name, string number)
        {
            if (storedData.gambles.Count == 0)//no gambles
                return Lang("NoGambles", player.UserIDString);

            int index = GetGambleIndex(name);

            if (index == -1)
                return Lang("GambleNotFound", player.UserIDString);

            int num = 0;

            if (!(int.TryParse(number, out num)) || num < 1 || num > storedData.gambles[index].numbers)//is number invalid?
                return Lang("ValidNumbers", player.UserIDString, storedData.gambles[index].numbers.ToString());

            for (int j = 0; j < storedData.gambles[index].bets.Count; j++)//search this name in bets list
            {
                if (storedData.gambles[index].bets[j].player == player.userID)//name found
                    return Lang("AlreadyBet", player.UserIDString);//can't bet
            }

            Item[] items = player.inventory.AllItems();//stores all items

            for (int k = 0; k < items.Length; k++)//search for the betted item
            {
                if (items[k].info.shortname != storedData.gambles[index].item || items[k].amount < storedData.gambles[index].itemAmount)//if this isn't the item or isn't enough
                    continue;//keep searching

                if (items[k].amount == storedData.gambles[index].itemAmount)//if exact amount
                    items[k].RemoveFromContainer();

                else//haves more
                {
                    items[k].amount -= storedData.gambles[index].itemAmount;//just subtract
                    items[k].MarkDirty();//update UI
                }

                storedData.gambles[index].bets.Add(new Bets(player.userID, num));//add this bet to the gamble
                return Lang("BetPlaced", player.UserIDString, name);
            }

            return Lang("NotEnoughItems", player.UserIDString);
        }

        private string TryToSet(string name, string item, string itemA, string number, IPlayer player = null)
        {
            if (!DoesItemExist(item))
                return PlayerEqualNull(player, "ItemNotFound", item);
                
            int itemAmount;

            if (!int.TryParse(itemA, out itemAmount) || itemAmount > ItemManager.FindItemDefinition(item).stackable || itemAmount <= 0)//is item amount invalid?
                return PlayerEqualNull(player, "InvalidItemAmount");

            int numbers;

            if (!int.TryParse(number, out numbers) || numbers <= 1)//is gamble numbers invalid?
                return PlayerEqualNull(player, "InvalidNumbers");

            if (GetGambleIndex(name) != -1)//if gamble already exists
                return PlayerEqualNull(player, "ExistingGamble");
            

            CreateGamble(name, item, itemAmount, numbers, player);
            return PlayerEqualNull(player, "GambleCreated", name);
        }

        private void CreateGamble(string name, string iName, int iAmount, int numbers, IPlayer player = null)
        {
            storedData.gambles.Add(new Gamble(name, iName, iAmount, numbers, GetAndDeletePreservedPot(iName)));//creates gamble and stores it in data

            PrintToChat(PlayerEqualNull(player, "NewGamble", name, numbers.ToString(), iAmount.ToString(), GetItemName(iName)));
        }

        private int GetAndDeletePreservedPot(string itemName)
        {
            if (!configData.preservePot)//if config disabled
                return 0;

            int preserved = 0;
            for (int i = 0; i < storedData.preserveds.Count; i++)//search for this item
            {
                if (storedData.preserveds[i].itemName == itemName)//found
                {
                    preserved = storedData.preserveds[i].amount;//save amount
                    storedData.preserveds.RemoveAt(i);//delete preserved pot
                    break;
                }
            }

            return preserved;
        }

        private void AddToPreservedPot(string itemName, int amount)//called when gamble finishes with no winner
        {
            if (!configData.preservePot || amount == 0)//if config disabled or no bets
                return;

            for (int i = 0; i < storedData.preserveds.Count; i++)//search for this item
            {
                if (storedData.preserveds[i].itemName == itemName)//found
                {
                    storedData.preserveds[i].amount += amount;//add more 
                    return;
                }
            }

            storedData.preserveds.Add(new Preserved(amount, itemName));//if wasn't found then create it
        }

        private void TryFinishGamble(string name, IPlayer player = null)
        {
            int index = GetGambleIndex(name);

            if (index == -1)//gamble not found
            {
                ReplyOrPutLang(player, "GambleNotFound");
                return;
            }

            Gamble gamble= storedData.gambles[index];
            int winnerNumber = UnityEngine.Random.Range(1, gamble.numbers + 1);

            List<ulong> winners = new List<ulong>();
            for (int i = 0; i < gamble.bets.Count; i++)//add all matching numbers to winners list
            {
                if (gamble.bets[i].number == winnerNumber)
                    winners.Add(gamble.bets[i].player);
            }


            if (winners.Count != 0)
            {
                PrintToChat(PlayerEqualNull(player,"GamblingFinished", name, winnerNumber, winners.Count));

                int eachAmount = (gamble.itemAmount * gamble.bets.Count + gamble.preservedPot) / winners.Count;
                foreach (ulong win in winners)
                    storedData.rewards.Add(new Reward(win, gamble.item, gamble.itemAmount));

                

                if (configData.showWinners)
                {
                    PrintToChat(PlayerEqualNull(player, "Winners"));
                    string winnersString = "";

                    foreach (ulong win in winners)
                        winnersString += BasePlayer.Find(win.ToString()).displayName + ", ";


                    PrintToChat(winnersString.Remove(winnersString.Length - 2));//deletes the last comma+space and prints
                }

            }
            else//no one won
            {
                AddToPreservedPot(gamble.item, gamble.itemAmount * gamble.bets.Count + gamble.preservedPot);

                PrintToChat(PlayerEqualNull(player, "GamblingFinishedNoWinner", name, winnerNumber));
            }

            Puts("Gamble " + gamble.name + " finished");
            storedData.gambles.RemoveAt(index);
        }

        private void ShowCurrentGambles(IPlayer player)
        {
            if (storedData.gambles.Count == 0)
            {
                ReplyOrPutLang(player, "NoGambles");
                return;
            }

            for (int i = 0; i < storedData.gambles.Count; i++)
            {
                Gamble gamble = storedData.gambles[i];
                ReplyOrPutLang(player, "CurrentGambles", gamble.name, (gamble.bets.Count * gamble.itemAmount + gamble.preservedPot).ToString(), gamble.name, gamble.numbers, gamble.itemAmount, GetItemName(gamble.item));
            }
        }

        private string TryGetReward(BasePlayer player)
        {
            for (int i = 0; i < storedData.rewards.Count; i++)
            {
                if (storedData.rewards[i].id != player.userID)
                    continue;

                if (player.inventory.GiveItem(ItemManager.CreateByName(storedData.rewards[i].item, storedData.rewards[i].quantity)))
                {
                    storedData.rewards.RemoveAt(i);
                    return Lang("RewardReceived", player.UserIDString);
                }
                else
                    return Lang("RewardInventorySpace", player.UserIDString);
            }
            
            return Lang("NoRewards", player.UserIDString);
        }

        private void TryChangeConfig(string variable, string newValue, IPlayer player = null)
        {
            switch (variable)
            {
                case "winners":
                    bool parsedWinners;
                    if (bool.TryParse(newValue, out parsedWinners))
                    {
                        configData.showWinners = parsedWinners;
                        ReplyOrPutLang(player, "ConfigChanged", variable, parsedWinners.ToString());
                        return;
                    }

                    ReplyOrPutLang(player, "WinnersValues");
                    break;


                case "preservepot":
                    bool parsedPot;
                    if (bool.TryParse(newValue, out parsedPot))
                    {
                        configData.preservePot = parsedPot;
                        ReplyOrPutLang(player, "ConfigChanged", variable, parsedPot.ToString());
                        return;
                    }

                    ReplyOrPutLang(player, "PreserveValues");
                    break;


                default:
                    ReplyOrPutLang(player, "ConfigHelp");
                    break;
            }
        }

        #endregion

        #region commands

        [Command("gamble")]  // if player has perm "allowed" they get access to /gamble play, /gamble current, /gamble reward
        private void CmdGamble(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission("simplegambling.allowed") && !player.HasPermission("simplegambling.admin"))
            {
                player.Reply( Lang("DontHavePermission", player.Id));
                return;
            }

            if (args.Length < 1)
            {
                if(player.HasPermission("simplegambling.admin"))
                    player.Reply( Lang("AdminHelp", player.Id));
                else
                    player.Reply( Lang("PlayerHelp", player.Id));
                return;
            }

            if (args[0].ToLower() == "play")
            {
                if (args.Length == 3)
                {
                    player.Reply( TryToBet(player.Object as BasePlayer, args[1], args[2]));
                    SaveAll();
                }
                else
                    ShowCurrentGambles(player);
                
                return;
            }

            if (args[0].ToLower() == "current")
            {
                ShowCurrentGambles(player);
                return;
            }

            if (args[0].ToLower() == "reward")
            {
                player.Reply( TryGetReward(player.Object as BasePlayer));
                return;
            }

            if (player.HasPermission("simplegambling.admin"))
                Commands(player, args);
        }

        private void Commands(IPlayer player, string[] args)
        {
            switch (args[0].ToLower())
            {
                case "set":
                    if (args.Length == 5)
                    {
                        ReplyOrPutString(player, TryToSet(args[1], args[2].ToLower(), args[3], args[4], player));
                        break;
                    }

                    ReplyOrPutLang(player, "SetHelp");
                    break;


                case "finish":
                    if (args.Length == 2)
                    {
                        TryFinishGamble(args[1], player);
                        break;
                    }

                    ReplyOrPutLang(player, "FinishHelp");
                    break;

                case "current":
                    ShowCurrentGambles(player);
                    break;


                case "config":
                    if (args.Length == 3)
                    {
                        TryChangeConfig(args[1].ToLower(), args[2], player);

                        break;
                    }

                    ReplyOrPutLang(player, "ConfigHelp");
                    break;

                case "resetpot":
                    storedData.preserveds = new List<Preserved>();

                    break;
            }

            SaveAll();
        }

        #endregion

    }
}


// --- End of file: SimpleGambling.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/slack-report ---
// --- Original File Path: S/SlackReport/SlackReport.cs ---

// Requires: Slack

using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("SlackReport", "Wulf/lukespragg", "0.1.3", ResourceId = 1954)]
    [Description("Sends reports to Slack via in-game /report command")]

    class SlackReport : CovalencePlugin
    {
        // Do NOT edit this file, instead edit SlackReport.json in oxide/config and SlackReport.en.json in oxide/lang,
        // or create a language file for another language using the 'en' file as a default.

        #region Initialization

        [PluginReference] Plugin Slack;

        const string permReport = "slackreport.use";

        void Init()
        {
            LoadDefaultConfig();
            LoadDefaultMessages();
            permission.RegisterPermission(permReport, this);
        }

        #endregion

        #region Configuration

        //string botName;
        string channel;

        protected override void LoadDefaultConfig()
        {
            //Config["BotName"] = botName = GetConfig("BotName", "Report");
            Config["Channel"] = channel = GetConfig("Channel", "");
            SaveConfig();
        }

        #endregion

        #region Localization

        void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "Sorry, you're not allowed to use 'report'",
                ["ReportFailed"] = "Your report failed to send, please nofity an admin!",
                ["ReportSent"] = "Thank you, your report has been sent!"
            }, this);
        }

        #endregion

        #region Reporting

        [Command("report")]
        void ReportCommand(IPlayer player, string command, string[] args)
        {
            if (!IsAllowed(player.Id, permReport))
            {
                player.Reply(Lang("NotAllowed", player.Id));
                return;
            }

            Action<bool> callback = response =>
            {
                if (!player.IsConnected) return;
                player.Reply(response ? Lang("ReportSent", player.Id) : Lang("ReportFailed", player.Id));
            };
            Slack.Call("TicketMessage", string.Join(" ", args), player, channel, callback);
        }

        #endregion

        #region Helpers

        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        bool IsAllowed(string userId, string perm) => permission.UserHasPermission(userId, perm);

        #endregion
    }
}

// --- End of file: SlackReport.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/shoot-to-ban ---
// --- Original File Path: S/ShootToBan/ShootToBan.cs ---

﻿using System.Collections.Generic;
namespace Oxide.Plugins
{
    [Info("ShootToBan", "Death", "1.1.1")]
    [Description("Make banning players easy by just shooting your gun.")]
    public class ShootToBan : RustPlugin
    {
        #region Declarations
        List<ulong> Armed = new List<ulong>();
        const string stbPerm = "shoottoban.use";
        #endregion

        #region Hooks
        void Init()
        {
            LoadConfigVariables();
            permission.RegisterPermission(stbPerm, this);

            if (!configData.Settings.Enabled)
                Unsubscribe(nameof(OnPlayerAttack));
        }

        void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if (attacker != null && Armed.Contains(attacker.userID))
            {
                BasePlayer victim = info?.HitEntity.ToPlayer();
                if (victim == null) return;
                if (attacker.GetActiveItem().info?.shortname == configData.Settings.Ban_Weapon)
                {
                    if (victim.IsConnected)
                        victim.Kick(lang.GetMessage("banned", this, attacker.UserIDString).Replace("{0}", attacker.displayName));

                    ServerUsers.Set(victim.userID, ServerUsers.UserGroup.Banned, string.Empty, string.Empty);
                    ServerUsers.Save();
                    rust.BroadcastChat(null, lang.GetMessage("banned", this, attacker.UserIDString).Replace("{0}", attacker.displayName).Replace("{1}", victim.displayName));
                }
            }
        }
        #endregion

        #region Functions
        [ChatCommand("stb")]
        void stb(BasePlayer player)
        {
            if (player == null)
                return;

            if (!permission.UserHasPermission(player.UserIDString, stbPerm))
            {
                MSG(player, lang.GetMessage("denied", this, player.UserIDString));
                return;
            }
            if (Armed.Contains(player.userID))
                Disable(player);
            else
            {
                int time = configData.Settings.Command_Active_Time;
                Armed.Add(player.userID);
                MSG(player, lang.GetMessage("enabled", this, player.UserIDString).Replace("{0}", time.ToString()));
                timer.Once(time, () =>
                Disable(player));
            }
        }

        void Disable(BasePlayer player)
        {
            if (!Armed.Contains(player.userID))
                return;

            Armed.Remove(player.userID);
            MSG(player, lang.GetMessage("disabled", this, player.UserIDString));
            if (Armed.Count == 0)
                Unsubscribe(nameof(OnPlayerAttack));
        }

        void MSG(BasePlayer player, string m)
        {
            if (player == null)
                return;

            SendReply(player, m);
            Puts($"Message sent to {player.displayName}: {m}");
        }
        #endregion

        #region Config
        private ConfigData configData;

        class ConfigData
        {
            public Settings Settings = new Settings();
        }

        class Settings
        {
            public bool Enabled = true;
            public string Ban_Weapon = "rifle.bolt";
            public int Command_Active_Time = 30;
        }

        private void LoadConfigVariables()
        {
            configData = Config.ReadObject<ConfigData>();
            SaveConfig(configData);
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData();
            SaveConfig(config);
        }

        void SaveConfig(ConfigData config)
            => Config.WriteObject(config, true);
        #endregion

        #region Lang
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                {"enabled", "ShootToBan is now enabled. Will deactivate after {0} seconds!" },
                {"disabled", "ShootToBan is now disabled." },
                {"denied", "You do not have permission to use this command!" },
                {"banned", "{0} banned {1} from the server!" },
                {"reason", "You've been banned from this server by {0}" }
            }, this, "en");
        }

        private string msg(string key, string id = null) => lang.GetMessage(key, this, id);
        #endregion
    }
}

// --- End of file: ShootToBan.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/security-cameras ---
// --- Original File Path: S/SecurityCameras/SecurityCameras.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Security Cameras", "Yurii,Rick", "0.1.1")]
    [Description("CCTV targeting system, cameras follow players, npcs & heli")]
    class SecurityCameras : CovalencePlugin
    {
        private const string ToggleManualControlUI = "SecurityCameras.ToggleManualControlUI";
        private readonly Dictionary<BasePlayer, SecurityCamera> PlayerUIStates = new Dictionary<BasePlayer, SecurityCamera>();
        /// <summary>
        /// Configuration options
        /// </summary>
        class ConfigData
        {
            [JsonProperty(PropertyName = "Detection Radius")]
            public int detection_radius = 30;
        }

        static SecurityCameras instance;
        private ConfigData config = new ConfigData();

        #region Config Handling
        /// <summary>
        /// Load default config file
        /// </summary>
        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }
        /// <summary>
        /// Load the config values to the config class
        /// </summary>
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Your configuration file is invalid");
                LoadDefaultConfig();
                return;
            }
            SaveConfig();
        }
        /// <summary>
        /// Save the config file
        /// </summary>
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        #endregion

        private const string UsePerm = "securitycameras.use";
        private bool HasPerms(string userID, string perm) { return (string.IsNullOrEmpty(userID) || string.IsNullOrEmpty(perm)) ? false : permission.UserHasPermission(userID, perm); }
        private bool HasPerms(ulong userID, string perm) { return HasPerms(userID.ToString(), perm); }
        private void Init()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            permission.RegisterPermission(UsePerm, this);
        }

        void OnServerInitialized()
        {
            instance = this;

            this.Reload();

            Subscribe(nameof(OnEntitySpawned));
        }

        void OnEntitySpawned(BaseNetworkable entity)
        {
            this.UpdateCameraUse(entity as CCTV_RC);
        }

        void OnGroupPermissionGranted(string name, string perm)
        {
            if (perm == UsePerm)
            {
                this.Reload();
            }
        }

        void OnGroupPermissionRevoked(string name, string perm)
        {
            if (perm == UsePerm)
            {
                this.Reload();
            }
        }

        void OnUserPermissionGranted(string id, string permName)
        {
            if (permName == UsePerm)
            {
                this.Reload();
            }
        }

        void OnUserPermissionRevoked(string id, string permName)
        {
            if (permName == UsePerm)
            {
                this.Reload();
            }
        }

        void OnBookmarkControlEnded(ComputerStation computerStation, BasePlayer player, BaseEntity controlledEntity)
        {
            this.DestroyButton(player);
        }

        void OnBookmarkControlStarted(ComputerStation computerStation, BasePlayer player, string bookmarkName, IRemoteControllable remoteControllable)
        {
            var camera = (remoteControllable as BaseNetworkable).gameObject.GetComponent<SecurityCamera>();
            if (camera == null) return;

            this.CreateButton(player, camera);
        }

        void Reload()
        {
            foreach (BaseNetworkable entity in BaseNetworkable.serverEntities)
            {
                this.UpdateCameraUse(entity as CCTV_RC);
            }
        }

        void UpdateCameraUse(CCTV_RC camera)
        {
            if (camera != null)
            {
                if (HasPerms(camera.OwnerID, UsePerm))
                {
                    if (camera.gameObject.GetComponent<SecurityCamera>() == null)
                    {
                        camera.gameObject.AddComponent<SecurityCamera>();
                    }
                }
                else
                {
                    SecurityCamera component = camera.gameObject.GetComponent<SecurityCamera>();
                    if (component != null)
                    {
                        component.DestroyCamera();
                    }
                }
            }
        }

        void Unload()
        {
            foreach (BaseNetworkable camera in BaseNetworkable.serverEntities)
            {
                if (camera is CCTV_RC)
                {
                    SecurityCamera component = camera.gameObject.GetComponent<SecurityCamera>();
                    if (component != null)
                    {
                        component.DestroyCamera();
                    }
                }
            }

            foreach (var item in PlayerUIStates) 
            {
                this.DestroyButton(item.Key);
            }
            instance = null;
        }

        #region Commands

        [Command("toggle")]
        private void UICommandToggle(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer) return;
            var basePlayer = player.Object as BasePlayer;
            if (PlayerUIStates.ContainsKey(basePlayer))
            {
                var camera = PlayerUIStates[basePlayer];
                camera.scanning = !camera.scanning;
                this.DestroyButton(basePlayer);
                this.CreateButton(basePlayer, camera);
            }
        }
        #endregion

        void CreateButton(BasePlayer player, SecurityCamera camera)
        {
            if (camera == null)
            {
                return;
            }
            var cuiElements = new CuiElementContainer
                {
                    {
                        new CuiButton
                        {
                            Text = {
                                Text = camera.scanning ? "Scanning" : "Manual Control",
                                Color = "0.97 0.92 0.88 1",
                                Align = TextAnchor.MiddleCenter,
                                FadeIn = 0.25f
                            },
                            Button =
                            {
                                Color = camera.scanning ? "0.44 0.54 0.26 1" : "0.7 0.3 0 1",
                                Command = "toggle"
                            },
                            RectTransform =
                            {
                                AnchorMin = "1 0",
                                AnchorMax = "1 0",
                                OffsetMin = "-150 50",
                                OffsetMax = "-50 80"
                            }
                        },
                        "Overlay",
                        ToggleManualControlUI
                    }
                };

            CuiHelper.AddUi(player, cuiElements);
            PlayerUIStates.Add(player, camera);
        }

        void DestroyButton(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, ToggleManualControlUI);
            PlayerUIStates.Remove(player);
        }

        #region SecurityCamera
        internal class SecurityCamera : MonoBehaviour
        {
            private ulong id;
            private CCTV_RC camera { get; set; } = null;
            public BaseCombatEntity target = null;
            public bool scanning = true;

            private void Awake()
            {
                camera = GetComponent<CCTV_RC>();
                id = camera.net.ID.Value;

                gameObject.layer = (int)Layer.Reserved1;
                var collider = gameObject.GetComponent<SphereCollider>();
                if (collider != null)
                    Destroy(collider);
                collider = gameObject.AddComponent<SphereCollider>();
                collider.center = Vector3.zero;
                collider.radius = instance.config.detection_radius;
                collider.isTrigger = true;
                collider.enabled = true;
                ResetTarget();
            }
            /// <summary>
            /// Reset the cameras target
            /// </summary>
            public void ResetTarget()
            {
                target = null;
                camera.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                SphereCollider collider = gameObject.GetComponent<SphereCollider>();
                collider.radius = instance.config.detection_radius;
            }
            /// <summary>
            /// New entity in range
            /// </summary>
            /// <param name="range"></param>
            private void OnTriggerEnter(Collider range)
            {
                BaseCombatEntity entity = range.GetComponentInParent<BaseCombatEntity>();
                if (target != null || !IsValid(entity))
                {
                    return;
                }
                if (ShouldTarget(entity))
                {
                    SetTarget(entity);
                }
            }
            /// <summary>
            /// Update entities within range
            /// </summary>
            /// <param name="range"></param>
            private void OnTriggerStay(Collider range)
            {
                BaseCombatEntity entity = range.GetComponentInParent<BaseCombatEntity>();
                if (!IsValid(entity))
                {
                    return;
                }
                if (ShouldTarget(entity))
                {
                    SetTarget(entity);
                }
            }
            /// <summary>
            /// Entity leaving range
            /// </summary>
            /// <param name="range"></param>
            private void OnTriggerExit(Collider range)
            {
                BaseCombatEntity entity = range.GetComponentInParent<BaseCombatEntity>();
                if (!IsValid(entity))
                {
                    return;
                }

                if (IsTargeting(entity))
                {
                    ResetTarget();
                }
            }
            /// <summary>
            /// Check if entity is a valid target
            /// </summary>
            /// <param name="entity"></param>
            /// <returns></returns>
            private bool IsValid(BaseCombatEntity entity)
            {
                if (!entity)
                {
                    return false;
                }

                if (entity is BasePlayer || entity is BaseHelicopter)
                {
                    return true;
                }
                if (entity is NPCPlayer && !camera.isStatic)
                {
                    return true;
                }
                return false;
            }

            /// <summary>
            /// Check if camera has line of sight to entity
            /// </summary>
            /// <param name="entity"></param>
            /// <returns></returns>
            public bool HasLoS(BaseCombatEntity entity)
            {
                if (!IsValid(entity))
                {
                    return false;
                }

                Ray ray = new Ray(camera.pivotOrigin.position, entity.transform.position - camera.transform.position);
                ray.origin += ray.direction / 2;
                float distance = gameObject.GetComponent<SphereCollider>().radius;

                var foundEntity = RaycastAll<BaseNetworkable>(ray, distance);

                if (foundEntity is BaseCombatEntity)
                {
                    if (entity == foundEntity as BaseCombatEntity)
                        return true;
                }
                return false;
            }

            /// <summary>
            /// Check if entity should be targeted
            /// </summary>
            /// <param name="entity"></param>
            /// <returns></returns>
            private bool ShouldTarget(BaseCombatEntity entity)
            {
                try
                {
                    if (!scanning)
                    {
                        return false;
                    }
                    if (!IsValid(entity))
                    {
                        return false;
                    }
                    if (!HasLoS(entity))
                    {
                        return false;
                    }
                    if (HasBuildingPrivilege(entity as BasePlayer))
                    {
                        return false;
                    }
                    if (!camera.IsPowered())
                    {
                        return false;
                    }
                    return true;
                }
                catch
                {
                    return false;
                }
            }

            /// <summary>
            /// Set the cameras target
            /// </summary>
            /// <param name="entity"></param>
            private void SetTarget(BaseCombatEntity entity)
            {
                if (entity == null)
                    return;

                target = entity;

                Vector3 vector3 = Vector3Ex.Direction((entity is BasePlayer)
                    ? (entity as BasePlayer).eyes.position
                    : entity.transform.position, camera.yaw.transform.position);
                vector3 = camera.transform.InverseTransformDirection(vector3);
                Quaternion quaternion = Quaternion.LookRotation(vector3);
                Vector3 v3 = BaseMountable.ConvertVector(quaternion.eulerAngles);
                camera.pitchAmount = v3.x;
                camera.yawAmount = v3.y;
                camera.pitchAmount = Mathf.Clamp(camera.pitchAmount, camera.pitchClamp.x, camera.pitchClamp.y);
                camera.yawAmount = Mathf.Clamp(camera.yawAmount, camera.yawClamp.x, camera.yawClamp.y);
                Quaternion quaternion1 = Quaternion.Euler(camera.pitchAmount, 0f, 0f);
                Quaternion quaternion2 = Quaternion.Euler(0f, camera.yawAmount, 0f);
                camera.pitch.transform.localRotation = quaternion1;
                camera.yaw.transform.localRotation = quaternion2;

                camera.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                SphereCollider collider = gameObject.GetComponent<SphereCollider>();
                collider.radius = instance.config.detection_radius;
            }

            /// <summary>
            /// Destroy collider
            /// </summary>
            public void DestroyCamera()
            {
                Destroy(this);
            }
            /// <summary>
            /// Check if the camera is targeting an entity
            /// </summary>
            /// <param name="entity"></param>
            /// <returns></returns>
            public bool IsTargeting(BaseCombatEntity entity = null)
            {
                if (entity != null && target != null)
                    if (target == entity)
                        return true;
                if (target != null && entity == null)
                    return true;
                return false;
            }
            /// <summary>
            /// Check if the player has building privledge
            /// </summary>
            /// <param name="player"></param>
            /// <returns></returns>
            private bool HasBuildingPrivilege(BasePlayer player)
            {
                BuildingPrivlidge buildingPrivlidge = player.GetBuildingPrivilege(player.WorldSpaceBounds());
                if (buildingPrivlidge && buildingPrivlidge.IsAuthed(player))
                {
                    return true;
                }
                return false;
            }

            /// <summary>
            /// Find first object in line of sight
            /// </summary>
            /// <typeparam name="T"></typeparam>
            /// <param name="ray"></param>
            /// <param name="distance"></param>
            /// <returns></returns>
            private object RaycastAll<T>(Ray ray, float distance)
            {
                var hits = Physics.RaycastAll(ray, Layers.Solid);
                GamePhysics.Sort(hits);
                object target = false;
                foreach (var hit in hits)
                {
                    var ent = hit.GetEntity();
                    if (ent is T)
                    {
                        target = ent;
                        break;
                    }
                }
                return target;
            }
        }
        #endregion
    }
}

// --- End of file: SecurityCameras.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sound-fx ---
// --- Original File Path: S/SoundFX/SoundFX.cs ---

using UnityEngine;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using Oxide.Core;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Sound FX", "Lincoln", "1.0.3")]
    [Description("Simulate various Rust sound effects")]

    class SoundFX : RustPlugin
    {
        private const string permUse = "soundfx.use";
        private const string permBypassCooldown = "soundfx.bypasscooldown.use";
        private readonly Hash<string, float> cooldowns = new Hash<string, float>();

        #region Variables
        private List<string> ricochetEffects = new List<string>()
        {
            "assets/bundled/prefabs/fx/ricochet/ricochet1.prefab",
            "assets/bundled/prefabs/fx/ricochet/ricochet2.prefab",
            "assets/bundled/prefabs/fx/ricochet/ricochet3.prefab",
            "assets/bundled/prefabs/fx/ricochet/ricochet4.prefab",
        };

        string explosion = "assets/bundled/prefabs/fx/explosions/explosion_03.prefab";
        string vomit = "assets/bundled/prefabs/fx/gestures/drink_vomit.prefab";
        string landmine = "assets/bundled/prefabs/fx/weapons/landmine/landmine_explosion.prefab";
        string scream = "assets/bundled/prefabs/fx/player/beartrap_scream.prefab";
        string fallDamage = "assets/bundled/prefabs/fx/player/fall-damage.prefab";
        string howl = "assets/bundled/prefabs/fx/player/howl.prefab";
        string lick = "assets/bundled/prefabs/fx/gestures/lick.prefab";
        string headshot = "assets/bundled/prefabs/fx/headshot_2d.prefab";
        string chatter = "assets/prefabs/npc/scientist/sound/chatter.prefab";
        string manDown = "assets/prefabs/npc/scientist/sound/responddeath.prefab";
        string roger = "assets/prefabs/npc/scientist/sound/respondok.prefab";
        string takeCover = "assets/prefabs/npc/scientist/sound/takecover.prefab";
        string slurp = "assets/bundled/prefabs/fx/gestures/drink_tea.prefab";

        string fish = "assets/prefabs/misc/decor_dlc/huntingtrophy_fish/effects/hunting-trophy-fish-song.prefab";
        string test = "assets/prefabs/npc/murderer/sound/breathing.prefab"; //for testing purposes only
        #endregion

        #region PluginConfig
        //Creating a config file
        private static PluginConfig config;
        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Max Cooldown: ")] public float maxCooldown { get; set; }
            [JsonProperty(PropertyName = "Max Radius: ")] public float maxRadius { get; set; }


            public static PluginConfig DefaultConfig() => new PluginConfig()
            {
                maxCooldown = 5,
                maxRadius = 5
            };

        }
        protected override void LoadDefaultConfig()
        {
            PrintWarning("New configuration file created.");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            SaveConfig();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        #endregion

        #region Permissions
        private void Init()
        {
            permission.RegisterPermission(permUse, this);
            permission.RegisterPermission(permBypassCooldown, this);
        }
        #endregion

        private bool hasPermission(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, permUse))
            {
                ChatMessage(player, "NoPerm");
                return false;
            }
            return true;
        }

        bool OnCoolDown(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, permBypassCooldown)) return false;

            if (!cooldowns.ContainsKey(player.UserIDString))
            {
                cooldowns.Add(player.UserIDString, 0f);
            }

            if (config.maxCooldown > 0 && cooldowns[player.UserIDString] + config.maxCooldown > Interface.Oxide.Now)
            {
                ChatMessage(player, "Cooldown", config.maxCooldown);
                foreach (KeyValuePair<string, float> kvp in cooldowns) Puts("Key: {0}, Value: {1}", kvp.Key, kvp.Value);
                return true;
            }
            cooldowns[player.UserIDString] = Interface.Oxide.Now;
            return false;
        }

        #region Commands
        [ChatCommand("fx")]
        private void fxCommand(BasePlayer player, string command, string[] args)
        {
            if (player == null || !hasPermission(player)) return;

            if (args.IsNullOrEmpty())
            {
                ChatMessage(player, "Help");
                return;
            }

            if (OnCoolDown(player))
            {
                return;
            }

            Vector3 pos = player.transform.position + UnityEngine.Random.insideUnitSphere * config.maxRadius;

            switch (args[0].ToLower())
            {
                case "ricochet":
                    SendEffect(ricochetEffects.GetRandom(), pos);
                    break;

                case "scream":
                    SendEffect(scream, pos);
                    break;

                case "explosion":
                    SendEffect(explosion, pos);
                    break;

                case "vomit":
                    SendEffect(vomit, pos);
                    break;

                case "slurp":
                    SendEffect(slurp, pos);
                    break;

                case "landmine":
                    SendEffect(landmine, pos);
                    break;

                case "fall":
                    SendEffect(fallDamage, pos);
                    break;

                case "howl":
                    SendEffect(howl, pos);
                    break;

                case "lick":
                    SendEffect(lick, pos);
                    break;

                case "headshot":
                    SendEffect(headshot, pos);
                    break;

                case "chatter":
                    SendEffect(chatter, pos);
                    break;

                case "mandown":
                    SendEffect(manDown, pos);
                    break;

                case "roger":
                    SendEffect(roger, pos);
                    break;

                case "takecover":
                    SendEffect(takeCover, pos);
                    break;

                case "help":
                    ChatMessage(player, "Help");
                    break;

                case "test":
                    SendEffect(test, pos);
                    break;

                case "fish":
                    SendEffect(fish, pos);
                    break;

                default:
                    ChatMessage(player, "Invalid");
                    break;
            }
        }

        #endregion

        #region Helpers
        private void SendEffect(string prefabName, Vector3 pos) => Effect.server.Run(prefabName, pos);
        #endregion

        #region Localization

        private void ChatMessage(BasePlayer player, string messageName, params object[] args) =>
            player.ChatMessage(string.Format(GetMessage(player.IPlayer, messageName), args));

        private string GetMessage(IPlayer player, string messageName, params object[] args) =>
            GetMessage(player.Id, messageName, args);

        private string GetMessage(string playerId, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, playerId);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Help"] = "<size=18 ><color=#ffc34d>SoundFX</color></size>" +
                "\n<color=#9999ff>/fx ricochet</color> Bullet ricochet." +
                "\n<color=#9999ff>/fx scream</color> Wounded scream." +
                "\n<color=#9999ff>/fx explosion</color> Grenade explosion." +
                "\n<color=#9999ff>/fx slurp</color> Slurping sound effect." +
                "\n<color=#9999ff>/fx vomit</color> Vomit sound effect." +
                "\n<color=#9999ff>/fx landmine</color> Land mine explosion." +
                "\n<color=#9999ff>/fx fall</color> Breaking your knees." +
                "\n<color=#9999ff>/fx howl</color> Wolf howling." +
                "\n<color=#9999ff>/fx lick</color> Gross licking/slurping sound." +
                "\n<color=#9999ff>/fx headshot</color> Headshot sound effect " +
                "\n<color=#9999ff>/fx roger</color> Scientist radio 'roger that' " +
                "\n<color=#9999ff>/fx takecover</color> Scientist radio 'take cover' " +
                "\n<color=#9999ff>/fx mandown</color> Scientist radio 'man down'" +
                "\n<color=#9999ff>/fx chatter</color> Scientist radio chatter. " +
                "\n <color=#9999ff>/fx fish</color> Fish song.",
                ["NoPerm"] = "<color=#ffc34d>SoundFX</color>: You don't have permission to use that.",
                ["Cooldown"] = "<color=#ffc34d>SoundFX</color>: You are still on a {0} second cooldown.",
                ["Invalid"] = "<color=#ffc34d>SoundFX</color> Not a valid FX command."

            }, this, "en");
        }
        #endregion

        private void Unload()
        {
            config = null;
        }
    }
}

// --- End of file: SoundFX.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/stash-traps ---
// --- Original File Path: S/StashTraps/StashTraps.cs ---

﻿//#define DEBUG
#if DEBUG
using System.Diagnostics;
using Debug = UnityEngine.Debug;
#endif
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Rust;
using UnityEngine;
using Random = System.Random;

namespace Oxide.Plugins
{
    [Info("Stash Traps", "misticos", "2.0.3")]
    [Description("Catch ESP hackers quickly and efficiently")]
    public class StashTraps : CovalencePlugin
    {
        #region Variables

        private static StashTraps _ins = null;

        [PluginReference("PowerSpawn")]
        private Plugin _spawns = null;

        [PluginReference("PlaceholderAPI")]
        private Plugin _placeholders = null;

        private const string PermissionUse = "stashtraps.use";
        private const string PermissionNotice = "stashtraps.notice";
        private const string PermissionIgnore = "stashtraps.ignore";

        private const string PrefabStash = "assets/prefabs/deployable/small stash/small_stash_deployed.prefab";

        private HashSet<NetworkableId> _generatedStashes = new HashSet<NetworkableId>();
        private HashSet<NetworkableId> _alreadyFoundStashes = new HashSet<NetworkableId>();
        private Dictionary<string, int> _foundStashes = new Dictionary<string, int>();
        private Action<IPlayer, StringBuilder, bool> _placeholderProcessor;

        private Random _random = new Random();

        private Dictionary<string, string> _cachedHeaders = new Dictionary<string, string>
            { { "Content-Type", "application/json" } };

        private string _webhookBodyCached = null;

        #endregion

        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Power Spawn Profile Name")]
            public string PowerSpawnProfile = string.Empty;

            [JsonProperty(PropertyName = "Commands")]
            public string[] Commands = { "stashtraps", "st", "stashes" };

            [JsonProperty(PropertyName = "Generated Stashes")]
            public int StashCount = 200;

            [JsonProperty(PropertyName = "Delete After Exposed In (Seconds)")]
            public float DeleteAfter = -1f;

            [JsonProperty(PropertyName = "Ignore Teammates")]
            public bool IgnoreTeam = true;

            [JsonProperty(PropertyName = "Notify Admins")]
            public bool NotifyAdmins = true;

            [JsonProperty(PropertyName = "Discord Settings")]
            public DiscordData Discord = new DiscordData();

            [JsonProperty(PropertyName = "Spawned Items")]
            public int ItemsCount = 2;

            [JsonProperty(PropertyName = "Items", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ItemData> Items = new List<ItemData>
            {
                new ItemData(), new ItemData { Shortname = "arrow.wooden", AmountMin = 6, AmountMax = 12 },
                new ItemData { Shortname = "corn", AmountMin = 2, AmountMax = 4 }
            };

            public class DiscordData
            {
                [JsonProperty(PropertyName = "Enabled")]
                public bool Enabled = false;

                [JsonProperty(PropertyName = "Webhook")]
                public string Webhook = string.Empty;

                [JsonProperty(PropertyName = "Setups", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<DiscordSetup> Setups = new List<DiscordSetup> { new DiscordSetup() };

                public class DiscordSetup
                {
                    [JsonProperty(PropertyName = "Threshold")]
                    public int Threshold = 1;

                    [JsonProperty(PropertyName = "Color (HEX)")]
                    public string Color = "ffad60";

                    [JsonProperty(PropertyName = "Inline")]
                    public bool Inline = true;

                    [JsonProperty(PropertyName = "Content")]
                    public string Content = "You could include pings here.";

                    [JsonProperty(PropertyName = "Title: Player Stash Found")]
                    public string StashPlayer = "**Player** stash found";

                    [JsonProperty(PropertyName = "Title: Generated Stash Found")]
                    public string StashGenerated = "**Generated** stash found";

                    [JsonProperty(PropertyName = "Title: Player Stash Found With Foundation")]
                    public string StashPlayerFoundation = "**Player** stash found with foundation";

                    [JsonProperty(PropertyName = "Title: Generated Stash Found With Foundation")]
                    public string StashGeneratedFoundation = "**Generated** stash found with foundation";

                    [JsonProperty(PropertyName = "Title: Stash")]
                    public string TitleStash = "Stash Information";

                    [JsonProperty(PropertyName = "Text: Stash")]
                    public string TextStash = "Network ID: {stash.id}\n" +
                                              "`teleportpos \"{stash.position}\"`";

                    [JsonProperty(PropertyName = "Title: Player")]
                    public string TitlePlayer = "Player";

                    [JsonProperty(PropertyName = "Text: Player")]
                    public string TextPlayer = "{player.id} ({player.name}) found **{stashtraps.found}** stashes";

                    [JsonIgnore]
                    public int ColorParsed = 0;

                    public static DiscordSetup Find(int found)
                    {
                        DiscordSetup highest = null;
                        foreach (var setup in _ins._config.Discord.Setups)
                        {
                            if (setup.Threshold > found)
                                continue;

                            if (highest == null || setup.Threshold > highest.Threshold)
                                highest = setup;
                        }

                        return highest;
                    }
                }
            }

            public class ItemData
            {
                [JsonProperty(PropertyName = "Shortname")]
                public string Shortname = "stones";

                [JsonProperty(PropertyName = "Minimum Amount")]
                public int AmountMin = 100;

                [JsonProperty(PropertyName = "Maximum Amount")]
                public int AmountMax = 200;

                [JsonIgnore]
                public ItemDefinition Definition = null;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();

                foreach (var thing in _config.Discord.Setups)
                {
                    thing.Content = Escape(thing.Content);
                    thing.StashPlayer = Escape(thing.StashPlayer);
                    thing.StashGenerated = Escape(thing.StashGenerated);
                    thing.TitleStash = Escape(thing.TitleStash);
                    thing.TextStash = Escape(thing.TextStash);
                    thing.TitlePlayer = Escape(thing.TitlePlayer);
                    thing.TextPlayer = Escape(thing.TextPlayer);
                }
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        private string Escape(string input)
        {
            var text = JsonConvert.ToString(input);
            return text.Substring(1, text.Length - 2);
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion

        #region Hooks

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {
                    "Notification: Stash Found", "<size=20><color=#ffad60>STASH FOUND</color></size>\n" +
                                                 "{player.id} ({player.name}) near {player.position}. Total found: {stashtraps.found}"
                },
                { "Command: No Permission", "You do not have enough permissions" },
                { "Command: Players Only", "This command is only available to players" },
                {
                    "Command: Syntax", "Syntax:\n" +
                                       "list - List existing stashes\n" +
                                       "teleport (ID) - Teleport to an existing stash"
                },
                {
                    "Command: List: Format", "Stashes ({count}):\n" +
                                             "{list}"
                },
                { "Command: List: Separator", "\n" },
                { "Command: List: Entry Format", "#{id}: {position}" },
                { "Command: Teleport: Unknown Stash", "There is no stash with such ID" }
            }, this);
        }

        private void Init()
        {
            _ins = this;

            _webhookBodyCached = JsonConvert.SerializeObject(new
            {
                content = "{content}",
                embeds = new[]
                {
                    new
                    {
                        title = "{title}", color = -5,
                        fields = new[]
                        {
                            new { name = "{s.title}", value = "{s.text}", inline = true },
                            new { name = "{p.title}", value = "{p.text}", inline = true }
                        }
                    }
                }
            });

            foreach (var setup in _config.Discord.Setups)
            {
                if (!int.TryParse(setup.Color, NumberStyles.HexNumber, null, out setup.ColorParsed))
                    setup.ColorParsed = 0;
            }

            permission.RegisterPermission(PermissionUse, this);
            permission.RegisterPermission(PermissionNotice, this);
            permission.RegisterPermission(PermissionIgnore, this);
        }

        private void OnServerInitialized()
        {
            if (_placeholders == null || _spawns == null)
            {
                Unsubscribe(nameof(OnStashExposed));
                Unsubscribe(nameof(OnEntityKill));

                PrintWarning("Please, install all dependencies from umod.org");
                return;
            }

            foreach (var item in _config.Items)
            {
                if ((item.Definition = ItemManager.FindItemDefinition(item.Shortname)) == null)
                {
                    PrintWarning($"Invalid item shortname: {item.Shortname}");
                }

                if (item.AmountMax < item.AmountMin)
                {
                    PrintWarning($"Invalid amount for item: {item.Shortname}");
                    item.Definition = null;
                }
            }

            AddCovalenceCommand(_config.Commands, nameof(CommandStashes));

            RefillStashes();
        }

        private void Unload()
        {
            InvokeHandler.Instance.CancelInvoke(RefillStashes);

            foreach (var stash in _generatedStashes)
            {
                BaseNetworkable.serverEntities.Find(stash)?.Kill();
            }

            _ins = null;
        }

        private void OnStashExposed(StashContainer stash, BasePlayer target) =>
            OnStashExposedInternal(stash, target, false);

        private void OnStashExposedInternal(StashContainer stash, BasePlayer target, bool foundation)
        {
            if (stash.OwnerID == target.userID)
                return;

            if (_config.IgnoreTeam)
            {
                var members = target.Team?.members;
                if (members != null && members.Contains(stash.OwnerID))
                    return;
            }

            if (_generatedStashes.Remove(stash.net.ID))
                RefillStashes();
            else if (stash.OwnerID == 0 || !_alreadyFoundStashes.Add(stash.net.ID))
                return; // Ignore already exposed generated stashes and such

            if (target.IPlayer.HasPermission(PermissionIgnore))
                return;

            int found;
            if (!_foundStashes.TryGetValue(target.UserIDString, out found))
                found = 0;

            _foundStashes[target.UserIDString] = ++found;

            if (_config.NotifyAdmins)
            {
                var builder = new StringBuilder();
                foreach (var player in players.Connected)
                {
                    if (!player.HasPermission(PermissionNotice))
                        continue;

                    builder.Clear().Append(GetMsg("Notification: Stash Found", player.Id));
                    _placeholderProcessor.Invoke(target.IPlayer, builder, false);

                    player.Message(builder.ToString());
                }
            }

            if (_config.Discord.Enabled)
            {
                var setup = Configuration.DiscordData.DiscordSetup.Find(found);
                if (setup != null)
                {
#if DEBUG
                    var sw = Stopwatch.StartNew();
#endif
                    var body = new StringBuilder(_webhookBodyCached)
                        .Replace("-5", setup.ColorParsed.ToString())
                        .Replace(true.ToString(), setup.Inline.ToString().ToLower())
                        .Replace("{content}", setup.Content).Replace("{title}",
                            foundation ? stash.OwnerID == 0 ? setup.StashGeneratedFoundation :
                            setup.StashPlayerFoundation :
                            stash.OwnerID == 0 ? setup.StashGenerated : setup.StashPlayer)
                        .Replace("{s.title}", setup.TitleStash).Replace("{s.text}", setup.TextStash)
                        .Replace("{p.title}", setup.TitlePlayer).Replace("{p.text}", setup.TextPlayer);

                    _placeholderProcessor?.Invoke(target.IPlayer, body, false);

                    body.Replace("{stash.id}", stash.net.ID.ToString())
                        .Replace("{stash.position}", stash.transform.position.ToString());

#if DEBUG
                    sw.Stop();
                    Debug.Log(body.ToString());
                    Debug.Log(JsonConvert.SerializeObject(_cachedHeaders));
                    Debug.Log($"Took {sw.Elapsed.TotalMilliseconds}ms");
#endif

                    webrequest.Enqueue(_config.Discord.Webhook, body.ToString(), (i, s) =>
                    {
                        if (i >= 300)
                            PrintWarning($"Unable to finish Discord webhook request ({i}):\n{s}");
                    }, this, RequestMethod.POST, _cachedHeaders);
                }
            }

            Interface.CallHook("OnStashTrapTriggered", target, stash);

            if (stash.OwnerID == 0 && _config.DeleteAfter >= 0f)
                stash.Invoke(() => stash.Kill(), _config.DeleteAfter);
        }

        private void OnEntityKill(StashContainer stash)
        {
            RaycastHit info;
            if (Physics.SphereCast(new Ray(stash.transform.position + Vector3.up * 5f, Vector3.down), 0.25f, out info,
                5f, Layers.Construction))
            {
                var entity = info.GetEntity() as StabilityEntity;
                if (entity != null)
                {
                    var player = players.FindPlayerById(entity.OwnerID.ToString())?.Object as BasePlayer;
                    if (player != null)
                    {
                        OnStashExposedInternal(stash, player, true);
                        return;
                    }
                }
            }

            if (!_generatedStashes.Remove(stash.net.ID))
                return;

            RefillStashes();
        }

        private void OnPlaceholderAPIReady()
        {
            _placeholderProcessor =
                _placeholders.Call<Action<IPlayer, StringBuilder, bool>>("GetProcessPlaceholders", 1);

            _placeholders.Call("AddPlaceholder", this, "stashtraps.found", new Func<IPlayer, string, object>(
                (player, option) =>
                {
                    if (player == null)
                        return null;

                    int found;
                    return _foundStashes.TryGetValue(player.Id, out found) ? found : 0;
                }));
        }

        private void OnPluginUnloaded(Plugin plugin)
        {
            if (plugin?.Name != "PlaceholderAPI")
                return;

            _placeholderProcessor = null;
        }

        #endregion

        #region Commands

        private void CommandStashes(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PermissionUse))
            {
                player.Reply(GetMsg("Command: No Permission", player.Id));
                return;
            }

            if (args.Length < 1)
                goto syntax;

            switch (args[0].ToLower())
            {
                case "list":
                {
                    var builder = new StringBuilder();

                    var separator = GetMsg("Command: List: Separator", player.Id);
                    var entry = GetMsg("Command: List: Entry Format", player.Id);

                    var firstStash = true;
                    foreach (var stash in _generatedStashes)
                    {
                        if (firstStash)
                            firstStash = false;
                        else
                            builder.Append(separator);

                        builder.Append(entry).Replace("{id}", stash.ToString()).Replace("{position}",
                            BaseNetworkable.serverEntities.Find(stash)?.transform.position.ToString() ?? "Unknown");
                    }

                    player.Reply(GetMsg("Command: List: Format", player.Id).Replace("{list}", builder.ToString())
                        .Replace("{count}", _generatedStashes.Count.ToString()));

                    return;
                }

                case "teleport":
                case "tp":
                {
                    if (args.Length != 2)
                        goto syntax;

                    var basePlayer = player.Object as BasePlayer;
                    if (basePlayer == null)
                    {
                        player.Reply(GetMsg("Command: Players Only", player.Id));
                        return;
                    }

                    ulong id;
                    if (!ulong.TryParse(args[1], out id))
                        goto syntax;

                    var entity = BaseNetworkable.serverEntities.Find(new NetworkableId(id)) as StashContainer;
                    if (entity == null)
                    {
                        player.Reply(GetMsg("Command: Teleport: Unknown Stash", player.Id));
                        return;
                    }

                    basePlayer.Teleport(entity.transform.position);
                    return;
                }
            }

            syntax:
            player.Reply(GetMsg("Command: Syntax", player.Id));
        }

        #endregion

        #region Helpers

        private void RefillStashes()
        {
            while (_generatedStashes.Count < _config.StashCount)
            {
                if (!TrySpawnStash())
                {
                    // Stop generating to give it some time
                    InvokeHandler.Instance.CancelInvoke(RefillStashes);
                    InvokeHandler.Instance.Invoke(RefillStashes, 10f);
                    return;
                }
            }
        }

        private readonly Quaternion _euler90 = Quaternion.Euler(90f, 0, 0);

        private bool TrySpawnStash()
        {
            var position = _spawns.Call("GetPregeneratedLocation", _config.PowerSpawnProfile) as Vector3?;
            if (position == null)
                return false;

            RaycastHit hit;
            if (!Physics.Raycast(position.Value + Vector3.up, Vector3.down, out hit, 2f, Layers.Terrain))
            {
#if DEBUG
                Debug.Log("No raycast");
#endif
                return false;
            }

#if DEBUG
            Debug.Log(
                $"Normal: {hit.normal} / LR: {(Quaternion.LookRotation(hit.normal, Vector3.down) * _euler90).eulerAngles}");
#endif
            var entity = GameManager.server.CreateEntity(PrefabStash, position.Value,
                Quaternion.LookRotation(hit.normal, Vector3.down) * _euler90) as StashContainer;

            if (entity == null)
                return false;

            entity.enableSaving = false;
            entity.Spawn();
            entity.SetFlag(StashContainer.StashContainerFlags.Hidden, true);
            entity.CancelInvoke(entity.Decay);

#if DEBUG
            var transform = entity.transform;
            Debug.Log($"Spawned EID{entity.net.ID} at P{transform.position}; R{transform.rotation.eulerAngles}");
#endif

            Shuffle(_config.Items);
            foreach (var item in _config.Items)
            {
                if (entity.inventory.itemList.Count >= _config.ItemsCount)
                    break;

                if (item.Definition == null)
                    continue;

                ItemManager.Create(item.Definition, _random.Next(item.AmountMin, item.AmountMax + 1))
                    .MoveToContainer(entity.inventory);
            }

            _generatedStashes.Add(entity.net.ID);
            return true;
        }

        private string GetMsg(string key, string userId = null) => lang.GetMessage(key, this, userId);

        private static void Shuffle<T>(IList<T> list)
        {
            var count = list.Count;
            while (count > 1)
            {
                count--;
                var index = _ins._random.Next(count + 1);
                var value = list[index];
                list[index] = list[count];
                list[count] = value;
            }
        }

        #endregion
    }
}

// --- End of file: StashTraps.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/stash-hider ---
// --- Original File Path: S/StashHider/StashHider.cs ---

using Oxide.Core.Plugins;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Stash Hider", "birthdates", "1.1.0")]
    [Description("Don't network stashes when they're hidden")]
    public class StashHider : RustPlugin
    {
        #region Variables

        [PluginReference]
        private readonly Plugin AutomatedStashTraps;

        private int LayerMask { get; } = UnityEngine.LayerMask.GetMask("Deployed");

        #endregion
        
        #region Hooks

        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (!input.WasJustPressed(BUTTON.USE) || Core.Random.Range(0, 6) != 0) return;
            var ray = player.eyes.HeadRay();
            RaycastHit hit;
            if (!Physics.Raycast(ray.origin, ray.direction, out hit, 3.0f, LayerMask, QueryTriggerInteraction.Ignore)) return;
            var entity = hit.GetEntity() as StashContainer;
            if (entity == null) return;
            entity.RPC_WantsUnhide(new BaseEntity.RPCMessage{player = player});
        }
        
        private void OnStashHidden(StashContainer stash, BasePlayer player)
        {
            // Wait for animation
            timer.In(1f, () => HideStash(stash));
        }

        private static void HideStash(StashContainer stash)
        {
            if (!stash.IsHidden()) return;
            stash.limitNetworking = true;
            stash.TerminateOnClient(BaseNetworkable.DestroyMode.None);
        }

        private static void ShowStash(StashContainer stash)
        {
            stash.limitNetworking = false;
            stash.SendNetworkUpdateImmediate();
            if (!stash.IsHidden()) return;
            stash.SetHidden(false); // Try play animation?
        }

        private object CanSeeStash(BasePlayer player, StashContainer stashContainer)
        {
            ShowStash(stashContainer);
            NextTick(() => stashContainer.SendNetworkUpdateImmediate());
            return null;
        }
        

        private void Unload()
        {
            foreach (var stash in GetStashes())
            {
                ShowStash(stash);
            }
        }

        private static IEnumerable<StashContainer> GetStashes()
        {
            return BaseNetworkable.serverEntities.entityList.Values.OfType<StashContainer>();
        }

        private void OnServerInitialized()
        {
            foreach (var entity in GetStashes())
            {
                if (!entity.IsHidden() || StashIsAutomatedTrap(entity)) continue;
                HideStash(entity);
            }
        }

        #endregion

        #region Helper Functions

        private bool PluginIsLoaded(Plugin plugin)
        {
            return plugin != null && plugin.IsLoaded ? true : false;
        }
        
        private bool StashIsAutomatedTrap(StashContainer stash)
        {
            if (PluginIsLoaded(AutomatedStashTraps))
                return AutomatedStashTraps.Call<bool>("StashIsAutomatedTrap", stash);
            else
                // Lang: Plugin is not loaded
            return false;
        }

        #endregion
    }
}

// --- End of file: StashHider.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/spectate ---
// --- Original File Path: S/Spectate/Spectate.cs ---

﻿using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

// TODO: Fix weapons floating when spectating

namespace Oxide.Plugins
{
    [Info("Spectate", "Wulf/lukespragg", "0.4.3")]
    [Description("Allows only players with permission to spectate")]
    public class Spectate : CovalencePlugin
    {
        #region Localization

        private new void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandSpectate"] = "spectate",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["NoValidTargets"] = "No valid spectate targets",
                ["PlayersOnly"] = "Command '{0}' can only be used by a player",
                ["SpectateSelf"] = "You cannot spectate yourself",
                ["SpectateStart"] = "Started spectating {0}",
                ["SpectateStop"] = "Stopped spectating {0}",
                ["TargetIsSpectating"] = "{0} is currently spectating another player"
            }, this);

            // French
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandSpectate"] = "spectre",
                ["NotAllowed"] = "Vous n’êtes pas autorisé à utiliser la commande « {0} »",
                ["NoValidTargets"] = "Non valides spectate cibles",
                ["PlayersOnly"] = "Commande « {0} » seulement peut être utilisée que par un joueur",
                ["SpectateSelf"] = "Vous ne pouvez pas vous-même spectate",
                ["SpectateStart"] = "Commencé spectature {0}",
                ["SpectateStop"] = "Cessé de spectature {0}",
                ["TargetIsSpectating"] = "{0} est spectature actuellement un autre joueur"
            }, this, "fr");

            // German
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandSpectate"] = "gespenst",
                ["NotAllowed"] = "Sie sind nicht berechtigt, verwenden Sie den Befehl '{0}'",
                ["NoValidTargets"] = "Zuschauen Sie keine gültige Ziele",
                ["PlayersOnly"] = "Befehl '{0}' kann nur von einem Spieler verwendet werden",
                ["SpectateSelf"] = "Sie können nicht selbst als Zuschauer",
                ["SpectateStart"] = "Begann zuschauen {0}",
                ["SpectateStop"] = "Nicht mehr zuschauen {0}",
                ["TargetIsSpectating"] = "{0} ist derzeit ein anderer Spieler zuschauen"
            }, this, "de");

            // Russian
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandSpectate"] = "Призрак",
                ["NotAllowed"] = "Нельзя использовать команду «{0}»",
                ["NoValidTargets"] = "Нет допустимых spectate целей",
                ["PlayersOnly"] = "Команда «{0}» может использоваться только игрок",
                ["SpectateSelf"] = "Вы не можете spectate себя",
                ["SpectateStart"] = "Начал spectating {0}",
                ["SpectateStop"] = "Остановлен spectating {0}",
                ["TargetIsSpectating"] = "{0} в настоящее время spectating другой игрок"
            }, this, "ru");

            // Spanish
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandSpectate"] = "espectador",
                ["NotAllowed"] = "No se permite utilizar el comando '{0}'",
                ["NoValidTargets"] = "No válido espectador objetivos",
                ["PlayersOnly"] = "Comando '{0}' solo puede ser usado por un jugador",
                ["SpectateSelf"] = "Usted no puede sí mismo espectador",
                ["SpectateStart"] = "Comenzó a observar {0}",
                ["SpectateStop"] = "Dejado de ver {0}",
                ["TargetIsSpectating"] = "{0} está actualmente tenemos otro jugador"
            }, this, "es");
        }

        #endregion Localization

        #region Initialization

        private readonly Dictionary<string, Vector3> lastPositions = new Dictionary<string, Vector3>();
        private readonly Dictionary<string, string> spectating = new Dictionary<string, string>();

        private const string permUse = "spectate.use";

        private void Init()
        {
            permission.RegisterPermission(permUse, this);

            AddLocalizedCommand("CommandSpectate", "SpectateCommand");
        }

        #endregion Initialization

        #region Chat Command

        private void SpectateCommand(IPlayer player, string command, string[] args)
        {
            if (player.IsServer)
            {
                Message(player, "PlayersOnly", command);
                return;
            }

            if (!player.HasPermission(permUse))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            BasePlayer basePlayer = player.Object as BasePlayer;
            if (basePlayer == null)
            {
                return;
            }

            if (!basePlayer.IsSpectating())
            {
                BasePlayer target = BasePlayer.Find(string.Join(" ", args.Select(v => v.ToString()).ToArray()));
                if (target == null || target.IsDead())
                {
                    Message(player, "NoValidTargets");
                    return;
                }

                if (ReferenceEquals(target, basePlayer))
                {
                    Message(player, "SpectateSelf");
                    return;
                }

                if (target.IsSpectating())
                {
                    Message(player, "TargetIsSpectating", target.displayName);
                    return;
                }

                // Store current location before spectating
                if (!lastPositions.ContainsKey(player.Id))
                {
                    lastPositions.Add(player.Id, basePlayer.transform.position);
                }
                else
                {
                    lastPositions[player.Id] = basePlayer.transform.position;
                }

                // Prep player for spectate mode
                HeldEntity heldEntity = basePlayer.GetActiveItem()?.GetHeldEntity() as HeldEntity;
                heldEntity?.SetHeld(false);

                // Put player in spectate mode
                basePlayer.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, true);
                basePlayer.gameObject.SetLayerRecursive(10);
                basePlayer.CancelInvoke("MetabolismUpdate");
                basePlayer.CancelInvoke("InventoryUpdate");
                basePlayer.ClearEntityQueue();
                basePlayer.SendEntitySnapshot(target);
                basePlayer.gameObject.Identity();
                basePlayer.SetParent(target);
                basePlayer.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, true);
                player.Command("camoffset 0,1.3,0");

                // Notify player and store target name
                Message(player, "SpectateStart", target.displayName);
                if (!spectating.ContainsKey(player.Id))
                {
                    spectating.Add(player.Id, target.displayName);
                }
                else
                {
                    spectating[player.Id] = target.displayName;
                }
            }
            else
            {
                // Restore player to normal mode
                player.Command("camoffset", "0,1,0");
                basePlayer.SetParent(null);
                basePlayer.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, false);
                basePlayer.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, false);
                basePlayer.gameObject.SetLayerRecursive(17);
                basePlayer.metabolism.Reset();
                basePlayer.InvokeRepeating("InventoryUpdate", 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));

                // Restore player to previous state
                basePlayer.StartSleeping();
                HeldEntity heldEntity = basePlayer.GetActiveItem()?.GetHeldEntity() as HeldEntity;
                heldEntity?.SetHeld(true);

                // Teleport to original location after spectating
                if (lastPositions.ContainsKey(player.Id))
                {
                    Vector3 lastPosition = lastPositions[player.Id];
                    player.Teleport(lastPosition.x, lastPosition.y + 0.3f, lastPosition.z);
                    lastPositions.Remove(player.Id);
                }

                // Notify player and clear target name
                if (spectating.ContainsKey(player.Id))
                {
                    Message(player, "SpectateStop", spectating[player.Id]);
                    spectating.Remove(player.Id);
                }
                else
                {
                    Message(player, "SpectateStop", "?");
                }
            }
        }

        #endregion Chat Command

        #region Game Hooks

        private void OnUserConnected(IPlayer player) => ResetSpectate(player);

        private void OnUserDisconnected(IPlayer player) => ResetSpectate(player);

        // Reset player's camera offset and stored states
        private void ResetSpectate(IPlayer player)
        {
            player.Command("camoffset 0,1,0");

            if (spectating.ContainsKey(player.Id))
            {
                spectating.Remove(player.Id);
            }

            if (lastPositions.ContainsKey(player.Id))
            {
                lastPositions.Remove(player.Id);
            }
        }

        #endregion Game Hooks

        #region Helpers

        private string Lang(string key, string id = null, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        private void AddLocalizedCommand(string key, string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages.Where(m => m.Key.Equals(key)))
                {
                    if (!string.IsNullOrEmpty(message.Value))
                    {
                        AddCovalenceCommand(message.Value, command);
                    }
                }
            }
        }
        private void Message(IPlayer player, string key, params object[] args)
        {
            player.Reply(Lang(key, player.Id, args));
        }

        #endregion Helpers
    }
}


// --- End of file: Spectate.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/shopfront-logs ---
// --- Original File Path: S/ShopfrontLogs/ShopfrontLogs.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core.Libraries;

namespace Oxide.Plugins
{
    [Info("Shopfront Logs", "Ryz0r", "1.0.0"), Description("Logs shopfront completed trades to Discord.")]
    public class ShopfrontLogs : RustPlugin
    {
        private const string BypassPerm = "shopfrontlogs.bypass";
        #region Configuration
        private Configuration _config;
        private class Configuration
        {
            [JsonProperty(PropertyName = "Discord Webhook URL")]
            public string WebhookURL = "https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks";
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("A new configuration file is being generated.");
            _config = new Configuration();
        }


        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        #endregion
        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(BypassPerm, this);
        }
        private object OnShopCompleteTrade(ShopFront entity)
        {
            if (permission.UserHasPermission(entity.customerPlayer.UserIDString, BypassPerm) ||
                permission.UserHasPermission(entity.vendorPlayer.UserIDString, BypassPerm)) return null;
            
            var vendorName = entity.vendorPlayer.displayName;
            var vendorId = entity.vendorPlayer.UserIDString;
            var cleanVendorItems = new List<string>();
            entity.vendorInventory.itemList.ToList().ForEach(item =>
                cleanVendorItems.Add($"{item.info.shortname.SentenceCase()} x {item.amount}"));


            var customerName = entity.customerPlayer.displayName;
            var customerId = entity.customerPlayer.UserIDString;
            var cleanCustomerItems = new List<string>();
            entity.customerInventory.itemList.ToList().ForEach(item =>
                cleanCustomerItems.Add($"{item.info.shortname.SentenceCase()} x {item.amount}"));

            SendDiscordMessage($"{vendorName} ({vendorId})", $"{customerName} ({customerId})", cleanVendorItems,
                cleanCustomerItems);
            return null;
        }
        #endregion
        #region Functions
        private void SendDiscordMessage(string v, string c, IReadOnlyCollection<string> vItems, IReadOnlyCollection<string> cItems)
        {
            var vItemString = vItems.Count < 1 ? "Null" : string.Join(", ", vItems);
            var cItemString = cItems.Count < 1 ? "Null" : string.Join(", ", cItems);
            
            var embed = new Embed()
                .AddField("Vendor:", v, true)
                .AddField("Customer:", c, true)
                .AddField("Vendor Items", vItemString, false)
                .AddField("Customer Items", cItemString, false)
                .SetColor("#FF0000");
            
            var headers = new Dictionary<string, string>() {{"Content-Type", "application/json"}};
            const float timeout = 500f;
            
            webrequest.Enqueue(_config.WebhookURL, new DiscordMessage("", embed).ToJson(),  GetCallback, this,
                RequestMethod.POST, headers, timeout);
        }
        
        private void GetCallback(int code, string response)
        {
            if (response != null && code == 204) return;
            
            Puts($"Error: {code} - Couldn't get an answer from server.");
        }
        #endregion
        #region Discord Stuff
        private class DiscordMessage
        {
            public DiscordMessage(string content, params Embed[] embeds)
            {
                Content = content;
                Embeds  = embeds.ToList();
            }

            [JsonProperty("content")] public string Content { get; set; }
            [JsonProperty("embeds")] public List<Embed> Embeds { get; set; }
            

            public string ToJson() => JsonConvert.SerializeObject(this);
        }

        private class Embed
        {
            [JsonProperty("fields")] public List<Field> Fields { get; set; } = new List<Field>();
            [JsonProperty("color")] public int Color { get; set; }

            public Embed AddField(string name, string value, bool inline)
            {
                Fields.Add(new Field(name, Regex.Replace(value, "<.*?>", string.Empty), inline));

                return this;
            }
            
            public Embed SetColor(string color)
            {
                var replace = color.Replace("#", "");
                var decValue = int.Parse(replace, System.Globalization.NumberStyles.HexNumber);
                Color = decValue;
                return this;
            }
        }

        private class Field
        {
            public Field(string name, string value, bool inline)
            {
                Name = name;
                Value = value;
                Inline = inline;
            }

            [JsonProperty("name")] public string Name { get; set; }
            [JsonProperty("value")] public string Value { get; set; }
            [JsonProperty("inline")] public bool Inline { get; set; }
        }
        #endregion
    }
}

// --- End of file: ShopfrontLogs.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/server-rewards ---
// --- Original File Path: S/ServerRewards/ServerRewards.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using Network;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Server Rewards", "k1lly0u", "0.4.78")]
    [Description("UI shop to buy items, kits, and commands")]
    class ServerRewards : RustPlugin
    {
        #region Fields
        [PluginReference]
        Plugin Kits, Economics, EventManager, HumanNPC, LustyMap, PlaytimeTracker, ImageLibrary;

        private PlayerData playerData;
        private NPCData npcData;
        private RewardData rewardData;
        private SaleData saleData;
        private CooldownData cooldownData;

        private DynamicConfigFile playerdata, npcdata, rewarddata, saledata, cooldowndata;

        private static ServerRewards ins;
        private UIManager uiManager;
        private Timer saveTimer;

        private static bool uiFadeIn;
        private bool isILReady;
        private string color1;
        private string color2;
        private int blueprintId = -996920608;

        private Dictionary<string, string> uiColors = new Dictionary<string, string>();
        private Dictionary<ulong, int> playerRP = new Dictionary<ulong, int>();
        private Hash<ulong, Timer> popupMessages = new Hash<ulong, Timer>();
        private Dictionary<int, string> itemIds = new Dictionary<int, string>();
        private Dictionary<string, string> itemNames = new Dictionary<string, string>();
        private Dictionary<ulong, KeyValuePair<string, NPCData.NPCInfo>> npcCreator = new Dictionary<ulong, KeyValuePair<string, NPCData.NPCInfo>>();
        private Dictionary<ulong, UserNPC> userNpc = new Dictionary<ulong, UserNPC>();

        enum UserNPC { Add, Edit, Remove }
        enum UIPanel { None, Navigation, Kits, Items, Commands, Exchange, Transfer, Sell }
        enum PurchaseType { Kit, Item, Command }
        enum Category { None, Weapon, Construction, Items, Resources, Attire, Tool, Medical, Food, Ammunition, Traps, Misc, Component, Electrical, Fun }
        #endregion

        #region UI
        const string UIMain = "SR_Store";
        const string UISelect = "SR_Select";
        const string UIRP = "SR_RPPanel";
        const string UIPopup = "SR_Popup";

        private class UI
        {
            public static CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax)
            {
                CuiElementContainer container = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                            CursorEnabled = true
                        },
                        new CuiElement().Parent = "Overlay",
                        panelName
                    }
                };
                return container;
            }

            public static void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel, CuiHelper.GetGuid());
            }

            public static void CreateLabel(ref CuiElementContainer container, string panel, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter, string color = null, float fadein = 1.0f)
            {
                if (uiFadeIn)
                    fadein = 0;
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, FadeIn = fadein, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel, CuiHelper.GetGuid());

            }

            public static void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 1.0f)
            {
                if (uiFadeIn)
                    fadein = 0;
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = fadein },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel, CuiHelper.GetGuid());
            }

            public static void LoadImage(ref CuiElementContainer container, string panel, string png, string aMin, string aMax)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent {Png = png },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                });
            }
            
            public static void LoadImage(ref CuiElementContainer container, string panel, int itemid, ulong skinid, string aMin, string aMax)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiImageComponent() {ItemId = itemid, SkinId = skinid },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                });
            }

            public static string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.TrimStart('#');
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }

        private class UIManager
        {
            public Dictionary<UIPanel, Dictionary<Category, Dictionary<int, CuiElementContainer>>> standardElements = new Dictionary<UIPanel, Dictionary<Category, Dictionary<int, CuiElementContainer>>>();

            public Dictionary<string, Dictionary<UIPanel, Dictionary<Category, Dictionary<int, CuiElementContainer>>>> npcElements = new Dictionary<string, Dictionary<UIPanel, Dictionary<Category, Dictionary<int, CuiElementContainer>>>>();

            public Dictionary<ulong, PlayerUI> playerUi = new Dictionary<ulong, PlayerUI>();

            public void AddUI(BasePlayer player, UIPanel type, Category subType = Category.None, int pageNumber = 0, string npcId = null)
            {
                PlayerUI data;
                if (!playerUi.TryGetValue(player.userID, out data))
                {
                    data = new PlayerUI { npcId = npcId };
                    playerUi.Add(player.userID, data);
                }

                CuiElementContainer container = null;
                if (type == UIPanel.Navigation)
                {
                    if (!string.IsNullOrEmpty(npcId))
                        container = npcElements[npcId][UIPanel.Navigation][Category.None][0];
                    else container = standardElements[UIPanel.Navigation][Category.None][0];

                    data.navigationIds.AddRange(container.Select(x => x.Name));
                    ins.DisplayPoints(player);
                }
                else
                {
                    if (type != UIPanel.Sell && type != UIPanel.Transfer)
                    {
                        if (!string.IsNullOrEmpty(npcId))
                            container = npcElements[npcId][type][subType][pageNumber];
                        else container = standardElements[type][subType][pageNumber];
                    }
                    else
                    {
                        switch (type)
                        {
                            case UIPanel.Transfer:
                                container = ins.CreateTransferElement(player, pageNumber);
                                break;
                            case UIPanel.Sell:
                                container = ins.CreateSaleElement(player);
                                break;
                        }
                    }
                    data.elementIds.AddRange(container.Select(x => x.Name));
                }
                if (container != null)
                    CuiHelper.AddUi(player, container);
                playerUi[player.userID] = data;
            }

            public void DestroyUI(BasePlayer player, bool destroyNav = false)
            {
                PlayerUI data;
                if (playerUi.TryGetValue(player.userID, out data))
                {
                    foreach (string elementId in data.elementIds)
                        CuiHelper.DestroyUi(player, elementId);

                    if (destroyNav)
                    {
                        foreach (string elementId in data.navigationIds)
                            CuiHelper.DestroyUi(player, elementId);

                        CuiHelper.DestroyUi(player, UIRP);
                        CuiHelper.DestroyUi(player, UISelect);

                        playerUi.Remove(player.userID);
                        ins.OpenMap(player);
                    }
                }
            }

            public void SwitchElement(BasePlayer player, UIPanel type, Category subType = Category.None, int pageNumber = 0, string npcId = null)
            {
                DestroyUI(player);
                AddUI(player, type, subType, pageNumber, npcId);
            }

            public bool IsOpen(BasePlayer player) => playerUi.ContainsKey(player.userID);

            public bool NPCHasUI(string npcId) => npcElements.ContainsKey(npcId);

            public void RemoveNPCUI(string npcId)
            {
                if (NPCHasUI(npcId))
                    npcElements.Remove(npcId);
            }

            public void RenameComponents(CuiElementContainer container)
            {
                foreach (CuiElement element in container)
                {
                    if (element.Name == "AddUI CreatedPanel")
                        element.Name = CuiHelper.GetGuid();
                }
            }

            public string GetNPCInUse(BasePlayer player)
            {
                if (playerUi.ContainsKey(player.userID))
                    return playerUi[player.userID].npcId;
                return string.Empty;
            }

            public class PlayerUI
            {
                public string npcId = string.Empty;
                public List<string> elementIds = new List<string>();
                public List<string> navigationIds = new List<string>();
            }
        }
        #endregion

        #region UI Creation
        private void CreateAllElements()
        {
            isILReady = true;

            CreateNewElement();

            foreach (KeyValuePair<string, NPCData.NPCInfo> npc in npcData.npcInfo)
                CreateNewElement(npc.Key, npc.Value);

            PrintWarning("All UI elements have been successfully generated!");
        }

        private void CreateNewElement(string npcId = null, NPCData.NPCInfo info = null)
        {
            Category[] categories = Enum.GetValues(typeof(Category)) as Category[];

            SetNewElement(npcId);
            CreateNavUI(npcId, info);
            CreateKitsUI(npcId, info);

            for (int i = 0; i < categories.Length; i++)            
                CreateItemsUI(categories[i], npcId, info);            

            CreateCommandsUI(npcId, info);
            CreateExchangeUI(npcId);
        }

        private void SetNewElement(string npcId = null)
        {
            Dictionary<UIPanel, Dictionary<Category, Dictionary<int, CuiElementContainer>>> structure = new Dictionary<UIPanel, Dictionary<Category, Dictionary<int, CuiElementContainer>>>
                {
                    { UIPanel.Commands, new Dictionary<Category, Dictionary<int, CuiElementContainer>> { { Category.None, new Dictionary<int, CuiElementContainer>()} } },
                    { UIPanel.Exchange, new Dictionary<Category, Dictionary<int, CuiElementContainer>> { { Category.None, new Dictionary<int, CuiElementContainer>()} } },
                    { UIPanel.Items, new Dictionary<Category, Dictionary<int, CuiElementContainer>>
                        {
                            { Category.Ammunition, new Dictionary<int, CuiElementContainer>()},
                            { Category.Attire, new Dictionary<int, CuiElementContainer>()},
                            { Category.Component, new Dictionary<int, CuiElementContainer>()},
                            { Category.Construction, new Dictionary<int, CuiElementContainer>()},
                            { Category.Electrical, new Dictionary<int, CuiElementContainer>()},
                            { Category.Food, new Dictionary<int, CuiElementContainer>()},
                            { Category.Items, new Dictionary<int, CuiElementContainer>()},
                            { Category.Medical, new Dictionary<int, CuiElementContainer>()},
                            { Category.Misc, new Dictionary<int, CuiElementContainer>()},
                            { Category.None, new Dictionary<int, CuiElementContainer>()},
                            { Category.Resources, new Dictionary<int, CuiElementContainer>()},
                            { Category.Tool, new Dictionary<int, CuiElementContainer>()},
                            { Category.Traps, new Dictionary<int, CuiElementContainer>()},
                            { Category.Weapon, new Dictionary<int, CuiElementContainer>()},
                            { Category.Fun, new Dictionary<int, CuiElementContainer>()},
                        }
                    },
                    { UIPanel.Kits, new Dictionary<Category, Dictionary<int, CuiElementContainer>> { { Category.None, new Dictionary<int, CuiElementContainer>()} } },
                    { UIPanel.Navigation, new Dictionary<Category, Dictionary<int, CuiElementContainer>> { { Category.None, new Dictionary<int, CuiElementContainer>()} } }

                };

            if (!string.IsNullOrEmpty(npcId))
                uiManager.npcElements.Add(npcId, structure);
            else uiManager.standardElements = structure;
        }

        private void CreateNavUI(string npcId = null, NPCData.NPCInfo npcInfo = null)
        {
            CuiElementContainer container = UI.CreateElementContainer(UISelect, uiColors["dark"], "0 0.95", "1 1");
            UI.CreatePanel(ref container, UISelect, uiColors["light"], "0.005 0", "0.995 1", true);
            UI.CreateLabel(ref container, UISelect, $"{color1}{msg("storeTitle")}</color>", 24, "0.01 0", "0.2 1");

            int i = 0;
            if (string.IsNullOrEmpty(npcId))
            {
                if (configData.Tabs.Kits)
                {
                    CreateMenuButton(ref container, UISelect, msg("storeKits"), $"SRUI_ChangeElement Kits 0", i);
                    i++;
                }
                if (configData.Tabs.Items)
                {
                    CreateMenuButton(ref container, UISelect, msg("storeItems"), $"SRUI_ChangeElement Items 0", i);
                    i++;
                }
                if (configData.Tabs.Commands)
                {
                    CreateMenuButton(ref container, UISelect, msg("storeCommands"), $"SRUI_ChangeElement Commands 0", i);
                    i++;
                }
                if (Economics && configData.Tabs.Exchange)
                {
                    CreateMenuButton(ref container, UISelect, msg("storeExchange"), "SRUI_ChangeElement Exchange 0", i);
                    i++;
                }
                if (configData.Tabs.Transfer)
                {
                    CreateMenuButton(ref container, UISelect, msg("storeTransfer"), "SRUI_ChangeElement Transfer 0", i);
                    i++;
                }
                if (configData.Tabs.Seller)
                {
                    CreateMenuButton(ref container, UISelect, msg("sellItems"), "SRUI_ChangeElement Sell 0", i);
                    i++;
                }
                CreateMenuButton(ref container, UISelect, msg("storeClose"), "SRUI_DestroyAll", i);

                uiManager.RenameComponents(container);
                uiManager.standardElements[UIPanel.Navigation][Category.None][0] = container;
            }
            else
            {
                if (npcInfo != null)
                {
                    if (configData.Tabs.Kits && npcInfo.sellKits)
                    {
                        CreateMenuButton(ref container, UISelect, msg("storeKits"), $"SRUI_ChangeElement Kits 0 {npcId}", i);
                        i++;
                    }
                    if (configData.Tabs.Items && npcInfo.sellItems)
                    {
                        CreateMenuButton(ref container, UISelect, msg("storeItems"), $"SRUI_ChangeElement Items 0 {npcId}", i);
                        i++;
                    }
                    if (configData.Tabs.Commands && npcInfo.sellCommands)
                    {
                        CreateMenuButton(ref container, UISelect, msg("storeCommands"), $"SRUI_ChangeElement Commands 0 {npcId}", i);
                        i++;
                    }
                    if (Economics && configData.Tabs.Exchange && npcInfo.canExchange)
                    {
                        CreateMenuButton(ref container, UISelect, msg("storeExchange"), $"SRUI_ChangeElement Exchange 0 {npcId}", i);
                        i++;
                    }
                    if (configData.Tabs.Transfer && npcInfo.canTransfer)
                    {
                        CreateMenuButton(ref container, UISelect, msg("storeTransfer"), $"SRUI_ChangeElement Transfer 0 {npcId}", i);
                        i++;
                    }
                    if (configData.Tabs.Seller && npcInfo.canSell)
                    {
                        CreateMenuButton(ref container, UISelect, msg("sellItems"), $"SRUI_ChangeElement Sell 0 {npcId}", i);
                        i++;
                    }
                    CreateMenuButton(ref container, UISelect, msg("storeClose"), "SRUI_DestroyAll", i);

                    uiManager.RenameComponents(container);
                    uiManager.npcElements[npcId][UIPanel.Navigation][Category.None][0] = container;
                }
                else PrintWarning($"Failed to create the navigation menu for NPC: {npcId}. Invalid data was supplied!");
            }
        }

        private void CreateItemsUI(Category category, string npcId = null, NPCData.NPCInfo npcInfo = null)
        {
            Category[] categories = Enum.GetValues(typeof(Category)) as Category[];

            if (string.IsNullOrEmpty(npcId))
            {
                int maxPages = 1;
                List<KeyValuePair<string, RewardData.RewardItem>> items = rewardData.items.Where(x => x.Value.category == category).ToList();
                
                if (items.Count == 0)
                {
                    CuiElementContainer container = CreateItemsElement(new List<KeyValuePair<string, RewardData.RewardItem>>(), category, 0, false, false, null);
                    uiManager.RenameComponents(container);
                    uiManager.standardElements[UIPanel.Items][category][0] = container;
                }
                else
                {
                    if (items.Count > 36)
                        maxPages = (items.Count - 1) / 36 + 1;
                    for (int i = 0; i < maxPages; i++)
                    {
                        int min = i * 36;
                        int max = items.Count < 36 ? items.Count : min + 36 > items.Count ? (items.Count - min) : 36;
                        List<KeyValuePair<string, RewardData.RewardItem>> range = items.OrderBy(x => x.Value.displayName).ToList().GetRange(min, max);
                        CuiElementContainer container = CreateItemsElement(range, category, i, i < maxPages - 1, i > 0, null);
                        uiManager.RenameComponents(container);
                        uiManager.standardElements[UIPanel.Items][category][i] = container;
                    }
                }
            }
            else
            {
                if (npcInfo != null)
                {
                    int maxPages = 1;

                    List<KeyValuePair<string, RewardData.RewardItem>> items = new List<KeyValuePair<string, RewardData.RewardItem>>();
                    if (npcInfo.useCustom)
                        items = rewardData.items.Where(y => npcInfo.items.Contains(y.Key)).Where(x => x.Value.category == category).ToList();
                    else items = rewardData.items.Where(x => x.Value.category == category).ToList();

                    if (items.Count == 0)
                    {
                        CuiElementContainer container = CreateItemsElement(new List<KeyValuePair<string, RewardData.RewardItem>>(), category, 0, false, false, npcId);
                        uiManager.RenameComponents(container);
                        uiManager.npcElements[npcId][UIPanel.Items][category][0] = container;
                    }
                    else
                    {
                        if (items.Count > 36)
                            maxPages = (items.Count - 1) / 36 + 1;
                        for (int i = 0; i < maxPages; i++)
                        {
                            int min = i * 36;
                            int max = items.Count < 36 ? items.Count : min + 36 > items.Count ? (items.Count - min) : 36;
                            List<KeyValuePair<string, RewardData.RewardItem>> range = items.OrderBy(x => x.Value.displayName).ToList().GetRange(min, max);
                            CuiElementContainer container = CreateItemsElement(range, category, i, i < maxPages - 1, i > 0, npcId);
                            uiManager.RenameComponents(container);
                            uiManager.npcElements[npcId][UIPanel.Items][category][i] = container;
                        }
                    }
                }
                else PrintWarning($"Failed to create items menu for NPC: {npcId} Category: {category}. Invalid data was supplied!");
            }
        }

        private void CreateKitsUI(string npcId = null, NPCData.NPCInfo npcInfo = null)
        {
            if (string.IsNullOrEmpty(npcId))
            {
                int maxPages = 1;
                SortedDictionary<string, RewardData.RewardKit> kits = rewardData.kits;
                if (kits.Count == 0)
                {
                    CuiElementContainer container = CreateKitsElement(new List<KeyValuePair<string, RewardData.RewardKit>>(), 0, false, false);
                    uiManager.RenameComponents(container);
                    uiManager.standardElements[UIPanel.Kits][Category.None][0] = container;
                }
                else
                {
                    if (kits.Count > 10)
                        maxPages = (kits.Count - 1) / 10 + 1;
                    for (int i = 0; i < maxPages; i++)
                    {
                        int min = i * 10;
                        int max = kits.Count < 10 ? kits.Count : min + 10 > kits.Count ? (kits.Count - min) : 10;
                        List<KeyValuePair<string, RewardData.RewardKit>> range = kits.OrderBy(x => x.Value.displayName).ToList().GetRange(min, max);
                        CuiElementContainer container = CreateKitsElement(range, i, i < maxPages - 1, i > 0);
                        uiManager.RenameComponents(container);
                        uiManager.standardElements[UIPanel.Kits][Category.None][i] = container;
                    }
                }
            }
            else
            {
                if (npcInfo != null)
                {
                    int maxPages = 1;
                    Dictionary<string, RewardData.RewardKit> kits = rewardData.kits.Where(x => npcInfo.kits.Contains(x.Key)).ToDictionary(v => v.Key, y => y.Value);
                    if (kits.Count == 0)
                    {
                        CuiElementContainer container = CreateKitsElement(new List<KeyValuePair<string, RewardData.RewardKit>>(), 0, false, false, npcId);
                        uiManager.RenameComponents(container);
                        uiManager.npcElements[npcId][UIPanel.Kits][Category.None][0] = container;
                    }
                    else
                    {
                        if (kits.Count > 10)
                            maxPages = (kits.Count - 1) / 10 + 1;
                        for (int i = 0; i < maxPages; i++)
                        {
                            int min = i * 10;
                            int max = kits.Count < 10 ? kits.Count : min + 10 > kits.Count ? (kits.Count - min) : 10;
                            List<KeyValuePair<string, RewardData.RewardKit>> range = kits.OrderBy(x => x.Value.displayName).ToList().GetRange(min, max);
                            CuiElementContainer container = CreateKitsElement(range, i, i < maxPages - 1, i > 0, npcId);
                            uiManager.RenameComponents(container);
                            uiManager.npcElements[npcId][UIPanel.Kits][Category.None][i] = container;
                        }
                    }
                }
                else PrintWarning($"Failed to create kits menu for NPC: {npcId}. Invalid data was supplied!");
            }
        }

        private void CreateCommandsUI(string npcId = null, NPCData.NPCInfo npcInfo = null)
        {
            if (string.IsNullOrEmpty(npcId))
            {
                int maxPages = 1;
                SortedDictionary<string, RewardData.RewardCommand> commands = rewardData.commands;
                if (commands.Count == 0)
                {
                    CuiElementContainer container = CreateCommandsElement(new List<KeyValuePair<string, RewardData.RewardCommand>>(), 0, false, false);
                    uiManager.RenameComponents(container);
                    uiManager.standardElements[UIPanel.Commands][Category.None][0] = container;
                }
                else
                {
                    if (commands.Count > 10)
                        maxPages = (commands.Count - 1) / 10 + 1;
                    for (int i = 0; i < maxPages; i++)
                    {
                        int min = i * 10;
                        int max = commands.Count < 10 ? commands.Count : min + 10 > commands.Count ? (commands.Count - min) : 10;
                        List<KeyValuePair<string, RewardData.RewardCommand>> range = commands.OrderBy(x => x.Value.displayName).ToList().GetRange(min, max);
                        CuiElementContainer container = CreateCommandsElement(range, i, i < maxPages - 1, i > 0);
                        uiManager.RenameComponents(container);
                        uiManager.standardElements[UIPanel.Commands][Category.None][i] = container;
                    }
                }
            }
            else
            {
                if (npcInfo != null)
                {
                    int maxPages = 1;
                    Dictionary<string, RewardData.RewardCommand> commands = rewardData.commands.Where(x => npcInfo.commands.Contains(x.Key)).ToDictionary(v => v.Key, y => y.Value);
                    if (commands.Count == 0)
                    {
                        CuiElementContainer container = CreateCommandsElement(new List<KeyValuePair<string, RewardData.RewardCommand>>(), 0, false, false, npcId);
                        uiManager.RenameComponents(container);
                        uiManager.npcElements[npcId][UIPanel.Commands][Category.None][0] = container;
                    }
                    else
                    {
                        if (commands.Count > 10)
                            maxPages = (commands.Count - 1) / 10 + 1;
                        for (int i = 0; i < maxPages; i++)
                        {
                            int min = i * 10;
                            int max = commands.Count < 10 ? commands.Count : min + 10 > commands.Count ? (commands.Count - min) : 10;
                            List<KeyValuePair<string, RewardData.RewardCommand>> range = commands.OrderBy(x => x.Value.displayName).ToList().GetRange(min, max);
                            CuiElementContainer container = CreateCommandsElement(range, i, i < maxPages - 1, i > 0, npcId);
                            uiManager.RenameComponents(container);
                            uiManager.npcElements[npcId][UIPanel.Commands][Category.None][i] = container;
                        }
                    }
                }
                else PrintWarning($"Failed to create commands menu for NPC: {npcId}. Invalid data was supplied!");
            }
        }

        private void CreateExchangeUI(string npcId = null)
        {
            CuiElementContainer container = UI.CreateElementContainer(UIMain, uiColors["dark"], "0 0", "1 0.95");
            UI.CreateLabel(ref container, UIMain, $"<color={configData.Colors.Background_Dark.Color}>{msg("storeExchange")}</color>", 200, "0 0", "1 1", TextAnchor.MiddleCenter);
            UI.CreatePanel(ref container, UIMain, uiColors["light"], "0.005 0.01", "0.995 0.99", true);
            UI.CreateLabel(ref container, UIMain, $"{color1}{msg("exchange1")}</color>", 24, "0 0.82", "1 0.9");
            UI.CreateLabel(ref container, UIMain, $"{color2}{msg("exchange2")}</color>{color1}{configData.Exchange.RP} {msg("storeRP")}</color> -> {color1}{configData.Exchange.Economics} {msg("storeCoins")}</color>", 20, "0 0.6", "1 0.7");
            UI.CreateLabel(ref container, UIMain, $"{color1}{msg("storeRP")} => {msg("storeEcon")}</color>", 20, "0.25 0.35", "0.4 0.4");
            UI.CreateLabel(ref container, UIMain, $"{color1}{msg("storeEcon")} => {msg("storeRP")}</color>", 20, "0.6 0.35", "0.75 0.4");
            UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], msg("storeExchange"), 20, "0.25 0.3", "0.4 0.35", "SRUI_Exchange 1");
            UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], msg("storeExchange"), 20, "0.6 0.3", "0.75 0.35", "SRUI_Exchange 2");

            uiManager.RenameComponents(container);
            if (!string.IsNullOrEmpty(npcId))
                uiManager.npcElements[npcId][UIPanel.Exchange][Category.None][0] = container;
            else uiManager.standardElements[UIPanel.Exchange][Category.None][0] = container;
        }

        private CuiElementContainer CreateItemsElement(List<KeyValuePair<string, RewardData.RewardItem>> items, Category category, int page, bool pageUp, bool pageDown, string npcId)
        {
            CuiElementContainer container = UI.CreateElementContainer(UIMain, uiColors["dark"], "0 0", "1 0.95");
            UI.CreateLabel(ref container, UIMain, $"<color={configData.Colors.Background_Dark.Color}>{msg(category.ToString())}</color>", 200, "0 0", "1 1", TextAnchor.MiddleCenter);

            UI.CreatePanel(ref container, UIMain, uiColors["light"], "0.005 0.949", "0.995 0.99", true);

            CreateSubMenu(ref container, UIMain, npcId);
            UI.CreatePanel(ref container, UIMain, uiColors["light"], "0.005 0.01", "0.995 0.94", true);

            if (pageUp) UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], ">>>", 16, "0.87 0.03", "0.955 0.07", $"SRUI_ChangeElement Items {page + 1} {npcId ?? "null"} {category}");
            if (pageDown) UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], "<<<", 16, "0.045 0.03", "0.13 0.07", $"SRUI_ChangeElement Items {page - 1} {npcId ?? "null"} {category}");

            for (int i = 0; i < items.Count; i++)
            {
                CreateItemEntry(ref container, UIMain, items[i].Key, items[i].Value, i);
            }

            return container;
        }

        private CuiElementContainer CreateKitsElement(List<KeyValuePair<string, RewardData.RewardKit>> kits, int page, bool pageUp, bool pageDown, string npcId = null)
        {
            CuiElementContainer container = UI.CreateElementContainer(UIMain, uiColors["dark"], "0 0", "1 0.95");
            UI.CreateLabel(ref container, UIMain, $"<color={configData.Colors.Background_Dark.Color}>{msg("storeKits")}</color>", 200, "0 0", "1 1", TextAnchor.MiddleCenter);

            UI.CreatePanel(ref container, UIMain, uiColors["light"], "0.005 0.01", "0.995 0.99", true);

            if (kits.Count == 0)
                UI.CreateLabel(ref container, UIMain, $"{color1}{msg("noKits")}</color>", 24, "0 0.82", "1 0.9");
            else
            {
                if (pageUp) UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], ">>>", 16, "0.87 0.03", "0.955 0.07", $"SRUI_ChangeElement Kits {page + 1} {npcId}");
                if (pageDown) UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], "<<<", 16, "0.045 0.03", "0.13 0.07", $"SRUI_ChangeElement Kits {page - 1} {npcId}");

                for (int i = 0; i < kits.Count; i++)
                {
                    RewardData.RewardKit kit = kits[i].Value;
                    string description = string.Empty;
                    if (configData.UIOptions.KitContents)
                        description = GetKitContents(kit.kitName);
                    else description = kit.description;
                    CreateKitCommandEntry(ref container, UIMain, kit.displayName, kits[i].Key, description, kit.cost, i, true, kit.iconName);
                }
            }
            return container;
        }

        private CuiElementContainer CreateCommandsElement(List<KeyValuePair<string, RewardData.RewardCommand>> commands, int page, bool pageUp, bool pageDown, string npcId = null)
        {
            CuiElementContainer container = UI.CreateElementContainer(UIMain, uiColors["dark"], "0 0", "1 0.95");
            UI.CreateLabel(ref container, UIMain, $"<color={configData.Colors.Background_Dark.Color}>{msg("storeCommands")}</color>", 200, "0 0", "1 1", TextAnchor.MiddleCenter);
            UI.CreatePanel(ref container, UIMain, uiColors["light"], "0.005 0.01", "0.995 0.99", true);

            if (commands.Count == 0)
                UI.CreateLabel(ref container, UIMain, $"{color1}{msg("noCommands")}</color>", 24, "0 0.82", "1 0.9");
            else
            {
                if (pageUp) UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], ">>>", 16, "0.87 0.03", "0.955 0.07", $"SRUI_ChangeElement Commands {page + 1} {npcId}");
                if (pageDown) UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], "<<<", 16, "0.045 0.03", "0.13 0.07", $"SRUI_ChangeElement Commands {page - 1} {npcId}");

                for (int i = 0; i < commands.Count; i++)
                {
                    RewardData.RewardCommand command = commands[i].Value;
                    CreateKitCommandEntry(ref container, UIMain, command.displayName, commands[i].Key, command.description, command.cost, i, false, command.iconName);
                }
            }
            return container;
        }

        private void PopupMessage(BasePlayer player, string msg)
        {
            CuiElementContainer element = UI.CreateElementContainer(UIPopup, uiColors["dark"], "0.33 0.45", "0.67 0.6");
            UI.CreatePanel(ref element, UIPopup, uiColors["light"], "0.01 0.04", "0.99 0.96");
            UI.CreateLabel(ref element, UIPopup, $"{color1}{msg}</color>", 20, "0.05 0.05", "0.95 0.95");

            if (popupMessages.ContainsKey(player.userID))
            {
                CuiHelper.DestroyUi(player, UIPopup);
                popupMessages[player.userID].Destroy();
                popupMessages.Remove(player.userID);
            }
            CuiHelper.AddUi(player, element);
            popupMessages.Add(player.userID, timer.In(3.5f, () =>
            {
                CuiHelper.DestroyUi(player, UIPopup);
                popupMessages.Remove(player.userID);
            }));
        }

        private void DisplayPoints(BasePlayer player)
        {
            if (player == null) return;

            CuiHelper.DestroyUi(player, UIRP);
            if (!uiManager.IsOpen(player)) return;

            int playerPoints = CheckPoints(player.userID);

            CuiElementContainer element = UI.CreateElementContainer(UIRP, "0 0 0 0", "0.3 0", "0.7 0.1");
            string message = $"{color1}{msg("storeRP", player.UserIDString)}: {playerPoints}</color>";
            if (Economics && configData.Tabs.Exchange)
            {
                object amount = Economics?.Call("Balance", player.UserIDString);
                message = message + $"  {color2}||</color> {color1}Economics: {amount}</color>";
            }
            if (configData.UIOptions.ShowPlaytime)
            {
                object time = Interface.CallHook("GetPlayTime", player.UserIDString);
                if (time is double)
                {
                    string playTime = FormatTime((double)time);
                    if (!string.IsNullOrEmpty(playTime))
                        message = $"{color1}{msg("storePlaytime", player.UserIDString)}: {playTime}</color> {color2}||</color> " + message;
                }
            }

            UI.CreateLabel(ref element, UIRP, message, 20, "0 0", "1 1", TextAnchor.MiddleCenter, null, 0f);

            CuiHelper.AddUi(player, element);
            timer.Once(1, () => DisplayPoints(player));
        }

        #region Sale System
        private CuiElementContainer CreateSaleElement(BasePlayer player)
        {
            CuiElementContainer container = UI.CreateElementContainer(UIMain, uiColors["dark"], "0 0", "1 0.95");
            UI.CreateLabel(ref container, UIMain, $"<color={configData.Colors.Background_Dark.Color}>{msg("storeSales")}</color>", 200, "0 0", "1 1", TextAnchor.MiddleCenter);
            UI.CreatePanel(ref container, UIMain, uiColors["light"], "0.005 0.01", "0.995 0.99", true);
            UI.CreateLabel(ref container, UIMain, $"{color1}{msg("selectItemSell")}</color>", 20, "0 0.9", "1 1");

            int i = 0;
            foreach (Item item in player.inventory.containerMain.itemList)
            {
                if (saleData.items.ContainsKey(item.info.shortname))
                {
                    if (!saleData.items[item.info.shortname].ContainsKey(item.skin))
                    {
                        saleData.items[item.info.shortname].Add(item.skin, new SaleData.SaleItem { displayName = item?.info?.steamItem?.displayName?.translated ?? $"{item.info.displayName.translated} {item.skin}" });
                        SaveSales();
                    }

                    string name = saleData.items[item.info.shortname][item.skin].displayName;
                    CreateInventoryEntry(ref container, UIMain, item.info.shortname, item.skin, name, item.amount, i);
                    i++;

                }
            }
            return container;
        }

        private void CreateInventoryEntry(ref CuiElementContainer container, string panelName, string shortname, ulong skinId, string name, int amount, int number)
        {
            float[] pos = CalcPosInv(number);

            UI.CreateLabel(ref container, panelName, $"{msg("Name")}:  {color1}{name}</color>", 14, $"{pos[0]} {pos[1]}", $"{pos[0] + 0.22f} {pos[3]}", TextAnchor.MiddleLeft);
            UI.CreateLabel(ref container, panelName, $"{msg("Amount")}:  {color1}{amount}</color>", 14, $"{pos[0] + 0.22f} {pos[1]}", $"{pos[0] + 0.32f} {pos[3]}", TextAnchor.MiddleLeft);
            if (saleData.items[shortname][skinId].enabled)
                UI.CreateButton(ref container, panelName, uiColors["buttonbg"], msg("Sell"), 12, $"{pos[0] + 0.37f} {pos[1] + 0.0015f}", $"{pos[2]} {pos[3] - 0.0015f}", $"SRUI_SellItem {shortname} {skinId} {amount}");
            else UI.CreateButton(ref container, panelName, uiColors["buttonbg"], msg("CantSell"), 12, $"{pos[0] + 0.37f} {pos[1] + 0.0015f}", $"{pos[2]} {pos[3] - 0.0015f}", string.Empty);
        }

        private void SellItem(BasePlayer player, string shortname, ulong skinId, int amount)
        {
            SaleData.SaleItem saleItem = saleData.items[shortname][skinId];
            string name = saleItem.displayName;
            CuiElementContainer container = UI.CreateElementContainer(UIMain, uiColors["dark"], "0 0", "1 0.95");
            UI.CreateLabel(ref container, UIMain, $"<color={configData.Colors.Background_Dark.Color}>{msg("storeSales")}</color>", 200, "0 0", "1 1", TextAnchor.MiddleCenter);
            UI.CreatePanel(ref container, UIMain, uiColors["light"], "0.005 0.01", "0.995 0.99", true);
            UI.CreateLabel(ref container, UIMain, $"{color1}{msg("selectToSell")}</color>", 20, "0 0.9", "1 1");
            int salePrice = (int)Math.Floor(saleItem.price * amount);

            UI.CreateLabel(ref container, UIMain, string.Format(msg("sellItemF"), color1, name), 18, "0.1 0.8", "0.3 0.84", TextAnchor.MiddleLeft);
            UI.CreateLabel(ref container, UIMain, string.Format(msg("sellPriceF"), color1, saleItem.price, msg("storeRP")), 18, "0.1 0.76", "0.3 0.8", TextAnchor.MiddleLeft);
            UI.CreateLabel(ref container, UIMain, string.Format(msg("sellUnitF"), color1, amount), 18, "0.1 0.72", "0.3 0.76", TextAnchor.MiddleLeft);
            UI.CreateLabel(ref container, UIMain, string.Format(msg("sellTotalF"), color1, salePrice, msg("storeRP")), 18, "0.1 0.68", "0.3 0.72", TextAnchor.MiddleLeft);


            UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], "+ 10000", 16, "0.84 0.72", "0.89 0.76", $"SRUI_SellItem {shortname} {skinId} {amount + 10000}");
            UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], "+ 1000", 16, "0.78 0.72", "0.83 0.76", $"SRUI_SellItem {shortname} {skinId} {amount + 1000}");
            UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], "+ 100", 16, "0.72 0.72", "0.77 0.76", $"SRUI_SellItem {shortname} {skinId} {amount + 100}");
            UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], "+ 10", 16, "0.66 0.72", "0.71 0.76", $"SRUI_SellItem {shortname} {skinId} {amount + 10}");
            UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], "+ 1", 16, "0.6 0.72", "0.65 0.76", $"SRUI_SellItem {shortname} {skinId} {amount + 1}");
            UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], "-1", 16, "0.54 0.72", "0.59 0.76", $"SRUI_SellItem {shortname} {skinId} {amount - 1}");
            UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], "-10", 16, "0.48 0.72", "0.53 0.76", $"SRUI_SellItem {shortname} {skinId} {amount - 10}");
            UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], "-100", 16, "0.42 0.72", "0.47 0.76", $"SRUI_SellItem {shortname} {skinId} {amount - 100}");
            UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], "-1000", 16, "0.36 0.72", "0.41 0.76", $"SRUI_SellItem {shortname} {skinId} {amount - 1000}");
            UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], "-10000", 16, "0.3 0.72", "0.35 0.76", $"SRUI_SellItem {shortname} {skinId} {amount - 10000}");

            UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], msg("cancelSale"), 16, "0.75 0.34", "0.9 0.39", "SRUI_CancelSale");
            UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], msg("confirmSale"), 16, "0.55 0.34", "0.7 0.39", $"SRUI_Sell {shortname} {skinId} {amount}");

            CuiHelper.DestroyUi(player, UIMain);
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Transfer System
        private CuiElementContainer CreateTransferElement(BasePlayer player, int page = 0)
        {
            CuiElementContainer container = UI.CreateElementContainer(UIMain, uiColors["dark"], "0 0", "1 0.95");
            UI.CreateLabel(ref container, UIMain, $"<color={configData.Colors.Background_Dark.Color}>{msg("storeTransfer")}</color>", 200, "0 0", "1 1", TextAnchor.MiddleCenter);
            UI.CreatePanel(ref container, UIMain, uiColors["light"], "0.005 0.01", "0.995 0.99", true);
            UI.CreateLabel(ref container, UIMain, $"{color1}{msg("transfer1", player.UserIDString)}</color>", 20, "0 0.9", "1 1");

            int playerCount = BasePlayer.activePlayerList.Count;
            if (playerCount > 136)
            {
                int maxpages = (playerCount - 1) / 136 + 1;
                if (page < maxpages - 1)
                    UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], msg("storeNext", player.UserIDString), 14, "0.87 0.935", "0.97 0.97", $"SRUI_Transfer {page + 1}");
                if (page > 0)
                    UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], msg("storeBack", player.UserIDString), 14, "0.03 0.935", "0.13 0.97", $"SRUI_Transfer {page - 1}");
            }

            int maxentries = (136 * (page + 1));
            if (maxentries > playerCount)
                maxentries = playerCount;

            int rewardcount = 136 * page;
            int i = 0;
            for (int n = rewardcount; n < maxentries; n++)
            {
                BasePlayer target = BasePlayer.activePlayerList[n];
                if (target == null || target == player)
                    continue;

                CreatePlayerNameEntry(ref container, UIMain, target.displayName, target.UserIDString, i);               
                i++;
            }
            return container;
        }

        private void TransferElement(BasePlayer player, string name, string id)
        {
            CuiHelper.DestroyUi(player, UIMain);
            CuiElementContainer container = UI.CreateElementContainer(UIMain, uiColors["dark"], "0 0", "1 0.95");
            UI.CreateLabel(ref container, UIMain, $"<color={configData.Colors.Background_Dark.Color}>{msg("storeTransfer")}</color>", 200, "0 0", "1 1", TextAnchor.MiddleCenter);
            UI.CreatePanel(ref container, UIMain, uiColors["light"], "0.005 0.01", "0.995 0.99", true);

            UI.CreateLabel(ref container, UIMain, $"{color1}{msg("transfer2", player.UserIDString)}</color>", 24, "0 0.82", "1 0.9");
            UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], "1", 20, "0.27 0.3", "0.37 0.35", $"SRUI_TransferID {id} 1");
            UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], "10", 20, "0.39 0.3", "0.49 0.35", $"SRUI_TransferID {id} 10");
            UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], "100", 20, "0.51 0.3", "0.61 0.35", $"SRUI_TransferID {id} 100");
            UI.CreateButton(ref container, UIMain, uiColors["buttonbg"], "1000", 20, "0.63 0.3", "0.73 0.35", $"SRUI_TransferID {id} 1000");

            CuiHelper.DestroyUi(player, UIMain);
            CuiHelper.AddUi(player, container);
        }
        #endregion
        #endregion

        #region UI Functions
        private void CreateMenuButton(ref CuiElementContainer container, string panelName, string buttonname, string command, int number)
        {
            Vector2 dimensions = new Vector2(0.1f, 0.6f);
            Vector2 origin = new Vector2(0.2f, 0.2f);
            Vector2 offset = new Vector2((0.005f + dimensions.x) * number, 0);

            Vector2 posMin = origin + offset;
            Vector2 posMax = posMin + dimensions;

            UI.CreateButton(ref container, panelName, uiColors["buttonbg"], buttonname, 15, $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}", command);
        }

        private void CreateSubMenu(ref CuiElementContainer container, string panelName, string npcId = null)
        {
            Category[] categories = Enum.GetValues(typeof(Category)) as Category[];

            float sizeX = 0.98f / (categories.Length - 1);
            int x = 0;
            int y = 0;
            for (int i = 0; i < categories.Length; i++)
            {
                Category cat = categories[i];

                if (cat == Category.None)
                    continue;

                if (rewardData.HasItems(cat))
                {
                    float xMin = 0.01f + (sizeX * x) + 0.003f;
                    float xMax = xMin + sizeX - 0.006f;
                    UI.CreateButton(ref container, panelName, uiColors["buttonbg"], msg(cat.ToString()), 12, $"{xMin} 0.955", $"{xMax} 0.985", $"SRUI_ChangeElement Items 0 {npcId ?? "null"} {cat.ToString()}");
                    x++;
                }
                y++;
            }
        }

        private void CreateItemEntry(ref CuiElementContainer container, string panelName, string itemIdS, RewardData.RewardItem item, int number)
        {
            Vector2 dimensions = new Vector2(0.1f, 0.19f);
            Vector2 origin = new Vector2(0.03f, 0.72f);
            float offsetY = 0;
            float offsetX = 0;

            if (number > 0 && number < 9)
                offsetX = (0.005f + dimensions.x) * number;
            if (number > 8 && number < 18)
            {
                offsetX = (0.005f + dimensions.x) * (number - 9);
                offsetY = (0.02f + dimensions.y) * 1;
            }
            if (number > 17 && number < 27)
            {
                offsetX = (0.005f + dimensions.x) * (number - 18);
                offsetY = (0.02f + dimensions.y) * 2;
            }
            if (number > 26 && number < 36)
            {
                offsetX = (0.005f + dimensions.x) * (number - 27);
                offsetY = (0.02f + dimensions.y) * 3;
            }

            Vector2 offset = new Vector2(offsetX, -offsetY);
            Vector2 posMin = origin + offset;
            Vector2 posMax = posMin + dimensions;

            string itemIcon = !string.IsNullOrEmpty(item.customIcon) ? GetImage(item.customIcon, 0) : string.Empty;
            int itemId = item.ItemDefinition ? item.ItemDefinition.itemid : 0;
           
            if (!string.IsNullOrEmpty(itemIcon))
                UI.LoadImage(ref container, panelName, itemIcon, $"{posMin.x + 0.02} {posMin.y + 0.08}", $"{posMax.x - 0.02} {posMax.y}");
            else if (itemId != 0)
                UI.LoadImage(ref container, panelName, itemId, item.skinId, $"{posMin.x + 0.02} {posMin.y + 0.08}", $"{posMax.x - 0.02} {posMax.y}");
            
            if (item.amount > 1)
                UI.CreateLabel(ref container, panelName, $"{color1}x{item.amount}</color>", 16, $"{posMin.x + 0.02} {posMin.y + 0.09}", $"{posMax.x - 0.02} {posMax.y - 0.02}", TextAnchor.LowerLeft);
            
            UI.CreateLabel(ref container, panelName, $"{item.displayName}{(item.isBp ? " " + msg("isBp") : string.Empty)}", 14, $"{posMin.x} {posMin.y + 0.04}", $"{posMax.x} {posMin.y + 0.09}");
            UI.CreateButton(ref container, panelName, uiColors["buttonbg"], $"{msg("storeCost")}: {item.cost}", 14, $"{posMin.x + 0.015} {posMin.y + 0.01}", $"{posMax.x - 0.015} {posMin.y + 0.04}", $"SRUI_BuyItem {itemIdS}");
        }

        private void CreateKitCommandEntry(ref CuiElementContainer container, string panelName, string displayName, string name, string description, int cost, int number, bool kit, string icon = null)
        {
            Vector2 dimensions = new Vector2(0.83f, 0.079f);
            Vector2 origin = new Vector2(0.03f, 0.86f);
            float offsetY = (0.004f + dimensions.y) * number;
            Vector2 offset = new Vector2(0, offsetY);
            Vector2 posMin = origin - offset;
            Vector2 posMax = posMin + dimensions;
            string command = kit ? $"SRUI_BuyKit {name}" : $"SRUI_BuyCommand {name}";

            if (!string.IsNullOrEmpty(icon))
            {
                string iconId = GetImage(icon);
                if (!string.IsNullOrEmpty(iconId))
                {
                    UI.LoadImage(ref container, panelName, iconId, $"{posMin.x} {posMin.y}", $"{posMin.x + 0.05} {posMax.y}");
                    posMin.x = 0.09f;
                }
            }

            UI.CreateLabel(ref container, panelName, $"{color1}{displayName}</color> -- {color2}<size=12>{description}</size></color>", 16, $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}", TextAnchor.MiddleLeft);
            UI.CreateButton(ref container, panelName, uiColors["buttonbg"], $"{msg("storeCost")}: {cost}", 13, $"0.9 {posMin.y + 0.03}", $"0.97 {posMax.y - 0.015f}", command);
        }

        private void CreatePlayerNameEntry(ref CuiElementContainer container, string panelName, string name, string id, int number)
        {
            float[] pos = CalcPlayerNamePos(number);
            UI.CreateButton(ref container, panelName, uiColors["buttonbg"], name, 10, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"SRUI_TransferNext {id}");
        }

        private float[] CalcPlayerNamePos(int number)
        {
            Vector2 position = new Vector2(0.012f, 0.84f);
            Vector2 dimensions = new Vector2(0.12f, 0.04f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 8)
            {
                offsetX = (0.0025f + dimensions.x) * number;
            }
            if (number > 7 && number < 16)
            {
                offsetX = (0.0025f + dimensions.x) * (number - 8);
                offsetY = (-0.0055f - dimensions.y) * 1;
            }
            if (number > 15 && number < 24)
            {
                offsetX = (0.0025f + dimensions.x) * (number - 16);
                offsetY = (-0.0055f - dimensions.y) * 2;
            }
            if (number > 23 && number < 32)
            {
                offsetX = (0.0025f + dimensions.x) * (number - 24);
                offsetY = (-0.0055f - dimensions.y) * 3;
            }
            if (number > 31 && number < 40)
            {
                offsetX = (0.0025f + dimensions.x) * (number - 32);
                offsetY = (-0.0055f - dimensions.y) * 4;
            }
            if (number > 39 && number < 48)
            {
                offsetX = (0.0025f + dimensions.x) * (number - 40);
                offsetY = (-0.0055f - dimensions.y) * 5;
            }
            if (number > 47 && number < 56)
            {
                offsetX = (0.0025f + dimensions.x) * (number - 48);
                offsetY = (-0.0055f - dimensions.y) * 6;
            }
            if (number > 55 && number < 64)
            {
                offsetX = (0.0025f + dimensions.x) * (number - 56);
                offsetY = (-0.0055f - dimensions.y) * 7;
            }
            if (number > 63 && number < 72)
            {
                offsetX = (0.0025f + dimensions.x) * (number - 64);
                offsetY = (-0.0055f - dimensions.y) * 8;
            }
            if (number > 71 && number < 80)
            {
                offsetX = (0.0025f + dimensions.x) * (number - 72);
                offsetY = (-0.0055f - dimensions.y) * 9;
            }
            if (number > 79 && number < 88)
            {
                offsetX = (0.0025f + dimensions.x) * (number - 80);
                offsetY = (-0.0055f - dimensions.y) * 10;
            }
            if (number > 87 && number < 96)
            {
                offsetX = (0.0025f + dimensions.x) * (number - 88);
                offsetY = (-0.0055f - dimensions.y) * 11;
            }
            if (number > 95 && number < 104)
            {
                offsetX = (0.0025f + dimensions.x) * (number - 96);
                offsetY = (-0.0055f - dimensions.y) * 12;
            }
            if (number > 103 && number < 112)
            {
                offsetX = (0.0025f + dimensions.x) * (number - 104);
                offsetY = (-0.0055f - dimensions.y) * 13;
            }
            if (number > 111 && number < 120)
            {
                offsetX = (0.0025f + dimensions.x) * (number - 112);
                offsetY = (-0.0055f - dimensions.y) * 14;
            }
            if (number > 119 && number < 128)
            {
                offsetX = (0.0025f + dimensions.x) * (number - 120);
                offsetY = (-0.0055f - dimensions.y) * 15;
            }
            if (number > 127 && number < 136)
            {
                offsetX = (0.0025f + dimensions.x) * (number - 128);
                offsetY = (-0.0055f - dimensions.y) * 16;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] CalcPosInv(int number)
        {
            Vector2 dimensions = new Vector2(0.45f, 0.04f);
            Vector2 origin = new Vector2(0.015f, 0.86f);
            float offsetY = 0.005f;
            float offsetX = 0.033f;
            float posX = 0;
            float posY = 0;
            if (number < 18)
            {
                posX = origin.x;
                posY = (offsetY + dimensions.y) * number;
            }
            else
            {
                number -= 18;
                posX = offsetX + dimensions.x;
                posY = (offsetY + dimensions.y) * number;
            }
            Vector2 offset = new Vector2(posX, -posY);
            Vector2 posMin = origin + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }
        #endregion

        #region UI Commands
        [ConsoleCommand("SRUI_BuyKit")]
        private void cmdBuyKit(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            string kitName = arg.FullString;
            if (rewardData.kits.ContainsKey(kitName))
            {
                RewardData.RewardKit kit = rewardData.kits[kitName];

                double remainingTime = 0;
                if (cooldownData.HasCooldown(player.userID, PurchaseType.Kit, kitName, out remainingTime))
                {
                    PopupMessage(player, string.Format(msg("hasCooldownKit", player.UserIDString), FormatTime(remainingTime)));
                    return;
                }

                int points = CheckPoints(player.userID);
                if (points >= kit.cost)
                {
                    if (TakePoints(player.userID, kit.cost, "Kit " + kit.displayName) != null)
                    {
                        Kits?.Call("GiveKit", new object[] { player, kit.kitName });

                        if (kit.cooldown > 0)
                            cooldownData.AddCooldown(player.userID, PurchaseType.Kit, kitName, kit.cooldown);

                        PopupMessage(player, string.Format(msg("buyKit", player.UserIDString), kitName));
                        return;
                    }
                }
                PopupMessage(player, msg("notEnoughPoints", player.UserIDString));
                return;
            }
            PopupMessage(player, msg("errorKit", player.UserIDString));
            return;
        }

        [ConsoleCommand("SRUI_BuyCommand")]
        private void cmdBuyCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            string commandname = arg.FullString;
            if (rewardData.commands.ContainsKey(commandname))
            {
                RewardData.RewardCommand command = rewardData.commands[commandname];

                double remainingTime = 0;
                if (cooldownData.HasCooldown(player.userID, PurchaseType.Command, commandname, out remainingTime))
                {
                    PopupMessage(player, string.Format(msg("hasCooldownCommand", player.UserIDString), FormatTime(remainingTime)));
                    return;
                }

                int points = CheckPoints(player.userID);
                if (points >= command.cost)
                {
                    if (TakePoints(player.userID, command.cost, "Command") != null)
                    {
                        foreach (string cmd in command.commands)
                            rust.RunServerCommand(cmd.Replace("$player.id", player.UserIDString).Replace("$player.name", player.displayName).Replace("$player.x", player.transform.position.x.ToString()).Replace("$player.y", player.transform.position.y.ToString()).Replace("$player.z", player.transform.position.z.ToString()));

                        if (command.cooldown > 0)
                            cooldownData.AddCooldown(player.userID, PurchaseType.Command, commandname, command.cooldown);

                        PopupMessage(player, string.Format(msg("buyCommand", player.UserIDString), commandname));
                        return;
                    }
                }
                PopupMessage(player, msg("notEnoughPoints", player.UserIDString));
                return;
            }
            PopupMessage(player, msg("errorCommand", player.UserIDString));
            return;
        }

        [ConsoleCommand("SRUI_BuyItem")]
        private void cmdBuyItem(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            string itemname = arg.GetString(0);
            if (rewardData.items.ContainsKey(itemname))
            {
                RewardData.RewardItem item = rewardData.items[itemname];

                double remainingTime = 0;
                if (cooldownData.HasCooldown(player.userID, PurchaseType.Item, itemname, out remainingTime))
                {
                    PopupMessage(player, string.Format(msg("hasCooldownItem", player.UserIDString), FormatTime(remainingTime)));
                    return;
                }

                int points = CheckPoints(player.userID);
                if (points >= item.cost)
                {
                    if (player.inventory.containerMain.itemList.Count == 24)
                    {
                        PopupMessage(player, msg("fullInv", player.UserIDString));
                        return;
                    }

                    if (TakePoints(player.userID, item.cost, item.displayName) != null)
                    {
                        GiveItem(player, itemname);

                        if (item.cooldown > 0)
                            cooldownData.AddCooldown(player.userID, PurchaseType.Item, itemname, item.cooldown);

                        PopupMessage(player, string.Format(msg("buyItem", player.UserIDString) + $"{(item.isBp ? " " + msg("isBp", player.UserIDString) : string.Empty)}", item.amount, item.displayName));
                        return;
                    }
                }
                PopupMessage(player, msg("notEnoughPoints", player.UserIDString));
                return;
            }
            PopupMessage(player, msg("errorItem", player.UserIDString));
            return;
        }

        [ConsoleCommand("SRUI_ChangeElement")]
        private void cmdChangeElement(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            string type = arg.GetString(0);
            int page = 0;
            string npcid = null;

            Category cat = Category.None;

            if (arg.Args.Length >= 2)
                page = arg.GetInt(1);

            if (arg.Args.Length >= 3)
            {
                npcid = arg.GetString(2);
                if (npcid == "null")
                    npcid = string.Empty;
            }

            if (arg.Args.Length >= 4)
                cat = (Category)Enum.Parse(typeof(Category), arg.GetString(3), true);

            switch (type)
            {
                case "Kits":
                    uiManager.SwitchElement(player, UIPanel.Kits, Category.None, page, npcid);
                    return;
                case "Commands":
                    uiManager.SwitchElement(player, UIPanel.Commands, Category.None, page, npcid);
                    return;
                case "Items":
                    uiManager.SwitchElement(player, UIPanel.Items, cat == Category.None ? Category.Ammunition : cat, page, npcid);
                    return;
                case "Exchange":
                    uiManager.SwitchElement(player, UIPanel.Exchange, Category.None, 0, npcid);
                    return;
                case "Transfer":
                    uiManager.SwitchElement(player, UIPanel.Transfer, Category.None, 0, npcid);
                    return;
                case "Sell":
                    uiManager.SwitchElement(player, UIPanel.Sell, Category.None, 0, npcid);
                    return;
            }
        }

        [ConsoleCommand("SRUI_Exchange")]
        private void cmdExchange(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            int type = int.Parse(arg.GetString(0).Replace("'", string.Empty));
            if (type == 1)
            {
                if (CheckPoints(player.userID) < configData.Exchange.RP)
                {
                    PopupMessage(player, msg("notEnoughPoints", player.UserIDString));
                    return;
                }
                if (TakePoints(player.userID, configData.Exchange.RP, "RP Exchange") != null)
                {
                    Economics?.Call("Deposit", player.UserIDString, (double)configData.Exchange.Economics);
                    PopupMessage(player, $"{msg("exchange", player.UserIDString)}{configData.Exchange.RP} {msg("storeRP", player.UserIDString)} for {configData.Exchange.Economics} {msg("storeCoins", player.UserIDString)}");
                }
            }
            else
            {
                double amount = (double)Economics?.Call("Balance", player.UserIDString);
                if (amount < configData.Exchange.Economics)
                {
                    PopupMessage(player, msg("notEnoughCoins", player.UserIDString));
                    return;
                }
                if ((bool)Economics?.Call("Withdraw", player.UserIDString, (double)configData.Exchange.Economics))
                {
                    AddPoints(player.userID, configData.Exchange.RP);
                    PopupMessage(player, $"{msg("exchange", player.UserIDString)}{configData.Exchange.Economics} {msg("storeCoins", player.UserIDString)} for {configData.Exchange.RP} {msg("storeRP", player.UserIDString)}");
                }
            }
        }

        [ConsoleCommand("SRUI_Transfer")]
        private void ccmdTransfer(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Connection.player as BasePlayer;
            if (player == null)
                return;

            uiManager.SwitchElement(player, UIPanel.Transfer, Category.None, args.GetInt(0), uiManager.GetNPCInUse(player));
        }

        [ConsoleCommand("SRUI_TransferNext")]
        private void ccmdTransferNext(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Connection.player as BasePlayer;
            if (player == null)
                return;

            string ID = args.GetString(0);
            if (!IsSteamId(ID))
                return;

            string name = (covalence.Players.FindPlayerById(ID)?.Object as BasePlayer)?.displayName ?? ID;

            TransferElement(player, name, ID);
        }

        [ConsoleCommand("SRUI_TransferID")]
        private void ccmdTransferID(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Connection.player as BasePlayer;
            if (player == null)
                return;

            string ID = args.GetString(0);
            if (!IsSteamId(ID))
                return;

            int amount = Mathf.Abs(args.GetInt(1));
            string name = (covalence.Players.FindPlayerById(ID)?.Object as BasePlayer)?.displayName ?? ID;

            int points = CheckPoints(player.userID);
            if (points >= amount)
            {
                if (TakePoints(player.userID, amount) != null)
                {
                    AddPoints(ID, amount);
                    PopupMessage(player, string.Format(msg("transfer3"), amount, msg("storeRP"), name));
                    return;
                }
            }
            PopupMessage(player, msg("notEnoughPoints"));
        }


        [ConsoleCommand("SRUI_DestroyAll")]
        private void cmdDestroyAll(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            uiManager.DestroyUI(player, true);
        }

        [ConsoleCommand("SRUI_CancelSale")]
        private void cmdCancelSale(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            uiManager.SwitchElement(player, UIPanel.Sell, Category.None, 0, uiManager.GetNPCInUse(player));
        }

        [ConsoleCommand("SRUI_SellItem")]
        private void cmdSellItem(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            string shortname = arg.GetString(0);
            ulong skinId = arg.GetUInt64(1);
            int amount = Mathf.Abs(arg.GetInt(2));

            int max = GetAmount(player, shortname, skinId);

            if (amount <= 0)
                amount = 1;
            if (amount > max)
                amount = max;

            SellItem(player, shortname, skinId, amount);
        }

        [ConsoleCommand("SRUI_Sell")]
        private void cmdSell(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            string shortname = arg.GetString(0);
            ulong skinId = arg.GetUInt64(1);
            int amount = Mathf.Abs(arg.GetInt(2));

            SaleData.SaleItem saleItem = saleData.items[shortname][skinId];
            if (!saleItem.enabled)
                return;

            if (TakeResources(player, shortname, skinId, amount))
            {                
                int salePrice = (int)Math.Floor(saleItem.price * amount);

                AddPoints(player.userID, salePrice);

                if (configData.Options.Logs)
                {
                    string message = $"{player.displayName} sold {amount}x {shortname} for {salePrice}";
                    LogToFile($"Sold Items", $"[{DateTime.Now.ToString("hh:mm:ss")}] {message}", this);
                }

                uiManager.SwitchElement(player, UIPanel.Sell, Category.None, 0, uiManager.GetNPCInUse(player));
                PopupMessage(player, string.Format(msg("saleSuccess"), amount, saleItem.displayName, salePrice, msg("storeRP")));
            }
        }
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            lang.RegisterMessages(messages, this);

            playerdata = Interface.Oxide.DataFileSystem.GetFile("ServerRewards/player_data");
            npcdata = Interface.Oxide.DataFileSystem.GetFile("ServerRewards/npc_data");
            rewarddata = Interface.Oxide.DataFileSystem.GetFile("ServerRewards/reward_data");
            saledata = Interface.Oxide.DataFileSystem.GetFile("ServerRewards/sale_data");
            cooldowndata = Interface.Oxide.DataFileSystem.GetFile("ServerRewards/cooldown_data");

            ins = this;
            uiManager = new UIManager();
        }

        private void OnServerInitialized()
        {
            LoadVariables();
            LoadData();

            if (!ImageLibrary)
            {
                PrintWarning("Image Library not detected, unloading ServerRewards");
                Interface.Oxide.UnloadPlugin(Name);
                return;
            }

            itemIds = ItemManager.itemList.ToDictionary(x => x.itemid, v => v.shortname);
            itemNames = ItemManager.itemList.ToDictionary(x => x.shortname, v => v.displayName.translated);
            LoadUIColors();
            LoadAllImages();
            UpdatePriceList();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);

            SaveLoop();
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player != null)
            {
                uiManager.DestroyUI(player, true);
                ulong ID = player.userID;
                if (CheckPoints(ID) > 0)
                    InformPoints(player);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player) => uiManager.DestroyUI(player, true);

        private void Unload()
        {
            if (saveTimer != null)
                saveTimer.Destroy();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                uiManager.DestroyUI(player, true);

            if (!ServerMgr.Instance.Restarting)
                SaveRP();
        }
        #endregion

        #region Functions
        private void LoadUIColors()
        {
            uiColors.Add("dark", UI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha));
            uiColors.Add("medium", UI.Color(configData.Colors.Background_Medium.Color, configData.Colors.Background_Medium.Alpha));
            uiColors.Add("light", UI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha));
            uiColors.Add("buttonbg", UI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha));
            uiColors.Add("buttoncom", UI.Color(configData.Colors.Button_Accept.Color, configData.Colors.Button_Accept.Alpha));
            uiColors.Add("buttongrey", UI.Color(configData.Colors.Button_Inactive.Color, configData.Colors.Button_Inactive.Alpha));
        }

        private void LoadAllImages()
        {
            Dictionary<string, string> newLoadOrder = new Dictionary<string, string>();

            string dataDir = $"file://{Interface.Oxide.DataDirectory}{Path.DirectorySeparatorChar}ServerRewards{Path.DirectorySeparatorChar}Images{Path.DirectorySeparatorChar}";
            foreach (KeyValuePair<string, RewardData.RewardItem> item in rewardData.items.Where(x => !string.IsNullOrEmpty(x.Value.customIcon)))
            {
                if (newLoadOrder.ContainsKey(item.Value.customIcon))
                    continue;

                string url = item.Value.customIcon;
                if (!url.StartsWith("http") && !url.StartsWith("www"))
                    url = $"{dataDir}{item.Value.customIcon}.png";

                newLoadOrder.Add(item.Value.customIcon, url);
            }
            foreach (KeyValuePair<string, RewardData.RewardKit> kit in rewardData.kits)
            {
                if (!string.IsNullOrEmpty(kit.Value.iconName))
                {
                    if (newLoadOrder.ContainsKey(kit.Value.iconName))
                        continue;

                    string url = kit.Value.iconName;
                    if (!url.StartsWith("http") && !url.StartsWith("www"))
                        url = $"{dataDir}{kit.Value.iconName}.png";

                    newLoadOrder.Add(kit.Value.iconName, url);
                }
            }
            foreach (KeyValuePair<string, RewardData.RewardCommand> command in rewardData.commands)
            {
                if (!string.IsNullOrEmpty(command.Value.iconName))
                {
                    if (newLoadOrder.ContainsKey(command.Value.iconName))
                        continue;

                    string url = command.Value.iconName;
                    if (!url.StartsWith("http") && !url.StartsWith("www"))
                        url = $"{dataDir}{command.Value.iconName}.png";

                    newLoadOrder.Add(command.Value.iconName, url);
                }
            }

            if (newLoadOrder.Count > 0)
                ImageLibrary.Call("ImportImageList", Title, newLoadOrder);

            ImageLibrary.Call("LoadImageList", Title, rewardData.items.Where(y => string.IsNullOrEmpty(y.Value.customIcon)).Select(x => new KeyValuePair<string, ulong>(x.Value.shortname, x.Value.skinId)).ToList(), new Action(CreateAllElements));
        }

        private void SaveLoop() => saveTimer = timer.Once(configData.Options.SaveInterval, () => { SaveRP(); SaveLoop(); });

        private void SendMSG(BasePlayer player, string msg, string keyword = "title")
        {
            if (keyword == "title")
                keyword = lang.GetMessage("title", this, player.UserIDString);

            SendReply(player, $"{color1}{keyword}</color> {color2}{msg}</color>");
        }

        private void InformPoints(BasePlayer player)
        {
            int outstanding = CheckPoints(player.userID);

            if (configData.Options.NPCOnly)
                SendMSG(player, string.Format(msg("msgOutRewardsnpc", player.UserIDString), outstanding));
            else SendMSG(player, string.Format(msg("msgOutRewards1", player.UserIDString), outstanding));
        }

        private object FindPlayer(BasePlayer player, string arg)
        {
            ulong targetID;
            if (ulong.TryParse(arg, out targetID))
            {
                IPlayer target = covalence.Players.FindPlayer(arg);
                if (target != null && target.Object is BasePlayer)
                    return target.Object as BasePlayer;
            }

            IEnumerable<IPlayer> targets = covalence.Players.FindPlayers(arg);

            if (targets.ToArray().Length == 0)
            {
                if (player != null)
                {
                    SendMSG(player, msg("noPlayers", player.UserIDString));
                    return null;
                }
                else return msg("noPlayers");
            }

            if (targets.ToArray().Length > 1)
            {
                if (player != null)
                {
                    SendMSG(player, msg("multiPlayers", player.UserIDString));
                    return null;
                }
                else return msg("multiPlayers");
            }

            if ((targets.ToArray()[0].Object as BasePlayer) != null)
                return targets.ToArray()[0].Object as BasePlayer;
            else
            {
                if (player != null)
                {
                    SendMSG(player, msg("noPlayers", player.UserIDString));
                    return null;
                }
                else return msg("noPlayers");
            }
        }

        private bool RemovePlayer(ulong ID)
        {
            if (playerRP.ContainsKey(ID))
            {
                playerRP.Remove(ID);
                return true;
            }
            return false;
        }

        private void SendEchoConsole(Network.Connection cn, string msg)
        {
            if (Net.sv.IsConnected())
            {
                NetWrite netWrite = Net.sv.StartWrite();
                netWrite.PacketID(Network.Message.Type.ConsoleMessage);
                netWrite.String(msg);
                netWrite.Send(new SendInfo(cn));
            }
        }

        private void OpenStore(BasePlayer player, string npcid = null)
        {
            if (!isILReady)
            {
                SendMSG(player, string.Empty, msg("imWait", player.UserIDString));
                return;
            }
            if (uiManager.IsOpen(player))
                return;

            object success = Interface.Call("canShop", player);
            if (success != null)
            {
                string message = "You are not allowed to shop at the moment";
                if (success is string)
                    message = (string)success;
                SendReply(player, message);
                return;
            }

            CloseMap(player);
            uiManager.AddUI(player, UIPanel.Navigation, Category.None, 0, npcid);

            if (configData.Tabs.Kits)
                uiManager.AddUI(player, UIPanel.Kits, Category.None, 0, npcid);
            else if (configData.Tabs.Items)
                uiManager.AddUI(player, UIPanel.Items, Category.Ammunition, 0, npcid);
            else if (configData.Tabs.Commands)
                uiManager.AddUI(player, UIPanel.Commands, Category.None, 0, npcid);
            else
            {
                uiManager.DestroyUI(player, true);
                PopupMessage(player, "All reward options are currently disabled. Closing the store.");
            }
        }

        private void GiveItem(BasePlayer player, string itemkey)
        {
            if (rewardData.items.ContainsKey(itemkey))
            {
                RewardData.RewardItem entry = rewardData.items[itemkey];
                Item item = null;
                if (entry.isBp)
                {
                    item = ItemManager.CreateByItemID(blueprintId, entry.amount, entry.skinId);
                    item.blueprintTarget = ItemManager.itemList.Find(x => x.shortname == entry.shortname)?.itemid ?? 0;
                }
                else item = ItemManager.CreateByName(entry.shortname, entry.amount, entry.skinId);
                player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
            }
        }

        private int GetAmount(BasePlayer player, string shortname, ulong skinId)
        {
            List<Item> list = Facepunch.Pool.Get<List<Item>>();
            player.inventory.GetAllItems(list);

            int count = 0;
            for (int i = 0; i < list.Count; i++)
            {
                Item item = list[i];
                if (!item.IsBusy() && item.info.shortname == shortname && item.skin == skinId)
                    count += item.amount;
            }

            Facepunch.Pool.FreeUnmanaged(ref list);
            return count;            
        }

        private bool TakeResources(BasePlayer player, string shortname, ulong skinId, int iAmount)
        {
            int itemId = ItemManager.itemDictionaryByName[shortname].itemid;
            
            List<Item> list = Facepunch.Pool.Get<List<Item>>();
            List<Item> collect = Facepunch.Pool.Get<List<Item>>();

            player.inventory.GetAllItems(list);

            int count = 0;
            for (int i = 0; i < list.Count; i++)
            {                
                Item item = list[i];
                if (item.info.shortname == shortname && item.skin == skinId)
                {
                    int required = iAmount - count;
                    if (item.amount <= required)
                    {
                        count += item.amount;
                        collect.Add(item);

                        if (count == iAmount)
                            break;
                    }
                    else
                    {
                        item.amount -= required;
                        item.MarkDirty();
                        count += required;
                        break;
                    }
                }
            }

            bool flag = false;

            if (count >= iAmount)
            {
                for (int i = 0; i < collect.Count; i++)
                {
                    Item item = collect[i];
                    item.RemoveFromContainer();
                    item.Remove(0f);
                }

                flag = true;
            }

            Facepunch.Pool.FreeUnmanaged(ref list);
            Facepunch.Pool.FreeUnmanaged(ref collect);
            return flag;           
        }
         
        private string FormatTime(double time)
        {
            TimeSpan dateDifference = TimeSpan.FromSeconds((float)time);
            int days = dateDifference.Days;
            int hours = dateDifference.Hours;
            hours += (days * 24);
            int mins = dateDifference.Minutes;
            int secs = dateDifference.Seconds;
            return string.Format("{0:00}:{1:00}:{2:00}", hours, mins, secs);
        }

        private static double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

        private bool IsSteamId(string id)
        {
            ulong userId;
            if (!ulong.TryParse(id, out userId))
                return false;
            return IsSteamId(userId);
        }

        private bool IsSteamId(ulong id)
        {
            return id > 76561197960265728L;
        }
        #endregion

        #region Hooks and API
        #region API
        private object AddPoints(object userID, int amount)
        {
            ulong ID;
            object success = GetUserID(userID);
            if (success is bool)
                return false;
            else ID = (ulong)success;

            if (!playerRP.ContainsKey(ID))
                playerRP.Add(ID, amount);
            else playerRP[ID] += amount;

            if (configData.Options.Logs)
            {
                string message = string.Empty;
                BasePlayer player = BasePlayer.FindByID(ID);
                if (player != null)
                    message = $"{ID} - {player.displayName} has been given {amount}x RP";
                else message = $"(offline){ID} has been given {amount}x RP";

                LogToFile($"Earnings", $"[{DateTime.Now.ToString("hh:mm:ss")}] {message}", this);
            }
            return true;
        }

        private object TakePoints(object userID, int amount, string item = "")
        {
            ulong ID;
            object success = GetUserID(userID);
            if (success is bool)
                return false;
            else ID = (ulong)success;

            if (!playerRP.ContainsKey(ID)) return null;
            playerRP[ID] -= amount;

            if (configData.Options.Logs)
            {
                string message = string.Empty;
                BasePlayer player = BasePlayer.FindByID(ID);
                if (player != null)
                    message = $"{ID} - {player.displayName} has spent {amount}x RP{(string.IsNullOrEmpty(item) ? string.Empty : $" on: {item}")}";
                else message = $"(offline){ID} has spent {amount}x RP";

                LogToFile($"SpentRP", $"[{DateTime.Now.ToString("hh:mm:ss")}] {message}", this);
            }
            return true;
        }

        private int CheckPoints(object userID)
        {
            ulong ID;
            object success = GetUserID(userID);
            if (success is bool)
                return 0;
            else ID = (ulong)success;

            if (!playerRP.ContainsKey(ID)) return 0;
            return playerRP[ID];
        }

        private object GetUserID(object userID)
        {
            switch( userID )
            {
                case null:
                    return false;
                case ulong id:
                    return id;
                case string id:
                {
                    if (ulong.TryParse(id, out ulong ID))
                        return ID;
                    return false;
                }
                case EncryptedValue<ulong> id:
                    return id.Get();
                case BasePlayer player:
                    return player.userID.Get();
                case IPlayer player:
                    return ulong.Parse(player.Id);
                default:
                    return false;
            }
        }

        private JObject GetItemList()
        {
            JObject obj = new JObject();
            foreach (KeyValuePair<string, RewardData.RewardItem> item in rewardData.items)
            {
                JObject itemobj = new JObject();
                itemobj["shortname"] = item.Key;
                itemobj["skinid"] = item.Value.skinId;
                itemobj["amount"] = item.Value.amount;
                itemobj["cost"] = item.Value.cost;
                itemobj["category"] = item.Value.category.ToString();
                obj[item.Key] = itemobj;
            }
            return obj;
        }

        private bool AddItem(string shortname, ulong skinId, int amount, int cost, string category, bool isBp = false)
        {
            Category cat = (Category)Enum.Parse(typeof(Category), category, true);

            RewardData.RewardItem newItem = new RewardData.RewardItem
            {
                amount = amount,
                cost = cost,
                shortname = shortname,
                skinId = skinId,
                category = cat,
                isBp = isBp
            };
            string itemName = $"{newItem.shortname}_{newItem.skinId}";

            if (rewardData.items.ContainsKey(itemName))
                return false;

            rewardData.items.Add(itemName, newItem);
            return true;
        }
        #endregion

        #region Hooks
        private void AddImage(string fileName)
        {
            string url = fileName;
            if (!url.StartsWith("http") && !url.StartsWith("www"))
                url = $"file://{Interface.Oxide.DataDirectory}{Path.DirectorySeparatorChar}ServerRewards{Path.DirectorySeparatorChar}Images{Path.DirectorySeparatorChar}{fileName}.png";
            ImageLibrary?.Call("AddImage", url, fileName, 0UL);
        }

        private string GetImage(string fileName, ulong skin = 0)
        {
            string imageId = (string)ImageLibrary.Call("GetImage", fileName, skin);
            if (!string.IsNullOrEmpty(imageId))
                return imageId;
            return string.Empty;
        }

        private void CloseMap(BasePlayer player)
        {
            if (LustyMap)
            {
                LustyMap.Call("DisableMaps", player);
            }
        }

        private void OpenMap(BasePlayer player)
        {
            if (LustyMap)
            {
                LustyMap.Call("EnableMaps", player);
            }
        }

        private void AddMapMarker(float x, float z, string name, string icon = "rewarddealer")
        {
            if (LustyMap)
            {
                LustyMap.Call("AddMarker", x, z, name, icon);
            }
        }

        private void RemoveMapMarker(string name)
        {
            if (LustyMap)
                LustyMap.Call("RemoveMarker", name);
        }

        private void OnUseNPC(BasePlayer npc, BasePlayer player)
        {
            if (player == null || npc == null)
                return;

            string npcID = npc.UserIDString;
            if (userNpc.ContainsKey(player.userID))
            {
                ModifyNPC(player, npc);
                return;
            }

            if (IsRegisteredNPC(npcID) && uiManager.NPCHasUI(npcID) && !uiManager.IsOpen(player))
                OpenStore(player, npcID);
        }
        #endregion
        #endregion

        #region NPC Registration
        private bool IsRegisteredNPC(string ID)
        {
            if (npcData.npcInfo.ContainsKey(ID))
                return true;
            return false;
        }

        [ChatCommand("srnpc")]
        private void cmdSRNPC(BasePlayer player, string command, string[] args)
        {
            if (!IsAuthed(player))
                return;

            if (args == null || args.Length == 0)
            {
                SendMSG(player, "/srnpc add - Add a new NPC vendor");
                SendMSG(player, "/srnpc remove - Remove a NPC vendor");
                SendMSG(player, "/srnpc loot - Create a custom loot table for the specified NPC vendor");
                return;
            }

            switch (args[0].ToLower())
            {
                case "add":
                    userNpc[player.userID] = UserNPC.Add;
                    SendMSG(player, "Press USE on the NPC you wish to add!");
                    return;
                case "remove":
                    userNpc[player.userID] = UserNPC.Remove;
                    SendMSG(player, "Press USE on the NPC you wish to remove!");
                    return;
                case "loot":
                    userNpc[player.userID] = UserNPC.Edit;
                    SendMSG(player, "Press USE on the NPC you wish to edit!");
                    return;
                default:
                    break;
            }
        }

        private void ModifyNPC(BasePlayer player, BasePlayer NPC)
        {
            bool isRegistered = IsRegisteredNPC(NPC.UserIDString);
            UserNPC type = userNpc[player.userID];
            userNpc.Remove(player.userID);

            switch (type)
            {
                case UserNPC.Add:
                    {
                        if (isRegistered)
                        {
                            SendMSG(player, msg("npcExist", player.UserIDString));
                            return;
                        }
                        int key = npcData.npcInfo.Count + 1;
                        npcData.npcInfo.Add(NPC.UserIDString, new NPCData.NPCInfo { name = $"{msg("Reward Dealer")} {key}", x = NPC.transform.position.x, z = NPC.transform.position.z });
                        AddMapMarker(NPC.transform.position.x, NPC.transform.position.z, $"{msg("Reward Dealer")} {key}");
                        CreateNewElement(NPC.UserIDString, npcData.npcInfo[NPC.UserIDString]);
                        SendMSG(player, msg("npcNew"));
                        SaveNPC();
                    }
                    return;
                case UserNPC.Remove:
                    {
                        if (isRegistered)
                        {
                            RemoveMapMarker(npcData.npcInfo[NPC.UserIDString].name);
                            npcData.npcInfo.Remove(NPC.UserIDString);
                            uiManager.RemoveNPCUI(NPC.UserIDString);

                            for (int i = 0; i < npcData.npcInfo.Count; i++)
                            {
                                KeyValuePair<string, NPCData.NPCInfo> info = npcData.npcInfo.ElementAt(i);

                                if (info.Value.name.StartsWith(msg("Reward Dealer")))
                                {
                                    RemoveMapMarker(info.Value.name);
                                    info.Value.name = $"{msg("Reward Dealer")} {i + 1}";
                                    npcData.npcInfo[info.Key] = info.Value;
                                    AddMapMarker(info.Value.x, info.Value.z, info.Value.name);
                                }
                            }

                            SendMSG(player, msg("npcRem"));
                            SaveNPC();
                        }
                        else SendMSG(player, msg("npcNotAdded"));
                    }
                    return;
                case UserNPC.Edit:
                    {
                        if (isRegistered)
                        {
                            if (!npcCreator.ContainsKey(player.userID))
                                npcCreator.Add(player.userID, new KeyValuePair<string, NPCData.NPCInfo>(NPC.UserIDString, new NPCData.NPCInfo()));

                            if (npcData.npcInfo[NPC.UserIDString].useCustom)
                                npcCreator[player.userID] = new KeyValuePair<string, NPCData.NPCInfo>(NPC.UserIDString, npcData.npcInfo[NPC.UserIDString]);
                            CuiElementContainer container = UI.CreateElementContainer(UIMain, uiColors["dark"], "0 0", "1 1");
                            UI.CreatePanel(ref container, UIMain, uiColors["light"], "0.01 0.01", "0.99 0.99", true);
                            UI.CreateLabel(ref container, UIMain, msg("cldesc", player.UserIDString), 18, "0.25 0.88", "0.75 0.98");
                            UI.CreateLabel(ref container, UIMain, msg("storeKits", player.UserIDString), 18, "0 0.8", "0.33 0.88");
                            UI.CreateLabel(ref container, UIMain, msg("storeItems", player.UserIDString), 18, "0.33 0.8", "0.66 0.88");
                            UI.CreateLabel(ref container, UIMain, msg("storeCommands", player.UserIDString), 18, "0.66 0.8", "1 0.88");
                            CuiHelper.AddUi(player, container);
                            NPCLootMenu(player);
                        }
                        else SendMSG(player, msg("npcNotAdded"));
                    }
                    return;
                default:
                    break;
            }
        }

        private void NPCLootMenu(BasePlayer player, int page = 0)
        {
            CuiElementContainer container = UI.CreateElementContainer(UISelect, "0 0 0 0", "0 0", "1 1");
            UI.CreateButton(ref container, UISelect, uiColors["buttonbg"], msg("save", player.UserIDString), 16, "0.85 0.91", "0.95 0.96", "SRUI_NPCSave", TextAnchor.MiddleCenter, 0f);
            UI.CreateButton(ref container, UISelect, uiColors["buttonbg"], msg("storeClose", player.UserIDString), 16, "0.05 0.91", "0.15 0.96", "SRUI_NPCCancel", TextAnchor.MiddleCenter, 0f);

            string[] itemNames = rewardData.items.Keys.ToArray();
            string[] kitNames = rewardData.kits.Keys.ToArray();
            string[] commNames = rewardData.commands.Keys.ToArray();

            int maxCount = itemNames.Length;
            if (kitNames.Length > maxCount) maxCount = kitNames.Length;
            if (commNames.Length > maxCount) maxCount = commNames.Length;

            if (maxCount > 30)
            {
                int maxpages = (maxCount - 1) / 30 + 1;
                if (page < maxpages - 1)
                    UI.CreateButton(ref container, UISelect, uiColors["buttonbg"], ">>>", 18, "0.84 0.05", "0.97 0.1", $"SRUI_NPCPage {page + 1}", TextAnchor.MiddleCenter, 0f);
                if (page > 0)
                    UI.CreateButton(ref container, UISelect, uiColors["buttonbg"], "<<<", 18, "0.03 0.05", "0.16 0.1", $"SRUI_NPCPage {page - 1}", TextAnchor.MiddleCenter, 0f);
            }

            int maxComm = (30 * (page + 1));
            if (maxComm > commNames.Length)
                maxComm = commNames.Length;
            int commcount = 30 * page;

            int comm = 0;
            for (int n = commcount; n < maxComm; n++)
            {
                KeyValuePair<string, RewardData.RewardCommand> command = rewardData.commands.ElementAt(n);

                string color1 = uiColors["buttonbg"];
                string text1 = command.Value.displayName;
                string command1 = $"SRUI_CustomList Commands {command.Key.Replace(" ", "%!%")} true {page}";
                string color2 = "0 0 0 0";
                string text2 = string.Empty;
                string command2 = string.Empty;

                if (npcCreator[player.userID].Value.commands.Contains(command.Key))
                {
                    color1 = uiColors["buttoncom"];
                    command1 = $"SRUI_CustomList Commands {command.Key.Replace(" ", "%!%")} false {page}";
                }
                if (n + 1 < commNames.Length)
                {
                    command = rewardData.commands.ElementAt(n + 1);
                    color2 = uiColors["buttonbg"];
                    text2 = command.Value.displayName;
                    command2 = $"SRUI_CustomList Commands {command.Key.Replace(" ", "%!%")} true {page}";
                    if (npcCreator[player.userID].Value.commands.Contains(command.Key))
                    {
                        color2 = uiColors["buttoncom"];
                        command2 = $"SRUI_CustomList Commands {command.Key.Replace(" ", "%!%")} false {page}";
                    }
                    ++n;
                }

                CreateItemButton(ref container, UISelect, color1, text1, command1, color2, text2, command2, comm, 0.66f);
                comm++;
            }

            int maxKit = (30 * (page + 1));
            if (maxKit > kitNames.Length)
                maxKit = kitNames.Length;
            int kitcount = 30 * page;

            int kits = 0;
            for (int n = kitcount; n < maxKit; n++)
            {
                KeyValuePair<string, RewardData.RewardKit> kit = rewardData.kits.ElementAt(n);

                string color1 = uiColors["buttonbg"];
                string text1 = kit.Value.displayName;
                string command1 = $"SRUI_CustomList Kits {kit.Key.Replace(" ", "%!%")} true {page}";
                string color2 = "0 0 0 0";
                string text2 = string.Empty;
                string command2 = string.Empty;
                if (npcCreator[player.userID].Value.kits.Contains(kit.Key))
                {
                    color1 = uiColors["buttoncom"];
                    command1 = $"SRUI_CustomList Kits {kit.Key.Replace(" ", "%!%")} false {page}";
                }
                if (n + 1 < kitNames.Length)
                {
                    kit = rewardData.kits.ElementAt(n + 1);
                    color2 = uiColors["buttonbg"];
                    text2 = kit.Value.displayName;
                    command2 = $"SRUI_CustomList Kits {kit.Key.Replace(" ", "%!%")} true {page}";
                    if (npcCreator[player.userID].Value.kits.Contains(kit.Key))
                    {
                        color2 = uiColors["buttoncom"];
                        command2 = $"SRUI_CustomList Kits {kit.Key.Replace(" ", "%!%")} false {page}";
                    }
                    ++n;
                }

                CreateItemButton(ref container, UISelect, color1, text1, command1, color2, text2, command2, kits, 0f);
                kits++;
            }

            int maxItem = (30 * (page + 1));
            if (maxItem > itemNames.Length)
                maxItem = itemNames.Length;
            int itemcount = 30 * page;

            int items = 0;
            for (int n = itemcount; n < maxItem; n++)
            {
                KeyValuePair<string, RewardData.RewardItem> item = rewardData.items.ElementAt(n);
                string color1 = uiColors["buttonbg"];
                string text1 = item.Value.displayName;
                string command1 = $"SRUI_CustomList Items {item.Key.Replace(" ", "%!%")} true {page}";
                string color2 = "0 0 0 0";
                string text2 = string.Empty;
                string command2 = string.Empty;

                if (npcCreator[player.userID].Value.items.Contains(item.Key))
                {
                    color1 = uiColors["buttoncom"];
                    command1 = $"SRUI_CustomList Items {item.Key.Replace(" ", "%!%")} false {page}";
                }
                if (n + 1 < rewardData.items.Count)
                {
                    item = rewardData.items.ElementAt(n + 1);
                    color2 = uiColors["buttonbg"];
                    text2 = item.Value.displayName;
                    command2 = $"SRUI_CustomList Items {item.Key.Replace(" ", "%!%")} true {page}";
                    if (npcCreator[player.userID].Value.items.Contains(item.Key))
                    {
                        color2 = uiColors["buttoncom"];
                        command2 = $"SRUI_CustomList Items {item.Key.Replace(" ", "%!%")} false {page}";
                    }
                    ++n;
                }

                CreateItemButton(ref container, UISelect, color1, text1, command1, color2, text2, command2, items, 0.33f);
                items++;
            }
            if (npcCreator[player.userID].Value.useCustom)
                UI.CreateButton(ref container, UISelect, uiColors["buttoncom"], msg("useCustom"), 16, "0.21 0.05", "0.34 0.1", $"SRUI_NPCOption {page} custom", TextAnchor.MiddleCenter, 0f);
            else UI.CreateButton(ref container, UISelect, uiColors["buttonbg"], msg("useCustom"), 16, "0.21 0.05", "0.34 0.1", $"SRUI_NPCOption {page} custom", TextAnchor.MiddleCenter, 0f);

            if (npcCreator[player.userID].Value.canExchange)
                UI.CreateButton(ref container, UISelect, uiColors["buttoncom"], msg("allowExchange"), 16, "0.36 0.05", "0.49 0.1", $"SRUI_NPCOption {page} exchange", TextAnchor.MiddleCenter, 0f);
            else UI.CreateButton(ref container, UISelect, uiColors["buttonbg"], msg("allowExchange"), 16, "0.36 0.05", "0.49 0.1", $"SRUI_NPCOption {page} exchange", TextAnchor.MiddleCenter, 0f);

            if (npcCreator[player.userID].Value.canSell)
                UI.CreateButton(ref container, UISelect, uiColors["buttoncom"], msg("allowSales"), 16, "0.51 0.05", "0.64 0.1", $"SRUI_NPCOption {page} sales", TextAnchor.MiddleCenter, 0f);
            else UI.CreateButton(ref container, UISelect, uiColors["buttonbg"], msg("allowSales"), 16, "0.51 0.05", "0.64 0.1", $"SRUI_NPCOption {page} sales", TextAnchor.MiddleCenter, 0f);

            if (npcCreator[player.userID].Value.canTransfer)
                UI.CreateButton(ref container, UISelect, uiColors["buttoncom"], msg("allowTransfer"), 16, "0.66 0.05", "0.79 0.1", $"SRUI_NPCOption {page} transfer", TextAnchor.MiddleCenter, 0f);
            else UI.CreateButton(ref container, UISelect, uiColors["buttonbg"], msg("allowTransfer"), 16, "0.66 0.05", "0.79 0.1", $"SRUI_NPCOption {page} transfer", TextAnchor.MiddleCenter, 0f);

            CuiHelper.DestroyUi(player, UISelect);
            CuiHelper.AddUi(player, container);
        }

        private void CreateItemButton(ref CuiElementContainer container, string panel, string b1color, string b1text, string b1command, string b2color, string b2text, string b2command, int number, float xPos)
        {
            float offsetX = 0.01f;
            float offsetY = 0.0047f;
            Vector2 dimensions = new Vector2(0.15f, 0.04f);
            Vector2 origin = new Vector2(xPos + offsetX, 0.76f);

            Vector2 offset = new Vector2(0, (offsetY + dimensions.y) * number);

            Vector2 posMin = origin - offset;
            Vector2 posMax = posMin + dimensions;

            UI.CreateButton(ref container, panel, b1color, b1text, 14, $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}", b1command, TextAnchor.MiddleCenter, 0f);
            UI.CreateButton(ref container, panel, b2color, b2text, 14, $"{posMin.x + offsetX + dimensions.x} {posMin.y}", $"{posMax.x + offsetX + dimensions.x} {posMax.y}", b2command, TextAnchor.MiddleCenter, 0f);
        }

        [ConsoleCommand("SRUI_CustomList")]
        private void cmdCustomList(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            string type = arg.GetString(0);
            string key = arg.GetString(1).Replace("%!%", " ");
            bool isAdding = arg.GetBool(2);
            int page = arg.GetInt(3);

            switch (type)
            {
                case "Kits":
                    if (isAdding)
                        npcCreator[player.userID].Value.kits.Add(key);
                    else npcCreator[player.userID].Value.kits.Remove(key);
                    break;
                case "Commands":
                    if (isAdding)
                        npcCreator[player.userID].Value.commands.Add(key);
                    else npcCreator[player.userID].Value.commands.Remove(key);
                    break;
                case "Items":
                    if (isAdding)
                        npcCreator[player.userID].Value.items.Add(key);
                    else npcCreator[player.userID].Value.items.Remove(key);
                    break;
            }
            NPCLootMenu(player, page);
        }

        [ConsoleCommand("SRUI_NPCPage")]
        private void cmdNPCPage(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            int page = arg.GetInt(0);
            NPCLootMenu(player, page);
        }

        [ConsoleCommand("SRUI_NPCOption")]
        private void cmdNPCOption(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            switch (arg.Args[1])
            {
                case "exchange":
                    npcCreator[player.userID].Value.canExchange = !npcCreator[player.userID].Value.canExchange;
                    break;
                case "transfer":
                    npcCreator[player.userID].Value.canTransfer = !npcCreator[player.userID].Value.canTransfer;
                    break;
                case "sales":
                    npcCreator[player.userID].Value.canSell = !npcCreator[player.userID].Value.canSell;
                    break;
                case "custom":
                    npcCreator[player.userID].Value.useCustom = !npcCreator[player.userID].Value.useCustom;
                    break;
                default:
                    break;
            }
            int page = arg.GetInt(0);
            NPCLootMenu(player, page);
        }

        [ConsoleCommand("SRUI_NPCCancel")]
        private void cmdNPCCancel(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            npcCreator.Remove(player.userID);
            CuiHelper.DestroyUi(player, UIMain);
            CuiHelper.DestroyUi(player, UISelect);
            SendReply(player, msg("clcanc", player.UserIDString));
        }

        [ConsoleCommand("SRUI_NPCSave")]
        private void cmdNPCSave(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            CuiHelper.DestroyUi(player, UIMain);
            CuiHelper.DestroyUi(player, UISelect);
            KeyValuePair<string, NPCData.NPCInfo> info = npcCreator[player.userID];
            if (info.Value.useCustom)
            {
                if (info.Value.kits.Count > 0)
                    info.Value.sellKits = true;
                else info.Value.sellKits = false;
                if (info.Value.items.Count > 0)
                    info.Value.sellItems = true;
                else info.Value.sellItems = false;
                if (info.Value.commands.Count > 0)
                    info.Value.sellCommands = true;
                else info.Value.sellCommands = false;
            }
            else
            {
                info.Value.sellKits = true;
                info.Value.sellItems = true;
                info.Value.sellCommands = true;
            }
            npcData.npcInfo[info.Key] = info.Value;
            SaveNPC();

            if (uiManager.npcElements.ContainsKey(info.Key))
                uiManager.npcElements.Remove(info.Key);
            CreateNewElement(info.Key, info.Value);
            npcCreator.Remove(player.userID);
            SendReply(player, msg("clootsucc", player.UserIDString));
        }
        #endregion

        #region Commands
        [ChatCommand("s")]
        private void cmdStore(BasePlayer player, string command, string[] args)
        {
            if ((configData.Options.NPCOnly && IsAuthed(player)) || !configData.Options.NPCOnly)
            {
                OpenStore(player);
            }
        }

        [ChatCommand("rewards")]
        private void cmdRewards(BasePlayer player, string command, string[] args)
        {
            if (args == null || args.Length == 0)
            {
                SendMSG(player, "V " + Version, msg("title", player.UserIDString));
                SendMSG(player, msg("chatCheck1", player.UserIDString), msg("chatCheck", player.UserIDString));
                SendMSG(player, msg("storeSyn2", player.UserIDString), msg("storeSyn21", player.UserIDString));
                if (IsAuthed(player))
                {
                    SendMSG(player, msg("chatAddKit", player.UserIDString), msg("addSynKit", player.UserIDString));
                    SendMSG(player, msg("chatAddItem2", player.UserIDString), msg("addSynItem2", player.UserIDString));
                    SendMSG(player, msg("chatAddCommand", player.UserIDString), msg("addSynCommand", player.UserIDString));
                    SendMSG(player, msg("editSynKit1", player.UserIDString), msg("editSynKit", player.UserIDString));
                    SendMSG(player, msg("editSynItem1", player.UserIDString), msg("editSynItem2", player.UserIDString));
                    SendMSG(player, msg("editSynCommand1", player.UserIDString), msg("editSynCommand", player.UserIDString));
                    SendMSG(player, msg("chatRemove", player.UserIDString), msg("remSynKit", player.UserIDString));
                    SendMSG(player, msg("chatRemove", player.UserIDString), msg("remSynItem", player.UserIDString));
                    SendMSG(player, msg("chatRemove", player.UserIDString), msg("remSynCommand", player.UserIDString));
                    SendMSG(player, msg("chatListOpt1", player.UserIDString), msg("chatListOpt", player.UserIDString));
                }
                return;
            }
            if (args.Length >= 1)
            {
                switch (args[0].ToLower())
                {
                    case "check":
                        int points = CheckPoints(player.userID);
                        SendMSG(player, string.Format(msg("tpointsAvail", player.UserIDString), points));
                        return;
                    #region Lists
                    case "list":
                        if (args.Length >= 2)
                        {
                            if (IsAuthed(player))
                            {
                                switch (args[1].ToLower())
                                {
                                    case "items":
                                        foreach (KeyValuePair<string, RewardData.RewardItem> entry in rewardData.items)
                                        {
                                            SendEchoConsole(player.net.connection, string.Format("Item ID: {0} - Name: {1} Skin ID: {4} - Amount: {2} - Cost: {3}", entry.Key, entry.Value.displayName, entry.Value.amount, entry.Value.cost, entry.Value.skinId));
                                        }
                                        return;
                                    case "kits":
                                        foreach (KeyValuePair<string, RewardData.RewardKit> entry in rewardData.kits)
                                        {
                                            SendEchoConsole(player.net.connection, string.Format("Kit ID: {0} - Name: {1} - Cost: {2} - Description: {3}", entry.Key, entry.Value.displayName, entry.Value.cost, entry.Value.description));
                                        }
                                        return;
                                    case "commands":
                                        foreach (KeyValuePair<string, RewardData.RewardCommand> entry in rewardData.commands)
                                        {
                                            SendEchoConsole(player.net.connection, string.Format("Command ID: {0} - Name: {1} - Cost: {2} - Description: {3} - Commands: {4}", entry.Key, entry.Value.displayName, entry.Value.cost, entry.Value.description, entry.Value.commands.ToSentence()));
                                        }
                                        return;
                                    default:
                                        return;
                                }
                            }
                        }
                        return;
                    #endregion
                    #region Additions
                    case "add":
                        if (args.Length >= 2)
                        {
                            if (IsAuthed(player))
                            {
                                switch (args[1].ToLower())
                                {
                                    case "kit":
                                        if (args.Length == 5)
                                        {
                                            int i = 0;
                                            if (!int.TryParse(args[4], out i))
                                            {
                                                SendMSG(player, msg("noCost", player.UserIDString));
                                                return;
                                            }

                                            object isKit = Kits?.Call("isKit", new object[] { args[3] });
                                            if (isKit is bool && (bool)isKit)
                                            {
                                                if (rewardData.kits.ContainsKey(args[2]))
                                                    SendMSG(player, string.Format(msg("rewardExisting", player.UserIDString), args[2]));
                                                else
                                                {
                                                    rewardData.kits.Add(args[3], new RewardData.RewardKit { displayName = args[2], kitName = args[3], cost = i, description = string.Empty });
                                                    SendMSG(player, string.Format(msg("addSuccess", player.UserIDString), "kit", args[2], i));
                                                    SaveRewards();
                                                }
                                            }
                                            else SendMSG(player, msg("noKit", player.UserIDString), string.Empty);
                                        }
                                        else SendMSG(player, string.Empty, msg("addSynKit", player.UserIDString));
                                        return;
                                    case "item":
                                        if (args.Length >= 3)
                                        {
                                            int i = 0;
                                            if (!int.TryParse(args[2], out i))
                                            {
                                                SendMSG(player, msg("noCost", player.UserIDString));
                                                return;
                                            }
                                            if (player.GetActiveItem() != null)
                                            {
                                                Item item = player.GetActiveItem();
                                                if (item == null)
                                                {
                                                    SendMSG(player, string.Empty, "You must place the item in your hands");
                                                    return;
                                                }

                                                Category cat = (Category)Enum.Parse(typeof(Category), item.info.category.ToString(), true);

                                                RewardData.RewardItem newItem = new RewardData.RewardItem
                                                {
                                                    amount = item.amount,
                                                    cost = i,
                                                    displayName = item.info.displayName.english,
                                                    skinId = item.skin,
                                                    shortname = item.info.shortname,
                                                    category = cat,
                                                    isBp = (args.Length >= 4 && args[3].ToLower() == "bp")
                                                };
                                                string key = $"{item.info.shortname}_{item.skin}";
                                                if (rewardData.items.ContainsKey(key))
                                                    key += $"_{UnityEngine.Random.Range(0, 1000)}";
                                                rewardData.items.Add(key, newItem);
                                                SendMSG(player, string.Format(msg("addSuccess", player.UserIDString), "item", newItem.displayName + $"{(newItem.isBp ? " " + msg("isBp", player.UserIDString) : string.Empty)}", i));
                                                SaveRewards();
                                            }
                                            else SendMSG(player, string.Empty, msg("itemInHand", player.UserIDString));
                                        }
                                        else SendMSG(player, string.Empty, msg("addSynItem2", player.UserIDString));
                                        return;
                                    case "command":
                                        if (args.Length == 5)
                                        {
                                            int i = 0;
                                            if (!int.TryParse(args[4], out i))
                                            {
                                                SendMSG(player, msg("noCost", player.UserIDString));
                                                return;
                                            }
                                            rewardData.commands.Add(args[2], new RewardData.RewardCommand { commands = new List<string> { args[3] }, cost = i, description = string.Empty });
                                            SendMSG(player, string.Format(msg("addSuccess", player.UserIDString), "command", args[2], i));
                                            SaveRewards();
                                        }
                                        else SendMSG(player, string.Empty, msg("addSynCommand", player.UserIDString));
                                        return;
                                }
                            }
                        }
                        return;
                    #endregion
                    #region Removal
                    case "remove":
                        if (IsAuthed(player))
                        {
                            if (args.Length == 3)
                            {
                                switch (args[1].ToLower())
                                {
                                    case "kit":
                                        if (rewardData.kits.ContainsKey(args[2]))
                                        {
                                            rewardData.kits.Remove(args[2]);
                                            SendMSG(player, string.Empty, string.Format(msg("remSuccess", player.UserIDString), args[2]));
                                            SaveRewards();
                                        }
                                        else SendMSG(player, msg("noKitRem", player.UserIDString), string.Empty);
                                        return;
                                    case "item":
                                        if (rewardData.items.ContainsKey(args[2]))
                                        {
                                            rewardData.items.Remove(args[2]);
                                            SendMSG(player, string.Empty, string.Format(msg("remSuccess", player.UserIDString), args[2]));
                                            SaveRewards();
                                        }
                                        else SendMSG(player, msg("noItemRem", player.UserIDString), string.Empty);
                                        return;
                                    case "command":
                                        if (rewardData.commands.ContainsKey(args[2]))
                                        {
                                            rewardData.commands.Remove(args[2]);
                                            SendMSG(player, string.Empty, string.Format(msg("remSuccess", player.UserIDString), args[2]));
                                            SaveRewards();
                                        }
                                        else SendMSG(player, msg("noCommandRem", player.UserIDString), string.Empty);
                                        return;
                                }
                            }
                        }
                        return;
                    #endregion
                    #region Editing
                    case "edit":
                        if (IsAuthed(player))
                        {
                            if (args.Length >= 3)
                            {
                                switch (args[1].ToLower())
                                {
                                    case "kit":
                                        if (rewardData.kits.ContainsKey(args[2]))
                                        {
                                            if (args.Length >= 5)
                                            {
                                                switch (args[3].ToLower())
                                                {
                                                    case "cost":
                                                        int cost = 0;
                                                        if (int.TryParse(args[4], out cost))
                                                        {
                                                            rewardData.kits[args[2]].cost = cost;
                                                            SaveRewards();
                                                            SendMSG(player, string.Format("Kit {0} cost set to {1}", args[2], cost));
                                                        }
                                                        else SendMSG(player, msg("noCost", player.UserIDString));
                                                        return;
                                                    case "description":
                                                        rewardData.kits[args[2]].description = args[4];
                                                        SaveRewards();
                                                        SendMSG(player, string.Format("Kit {0} description set to {1}", args[2], args[4]));
                                                        return;
                                                    case "name":
                                                        rewardData.kits[args[2]].displayName = args[4];
                                                        SaveRewards();
                                                        SendMSG(player, string.Format("Kit {0} name set to {1}", args[2], args[4]));
                                                        return;
                                                    case "icon":
                                                        rewardData.kits[args[2]].iconName = args[4];
                                                        SaveRewards();
                                                        SendMSG(player, string.Format("Kit {0} icon set to {1}", args[2], args[4]));
                                                        return;
                                                    case "cooldown":
                                                        int cooldown = 0;
                                                        if (int.TryParse(args[4], out cooldown))
                                                        {
                                                            rewardData.kits[args[2]].cooldown = cooldown;
                                                            SaveRewards();
                                                            SendMSG(player, string.Format("Kit {0} cooldown set to {1} seconds", args[2], args[4]));
                                                        }
                                                        else SendMSG(player, "You must enter a cooldown number");
                                                        return;
                                                    default:
                                                        SendMSG(player, msg("editSynKit", player.UserIDString), string.Empty);
                                                        return; ;
                                                }
                                            }
                                            else SendMSG(player, msg("editSynKit", player.UserIDString), string.Empty);
                                        }
                                        SendMSG(player, msg("noKitRem", player.UserIDString), string.Empty);
                                        return;
                                    case "item":
                                        if (rewardData.items.ContainsKey(args[2]))
                                        {
                                            if (args.Length >= 5)
                                            {
                                                switch (args[3].ToLower())
                                                {

                                                    case "amount":
                                                        int amount = 0;
                                                        if (int.TryParse(args[4], out amount))
                                                        {
                                                            rewardData.items[args[2]].amount = amount;
                                                            SaveRewards();
                                                            SendMSG(player, string.Format("Item {0} amount set to {1}", args[2], amount));
                                                        }
                                                        else SendMSG(player, msg("noCost", player.UserIDString));
                                                        return;
                                                    case "cost":
                                                        int cost = 0;
                                                        if (int.TryParse(args[4], out cost))
                                                        {
                                                            rewardData.items[args[2]].cost = cost;
                                                            SaveRewards();
                                                            SendMSG(player, string.Format("Item {0} cost set to {1}", args[2], cost));
                                                        }
                                                        else SendMSG(player, msg("noCost", player.UserIDString));
                                                        return;
                                                    case "name":
                                                        rewardData.items[args[2]].displayName = args[4];
                                                        SaveRewards();
                                                        SendMSG(player, string.Format("Item {0} name set to {1}", args[2], args[4]));
                                                        return;
                                                    case "icon":
                                                        rewardData.items[args[2]].customIcon = args[4];
                                                        SaveRewards();
                                                        SendMSG(player, string.Format("Item {0} icon set to {1}", args[2], args[4]));
                                                        return;
                                                    case "cooldown":
                                                        int cooldown = 0;
                                                        if (int.TryParse(args[4], out cooldown))
                                                        {
                                                            rewardData.items[args[2]].cooldown = cooldown;
                                                            SaveRewards();
                                                            SendMSG(player, string.Format("Item {0} cooldown set to {1} seconds", args[2], args[4]));
                                                        }
                                                        else SendMSG(player, "You must enter a cooldown number");
                                                        return;
                                                    default:
                                                        SendMSG(player, msg("editSynItem2", player.UserIDString), string.Empty);
                                                        return;
                                                }
                                            }
                                            else SendMSG(player, msg("editSynKit", player.UserIDString), string.Empty);
                                        }
                                        SendMSG(player, msg("noItemRem", player.UserIDString), string.Empty);
                                        return;
                                    case "command":
                                        if (rewardData.commands.ContainsKey(args[2]))
                                        {
                                            if (args.Length >= 5)
                                            {
                                                switch (args[3].ToLower())
                                                {
                                                    case "cost":
                                                        int cost = 0;
                                                        if (int.TryParse(args[4], out cost))
                                                        {
                                                            rewardData.commands[args[2]].cost = cost;
                                                            SaveRewards();
                                                            SendMSG(player, string.Format("Command {0} cost set to {1}", args[2], cost));
                                                        }
                                                        else SendMSG(player, msg("noCost", player.UserIDString));
                                                        return;
                                                    case "description":
                                                        rewardData.commands[args[2]].description = args[4];
                                                        SaveRewards();
                                                        SendMSG(player, string.Format("Command {0} description set to {1}", args[2], args[4]));
                                                        return;
                                                    case "name":
                                                        rewardData.commands[args[2]].displayName = args[4];
                                                        SaveRewards();
                                                        SendMSG(player, string.Format("Command {0} name set to {1}", args[2], args[4]));
                                                        return;
                                                    case "icon":
                                                        rewardData.commands[args[2]].iconName = args[4];
                                                        SaveRewards();
                                                        SendMSG(player, string.Format("Command {0} icon set to {1}", args[2], args[4]));
                                                        return;
                                                    case "add":
                                                        if (!rewardData.commands[args[2]].commands.Contains(args[4]))
                                                        {
                                                            rewardData.commands[args[2]].commands.Add(args[4]);
                                                            SaveRewards();
                                                            SendMSG(player, string.Format("Added command \"{1}\" to Reward Command {0}", args[2], args[4]));
                                                        }
                                                        else SendMSG(player, string.Format("The command \"0\" is already registered to this reward command", args[4]));
                                                        return;
                                                    case "remove":
                                                        if (rewardData.commands[args[2]].commands.Contains(args[4]))
                                                        {
                                                            rewardData.commands[args[2]].commands.Remove(args[4]);
                                                            SaveRewards();
                                                            SendMSG(player, string.Format("Removed command \"{1}\" to Command {0}", args[2], args[4]));
                                                        }
                                                        else SendMSG(player, string.Format("The command \"{0}\" is not registered to this reward command", args[4]));
                                                        return;
                                                    case "cooldown":
                                                        int cooldown = 0;
                                                        if (int.TryParse(args[4], out cooldown))
                                                        {
                                                            rewardData.commands[args[2]].cooldown = cooldown;
                                                            SaveRewards();
                                                            SendMSG(player, string.Format("Command {0} cooldown set to {1} seconds", args[2], args[4]));
                                                        }
                                                        else SendMSG(player, "You must enter a cooldown number");
                                                        return;
                                                    default:
                                                        SendMSG(player, msg("editSynCommand", player.UserIDString), string.Empty);
                                                        return;
                                                }
                                            }
                                            else SendMSG(player, msg("editSynKit", player.UserIDString), string.Empty);
                                        }
                                        SendMSG(player, msg("noCommandRem", player.UserIDString), string.Empty);
                                        return;
                                }
                            }
                        }
                        return;
                        #endregion
                }
            }
        }

        [ConsoleCommand("rewards")]
        private void ccmdRewards(ConsoleSystem.Arg conArgs)
        {
            if (conArgs.Connection != null) return;

            string[] args = conArgs.Args;
            if (args == null || args.Length == 0)
            {
                SendReply(conArgs, $"{Title}  v{Version}");
                SendReply(conArgs, "--- List Rewards ---");
                SendReply(conArgs, "rewards list <items | kits | commands> - Display a list of rewards for the specified category, which information on each item");
                SendReply(conArgs, "--- Add Rewards ---");
                SendReply(conArgs, "rewards add item <shortname> <skinId> <amount> <cost> <opt: cooldown> <opt:bp> - Add a new reward item to the store (add \"bp\" to add the item as a blueprint)");
                SendReply(conArgs, "rewards add kit <name> <kitname> <cost> <opt: cooldown> - Add a new reward kit to the store");
                SendReply(conArgs, "rewards add command <name> <command> <cost> <opt: cooldown> - Add a new reward command to the store");
                SendReply(conArgs, "--- Editing Rewards ---");
                SendReply(conArgs, "rewards edit item <ID> <name | cost | amount | cooldown> \"edit value\" - Edit the specified field of the item with ID number <ID>");
                SendReply(conArgs, "rewards edit kit <ID> <name | cost | description | icon | cooldown> \"edit value\" - Edit the specified field of the kit with ID number <ID>");
                SendReply(conArgs, "rewards edit command <ID> <name | cost | amount | description | icon | add | remove | cooldown> \"edit value\" - Edit the specified field of the kit with ID number <ID>");
                SendReply(conArgs, "Icon field : The icon field can either be a URL, or a image saved to disk under the folder \"oxide/data/ServerRewards/Images/\"");
                SendReply(conArgs, "Command add/remove field: Here you add additional commands or remove existing commands. Be sure to type the command inside quotation marks");
                SendReply(conArgs, "--- Removing Rewards ---");
                SendReply(conArgs, "rewards remove item <ID> - Removes the item with the specified ID");
                SendReply(conArgs, "rewards remove kit <ID> - Removes the kit with the specified ID");
                SendReply(conArgs, "rewards remove command <ID> - Removes the command with the specified ID");
                SendReply(conArgs, "--- Important Note ---");
                SendReply(conArgs, "Any changes you make to the store items/kits/commands will NOT be reflected until you reload the plugin!");
                return;
            }
            if (args.Length >= 1)
            {
                switch (args[0].ToLower())
                {
                    #region Lists
                    case "list":
                        if (args.Length >= 2)
                        {
                            switch (args[1].ToLower())
                            {
                                case "items":
                                    foreach (KeyValuePair<string, RewardData.RewardItem> entry in rewardData.items)
                                    {
                                        SendReply(conArgs, string.Format("Item ID: {0} || Name: {1} || Skin ID: {4} || Amount: {2} || Cost: {3} || Cooldown : {4}", entry.Key, entry.Value.displayName, entry.Value.amount, entry.Value.cost, entry.Value.skinId, entry.Value.cooldown));
                                    }
                                    return;
                                case "kits":
                                    foreach (KeyValuePair<string, RewardData.RewardKit> entry in rewardData.kits)
                                    {
                                        SendReply(conArgs, string.Format("Kit ID: {0} || Name: {1} || Cost: {2} || Description: {3} || Cooldown : {4}", entry.Key, entry.Value.displayName, entry.Value.cost, entry.Value.description, entry.Value.cooldown));
                                    }
                                    return;
                                case "commands":
                                    foreach (KeyValuePair<string, RewardData.RewardCommand> entry in rewardData.commands)
                                    {
                                        SendReply(conArgs, string.Format("Command ID: {0} || Name: {1} || Cost: {2} || Description: {3} || Commands: {4} || Cooldown : {5}", entry.Key, entry.Value.displayName, entry.Value.cost, entry.Value.description, entry.Value.commands.ToSentence(), entry.Value.cooldown));
                                    }
                                    return;
                                default:
                                    return;
                            }
                        }
                        return;
                    #endregion
                    #region Additions
                    case "add":
                        if (args.Length >= 2)
                        {
                            switch (args[1].ToLower())
                            {
                                case "item":
                                    if (args.Length >= 6)
                                    {
                                        string shortname = args[2];
                                        ulong skinId;
                                        if (!ulong.TryParse(args[3], out skinId))
                                        {
                                            SendReply(conArgs, "You must enter a number for the skin ID. If you dont wish to select any skin use 0");
                                            return;
                                        }
                                        int amount;
                                        if (!int.TryParse(args[4], out amount))
                                        {
                                            SendReply(conArgs, "You must enter an amount of this item to sell");
                                            return;
                                        }
                                        int cost;
                                        if (!int.TryParse(args[5], out cost))
                                        {
                                            SendReply(conArgs, "You must enter a price for this item");
                                            return;
                                        }
                                        ItemDefinition itemDef = ItemManager.FindItemDefinition(shortname);
                                        if (itemDef != null)
                                        {
                                            Category cat = (Category)Enum.Parse(typeof(Category), itemDef.category.ToString(), true);
                                            int cooldown = 0;
                                            if (args.Length >= 7)
                                                int.TryParse(args[6], out cooldown);
                                            RewardData.RewardItem newItem = new RewardData.RewardItem
                                            {
                                                amount = amount,
                                                cost = cost,
                                                displayName = itemDef.displayName.translated,
                                                skinId = skinId,
                                                shortname = shortname,
                                                category = cat,
                                                cooldown = cooldown,
                                                isBp = (args.Length >= 8 && args[7].ToLower() == "bp")
                                            };
                                            string key = $"{shortname}_{skinId}";
                                            if (rewardData.items.ContainsKey(key))
                                                key += $"_{UnityEngine.Random.Range(0, 1000)}";
                                            rewardData.items.Add(key, newItem);
                                            SendReply(conArgs, string.Format(msg("addSuccess"), "item", newItem.displayName + $"{(newItem.isBp ? " " + msg("isBp") : string.Empty)}", cost));
                                            SaveRewards();
                                        }
                                        else SendReply(conArgs, "Invalid item selected!");
                                    }
                                    else SendReply(conArgs, msg("addSynItemCon"));
                                    return;
                                case "kit":
                                    if (args.Length >= 5)
                                    {
                                        int i = 0;
                                        if (!int.TryParse(args[4], out i))
                                        {
                                            SendReply(conArgs, msg("noCost"));
                                            return;
                                        }

                                        int cooldown = 0;
                                        if (args.Length >= 6)
                                            int.TryParse(args[5], out cooldown);

                                        object isKit = Kits?.Call("isKit", new object[] { args[3] });
                                        if (isKit is bool && (bool)isKit)
                                        {
                                            if (rewardData.kits.ContainsKey(args[2]))
                                                SendReply(conArgs, string.Format(msg("rewardExisting"), args[2]));
                                            else
                                            {
                                                rewardData.kits.Add(args[3], new RewardData.RewardKit { displayName = args[2], kitName = args[3], cost = i, description = string.Empty, cooldown = cooldown });
                                                SendReply(conArgs, string.Format(msg("addSuccess"), "kit", args[2], i));
                                                SaveRewards();
                                            }
                                        }
                                        else SendReply(conArgs, msg("noKit"));
                                    }
                                    else SendReply(conArgs, msg("addSynKit"));
                                    return;
                                case "command":
                                    if (args.Length >= 5)
                                    {
                                        int i = 0;
                                        if (!int.TryParse(args[4], out i))
                                        {
                                            SendReply(conArgs, msg("noCost"));
                                            return;
                                        }

                                        int cooldown = 0;
                                        if (args.Length >= 6)
                                            int.TryParse(args[5], out cooldown);

                                        rewardData.commands.Add(args[2], new RewardData.RewardCommand { commands = new List<string> { args[3] }, cost = i, description = string.Empty, cooldown = cooldown });
                                        SendReply(conArgs, string.Format(msg("addSuccess"), "command", args[2], i));
                                        SaveRewards();
                                    }
                                    else SendReply(conArgs, msg("addSynCommand"));
                                    return;
                            }
                        }

                        return;
                    #endregion
                    #region Removal
                    case "remove":
                        if (args.Length == 3)
                        {
                            switch (args[1].ToLower())
                            {
                                case "kit":
                                    if (rewardData.kits.ContainsKey(args[2]))
                                    {
                                        rewardData.kits.Remove(args[2]);
                                        SendReply(conArgs, string.Format(msg("remSuccess"), args[2]));
                                        SaveRewards();
                                    }
                                    else SendReply(conArgs, msg("noKitRem"));
                                    return;
                                case "item":
                                    if (rewardData.items.ContainsKey(args[2]))
                                    {
                                        rewardData.items.Remove(args[2]);
                                        SendReply(conArgs, string.Format(msg("remSuccess"), args[2]));
                                        SaveRewards();
                                    }
                                    else SendReply(conArgs, msg("noItemRem"));
                                    return;
                                case "command":
                                    if (rewardData.commands.ContainsKey(args[2]))
                                    {
                                        rewardData.commands.Remove(args[2]);
                                        SendReply(conArgs, string.Format(msg("remSuccess"), args[2]));
                                        SaveRewards();
                                    }
                                    else SendReply(conArgs, msg("noCommandRem"));
                                    return;
                            }
                        }
                        return;
                    #endregion
                    #region Editing
                    case "edit":
                        if (args.Length >= 3)
                        {
                            switch (args[1].ToLower())
                            {
                                case "kit":
                                    if (rewardData.kits.ContainsKey(args[2]))
                                    {
                                        if (args.Length >= 5)
                                        {
                                            switch (args[3].ToLower())
                                            {
                                                case "cost":
                                                    int cost = 0;
                                                    if (int.TryParse(args[4], out cost))
                                                    {
                                                        rewardData.kits[args[2]].cost = cost;
                                                        SaveRewards();
                                                        SendReply(conArgs, string.Format("Kit {0} cost set to {1}", args[2], cost));
                                                    }
                                                    else SendReply(conArgs, msg("noCost"));
                                                    return;
                                                case "description":
                                                    rewardData.kits[args[2]].description = args[4];
                                                    SaveRewards();
                                                    SendReply(conArgs, string.Format("Kit {0} description set to {1}", args[2], args[4]));
                                                    return;
                                                case "name":
                                                    rewardData.kits[args[2]].displayName = args[4];
                                                    SaveRewards();
                                                    SendReply(conArgs, string.Format("Kit {0} name set to {1}", args[2], args[4]));
                                                    return;
                                                case "icon":
                                                    rewardData.kits[args[2]].iconName = args[4];
                                                    SaveRewards();
                                                    SendReply(conArgs, string.Format("Kit {0} icon set to {1}", args[2], args[4]));
                                                    return;
                                                case "cooldown":
                                                    int cooldown = 0;
                                                    if (int.TryParse(args[4], out cooldown))
                                                    {
                                                        rewardData.kits[args[2]].cooldown = cooldown;
                                                        SaveRewards();
                                                        SendReply(conArgs, string.Format("Kit {0} cooldown set to {1} seconds", args[2], args[4]));
                                                    }
                                                    else SendReply(conArgs, "You must enter a cooldown number");
                                                    return;
                                                default:
                                                    SendReply(conArgs, msg("editSynKit"));
                                                    return; ;
                                            }
                                        }
                                        else SendReply(conArgs, msg("editSynKit"));
                                    }
                                    else SendReply(conArgs, msg("noKitRem"));
                                    return;
                                case "item":
                                    if (rewardData.items.ContainsKey(args[2]))
                                    {
                                        if (args.Length >= 5)
                                        {
                                            switch (args[3].ToLower())
                                            {

                                                case "amount":
                                                    int amount = 0;
                                                    if (int.TryParse(args[4], out amount))
                                                    {
                                                        rewardData.items[args[2]].amount = amount;
                                                        SaveRewards();
                                                        SendReply(conArgs, string.Format("Item {0} amount set to {1}", args[2], amount));
                                                    }
                                                    else SendReply(conArgs, msg("noCost"));
                                                    return;
                                                case "cost":
                                                    int cost = 0;
                                                    if (int.TryParse(args[4], out cost))
                                                    {
                                                        rewardData.items[args[2]].cost = cost;
                                                        SaveRewards();
                                                        SendReply(conArgs, string.Format("Item {0} cost set to {1}", args[2], cost));
                                                    }
                                                    else SendReply(conArgs, msg("noCost"));
                                                    return;
                                                case "name":
                                                    rewardData.items[args[2]].displayName = args[4];
                                                    SaveRewards();
                                                    SendReply(conArgs, string.Format("Item {0} name set to {1}", args[2], args[4]));
                                                    return;
                                                case "icon":
                                                    rewardData.items[args[2]].customIcon = args[4];
                                                    SaveRewards();
                                                    SendReply(conArgs, string.Format("Item {0} icon set to {1}", args[2], args[4]));
                                                    return;
                                                case "cooldown":
                                                    int cooldown = 0;
                                                    if (int.TryParse(args[4], out cooldown))
                                                    {
                                                        rewardData.items[args[2]].cooldown = cooldown;
                                                        SaveRewards();
                                                        SendReply(conArgs, string.Format("Item {0} cooldown set to {1} seconds", args[2], args[4]));
                                                    }
                                                    else SendReply(conArgs, "You must enter a cooldown number");
                                                    return;
                                                default:
                                                    SendReply(conArgs, msg("editSynItem2"));
                                                    return;
                                            }
                                        }
                                        else SendReply(conArgs, msg("editSynKit"));
                                    }
                                    else SendReply(conArgs, msg("noItemRem"));
                                    return;
                                case "command":
                                    if (rewardData.commands.ContainsKey(args[2]))
                                    {
                                        if (args.Length >= 5)
                                        {
                                            switch (args[3].ToLower())
                                            {
                                                case "cost":
                                                    int cost = 0;
                                                    if (int.TryParse(args[4], out cost))
                                                    {
                                                        rewardData.commands[args[2]].cost = cost;
                                                        SaveRewards();
                                                        SendReply(conArgs, string.Format("Command {0} cost set to {1}", args[2], cost));
                                                    }
                                                    else SendReply(conArgs, msg("noCost"));
                                                    return;
                                                case "description":
                                                    rewardData.commands[args[2]].description = args[4];
                                                    SaveRewards();
                                                    SendReply(conArgs, string.Format("Command {0} description set to {1}", args[2], args[4]));
                                                    return;
                                                case "name":
                                                    rewardData.commands[args[2]].displayName = args[4];
                                                    SaveRewards();
                                                    SendReply(conArgs, string.Format("Command {0} name set to {1}", args[2], args[4]));
                                                    return;
                                                case "icon":
                                                    rewardData.commands[args[2]].iconName = args[4];
                                                    SaveRewards();
                                                    SendReply(conArgs, string.Format("Command {0} icon set to {1}", args[2], args[4]));
                                                    return;
                                                case "add":
                                                    if (!rewardData.commands[args[2]].commands.Contains(args[4]))
                                                    {
                                                        rewardData.commands[args[2]].commands.Add(args[4]);
                                                        SaveRewards();
                                                        SendReply(conArgs, string.Format("Added command \"{1}\" to Reward Command {0}", args[2], args[4]));
                                                    }
                                                    else SendReply(conArgs, string.Format("The command \"0\" is already registered to this reward command", args[4]));
                                                    return;
                                                case "remove":
                                                    if (rewardData.commands[args[2]].commands.Contains(args[4]))
                                                    {
                                                        rewardData.commands[args[2]].commands.Remove(args[4]);
                                                        SaveRewards();
                                                        SendReply(conArgs, string.Format("Removed command \"{1}\" to Command {0}", args[2], args[4]));
                                                    }
                                                    else SendReply(conArgs, string.Format("The command \"{0}\" is not registered to this reward command", args[4]));
                                                    return;
                                                case "cooldown":
                                                    int cooldown = 0;
                                                    if (int.TryParse(args[4], out cooldown))
                                                    {
                                                        rewardData.commands[args[2]].cooldown = cooldown;
                                                        SaveRewards();
                                                        SendReply(conArgs, string.Format("Command {0} cooldown set to {1} seconds", args[2], args[4]));
                                                    }
                                                    else SendReply(conArgs, "You must enter a cooldown number");
                                                    return;
                                                default:
                                                    SendReply(conArgs, msg("editSynCommand"));
                                                    return;
                                            }
                                        }
                                        else SendReply(conArgs, msg("editSynKit"));
                                    }
                                    else SendReply(conArgs, msg("noCommandRem"));
                                    return;
                            }
                        }
                        return;
                        #endregion
                }
            }
        }

        [ChatCommand("sr")]
        private void cmdSR(BasePlayer player, string command, string[] args)
        {
            if (!IsAuthed(player))
                return;

            if (args == null || args.Length == 0)
            {
                SendMSG(player, msg("srAdd2", player.UserIDString), "/sr add <playername> <amount>");
                SendMSG(player, msg("srTake2", player.UserIDString), "/sr take <playername> <amount>");
                SendMSG(player, msg("srClear2", player.UserIDString), "/sr clear <playername>");
                SendMSG(player, msg("srCheck", player.UserIDString), "/sr check <playername>");
                SendMSG(player, msg("srAdd3", player.UserIDString), "/sr add all <amount>");
                SendMSG(player, msg("srTake3", player.UserIDString), "/sr take all <amount>");
                SendMSG(player, msg("srClear3", player.UserIDString), "/sr clear all");
                return;
            }
            if (args.Length >= 2)
            {
                if (args[1].ToLower() == "all")
                {
                    switch (args[0].ToLower())
                    {
                        case "add":
                            if (args.Length == 3)
                            {
                                int i = 0;
                                if (int.TryParse(args[2], out i))
                                {
                                    ulong[] pList = playerRP.Keys.ToArray();
                                    foreach (ulong entry in pList)
                                        AddPoints(entry, i);
                                    SendMSG(player, string.Format(msg("addPointsAll", player.UserIDString), i));
                                }
                            }
                            return;

                        case "take":
                            if (args.Length == 3)
                            {
                                int i = 0;
                                if (int.TryParse(args[2], out i))
                                {
                                    ulong[] pList = playerRP.Keys.ToArray();
                                    foreach (ulong entry in pList)
                                    {
                                        int amount = CheckPoints(entry);
                                        if (amount >= i)
                                            TakePoints(entry, i);
                                        else TakePoints(entry, amount);
                                    }

                                    SendMSG(player, string.Format(msg("remPointsAll", player.UserIDString), i));
                                }
                            }
                            return;
                        case "clear":
                            playerRP.Clear();
                            SendMSG(player, msg("clearAll", player.UserIDString));
                            return;
                    }
                }
                object target = FindPlayer(player, args[1]);
                if (target != null && target is BasePlayer)
                {
                    switch (args[0].ToLower())
                    {
                        case "add":
                            if (args.Length == 3)
                            {
                                int i = 0;
                                int.TryParse(args[2], out i);
                                if (i != 0)
                                    if (AddPoints((target as BasePlayer).userID, i) != null)
                                        SendMSG(player, string.Format(msg("addPoints", player.UserIDString), (target as BasePlayer).displayName, i));
                            }
                            return;

                        case "take":
                            if (args.Length == 3)
                            {
                                int i = 0;
                                int.TryParse(args[2], out i);
                                if (i != 0)
                                    if (TakePoints((target as BasePlayer).userID, i) != null)
                                        SendMSG(player, string.Format(msg("removePoints", player.UserIDString), i, (target as BasePlayer).displayName));
                            }
                            return;
                        case "clear":
                            RemovePlayer((target as BasePlayer).userID);
                            SendMSG(player, string.Format(msg("clearPlayer", player.UserIDString), (target as BasePlayer).displayName));
                            return;
                        case "check":
                            if (args.Length == 2)
                            {
                                int points = CheckPoints((target as BasePlayer).userID);
                                SendMSG(player, string.Format("{0} - {2}: {1}", (target as BasePlayer).displayName, points, msg("storeRP")));
                            }
                            return;
                    }
                }
            }
        }

        [ConsoleCommand("sr")]
        private void ccmdSR(ConsoleSystem.Arg arg)
        {
            if (!IsAuthedConsole(arg)) return;
            if (arg.Args == null || arg.Args.Length == 0)
            {
                SendReply(arg, "sr add <playername> <amount>" + msg("srAdd2"));
                SendReply(arg, "sr take <playername> <amount>" + msg("srTake2"));
                SendReply(arg, "sr clear <playername>" + msg("srClear2"));
                SendReply(arg, "sr check <playername>" + msg("srCheck"));
                SendReply(arg, "sr add all <amount>" + msg("srAdd3"));
                SendReply(arg, "sr take all <amount>" + msg("srTake3"));
                SendReply(arg, "sr clear all" + msg("srClear3"));
                return;
            }
            if (arg.Args.Length >= 2)
            {
                if (arg.Args[1].ToLower() == "all")
                {
                    switch (arg.Args[0].ToLower())
                    {
                        case "add":
                            if (arg.Args.Length == 3)
                            {
                                int i = 0;
                                if (int.TryParse(arg.Args[2], out i))
                                {
                                    ulong[] pList = playerRP.Keys.ToArray();
                                    foreach (ulong entry in pList)
                                        AddPoints(entry, i);
                                    SendReply(arg, string.Format(msg("addPointsAll"), i));
                                }
                            }
                            return;

                        case "take":
                            if (arg.Args.Length == 3)
                            {
                                int i = 0;
                                if (int.TryParse(arg.Args[2], out i))
                                {
                                    ulong[] pList = playerRP.Keys.ToArray();
                                    foreach (ulong entry in pList)
                                    {
                                        int amount = CheckPoints(entry);
                                        if (amount >= i)
                                            TakePoints(entry, i);
                                        else TakePoints(entry, amount);
                                    }

                                    SendReply(arg, string.Format(msg("remPointsAll"), i));
                                }
                            }
                            return;
                        case "clear":
                            playerRP.Clear();
                            SendReply(arg, msg("clearAll"));
                            return;
                    }
                }

                object target = FindPlayer(null, arg.Args[1]);
                if (target is string)
                {
                    SendReply(arg, (string)target);
                    return;
                }

                if (target != null && target is BasePlayer)
                {
                    switch (arg.Args[0].ToLower())
                    {
                        case "add":
                            if (arg.Args.Length == 3)
                            {
                                int i = 0;
                                int.TryParse(arg.Args[2], out i);
                                if (i != 0)
                                    if (AddPoints((target as BasePlayer).userID, i) != null)
                                        SendReply(arg, string.Format(msg("addPoints"), (target as BasePlayer).displayName, i));
                            }
                            return;
                        case "take":
                            if (arg.Args.Length == 3)
                            {
                                int i = 0;
                                int.TryParse(arg.Args[2], out i);
                                if (i != 0)
                                    if (TakePoints((target as BasePlayer).userID, i) != null)
                                        SendReply(arg, string.Format(msg("removePoints"), i, (target as BasePlayer).displayName));
                            }
                            return;
                        case "clear":
                            RemovePlayer((target as BasePlayer).userID);
                            SendReply(arg, string.Format(msg("clearPlayer"), (target as BasePlayer).displayName));
                            return;
                        case "check":
                            if (arg.Args.Length == 2)
                            {
                                int points = CheckPoints((target as BasePlayer).userID);
                                SendReply(arg, string.Format("{0} - {2}: {1}", (target as BasePlayer).displayName, points, msg("storeRP")));
                            }
                            return;
                    }
                }
            }
        }

        private bool IsAuthed(BasePlayer player)
        {
            if (player.net.connection != null)
                if (player.net.connection.authLevel < 1)
                    return false;
            return true;
        }

        private bool IsAuthedConsole(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                if (arg.Connection.authLevel < 1)
                {
                    SendReply(arg, "You dont not have permission to use this command.");
                    return false;
                }
            }
            return true;
        }
        #endregion

        #region Kit Contents
        private string GetKitContents(string kitname)
        {
            object contents = Kits?.Call("GetKitInfo", kitname);
            if (contents != null && contents is JObject)
            {
                List<string> contentList = new List<string>();
                JObject kitContents = contents as JObject;

                JArray items = kitContents["items"] as JArray;
                foreach (JToken itemEntry in items)
                {
                    JObject item = itemEntry as JObject;
                    string itemString = (int)item["amount"] > 1 ? $"{(int)item["amount"]}x " : string.Empty;
                    itemString += itemNames[itemIds[(int)item["itemid"]]];

                    List<string> mods = new List<string>();
                    foreach (JToken mod in item["mods"] as JArray)
                        mods.Add(itemNames[itemIds[(int)mod]]);

                    if (mods.Count > 0)
                        itemString += $" ({mods.ToSentence()})";

                    contentList.Add(itemString);
                }
                return contentList.ToSentence();
            }
            return null;
        }
        #endregion

        #region Config
        private ConfigData configData;

        private class Colors
        {
            [JsonProperty(PropertyName = "Primary text color")]
            public string TextColor_Primary { get; set; }
            [JsonProperty(PropertyName = "Secondary text color")]
            public string TextColor_Secondary { get; set; }
            [JsonProperty(PropertyName = "Background color")]
            public UIColor Background_Dark { get; set; }
            [JsonProperty(PropertyName = "Secondary panel color")]
            public UIColor Background_Medium { get; set; }
            [JsonProperty(PropertyName = "Primary panel color")]
            public UIColor Background_Light { get; set; }
            [JsonProperty(PropertyName = "Button color - standard")]
            public UIColor Button_Standard { get; set; }
            [JsonProperty(PropertyName = "Button color - accept")]
            public UIColor Button_Accept { get; set; }
            [JsonProperty(PropertyName = "Button color - inactive")]
            public UIColor Button_Inactive { get; set; }
        }

        private class UIColor
        {
            [JsonProperty(PropertyName = "Hex color")]
            public string Color { get; set; }
            [JsonProperty(PropertyName = "Transparency (0 - 1)")]
            public float Alpha { get; set; }
        }

        private class Tabs
        {
            [JsonProperty(PropertyName = "Show kits tab")]
            public bool Kits { get; set; }
            [JsonProperty(PropertyName = "Show commands tab")]
            public bool Commands { get; set; }
            [JsonProperty(PropertyName = "Show items tab")]
            public bool Items { get; set; }
            [JsonProperty(PropertyName = "Show exchange tab")]
            public bool Exchange { get; set; }
            [JsonProperty(PropertyName = "Show transfer tab")]
            public bool Transfer { get; set; }
            [JsonProperty(PropertyName = "Show seller tab")]
            public bool Seller { get; set; }
        }

        private class Exchange
        {
            [JsonProperty(PropertyName = "Value of RP")]
            public int RP { get; set; }
            [JsonProperty(PropertyName = "Value of Economics")]
            public int Economics { get; set; }
        }

        private class Options
        {
            [JsonProperty(PropertyName = "Log all transactions")]
            public bool Logs { get; set; }
            [JsonProperty(PropertyName = "Data save interval")]
            public int SaveInterval { get; set; }
            [JsonProperty(PropertyName = "Use NPC dealers only")]
            public bool NPCOnly { get; set; }
        }

        private class UIOptions
        {
            [JsonProperty(PropertyName = "Disable fade in effect")]
            public bool FadeIn { get; set; }
            
            [JsonProperty(PropertyName = "Display kit contents as the description")]
            public bool KitContents { get; set; }
            
            [JsonProperty(PropertyName = "Display user playtime")]
            public bool ShowPlaytime { get; set; }
        }

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Coloring")]
            public Colors Colors { get; set; }
            [JsonProperty(PropertyName = "Active categories (global)")]
            public Tabs Tabs { get; set; }
            [JsonProperty(PropertyName = "Currency exchange rates")]
            public Exchange Exchange { get; set; }
            [JsonProperty(PropertyName = "Options")]
            public Options Options { get; set; }
            [JsonProperty(PropertyName = "UI Options")]
            public UIOptions UIOptions { get; set; }
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
            color1 = $"<color={configData.Colors.TextColor_Primary}>";
            color2 = $"<color={configData.Colors.TextColor_Secondary}>";
        }

        protected override void LoadDefaultConfig()
        {
            ConfigData config = new ConfigData
            {
                Colors = new Colors
                {
                    Background_Dark = new UIColor { Color = "#2a2a2a", Alpha = 0.98f },
                    Background_Medium = new UIColor { Color = "#373737", Alpha = 0.98f },
                    Background_Light = new UIColor { Color = "#696969", Alpha = 0.4f },
                    Button_Accept = new UIColor { Color = "#00cd00", Alpha = 0.9f },
                    Button_Inactive = new UIColor { Color = "#a8a8a8", Alpha = 0.9f },
                    Button_Standard = new UIColor { Color = "#2a2a2a", Alpha = 0.9f },
                    TextColor_Primary = "#ce422b",
                    TextColor_Secondary = "#939393"
                },
                Exchange = new Exchange
                {
                    Economics = 100,
                    RP = 1
                },
                Options = new Options
                {
                    Logs = true,
                    NPCOnly = false,
                    SaveInterval = 600
                },
                Tabs = new Tabs
                {
                    Commands = true,
                    Exchange = true,
                    Items = true,
                    Kits = true,
                    Seller = true,
                    Transfer = true
                },
                UIOptions = new UIOptions
                {
                    FadeIn = true,
                    KitContents = true,
                    ShowPlaytime = true
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Data Management
        private void SaveRP()
        {
            playerData.playerRP = playerRP;
            playerdata.WriteObject(playerData);
            cooldowndata.WriteObject(cooldownData);
        }

        private void SaveRewards() => rewarddata.WriteObject(rewardData);

        private void SaveNPC() => npcdata.WriteObject(npcData);

        private void SaveSales() => saledata.WriteObject(saleData);

        private void LoadData()
        {
            try
            {
                playerData = playerdata.ReadObject<PlayerData>();
                playerRP = playerData.playerRP;
            }
            catch
            {
                PrintWarning("No player data found! Creating a new data file");
                playerData = new PlayerData();
            }
            try
            {
                rewardData = rewarddata.ReadObject<RewardData>();
            }
            catch
            {
                PrintWarning("No reward data found! Creating a new data file");
                rewardData = new RewardData();
            }
            try
            {
                npcData = npcdata.ReadObject<NPCData>();
            }
            catch
            {
                PrintWarning("No npc data found! Creating a new data file");
                npcData = new NPCData();
            }
            try
            {
                saleData = saledata.ReadObject<SaleData>();
            }
            catch
            {
                PrintWarning("No sale data found! Creating a new data file");
                saleData = new SaleData();
            }
            try
            {
                cooldownData = cooldowndata.ReadObject<CooldownData>();
            }
            catch
            {
                PrintWarning("No cooldown data found! Creating a new data file");
                cooldownData = new CooldownData();
            }
        }

        private class PlayerData
        {
            public Dictionary<ulong, int> playerRP = new Dictionary<ulong, int>();
        }

        private class CooldownData
        {
            public Dictionary<ulong, CooldownUser> users = new Dictionary<ulong, CooldownUser>();

            public void AddCooldown(ulong playerId, PurchaseType type, string key, int time)
            {
                CooldownUser userData;
                if (!users.TryGetValue(playerId, out userData))
                {
                    userData = new CooldownUser();
                    users.Add(playerId, userData);
                }

                userData.AddCooldown(type, key, time);
            }

            public bool HasCooldown(ulong playerId, PurchaseType type, string key, out double remaining)
            {
                remaining = 0;
                CooldownUser userData;
                if (!users.TryGetValue(playerId, out userData))
                    return false;

                return userData.HasCooldown(type, key, out remaining);
            }

            public class CooldownUser
            {
                Dictionary<PurchaseType, Dictionary<string, double>> items = new Dictionary<PurchaseType, Dictionary<string, double>>
                {
                    [PurchaseType.Command] = new Dictionary<string, double>(),
                    [PurchaseType.Item] = new Dictionary<string, double>(),
                    [PurchaseType.Kit] = new Dictionary<string, double>()
                };

                public void AddCooldown(PurchaseType type, string key, int time)
                {
                    if (!items[type].ContainsKey(key))
                        items[type].Add(key, time + GrabCurrentTime());
                    else items[type][key] = time + GrabCurrentTime();
                }

                public bool HasCooldown(PurchaseType type, string key, out double remaining)
                {
                    remaining = 0;
                    double time;
                    if (items[type].TryGetValue(key, out time))
                    {
                        double currentTime = GrabCurrentTime();
                        if (time > currentTime)
                        {
                            remaining = time - currentTime;
                            return true;
                        }
                    }
                    return false;
                }
            }
        }

        private class NPCData
        {
            public Dictionary<string, NPCInfo> npcInfo = new Dictionary<string, NPCInfo>();

            public class NPCInfo
            {
                public string name;
                public float x, z;
                public bool useCustom, sellItems, sellKits, sellCommands, canTransfer, canSell, canExchange;
                public List<string> items = new List<string>();
                public List<string> kits = new List<string>();
                public List<string> commands = new List<string>();
            }
        }

        private class RewardData
        {
            public Dictionary<string, RewardItem> items = new Dictionary<string, RewardItem>();
            public SortedDictionary<string, RewardKit> kits = new SortedDictionary<string, RewardKit>();
            public SortedDictionary<string, RewardCommand> commands = new SortedDictionary<string, RewardCommand>();

            public bool HasItems(Category category)
            {
                foreach (KeyValuePair<string, RewardItem> kvp in items)
                {
                    if (kvp.Value.category == category)
                        return true;
                }
                return false;
            }

            public class RewardItem : Reward
            {
                public string shortname, customIcon;
                public int amount;
                public ulong skinId;
                public bool isBp;
                public Category category;
                
                [JsonIgnore]
                private ItemDefinition _itemDefinition;

                [JsonIgnore]
                public ItemDefinition ItemDefinition
                {
                    get
                    {
                        if (!_itemDefinition)
                            _itemDefinition = ItemManager.FindItemDefinition(shortname);
                        return _itemDefinition;
                    }
                }
            }

            public class RewardKit : Reward
            {
                public string kitName, description, iconName;
            }

            public class RewardCommand : Reward
            {
                public string description, iconName;
                public List<string> commands = new List<string>();
            }

            public class Reward
            {
                public string displayName;
                public int cost;
                public int cooldown;
            }
        }

        private class SaleData
        {
            public Dictionary<string, Dictionary<ulong, SaleItem>> items = new Dictionary<string, Dictionary<ulong, SaleItem>>();

            public class SaleItem
            {
                public float price = 0;
                public string displayName;
                public bool enabled = false;
            }
        }
        #endregion

        #region Sales Updater
        private void UpdatePriceList()
        {
            bool changed = false;
            foreach (ItemDefinition item in ItemManager.itemList)
            {
                if (!saleData.items.ContainsKey(item.shortname))
                {
                    saleData.items.Add(item.shortname, new Dictionary<ulong, SaleData.SaleItem> { { 0, new SaleData.SaleItem { displayName = item.displayName.translated } } });
                    changed = true;
                }
                if (HasSkins(item))
                {
                    foreach (ItemSkinDirectory.Skin skin in ItemSkinDirectory.ForItem(item))
                    {
                        ulong skinId = Convert.ToUInt64(skin.id);
                        if (!saleData.items[item.shortname].ContainsKey(skinId))
                        {
                            saleData.items[item.shortname].Add(skinId, new SaleData.SaleItem { displayName = skin.invItem.displayName.translated });
                            changed = true;
                        }
                    }
                    foreach (Rust.Workshop.ApprovedSkinInfo skin in Rust.Workshop.Approved.All.Values.Where(x => x.Name == item.shortname))
                    {
                        if (!saleData.items[item.shortname].ContainsKey(skin.WorkshopdId))
                        {
                            saleData.items[item.shortname].Add(skin.WorkshopdId, new SaleData.SaleItem() { displayName = skin.Name });
                            changed = true;
                        }
                    }
                }
            }
            if (changed)
                SaveSales();
        }

        private bool HasSkins(ItemDefinition item)
        {
            if (item != null)
            {
                List<ItemSkinDirectory.Skin> skins = ItemSkinDirectory.ForItem(item).ToList();
                if (skins.Count > 0)
                    return true;
                else if (Rust.Workshop.Approved.All.Where(x => x.Value.Name == item.shortname).Count() > 0)
                    return true;

            }
            return false;
        }
        #endregion

        #region Localization
        private string msg(string key, string playerId = null) => lang.GetMessage(key, this, playerId);

        private Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"title", "ServerRewards: " },
            { "msgOutRewards1", "You currently have {0} unspent reward tokens! Spend them in the reward store using /s" },
            { "msgOutRewardsnpc", "You currently have {0} unspent reward tokens! Spend them in the reward store by finding a NPC reward dealer" },
            {"msgNoPoints", "You dont have enough reward points" },
            {"errorProfile", "Error getting your profile from the database"},
            {"errorPCon", "There was a error pulling {0}'s profile from the database" },
            {"errorItemPlayer", "There was an error whilst retrieving your reward, please contact an administrator" },
            {"noFind", "Unable to find {0}" },
            {"rInviter", "You have recieved {0} reward points for inviting {1}" },
            {"rInvitee", "You have recieved {0} reward points" },
            {"refSyn", "/refer <playername>" },
            {"remSynKit", "/rewards remove kit <name>" },
            {"remSynItem", "/rewards remove item <number>" },
            {"remSynCommand", "/rewards remove command <name>" },
            {"noKit", "Kit's could not confirm that the kit exists. Check Kit's and your kit data" },
            {"noKitRem", "Unable to find a reward kit with that name" },
            {"noItemRem", "Unable to find a reward item with that number" },
            {"noCommandRem", "Unable to find a reward command with that name" },
            {"remSuccess", "You have successfully removed {0} from the rewards list" },
            {"addSynKit", "/rewards add kit <Name> <kitname> <cost>" },
            {"addSynItem2", "/rewards add item <cost> <opt:bp>" },
            {"addSynItemCon", "rewards add item <shortname> <skinId> <amount> <cost> <opt:bp>" },
            {"addSynCommand", "/rewards add command <Name> <command> <cost>" },
            {"editSynItem2", "/rewards edit item <ID> <cost|amount|name|cooldown> \"info here\"" },
            {"editSynItem1", "- Edit a reward item information" },
            {"editSynKit", "/rewards edit kit <ID> <cost|description|name|icon|cooldown> \"info here\"" },
            {"editSynKit1", "- Edit a reward kit information" },
            {"editSynCommand", "/rewards edit command <ID> <cost|description|name|icon|add|remove|cooldown> \"info here\"" },
            {"editSynCommand1", "- Edit a reward command information" },
            {"storeSyn21", "/s" },
            {"storeSyn2", " - Opens the reward store" },
            {"addSuccess", "You have added the {0} {1}, available for {2} RP" },
            {"rewardExisting", "You already have a reward kit named {0}" },
            {"noCost", "You must enter a reward cost" },
            {"reward", "Reward: " },
            {"desc1", ", Description: " },
            {"cost", ", Cost: " },
            {"claimSyn", "/claim <rewardname>" },
            {"noReward", "This reward doesnt exist!" },
            {"claimSuccess", "You have claimed {0}" },
            {"multiPlayers", "Multiple players found with that name" },
            {"noPlayers", "No players found" },
            {"tpointsAvail", "You have {0} reward point(s) to spend" },
            {"rewardAvail", "Available Rewards;" },
            {"chatClaim", " - Claim the reward"},
            {"chatCheck", "/rewards check" },
            {"chatCheck1", " - Displays you current time played and current reward points"},
            {"chatListOpt", "/rewards list <items|commands|kits>"},
            {"chatListOpt1", " - Display rewards with their ID numbers and info in F1 console"},
            {"chatAddKit", " - Add a new reward kit"},
            {"chatAddItem2", " - Add a new reward item (add \"bp\" to the end of the command to add a blueprint)"},
            {"chatAddCommand", " - Add a new reward command"},
            {"chatRemove", " - Removes a reward"},
            {"chatRefer", " - Acknowledge your referral from <playername>"},
            {"alreadyRefer1", "You have already been referred" },
            {"addPoints", "You have given {0} {1} points" },
            {"removePoints", "You have taken {0} points from {1}"},
            {"clearPlayer", "You have removed {0}'s reward profile" },
            {"addPointsAll", "You have given everyone {0} points" },
            {"remPointsAll", "You have taken {0} points from everyone"},
            {"clearAll", "You have removed all reward profiles" },
            {"srAdd2", " - Adds <amount> of reward points to <playername>" },
            {"srAdd3", " - Adds <amount> of reward points to all players" },
            {"srTake2", " - Takes <amount> of reward points from <playername>" },
            {"srTake3", " - Takes <amount> of reward points from all players" },
            {"srClear2", " - Clears <playername>'s reward profile" },
            {"srClear3", " - Clears all reward profiles" },
            {"srCheck", " - Check a players point count" },
            {"notSelf", "You cannot refer yourself. But nice try!" },
            {"noCommands", "There are currently no commands set up" },
            {"noTypeItems", "This store currently has no {0} items available" },
            {"noKits", "There are currently no kits set up" },
            {"exchange1", "Here you can exchange economics money (Coins) for reward points (RP) and vice-versa" },
            {"exchange2", "The current exchange rate is " },
            {"buyKit", "You have purchased a {0} kit" },
            {"notEnoughPoints", "You don't have enough points" },
            {"errorKit", "There was a error purchasing this kit. Contact a administrator" },
            {"buyCommand", "You have purchased the {0} command" },
            {"errorCommand", "There was a error purchasing this command. Contact a administrator" },
            {"buyItem", "You have purchased {0}x {1}" },
            {"errorItem", "There was a error purchasing this item. Contact a administrator" },
            {"notEnoughCoins", "You do not have enough coins to exchange" },
            {"exchange", "You have exchanged " },
            {"itemInHand", "You must place the item you wish to add in your hands" },
            {"itemIDHelp", "You must enter the items number. Type /rewards list to see available entries" },
            {"noProfile", "{0} does not have any saved data" },
            {"storeTitle", "Reward Store" },
            {"storeKits", "Kits" },
            {"storeCommands", "Commands" },
            {"storeItems", "Items" },
            {"storeExchange", "Exchange" },
            {"storeTransfer", "Transfer" },
            {"storeSales", "Sales" },
            {"storeClose", "Close" },
            {"storeNext", "Next" },
            {"storeBack", "Back" },
            {"storePlaytime", "Playtime" },
            {"storeCost", "Cost" },
            {"storeRP", "RP" },
            {"storeEcon", "Economics" },
            {"storeCoins", "Coins" },
            {"npcExist", "This NPC is already a Reward Dealer" },
            {"npcNew", "You have successfully added a new Reward Dealer" },
            {"npcRem", "You have successfully removed a Reward Dealer" },
            {"npcNotAdded", "This NPC is not a Reward Dealer" },
            {"noNPC", "Could not find a NPC to register" },
            {"Reward Dealer", "Reward Dealer" },
            {"fullInv", "Your inventory is full" },
            {"transfer1", "Select a user to transfer money to" },
            {"transfer2", "Select a amount to send" },
            {"transfer3", "You have transferred {0} {1} to {2}" },
            {"clootsucc", "You have successfully created a new loot list for this NPC" },
            {"save", "Save"},
            {"cldesc", "Select items, kits and commands to add to this NPC's custom store list" },
            {"clcanc", "You have cancelled custom loot creation"},
            {"sellItems", "Sell Items" },
            {"selectItemSell", "Select an item to sell. You can only sell items that are in your main inventory container" },
            {"Name", "Name" },
            {"Amount", "Amount" },
            {"Sell","Sell" },
            {"CantSell","Not Sell-able" },
            {"selectToSell", "Select an amount of the item you wish to sell" },
            {"sellItemF","Item: {0}{1}</color>" },
            {"sellPriceF","Price per unit: {0}{1} {2}</color>" },
            {"sellUnitF","Units to sell: {0}{1}</color>" },
            {"sellTotalF","Total sale price: {0}{1} {2}</color>" },
            {"cancelSale","Cancel Sale" },
            {"confirmSale","Sell Item" },
            {"saleSuccess", "You have sold {0}x {1} for {2} {3}" },
            {"allowExchange", "Currency Exchange" },
            {"allowTransfer", "Currency Transfer" },
            {"allowSales", "Item Sales" },
            {"Weapon", "Weapons" },
            {"Construction", "Construction" },
            {"Items", "Items" },
            {"Resources", "Resources" },
            {"Attire", "Attire" },
            {"Tool", "Tools" },
            {"Medical", "Medical" },
            {"Food", "Food" },
            {"Ammunition", "Ammunition" },
            {"Traps", "Traps" },
            {"Misc", "Misc" },
            {"Component", "Components" },
            {"imWait", "You must wait until ImageLibrary has finished processing its images" },
            {"useCustom", "Use Custom Loot" },
            {"isBp", "(BP)" },
            {"hasCooldownCommand", "You have {0} remaining on the cooldown for this command" },
            {"hasCooldownKit", "You have {0} remaining on the cooldown for this kit" },
            {"hasCooldownItem", "You have {0} remaining on the cooldown for this item" }
        };
        #endregion
    }
}


// --- End of file: ServerRewards.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/statistics-db ---
// --- Original File Path: S/StatisticsDB/StatisticsDB.cs ---

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Rust;
using Time = Oxide.Core.Libraries.Time;

namespace Oxide.Plugins;

[Info("Statistics DB", "misticos", "1.2.7")]
[Description("Statistics database for developers")]
internal class StatisticsDB : CovalencePlugin
{
    #region Variables

    [PluginReference]
    // ReSharper disable InconsistentNaming
    private Plugin ConnectionDB = null, PlayerDatabase = null;
    // ReSharper restore InconsistentNaming

    private static PluginData _data = new();

    private static StatisticsDB _ins;

    private static readonly Time Time = GetLibrary<Time>();

    #endregion

    #region Configuration

    private static Configuration _config = new();

    private class Configuration
    {
        [JsonProperty(PropertyName = "Debug")]
        public bool Debug { get; set; } = false;

        [JsonProperty(PropertyName = "Inactive Entry Lifetime")]
        public uint Lifetime { get; set; } = 259200;

        [JsonProperty(PropertyName = "Collect Joins")]
        public bool CollectJoins { get; set; } = true;

        [JsonProperty(PropertyName = "Collect Leaves")]
        public bool CollectLeaves { get; set; } = true;

        [JsonProperty(PropertyName = "Collect Kills")]
        public bool CollectKills { get; set; } = true;

        [JsonProperty(PropertyName = "Collect Deaths")]
        public bool CollectDeaths { get; set; } = true;

        [JsonProperty(PropertyName = "Collect Suicides")]
        public bool CollectSuicides { get; set; } = true;

        [JsonProperty(PropertyName = "Collect Shots")]
        public bool CollectShots { get; set; } = true;

        [JsonProperty(PropertyName = "Collect Headshots")]
        public bool CollectHeadshots { get; set; } = true;

        [JsonProperty(PropertyName = "Collect Experiments")]
        public bool CollectExperiments { get; set; } = true;

        [JsonProperty(PropertyName = "Collect Recoveries")]
        public bool CollectRecoveries { get; set; } = true;

        [JsonProperty(PropertyName = "Collect Voice Bytes")]
        public bool CollectVoiceBytes { get; set; } = true;

        [JsonProperty(PropertyName = "Collect Wounded Times")]
        public bool CollectWoundedTimes { get; set; } = true;

        [JsonProperty(PropertyName = "Collect Crafted Items")]
        public bool CollectCraftedItems { get; set; } = true;

        [JsonProperty(PropertyName = "Collect Repaired Items")]
        public bool CollectRepairedItems { get; set; } = true;

        [JsonProperty(PropertyName = "Collect Lift Usages")]
        public bool CollectLiftUsages { get; set; } = true;

        [JsonProperty(PropertyName = "Collect Wheel Spins")]
        public bool CollectWheelSpins { get; set; } = true;

        [JsonProperty(PropertyName = "Collect Hammer Hits")]
        public bool CollectHammerHits { get; set; } = true;

        [JsonProperty(PropertyName = "Collect Explosives Thrown")]
        public bool CollectExplosivesThrown { get; set; } = true;

        [JsonProperty(PropertyName = "Collect Weapon Reloads")]
        public bool CollectWeaponReloads { get; set; } = true;

        [JsonProperty(PropertyName = "Collect Rockets Launched")]
        public bool CollectRocketsLaunched { get; set; } = true;

        [JsonProperty(PropertyName = "Collect Collectible Pickups")]
        public bool CollectCollectiblePickups { get; set; } = true;

        [JsonProperty(PropertyName = "Collect Plant Pickups")]
        public bool CollectPlantPickups { get; set; } = true;

        [JsonProperty(PropertyName = "Collect Gathered")]
        public bool CollectGathered { get; set; } = true;
    }

    protected override void LoadConfig()
    {
        base.LoadConfig();
        try
        {
            _config = Config.ReadObject<Configuration>();
            if (_config == null) throw new Exception();
        }
        catch
        {
            PrintError("Your configuration file contains an error. Using default configuration values.");
            LoadDefaultConfig();
        }
    }

    protected override void LoadDefaultConfig() => _config = new Configuration();

    protected override void SaveConfig() => Config.WriteObject(_config);

    #endregion

    #region Work with Data

    private void SaveData()
    {
        foreach (var kvp in _data.Statistics)
        {
            SaveData(kvp.Key);
        }
    }

    private void SaveData(ulong id)
    {
        PlayerDatabase.Call("SetPlayerData", id.ToString(), Name, _data.Statistics[id], true);
    }

    private void LoadData(ulong id)
    {
        var success = PlayerDatabase.Call("GetPlayerDataRaw", id.ToString(), Name);
        if (success is string result)
        {
            _data.Statistics[id] = JsonConvert.DeserializeObject<PlayerStats>(result);
        }
    }

    private class PluginData
    {
        public Dictionary<ulong, PlayerStats> Statistics = new();
    }

    private class PlayerStats
    {
        public uint LastUpdate;

        public uint Joins;

        public uint Leaves;

        public uint Kills;

        public uint Deaths;

        public uint Suicides;

        public uint Shots;

        public uint Headshots;

        public uint Experiments;

        public uint Recoveries;

        public uint VoiceBytes;

        public uint WoundedTimes;

        public uint CraftedItems;

        public uint RepairedItems;

        public uint LiftUsages;

        public uint WheelSpins;

        public uint HammerHits;

        public uint ExplosivesThrown;

        public uint WeaponReloads;

        public uint RocketsLaunched;

        public uint SecondsPlayed;

        public List<string> Names;

        // ReSharper disable once InconsistentNaming
        public List<string> IPs;

        public List<uint> TimeStamps;

        public Dictionary<string, uint> CollectiblePickups = new();

        public Dictionary<string, uint> PlantPickups = new();

        public Dictionary<string, uint> Gathered = new();

        public PlayerStats()
        {
        }

        internal PlayerStats(ulong id)
        {
            if (!id.IsSteamId())
                return;

            Update();
            _data.Statistics.Add(id, this);
        }

        public void Update() => LastUpdate = Time.GetUnixTimestamp();

        public static PlayerStats Find(ulong id)
        {
            if (_data.Statistics.TryGetValue(id, out var statistics))
            {
                return statistics;
            }

            _ins.LoadData(id);

            return _data.Statistics.TryGetValue(id, out statistics) ? statistics : null;
        }
    }

    #endregion

    #region Hooks

    private void Init()
    {
        _ins = this;

        if (!_config.CollectJoins)
            Unsubscribe(nameof(OnPlayerConnected));

        if (!_config.CollectLeaves)
            Unsubscribe(nameof(OnPlayerDisconnected));

        if (!_config.CollectExperiments)
            Unsubscribe(nameof(CanExperiment));

        if (!_config.CollectHeadshots)
            Unsubscribe(nameof(OnEntityTakeDamage));

        if (!_config.CollectWoundedTimes)
            Unsubscribe(nameof(OnPlayerWound));

        if (!_config.CollectRecoveries)
            Unsubscribe(nameof(OnPlayerRecover));

        if (!_config.CollectVoiceBytes)
            Unsubscribe(nameof(OnPlayerVoice));

        if (!_config.CollectCraftedItems)
            Unsubscribe(nameof(OnItemCraftFinished));

        if (!_config.CollectRepairedItems)
            Unsubscribe(nameof(OnItemRepair));

        if (!_config.CollectLiftUsages)
            Unsubscribe(nameof(OnLiftUse));

        if (!_config.CollectWheelSpins)
            Unsubscribe(nameof(OnSpinWheel));

        if (!_config.CollectHammerHits)
            Unsubscribe(nameof(OnHammerHit));

        if (!_config.CollectExplosivesThrown)
            Unsubscribe(nameof(OnExplosiveThrown));

        if (!_config.CollectWeaponReloads)
            Unsubscribe(nameof(OnReloadWeapon));

        if (!_config.CollectRocketsLaunched)
            Unsubscribe(nameof(OnRocketLaunched));

        if (!_config.CollectShots)
            Unsubscribe(nameof(OnWeaponFired));

        if (!_config.CollectCollectiblePickups)
            Unsubscribe(nameof(OnCollectiblePickup));

        if (!_config.CollectPlantPickups)
            Unsubscribe(nameof(OnGrowableGather));

        if (!_config.CollectGathered)
            Unsubscribe(nameof(OnDispenserGather));
    }

    private void OnServerInitialized()
    {
        var playersCount = BasePlayer.activePlayerList.Count;
        for (var i = 0; i < playersCount; i++)
        {
            OnPlayerConnected(BasePlayer.activePlayerList[i]);
        }
    }

    private void OnServerSave()
    {
        var current = Time.GetUnixTimestamp();
        var data = _data.Statistics.ToArray();
        var removed = 0;
        for (var i = _data.Statistics.Count - 1; i >= 0; i--)
        {
            var entry = data[i].Value;
            if (entry.LastUpdate + _config.Lifetime > current) continue;

            _data.Statistics.Remove(data[i].Key);
            removed++;
        }

        PrintDebug($"Removed old data entries: {removed}");
        SaveData();
    }

    private void Unload() => SaveData();

    private void OnPlayerConnected(BasePlayer player)
    {
        InitPlayer(player);
        var stats = PlayerStats.Find(player.userID);
        stats.Joins++;
        stats.Update();
    }

    [Command("statistics.migrate")]
    private void MigrateCommand(IPlayer player, string command, string[] args)
    {
        if (!player.IsAdmin) return;
        try
        {
            _data = JsonConvert.DeserializeObject<PluginData>(ConnectionDB?.Call<string>("API_GetValueRaw", Name),
                new JsonSerializerSettings
                {
                    ObjectCreationHandling = ObjectCreationHandling.Replace,
                    NullValueHandling = NullValueHandling.Ignore
                });
        }
        catch (Exception e)
        {
            PrintError($"Error: {e.Message}\n" +
                       $"Description: {e.StackTrace}");
            return;
        }

        if (_data == null) return;

        SaveData();
        player.Reply("Migration successful!");
    }

    [Command("statistics.output")]
    private void OutputCommand(IPlayer player, string command, string[] args)
    {
        if (!player.IsAdmin || args.Length == 0)
            return;

        var target = players.FindPlayer(string.Join(" ", args));
        if (target == null) // TODO: Message
            return;

        Puts(API_GetAllPlayerData(ulong.Parse(target.Id)).ToString());
    }

    private void OnPlayerDisconnected(BasePlayer player) => PlayerStats.Find(player.userID).Leaves++;

    private void CanExperiment(BasePlayer player, Workbench workbench) =>
        PlayerStats.Find(player.userID).Experiments++;

    private void OnPlayerDeath(BasePlayer player, HitInfo info)
    {
        if (info == null || player == null || player.IsNpc)
            return;

        var stats = PlayerStats.Find(player.userID);
        if (_config.CollectSuicides && info.damageTypes.GetMajorityDamageType() == DamageType.Suicide)
            stats.Suicides++;
        else
        {
            if (_config.CollectDeaths)
                stats.Deaths++;

            if (!_config.CollectKills) return;

            var attacker = info.InitiatorPlayer;
            if (attacker == null || attacker.IsNpc)
                return;

            stats = PlayerStats.Find(attacker.userID);
            stats.Kills++;
        }
    }

    private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
    {
        if (info?.InitiatorPlayer == null || !info.isHeadshot)
            return;

        PlayerStats.Find(info.InitiatorPlayer.userID).Headshots++;
    }

    private void OnPlayerWound(BasePlayer player) => PlayerStats.Find(player.userID).WoundedTimes++;

    private void OnPlayerRecover(BasePlayer player) => PlayerStats.Find(player.userID).Recoveries++;

    private void OnPlayerVoice(BasePlayer player, byte[] data) =>
        PlayerStats.Find(player.userID).VoiceBytes += (uint)data.Length;

    private void OnItemCraftFinished(ItemCraftTask task, Item item, ItemCrafter crafter) =>
        PlayerStats.Find(crafter.owner.userID).CraftedItems++;

    private void OnItemRepair(BasePlayer player, Item item) => PlayerStats.Find(player.userID).RepairedItems++;

    private void OnLiftUse(Lift lift, BasePlayer player) => PlayerStats.Find(player.userID).LiftUsages++;

    private void OnLiftUse(ProceduralLift lift, BasePlayer player) => PlayerStats.Find(player.userID).LiftUsages++;

    private void OnSpinWheel(BasePlayer player, SpinnerWheel wheel) => PlayerStats.Find(player.userID).WheelSpins++;

    private void OnHammerHit(BasePlayer player, HitInfo info) => PlayerStats.Find(player.userID).HammerHits++;

    private void OnExplosiveThrown(BasePlayer player, BaseEntity entity) =>
        PlayerStats.Find(player.userID).ExplosivesThrown++;

    private void OnReloadWeapon(BasePlayer player, BaseProjectile projectile) =>
        PlayerStats.Find(player.userID).WeaponReloads++;

    private static Time _time = GetLibrary<Time>();

    private void InitPlayer(BasePlayer player, bool isDisconnect = false)
    {
        var id = player.userID;
        var name = player.displayName;
        var ip = player.net.connection.ipaddress;
        var time = _time.GetUnixTimestamp();

        ip = ip.Substring(0, ip.LastIndexOf(':'));

        var stats = PlayerStats.Find(player.userID);
        if (stats == null)
        {
            var info = new PlayerStats
            {
                Names = new List<string> { name },
                IPs = new List<string> { ip },
                TimeStamps = new List<uint> { time },
                SecondsPlayed = 1
            };

            PrintDebug($"Added new user {name} ({id})");
            _data.Statistics.Add(id, info);
            SaveData(player.userID);
            return;
        }

        if (!stats.Names.Contains(name))
            stats.Names.Add(name);

        if (!stats.IPs.Contains(ip))
            stats.IPs.Add(ip);

        if (isDisconnect)
            stats.SecondsPlayed += time - stats.TimeStamps.Last();
        stats.TimeStamps.Add(time);

        PrintDebug($"Updated user {name} ({id})");
    }

    private void OnRocketLaunched(BasePlayer player, BaseEntity entity) =>
        PlayerStats.Find(player.userID).RocketsLaunched++;

    private void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile mod,
        ProtoBuf.ProjectileShoot projectiles) => PlayerStats.Find(player.userID).Shots++;

    private void OnCollectiblePickup(Item item, BasePlayer player)
    {
        var dict = PlayerStats.Find(player.userID).CollectiblePickups;
        if (dict.TryGetValue(item.info.shortname, out var count))
            count += (uint)item.amount;
        else
        {
            count = (uint)item.amount;
            dict.Add(item.info.shortname, count);
        }

        dict[item.info.shortname] = count;
    }

    private void OnGrowableGather(GrowableEntity plant, Item item, BasePlayer player)
    {
        var dict = PlayerStats.Find(player.userID).PlantPickups;
        if (dict.TryGetValue(item.info.shortname, out var count))
            count += (uint)item.amount;
        else
        {
            count = (uint)item.amount;
            dict.Add(item.info.shortname, count);
        }

        dict[item.info.shortname] = count;
    }

    private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
    {
        var dict = PlayerStats.Find(((BasePlayer)entity).userID).Gathered;
        if (dict.ContainsKey(item.info.shortname))
            dict[item.info.shortname] += (uint)item.amount;
        else
        {
            dict.Add(item.info.shortname, (uint)item.amount);
        }
    }

    #endregion

    #region API

    // General API

    private JObject API_GetAllData() => JObject.FromObject(_data.Statistics);
    private JObject API_GetAllPlayerData(ulong id) => JObject.FromObject(PlayerStats.Find(id));
    private bool API_ContainsPlayer(ulong id) => PlayerStats.Find(id) != null;

    private uint? API_GetJoins(ulong id) => PlayerStats.Find(id)?.Joins;
    private uint? API_GetLeaves(ulong id) => PlayerStats.Find(id)?.Leaves;
    private uint? API_GetKills(ulong id) => PlayerStats.Find(id)?.Kills;
    private uint? API_GetDeaths(ulong id) => PlayerStats.Find(id)?.Deaths;
    private uint? API_GetSuicides(ulong id) => PlayerStats.Find(id)?.Suicides;
    private uint? API_GetShots(ulong id) => PlayerStats.Find(id)?.Shots;
    private uint? API_GetHeadshots(ulong id) => PlayerStats.Find(id)?.Headshots;
    private uint? API_GetExperiments(ulong id) => PlayerStats.Find(id)?.Experiments;
    private uint? API_GetRecoveries(ulong id) => PlayerStats.Find(id)?.Recoveries;
    private uint? API_GetVoiceBytes(ulong id) => PlayerStats.Find(id)?.VoiceBytes;
    private uint? API_GetWoundedTimes(ulong id) => PlayerStats.Find(id)?.WoundedTimes;
    private uint? API_GetCraftedItems(ulong id) => PlayerStats.Find(id)?.CraftedItems;
    private uint? API_GetRepairedItems(ulong id) => PlayerStats.Find(id)?.RepairedItems;
    private uint? API_GetLiftUsages(ulong id) => PlayerStats.Find(id)?.LiftUsages;
    private uint? API_GetWheelSpins(ulong id) => PlayerStats.Find(id)?.WheelSpins;
    private uint? API_GetHammerHits(ulong id) => PlayerStats.Find(id)?.HammerHits;
    private uint? API_GetExplosivesThrown(ulong id) => PlayerStats.Find(id)?.ExplosivesThrown;
    private uint? API_GetWeaponReloads(ulong id) => PlayerStats.Find(id)?.WeaponReloads;
    private uint? API_GetRocketsLaunched(ulong id) => PlayerStats.Find(id)?.RocketsLaunched;
    private uint? API_GetSecondsPlayed(ulong id) => PlayerStats.Find(id)?.SecondsPlayed;
    private List<string> API_GetNames(ulong id) => PlayerStats.Find(id)?.Names;
    private List<string> API_GetIPs(ulong id) => PlayerStats.Find(id)?.IPs;
    private List<uint> API_GetTimeStamps(ulong id) => PlayerStats.Find(id)?.TimeStamps;

    // Gather API

    private Dictionary<string, uint> API_GetCollectiblePickups(ulong id) =>
        PlayerStats.Find(id)?.CollectiblePickups;

    private Dictionary<string, uint> API_GetPlantPickups(ulong id) =>
        PlayerStats.Find(id)?.PlantPickups;

    private Dictionary<string, uint> API_GetGathered(ulong id) =>
        PlayerStats.Find(id)?.Gathered;

    private uint? API_GetCollectiblePickups(ulong id, string shortname)
    {
        var data = API_GetCollectiblePickups(id);
        if (data?.TryGetValue(shortname, out var amount) == true)
            return amount;

        return null;
    }

    private uint? API_GetPlantPickups(ulong id, string shortname)
    {
        var data = API_GetPlantPickups(id);
        if (data?.TryGetValue(shortname, out var amount) == true)
            return amount;

        return null;
    }

    private uint? API_GetGathered(ulong id, string shortname)
    {
        var data = API_GetGathered(id);
        if (data?.TryGetValue(shortname, out var amount) == true)
            return amount;

        return null;
    }

    #endregion

    #region Helpers

    [Conditional("DEBUG")]
    private static void PrintDebug(string message)
    {
        _ins.Puts(message);
    }

    #endregion
}

// --- End of file: StatisticsDB.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/simple-no-vehicle-fuel ---
// --- Original File Path: S/SimpleNoVehicleFuel/SimpleNoVehicleFuel.cs ---

using Oxide.Core.Plugins;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Simple No Vehicle Fuel", "Mabel", "1.1.0")]
    [Description("Removes requirement of fuel in all vehicles")]

    public class SimpleNoVehicleFuel : RustPlugin
    {
        [PluginReference] readonly Plugin Convoy;

        #region Oxide Hooks

        private void Init()
        {
            Unsubscribe(nameof(OnEntitySpawned));
        }

        private void OnServerInitialized()
        {
            Subscribe(nameof(OnEntitySpawned));

            foreach (var entity in BaseNetworkable.serverEntities)
            {
                if (entity is Catapult) return;

                if (entity is BaseVehicle vehicle)
                {
                    bool isConvoyVehicle = Convoy != null && (bool)Convoy?.Call("IsConvoyVehicle", vehicle);
                  
                    if (!isConvoyVehicle)
                    {
                        ModifyVehicle(vehicle);
                    }
                }
                else if (entity is HotAirBalloon balloon)
                {
                    ModifyBalloon(balloon);
                }
            }
        }

        private void Unload()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                if (entity is BaseVehicle vehicle)
                {
                    bool isConvoyVehicle = Convoy != null && (bool?)Convoy.Call("IsConvoyVehicle", vehicle) == true;

                    if (!isConvoyVehicle)
                    {
                        ResetVehicle(vehicle);
                    }
                }
                else if (entity is HotAirBalloon balloon)
                {
                    ResetBalloon(balloon);
                }
            }
        }

        private void OnEntitySpawned(BaseVehicle vehicle)
        {
            if (vehicle is Catapult) return;

            NextTick(() =>
            {
                if (vehicle == null || !vehicle.IsValid())
                    return;

                bool isConvoyVehicle = Convoy != null && (bool?)Convoy.Call("IsConvoyVehicle", vehicle) == true;

                if (!isConvoyVehicle)
                {
                    ModifyVehicle(vehicle);
                }
            });
        }

        private void OnEntitySpawned(HotAirBalloon balloon)
        {
            NextTick(() =>
            {
                if (balloon == null) return;

                if (balloon.IsValid())
                {
                    ModifyBalloon(balloon);
                }
            });
        }

        #endregion

        #region Core

        private void ModifyVehicle(BaseVehicle vehicle)
        {
            var fuelSystem = vehicle.GetFuelSystem() as EntityFuelSystem;
            var container = fuelSystem?.fuelStorageInstance.Get(true);
            if (container == null)
            {
                container = vehicle.GetComponentsInChildren<StorageContainer>().FirstOrDefault(x => x.inventory.onlyAllowedItems != null);
            }

            if (container == null)
            {
                return;
            }

            var item = container.inventory.GetSlot(0);
            if (item == null)
            {
                item = ItemManager.Create(container.inventory.onlyAllowedItems.FirstOrDefault());
                if (item == null)
                {
                    return;
                }
                item.MoveToContainer(container.inventory);
            }

            item.amount = 200;
            item.skin = 12345;
            item.OnDirty += item1 => Refill(item1);
            item.SetFlag(global::Item.Flag.IsLocked, true);
            container.dropsLoot = false;
            container.inventory.SetFlag(ItemContainer.Flag.IsLocked, true);
            container.SetFlag(BaseEntity.Flags.Locked, true);
        }

        private void ModifyBalloon(HotAirBalloon balloon)
        {
            var fuelSystem = balloon.GetFuelSystem() as EntityFuelSystem;
            var container = fuelSystem?.fuelStorageInstance.Get(true);
            if (container == null)
            {
                container = balloon.GetComponentsInChildren<StorageContainer>().FirstOrDefault(x => x.inventory.onlyAllowedItems != null);
            }

            if (container == null)
            {
                return;
            }

            var item = container.inventory.GetSlot(0);
            if (item == null)
            {
                item = ItemManager.Create(container.inventory.onlyAllowedItems.FirstOrDefault());
                if (item == null)
                {
                    return;
                }
                item.MoveToContainer(container.inventory);
            }

            item.amount = 200;
            item.skin = 12345;
            item.OnDirty += item1 => Refill(item1);
            item.SetFlag(global::Item.Flag.IsLocked, true);
            container.dropsLoot = false;
            container.inventory.SetFlag(ItemContainer.Flag.IsLocked, true);
            container.SetFlag(BaseEntity.Flags.Locked, true);
        }

        private void ResetVehicle(BaseVehicle vehicle)
        {
            var fuelSystem = vehicle.GetFuelSystem() as EntityFuelSystem;
            var container = fuelSystem?.fuelStorageInstance.Get(true);
            if (container == null)
            {
                container = vehicle.GetComponentsInChildren<StorageContainer>().FirstOrDefault(x => x.inventory.onlyAllowedItems != null);
            }

            if (container == null)
            {
                return;
            }

            var item = container.inventory.GetSlot(0);
            if (item != null && item.skin == 12345)
            {
                item.DoRemove();
            }

            container.inventory.SetFlag(ItemContainer.Flag.IsLocked, false);
            container.SetFlag(BaseEntity.Flags.Locked, false);
        }

        private void ResetBalloon(HotAirBalloon balloon)
        {
            var fuelSystem = balloon.GetFuelSystem() as EntityFuelSystem;
            var container = fuelSystem?.fuelStorageInstance.Get(true);
            if (container == null)
            {
                container = balloon.GetComponentsInChildren<StorageContainer>().FirstOrDefault(x => x.inventory.onlyAllowedItems != null);
            }

            if (container == null)
            {
                return;
            }

            var item = container.inventory.GetSlot(0);
            if (item != null && item.skin == 12345)
            {
                item.DoRemove();
            }

            container.inventory.SetFlag(ItemContainer.Flag.IsLocked, false);
            container.SetFlag(BaseEntity.Flags.Locked, false);
        }

        private void Refill(Item item)
        {
            item.amount = 200;
        }

        #endregion
    }
}

// --- End of file: SimpleNoVehicleFuel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sam-site-authorization ---
// --- Original File Path: S/SAMSiteAuth/SAMSiteAuth.cs ---

using System.Collections.Generic;
using static BaseVehicle;

namespace Oxide.Plugins
{
    [Info("SAMSiteAuth", "haggbart", "2.4.3")]
    [Description("Makes SAM Sites act in a similar fashion to shotgun traps and flame turrets.")]
    internal class SAMSiteAuth : RustPlugin
    {
        private readonly object True = true;

        private object OnSamSiteTarget(SamSite samSite, BaseCombatEntity target)
        {
            var mountPoints = (target as BaseVehicle)?.mountPoints;
            if (!IsOccupied(target, mountPoints))
                return True;

            if (samSite.staticRespawn)
                return null;

            var cupboard = samSite.GetBuildingPrivilege(samSite.WorldSpaceBounds());
            if ((object)cupboard == null)
                return null;

            if (mountPoints != null)
            {
                foreach (var mountPoint in mountPoints)
                {
                    var player = mountPoint.mountable.GetMounted();
                    if ((object)player != null && IsAuthed(cupboard, player.userID))
                        return True;
                }
            }

            foreach (var child in target.children)
            {
                var player = child as BasePlayer;
                if ((object)player != null)
                {
                    if (IsAuthed(cupboard, player.userID))
                        return True;
                }
            }

            return null;
        }

        private static bool IsOccupied(BaseCombatEntity entity, List<MountPointInfo> mountPoints)
        {
            if (mountPoints != null)
            {
                foreach (var mountPoint in mountPoints)
                {
                    var player = mountPoint.mountable.GetMounted();
                    if ((object)player != null)
                        return true;
                }
            }

            foreach (var child in entity.children)
            {
                if (child is BasePlayer)
                    return true;
            }

            return false;
        }

        private static bool IsAuthed(BuildingPrivlidge cupboard, ulong userId)
        {
            foreach (var entry in cupboard.authorizedPlayers)
            {
                if (entry.userid == userId)
                    return true;
            }

            return false;
        }
    }
}

// --- End of file: SAMSiteAuth.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/steam-checks ---
// --- Original File Path: S/SteamChecks/SteamChecks.cs ---

#define DEBUG
using Newtonsoft.Json;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;


//SteamChecks created with PluginMerge v(1.0.4.0) by MJSU @ https://github.com/dassjosh/Plugin.Merge
namespace Oxide.Plugins
{
    [Info("Steam Checks", "Shady14u", "5.0.8")]
    [Description("Kick players depending on information on their Steam profile")]
    public partial class SteamChecks : CovalencePlugin
    {
        #region SteamChecks.cs
        #region Methods (Private)
        
        /// <summary>
        ///     Checks a steamId, if it would be allowed into the server
        /// </summary>
        /// <param name="steamId">steamId64 of the user</param>
        /// <param name="callback">
        ///     First parameter is true, when the user is allowed, otherwise false
        ///     Second parameter is the reason why he is not allowed, filled out when first is false
        /// </param>
        /// <remarks>
        ///     Asynchronously
        ///     Runs through all checks one-by-one
        ///     1. Bans
        ///     2. Player Summaries (Private profile, Creation time)
        ///     3. Player Level
        ///     Via <see cref="CheckPlayerGameTime"></see>
        ///     4. Game Hours and Count
        ///     5. Game badges, to get amount of games if user has hidden Game Hours
        /// </remarks>
        private void CheckPlayer(string steamId, Action<bool, string> callback)
        {
            // Check Bans first, as they are also visible on private profiles
            GetPlayerBans(steamId, (banStatusCode, banResponse) =>
            {
                if (banStatusCode != (int) StatusCode.Success)
                {
                    ApiError(steamId, "GetPlayerBans", banStatusCode);
                    return;
                }
                
                if (banResponse.CommunityBan && kickCommunityBan)
                {
                    callback(false, Lang("KickCommunityBan", steamId));
                    return;
                }
                
                if (banResponse.EconomyBan && kickTradeBan)
                {
                    callback(false, Lang("KickTradeBan", steamId));
                    return;
                }
                
                if (banResponse.GameBanCount > maxGameBans && maxGameBans > -1)
                {
                    callback(false, Lang("KickGameBan", steamId));
                    return;
                }
                
                if (banResponse.VacBanCount > maxVACBans && maxVACBans > -1)
                {
                    callback(false, Lang("KickVacBan", steamId));
                    return;
                }
                
                if (banResponse.LastBan > 0 && banResponse.LastBan < minDaysSinceLastBan && minDaysSinceLastBan > 0)
                {
                    callback(false, Lang("KickVacBan", steamId));
                    return;
                }
                
                //get Player summaries - we have to check if the profile is public
                GetSteamPlayerSummaries(steamId, (statusCode, sumResult) =>
                {
                    if (statusCode != (int) StatusCode.Success)
                    {
                        ApiError(steamId, "GetSteamPlayerSummaries", statusCode);
                        return;
                    }
                    
                    if (sumResult.LimitedAccount && kickLimitedAccount)
                    {
                        callback(false, Lang("KickLimitedAccount", steamId));
                        return;
                    }
                    
                    
                    if (sumResult.NoProfile && kickNoProfile)
                    {
                        callback(false, Lang("KickNoProfile", steamId));
                        return;
                    }
                    
                    // Is profile not public?
                    if (sumResult.Visibility != PlayerSummary.VisibilityType.Public)
                    {
                        if (kickPrivateProfile)
                        {
                            callback(false, Lang("KickPrivateProfile", steamId));
                            return;
                        }
                        else
                        {
                            // If it is not public, we can cancel checks here and allow the player in
                            callback(true, null);
                            return;
                        }
                    }
                    
                    // Check how old the account is
                    if (maxAccountCreationTime > 0 && sumResult.Timecreated > maxAccountCreationTime)
                    {
                        callback(false, Lang("KickMaxAccountCreationTime", steamId));
                        return;
                    }
                    
                    // Check Steam Level
                    if (minSteamLevel > 0)
                    {
                        GetSteamLevel(steamId, (steamLevelStatusCode, steamLevelResult) =>
                        {
                            if (steamLevelStatusCode != (int) StatusCode.Success)
                            {
                                ApiError(steamId, "GetSteamLevel", statusCode);
                                return;
                            }
                            
                            if (minSteamLevel > steamLevelResult)
                            {
                                callback(false, Lang("KickMinSteamLevel", steamId));
                            }
                            else
                            {
                                // Check game time, and amount of games
                                if (minGameCount > 1 || minRustHoursPlayed > 0 || maxRustHoursPlayed > 0 ||
                                minOtherGamesPlayed > 0 || minAllGamesHoursPlayed > 0)
                                CheckPlayerGameTime(steamId, callback);
                                else // Player now already passed all checks
                                callback(true, null);
                            }
                        });
                    }
                    // Else, if level check not done, Check game time, and amount of games
                    else if (minGameCount > 1 || minRustHoursPlayed > 0 || maxRustHoursPlayed > 0 ||
                    minOtherGamesPlayed > 0 || minAllGamesHoursPlayed > 0)
                    {
                        CheckPlayerGameTime(steamId, callback);
                    }
                    else // Player now already passed all checks
                    {
                        callback(true, null);
                    }
                });
            });
        }
        
        /// <summary>
        ///     Checks a steamId, and if it would be allowed into the server
        ///     Called by <see cref="CheckPlayer"></see>
        /// </summary>
        /// <param name="steamId">steamId64 of the user</param>
        /// <param name="callback">
        ///     First parameter is true, when the user is allowed, otherwise false
        ///     Second parameter is the reason why he is not allowed, filled out when first is false
        /// </param>
        /// <remarks>
        ///     Regards those specific parts:
        ///     - Game Hours and Count
        ///     - Game badges, to get amount of games if user has hidden Game Hours
        /// </remarks>
        void CheckPlayerGameTime(string steamId, Action<bool, string> callback)
        {
            GetPlaytimeInformation(steamId, (gameTimeStatusCode, gameTimeResult) =>
            {
                // Players can additionally hide their play time, check
                var gameTimeHidden = false;
                if (gameTimeStatusCode == (int) StatusCode.GameInfoHidden)
                {
                    gameTimeHidden = true;
                }
                // Check if the request failed in general
                else if (gameTimeStatusCode != (int) StatusCode.Success)
                {
                    ApiError(steamId, "GetPlaytimeInformation", gameTimeStatusCode);
                    return;
                }
                
                // In rare cases, the SteamAPI returns all games, however with the game time set to 0. (when the user has this info hidden)
                if (gameTimeResult != null && (gameTimeResult.PlaytimeRust == 0 || gameTimeResult.PlaytimeAll == 0))
                gameTimeHidden = true;
                
                // If the server owner really wants a hour check, we will kick
                if (gameTimeHidden && forceHoursPlayedKick)
                {
                    if (minRustHoursPlayed > 0 || maxRustHoursPlayed > 0 ||
                    minOtherGamesPlayed > 0 || minAllGamesHoursPlayed > 0)
                    {
                        callback(false, Lang("KickHoursPrivate", steamId));
                        return;
                    }
                }
                // Check the times and game count now, when not hidden
                else if (!gameTimeHidden && gameTimeResult != null)
                {
                    if (minRustHoursPlayed > 0 && gameTimeResult.PlaytimeRust < minRustHoursPlayed)
                    {
                        callback(false, Lang("KickMinRustHoursPlayed", steamId));
                        return;
                    }
                    
                    if (maxRustHoursPlayed > 0 && gameTimeResult.PlaytimeRust > maxRustHoursPlayed)
                    {
                        callback(false, Lang("KickMaxRustHoursPlayed", steamId));
                        return;
                    }
                    
                    if (minAllGamesHoursPlayed > 0 && gameTimeResult.PlaytimeAll < minAllGamesHoursPlayed)
                    {
                        callback(false, Lang("KickMinSteamHoursPlayed", steamId));
                        return;
                    }
                    
                    if (minOtherGamesPlayed > 0 &&
                    (gameTimeResult.PlaytimeAll - gameTimeResult.PlaytimeRust) < minOtherGamesPlayed &&
                    gameTimeResult.GamesCount >
                    1) // it makes only sense to check, if there are other games in the result set
                    {
                        callback(false, Lang("KickMinNonRustPlayed", steamId));
                        return;
                    }
                    
                    if (minGameCount > 1 && gameTimeResult.GamesCount < minGameCount)
                    {
                        callback(false, Lang("KickGameCount", steamId));
                        return;
                    }
                }
                
                // If the server owner wants to check minimum amount of games, but the user has hidden game time
                // We will get the count over an additional API request via badges
                if (gameTimeHidden && minGameCount > 1)
                {
                    GetSteamBadges(steamId, (badgeStatusCode, badgeResult) =>
                    {
                        // Check if the request failed in general
                        if (badgeStatusCode != (int) StatusCode.Success)
                        {
                            ApiError(steamId, "GetPlaytimeInformation", gameTimeStatusCode);
                            return;
                        }
                        
                        var gamesOwned = ParseBadgeLevel(badgeResult, Badge.GamesOwned);
                        if (gamesOwned < minGameCount)
                        {
                            callback(false, Lang("KickGameCount", steamId));
                        }
                        else
                        {
                            // Checks passed
                            callback(true, null);
                        }
                    });
                }
                else
                {
                    // Checks passed
                    callback(true, null);
                }
            });
        }
        
        private void DoChecks(IPlayer player)
        {
            if (string.IsNullOrEmpty(apiKey))
            return;
            
            if (player.HasPermission(skipPermission))
            {
                Log("{0} / {1} in whitelist (via permission {2})", player.Name, player.Id, skipPermission);
                return;
            }
            
            // Check temporary White/Blacklist if kicking is enabled
            if (!logInsteadofKick)
            {
                // Player already passed the checks, since the plugin is active
                if (cachePassedPlayers && passedList.Contains(player.Id))
                {
                    Log("{0} / {1} passed all checks already previously", player.Name, player.Id);
                    return;
                }
                
                // Player already passed the checks, since the plugin is active
                if (cacheDeniedPlayers && failedList.Contains(player.Id))
                {
                    Log("{0} / {1} failed a check already previously", player.Name, player.Id);
                    webrequest.Enqueue($"https://steamcommunity.com/profiles/{player.Id}?xml=1", string.Empty,
                    (code, result) =>
                    {
                        WebHookThumbnail thumbnail = null;
                        if (code >= 200 && code <= 204)
                        thumbnail = new WebHookThumbnail
                        {
                            Url = _steamAvatarRegex.Match(result).Value
                        };
                        SendDiscordMessage(player.Id, "The player failed a steam check previously.", thumbnail);
                    }, this);
                    player.Kick(Lang("KickGeneric", player.Id) + " " + additionalKickMessage);
                    return;
                }
            }
            
            CheckPlayer(player.Id, (playerAllowed, reason) =>
            {
                if (playerAllowed)
                {
                    Log("{0} / {1} passed all checks", player.Name, player.Id);
                    passedList.Add(player.Id);
                }
                else
                {
                    if (logInsteadofKick)
                    {
                        Log("{0} / {1} would have been kicked. Reason: {2}", player.Name, player.Id, reason);
                        SendDiscordMessage(player.Id,
                        $"The player would have been kicked for steam checks. Reason: {reason}", null);
                    }
                    else
                    {
                        Log("{0} / {1} kicked. Reason: {2}", player.Name, player.Id, reason);
                        failedList.Add(player.Id);
                        webrequest.Enqueue($"https://steamcommunity.com/profiles/{player.Id}?xml=1", string.Empty,
                        (code, result) =>
                        {
                            WebHookThumbnail thumbnail = null;
                            if (code >= 200 && code <= 204)
                            thumbnail = new WebHookThumbnail
                            {
                                Url = _steamAvatarRegex.Match(result).Value
                            };
                            SendDiscordMessage(player.Id,
                            $"The player was kicked for steam checks. Reason: {reason}", thumbnail);
                        }, this);
                        
                        player.Kick(reason + " " + additionalKickMessage);
                        
                        if (broadcastKick)
                        {
                            foreach (var target in players.Connected)
                            {
                                target.Message(Lang("Console", player.Id), "", player.Name, reason);
                            }
                        }
                    }
                }
            });
        }
        
        #endregion
        #endregion

        #region SteamChecks.Config.cs
        /// <summary>
        /// Url to the Steam Web API
        /// </summary>
        private const string apiURL = "https://api.steampowered.com";
        private readonly Regex _steamAvatarRegex =
        new Regex(@"(?<=<avatarMedium>[\w\W]+)https://.+\.jpg(?=[\w\W]+<\/avatarMedium>)", RegexOptions.Compiled);
        /// <summary>
        /// Oxide permission for a whitelist
        /// </summary>
        private const string skipPermission = "steamchecks.skip";
        
        /// <summary>
        /// Timeout for a web request
        /// </summary>
        private const int webTimeout = 2000;
        
        /// <summary>
        /// This message will be appended to all Kick-messages
        /// </summary>
        private string additionalKickMessage;
        
        /// <summary>
        /// API Key to use for the Web API
        /// </summary>
        /// <remarks>
        /// https://steamcommunity.com/dev/apikey
        /// </remarks>
        private string apiKey;
        
        /// <summary>
        /// AppID of the game, where the plugin is loaded
        /// </summary>
        private uint appId;
        
        /// <summary>
        /// Broadcast kick via chat?
        /// </summary>
        private bool broadcastKick;
        
        /// <summary>
        /// Cache players, which joined and failed the checks
        /// </summary>
        private bool cacheDeniedPlayers;
        
        /// <summary>
        /// Cache players, which joined and successfully completed the checks
        /// </summary>
        private bool cachePassedPlayers;
        
        private List<string> discordRolesToMention = new List<string>();
        
        private string discordWebHookUrl;
        
        /// <summary>
        /// Set of steamIds, which failed the steam check test on joining
        /// </summary>
        /// <remarks>
        /// Resets after a plugin reload
        /// </remarks>
        private HashSet<string> failedList;
        
        /// <summary>
        /// Kick user, when his hours are hidden
        /// </summary>
        /// <remarks>
        /// A lot of steam users have their hours hidden
        /// </remarks>
        private bool forceHoursPlayedKick;
        
        private bool checkPlayersOnRespawn;
        
        /// <summary>
        /// Kick when the user has a Steam Community ban
        /// </summary>
        private bool kickCommunityBan;
        
        /// <summary>
        /// Kick when the user has not set up his steam profile yet
        /// </summary>
        private bool kickNoProfile;
        
        // <summary>
        /// Kick when the user has limited Account
        /// </summary>
        private bool kickLimitedAccount;
        
        /// <summary>
        /// Kick when the user has a private profile
        /// </summary>
        /// <remarks>
        /// Most checks depend on a public profile
        /// </remarks>
        private bool kickPrivateProfile;
        
        /// <summary>
        /// Kick when the user has a Steam Trade ban
        /// </summary>
        private bool kickTradeBan;
        
        /// <summary>
        /// Just log instead of actually kicking users?
        /// </summary>
        private bool logInsteadofKick;
        
        /// <summary>
        /// Unix-Time, if the account created by the user is newer/higher than it
        /// he won't be allowed
        /// </summary>
        private long maxAccountCreationTime;
        
        /// <summary>
        /// Maximum amount of game bans, the user is allowed to have
        /// </summary>
        private int maxGameBans;
        
        /// <summary>
        /// Maximum amount of rust played
        /// </summary>
        private int maxRustHoursPlayed;
        
        /// <summary>
        /// Maximum amount of VAC bans, the user is allowed to have
        /// </summary>
        private int maxVACBans;
        
        /// <summary>
        /// Minimum amount of Steam games played - including Rust
        /// </summary>
        private int minAllGamesHoursPlayed;
        
        /// <summary>
        /// How old the last VAC ban should minimally
        /// </summary>
        private int minDaysSinceLastBan;
        
        /// <summary>
        /// Minimum amount of Steam games
        /// </summary>
        private int minGameCount;
        
        /// <summary>
        /// Minimum amount of Steam games played - except Rust
        /// </summary>
        private int minOtherGamesPlayed;
        
        /// <summary>
        /// Minimum amount of rust played
        /// </summary>
        private int minRustHoursPlayed;
        
        /// <summary>
        /// The minimum steam level, the user must have
        /// </summary>
        private int minSteamLevel;
        
        /// <summary>
        /// Set of steamIds, which already passed the steam check test on joining
        /// </summary>
        /// <remarks>
        /// Resets after a plugin reload
        /// </remarks>
        private HashSet<string> passedList;
        
        #region Methods (Protected)
        
        /// <summary>
        /// Loads default configuration options
        /// </summary>
        protected override void LoadDefaultConfig()
        {
            Config["ApiKey"] = "";
            Config["BroadcastKick"] = false;
            Config["LogInsteadofKick"] = false;
            Config["AdditionalKickMessage"] = "";
            Config["CachePassedPlayers"] = true;
            Config["CacheDeniedPlayers"] = false;
            Config["CheckPlayersOnRespawn"] = false;
            Config["Kicking"] = new Dictionary<string, bool>
            {
                ["CommunityBan"] = true,
                ["TradeBan"] = true,
                ["PrivateProfile"] = true,
                ["LimitedAccount"] = true,
                ["NoProfile"] = true,
                ["FamilyShare"] = false,
                ["ForceHoursPlayedKick"] = false,
            };
            Config["Thresholds"] = new Dictionary<string, long>
            {
                ["MaxVACBans"] = 1,
                ["MinDaysSinceLastBan"] = -1,
                ["MaxGameBans"] = 1,
                ["MinSteamLevel"] = 2,
                ["MaxAccountCreationTime"] = -1,
                ["MinGameCount"] = 3,
                ["MinRustHoursPlayed"] = -1,
                ["MaxRustHoursPlayed"] = -1,
                ["MinOtherGamesPlayed"] = 2,
                ["MinAllGamesHoursPlayed"] = -1
            };
            Config["DiscordRolesToMention"] = new List<string>();
            Config["discordWebHookUrl"] = "";
        }
        
        #endregion
        
        #region Methods (Private)
        
        /// <summary>
        /// Initializes config options, for every plugin start
        /// </summary>
        private void InitializeConfig()
        {
            apiKey = Config.Get<string>("ApiKey");
            broadcastKick = Config.Get<bool>("BroadcastKick");
            logInsteadofKick = Config.Get<bool>("LogInsteadofKick");
            additionalKickMessage = Config.Get<string>("AdditionalKickMessage");
            cachePassedPlayers = Config.Get<bool>("CachePassedPlayers");
            cacheDeniedPlayers = Config.Get<bool>("CacheDeniedPlayers");
            
            kickCommunityBan = Config.Get<bool>("Kicking", "CommunityBan");
            kickTradeBan = Config.Get<bool>("Kicking", "TradeBan");
            kickPrivateProfile = Config.Get<bool>("Kicking", "PrivateProfile");
            kickNoProfile = Config.Get<bool>("Kicking", "NoProfile");
            kickLimitedAccount = Config.Get<bool>("Kicking","LimitedAccount");
            forceHoursPlayedKick = Config.Get<bool>("Kicking", "ForceHoursPlayedKick");
            checkPlayersOnRespawn = Config.Get<bool>("CheckPlayersOnRespawn");
            maxVACBans = Config.Get<int>("Thresholds", "MaxVACBans");
            minDaysSinceLastBan = Config.Get<int>("Thresholds", "MinDaysSinceLastBan");
            maxGameBans = Config.Get<int>("Thresholds", "MaxGameBans");
            
            
            minSteamLevel = Config.Get<int>("Thresholds", "MinSteamLevel");
            
            minRustHoursPlayed = Config.Get<int>("Thresholds", "MinRustHoursPlayed") * 60;
            maxRustHoursPlayed = Config.Get<int>("Thresholds", "MaxRustHoursPlayed") * 60;
            minOtherGamesPlayed = Config.Get<int>("Thresholds", "MinOtherGamesPlayed") * 60;
            minAllGamesHoursPlayed = Config.Get<int>("Thresholds", "MinAllGamesHoursPlayed") * 60;
            
            minGameCount = Config.Get<int>("Thresholds", "MinGameCount");
            maxAccountCreationTime = Config.Get<long>("Thresholds", "MaxAccountCreationTime");
            
            if (!kickPrivateProfile)
            {
                if (minRustHoursPlayed > 0 || maxRustHoursPlayed > 0 || minOtherGamesPlayed > 0 ||
                minAllGamesHoursPlayed > 0)
                LogWarning(Lang("WarningPrivateProfileHours"));
                
                if (minGameCount > 1)
                LogWarning(Lang("WarningPrivateProfileGames"));
                
                if (maxAccountCreationTime > 0)
                LogWarning(Lang("WarningPrivateProfileCreationTime"));
                
                if (minSteamLevel > 0)
                LogWarning(Lang("WarningPrivateProfileSteamLevel"));
            }
            
            discordRolesToMention = Config.Get<List<string>>("DiscordRolesToMention");
            discordWebHookUrl = Config.Get<string>("discordWebHookUrl");
        }
        
        #endregion
        #endregion

        #region SteamChecks.Class.Discord.cs
        private class WebHookAuthor
        {
            [JsonProperty(PropertyName = "icon_url")]
            public string AuthorIconUrl;
            
            [JsonProperty(PropertyName = "url")]
            public string AuthorUrl;
            [JsonProperty(PropertyName = "name")]
            public string Name;
        }
        
        private class WebHookContentBody
        {
            [JsonProperty(PropertyName = "content")]
            public string Content;
        }
        
        private class WebHookEmbed
        {
            [JsonProperty(PropertyName = "author")]
            public WebHookAuthor Author;
            
            [JsonProperty(PropertyName = "color")]
            public int Color;
            
            [JsonProperty(PropertyName = "description")]
            public string Description;
            
            [JsonProperty(PropertyName = "fields")]
            public List<WebHookField> Fields;
            
            [JsonProperty(PropertyName = "footer")]
            public WebHookFooter Footer;
            
            [JsonProperty(PropertyName = "image")]
            public WebHookImage Image;
            
            [JsonProperty(PropertyName = "thumbnail")]
            public WebHookThumbnail Thumbnail;
            
            [JsonProperty(PropertyName = "title")]
            public string Title;
            
            [JsonProperty(PropertyName = "type")]
            public string Type = "rich";
        }
        
        private class WebHookEmbedBody
        {
            [JsonProperty(PropertyName = "embeds")]
            public WebHookEmbed[] Embeds;
        }
        
        private class WebHookField
        {
            [JsonProperty(PropertyName = "inline")]
            public bool Inline;
            
            [JsonProperty(PropertyName = "name")]
            public string Name;
            
            [JsonProperty(PropertyName = "value")]
            public string Value;
        }
        
        private class WebHookFooter
        {
            [JsonProperty(PropertyName = "icon_url")]
            public string IconUrl;
            
            [JsonProperty(PropertyName = "proxy_icon_url")]
            public string ProxyIconUrl;
            
            [JsonProperty(PropertyName = "text")]
            public string Text;
        }
        
        private class WebHookImage
        {
            [JsonProperty(PropertyName = "height")]
            public int? Height;
            
            [JsonProperty(PropertyName = "proxy_url")]
            public string ProxyUrl;
            
            [JsonProperty(PropertyName = "url")]
            public string Url;
            
            [JsonProperty(PropertyName = "width")]
            public int? Width;
        }
        
        private class WebHookThumbnail
        {
            [JsonProperty(PropertyName = "height")]
            public int? Height;
            
            [JsonProperty(PropertyName = "proxy_url")]
            public string ProxyUrl;
            
            [JsonProperty(PropertyName = "url")]
            public string Url;
            
            [JsonProperty(PropertyName = "width")]
            public int? Width;
        }
        #endregion

        #region SteamChecks.Class.GameTimeInformation.cs
        /// <summary>
        /// Struct for the GetOwnedGames API request
        /// </summary>
        private class GameTimeInformation
        {
            #region Constructors
            
            public GameTimeInformation(int gamesCount, int playtimeRust, int playtimeAll)
            {
                GamesCount = gamesCount;
                PlaytimeRust = playtimeRust;
                PlaytimeAll = playtimeAll;
            }
            
            #endregion
            
            #region Properties and Indexers
            
            /// <summary>
            /// Amount of games the user has
            /// </summary>
            public int GamesCount { get; set; }
            
            /// <summary>
            /// Play time across all Steam games
            /// </summary>
            public int PlaytimeAll { get; set; }
            
            /// <summary>
            /// Play time in rust
            /// </summary>
            public int PlaytimeRust { get; set; }
            
            #endregion
            
            #region Methods (Public)
            
            public override string ToString()
            {
                return
                $"Games Count: {GamesCount} - Playtime in Rust: {PlaytimeRust} - Playtime all Steam games: {PlaytimeAll}";
            }
            
            #endregion
        }
        #endregion

        #region SteamChecks.Class.PlayerBans.cs
        /// <summary>
        /// Struct for the GetPlayerBans/v1 Web API
        /// </summary>
        public class PlayerBans
        {
            #region Properties and Indexers
            
            /// <summary>
            /// if the user has a community ban
            /// </summary>
            public bool CommunityBan { get; set; }
            
            /// <summary>
            /// If the user is economy banned
            /// </summary>
            public bool EconomyBan { get; set; }
            
            /// <summary>
            /// Amount of game bans
            /// </summary>
            public int GameBanCount { get; set; }
            
            /// <summary>
            /// When the last ban was, in Unix time
            /// </summary>
            /// <remarks>
            /// The steam profile only shows bans in the last 7 years
            /// </remarks>
            public int LastBan { get; set; }
            
            /// <summary>
            /// Seems to be true, when the steam user has at least one ban
            /// </summary>
            public bool VacBan { get; set; }
            
            /// <summary>
            /// Amount of VAC Bans
            /// </summary>
            public int VacBanCount { get; set; }
            
            #endregion
            
            #region Methods (Public)
            
            public override string ToString()
            {
                return $"Community Ban: {CommunityBan} - VAC Ban: {VacBan} " +
                $"- VAC Ban Count: {VacBanCount} - Last Ban: {LastBan} " +
                $"- Game Ban Count: {GameBanCount} - Economy Ban: {EconomyBan}";
            }
            
            #endregion
        }
        #endregion

        #region SteamChecks.Class.PlayerSummary.cs
        /// <summary>
        /// Struct for the GetPlayerSummaries/v2 Web API request
        /// </summary>
        public class PlayerSummary
        {
            #region VisibilityType enum
            
            /// <summary>
            /// How visible the Steam Profile is
            /// </summary>
            public enum VisibilityType
            {
                Private = 1,
                Friend = 2,
                Public = 3
            }
            
            #endregion
            
            #region Properties and Indexers
            
            /// <summary>
            /// Is the account limited?
            /// </summary>
            /// <remarks>
            /// Will be fulfilled by an additional request directly to the steamprofile with ?xml=1
            /// </remarks>
            public bool LimitedAccount { get; set; }
            
            /// <summary>
            /// Has the user set up his profile?
            /// </summary>
            /// <remarks>
            /// Will be fulfilled by an additional request directly to the steamprofile with ?xml=1
            /// </remarks>
            public bool NoProfile { get; set; }
            
            /// <summary>
            /// URL to his steam profile
            /// </summary>
            public string Profileurl { get; set; }
            
            /// <summary>
            /// When his account was created - in Unix time
            /// </summary>
            /// <remarks>
            /// Will only be filled, if the users profile is public
            /// </remarks>
            public long Timecreated { get; set; }
            
            public VisibilityType Visibility { get; set; }
            
            #endregion
            
            #region Methods (Public)
            
            public override string ToString()
            {
                return
                $"Steam profile visibility: {Visibility} - Profile URL: {Profileurl} " +
                $"- Account created: {Timecreated} - Limited: {LimitedAccount} - NoProfile: {NoProfile}";
            }
            
            #endregion
        }
        #endregion

        #region SteamChecks.Class.SteamApiResponse.cs
        public class SteamApiResponse
        {
            #region Properties and Indexers
            
            public SteamResponse Response { get; set; }
            
            #endregion
        }
        
        public class SteamLevelApiResponse
        {
            #region Properties and Indexers
            
            public SteamLevelResponse Response { get; set; }
            
            #endregion
        }
        
        public class SteamBadgeApiResponse
        {
            #region Properties and Indexers
            
            public SteamBadgeResponse response { get; set; }
            
            #endregion
        }
        
        public class SteamBanApiResponse
        {
            #region Properties and Indexers
            
            public List<SteamBanPlayer> players { get; set; }
            
            #endregion
        }
        #endregion

        #region SteamChecks.Class.SteamBadge.cs
        public class SteamBadge
        {
            #region Properties and Indexers
            
            public int badgeid { get; set; }
            public int completion_time { get; set; }
            public int level { get; set; }
            public int scarcity { get; set; }
            public int xp { get; set; }
            
            #endregion
        }
        #endregion

        #region SteamChecks.Class.SteamGame.cs
        public class SteamGame
        {
            #region Properties and Indexers
            
            public int appid { get; set; }
            public int? playtime_2weeks { get; set; }
            public int playtime_forever { get; set; }
            public int playtime_linux_forever { get; set; }
            public int playtime_mac_forever { get; set; }
            public int playtime_windows_forever { get; set; }
            
            #endregion
        }
        #endregion

        #region SteamChecks.Class.SteamPlayer.cs
        public class SteamPlayer
        {
            #region Properties and Indexers
            
            public string avatar { get; set; }
            public string avatarfull { get; set; }
            public string avatarhash { get; set; }
            public string avatarmedium { get; set; }
            public int commentpermission { get; set; }
            public int communityvisibilitystate { get; set; }
            public string gameextrainfo { get; set; }
            public string gameid { get; set; }
            public string gameserverip { get; set; }
            public string gameserversteamid { get; set; }
            public int lastlogoff { get; set; }
            public string loccountrycode { get; set; }
            public string locstatecode { get; set; }
            public string personaname { get; set; }
            public int personastate { get; set; }
            public int personastateflags { get; set; }
            public string primaryclanid { get; set; }
            public int profilestate { get; set; }
            public string profileurl { get; set; }
            public int timecreated { get; set; }
            public string steamId { get; set; }
            
            #endregion
        }
        
        public class SteamBanPlayer
        {
            #region Properties and Indexers
            
            public string SteamId { get; set; }
            public bool CommunityBanned { get; set; }
            public bool VACBanned { get; set; }
            public int NumberOfVACBans { get; set; }
            public int DaysSinceLastBan { get; set; }
            public int NumberOfGameBans { get; set; }
            public string EconomyBan { get; set; }
            
            #endregion
        }
        #endregion

        #region SteamChecks.Class.SteamResponse.cs
        public class SteamResponse
        {
            public int? game_count;
            
            #region Properties and Indexers
            
            public List<SteamGame> games { get; set; }
            public List<SteamPlayer> players { get; set; }
            
            #endregion
        }
        
        public class SteamLevelResponse
        {
            public int player_level { get; set; }
        }
        
        public class SteamBadgeResponse
        {
            #region Properties and Indexers
            
            public List<SteamBadge> badges { get; set; }
            public int player_level { get; set; }
            public int player_xp { get; set; }
            public int player_xp_needed_current_level { get; set; }
            public int player_xp_needed_to_level_up { get; set; }
            
            #endregion
        }
        #endregion

        #region SteamChecks.Discord.cs
        private void SendDiscordMessage(string steamId, string reasonMessage, WebHookThumbnail thumbnail)
        {
            if (string.IsNullOrEmpty(discordWebHookUrl)) return;
            
            var mentions = "";
            if (discordRolesToMention != null)
            foreach (var roleId in discordRolesToMention)
            {
                mentions += $"<@&{roleId}> ";
            }
            
            var message = Lang("DiscordMessage");
            
            var contentBody = new WebHookContentBody
            {
                Content = $"{mentions}{message}"
            };
            
            var color = 3092790;
            var player = BasePlayer.FindAwakeOrSleeping(steamId);
            
            var firstBody = new WebHookEmbedBody
            {
                Embeds = new[]
                {
                    new WebHookEmbed
                    {
                        Color = color,
                        Thumbnail = thumbnail,
                        Description =
                        $"Player{Environment.NewLine}[{player?.displayName??steamId}](https://steamcommunity.com/profiles/{steamId})" +
                        $"{Environment.NewLine}{Environment.NewLine}Steam ID{Environment.NewLine}{steamId}" +
                        $"{Environment.NewLine}{Environment.NewLine}{reasonMessage}"
                    }
                }
            };
            
            webrequest.Enqueue(discordWebHookUrl,
            JsonConvert.SerializeObject(contentBody,
            new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore }),
            (headerCode, headerResult) =>
            {
                if (headerCode >= 200 && headerCode <= 204)
                {
                    webrequest.Enqueue(discordWebHookUrl,
                    JsonConvert.SerializeObject(firstBody,
                    new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore }),
                    (firstCode, firstResult) => { }, this, RequestMethod.POST,
                    new Dictionary<string, string> { { "Content-Type", "application/json" } });
                }
            }, this, RequestMethod.POST,
            new Dictionary<string, string> { { "Content-Type", "application/json" } });
        }
        #endregion

        #region SteamChecks.Enum.Badge.cs
        /// <summary>
        /// The badges we reference.
        /// </summary>
        /// <remarks>
        /// Every badge comes with a level, and EXP gained
        /// </remarks>
        private enum Badge
        {
            /// <summary>
            /// Badge for the amount of games owned
            /// </summary>
            /// <remarks>
            /// The level in this badge is exactly to the amount of games owned
            /// E.g. 42 games == level 42 for badge 13
            /// (so not the same as shown on the steam profiles)
            /// </remarks>
            GamesOwned = 13
        }
        #endregion

        #region SteamChecks.Enum.StatusCode.cs
        /// <summary>
        /// HTTP Status Codes (positive) and
        /// custom status codes (negative)
        ///
        /// 200 is successful in all cases
        /// </summary>
        private enum StatusCode
        {
            Success = 200,
            BadRequest = 400,
            Unauthorized = 401,
            Forbidden = 403,
            NotFound = 404,
            MethodNotAllowed = 405,
            TooManyRequests = 429,
            InternalError = 500,
            Unavailable = 503,
            
            /// <summary>
            /// User has is games and game hours hidden
            /// </summary>
            GameInfoHidden = -100,
            
            /// <summary>
            /// Invalid steamId
            /// </summary>
            PlayerNotFound = -101,
            
            /// <summary>
            /// Can also happen, when the SteamAPI returns something unexpected
            /// </summary>
            ParsingFailed = -102
        }
        #endregion

        #region SteamChecks.Enum.SteamRequestType.cs
        /// <summary>
        /// Type of Steam request
        /// </summary>
        private enum SteamRequestType
        {
            /// <summary>
            /// Allows to request only one SteamID
            /// </summary>
            IPlayerService,
            
            /// <summary>
            /// Allows to request multiple SteamID
            /// But only one used
            /// </summary>
            ISteamUser
        }
        #endregion

        #region SteamChecks.Hooks.cs
        #region Methods (Private)
        
        /// <summary>
        /// Called by Oxide when plugin starts
        /// </summary>
        private void Init()
        {
            InitializeConfig();
            
            if (string.IsNullOrEmpty(apiKey))
            {
                LogError(Lang("ErrorAPIConfig"));
                
                // Unload on next tick
                timer.Once(1f, () => { server.Command("oxide.unload SteamChecks"); });
                return;
            }
            
            appId = covalence.ClientAppId;
            
            passedList = new HashSet<string>();
            failedList = new HashSet<string>();
            
            permission.RegisterPermission(skipPermission, this);
        }
        
        /// <summary>
        /// Called when a user connects (but before he is spawning)
        /// </summary>
        /// <param name="player"></param>
        private void OnUserConnected(IPlayer player)
        {
            DoChecks(player);
        }
        
        
        private void OnUserRespawned(IPlayer player)
        {
            if (!checkPlayersOnRespawn)
            {
                return;
            }
            DoChecks(player);
        }
        
        
        
        #endregion
        #endregion

        #region SteamChecks.Lang.cs
        #region Methods (Private)
        
        /// <summary>
        /// Abbreviation for printing Language-Strings
        /// </summary>
        /// <param name="key">Language Key</param>
        /// <param name="userId"></param>
        /// <returns></returns>
        private string Lang(string key, string userId = null) => lang.GetMessage(key, this, userId);
        
        #endregion
        
        /// <summary>
        /// Load default language messages, for every plugin start
        /// </summary>
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Console"] = "Kicking {0}... ({1})",
                
                ["ErrorAPIConfig"] = "The API key you supplied in the config is empty.. register one here https://steamcommunity.com/dev/apikey",
                ["WarningPrivateProfileHours"] = "**** WARNING: Private profile-kick is off. However a option to kick for minimum amount of hours is on.",
                ["WarningPrivateProfileGames"] = "**** WARNING: Private profile-kick is off. However the option to kick for minimum amount of games is on (MinGameCount).",
                ["WarningPrivateProfileCreationTime"] = "**** WARNING: Private profile-kick is off. However the option to kick for account age is on (MinAccountCreationTime).",
                ["WarningPrivateProfileSteamLevel"] = "**** WARNING: Private profile-kick is off. However the option to kick for steam level is on (MinSteamLevel).",
                
                ["ErrorHttp"] = "Error while contacting the SteamAPI. Error: {0}.",
                ["ErrorPrivateProfile"] = "This player has a private profile, therefore SteamChecks cannot check their hours.",
                
                ["KickCommunityBan"] = "You have a Steam Community ban on record.",
                ["KickVacBan"] = "You have too many VAC bans on record.",
                ["KickGameBan"] = "You have too many Game bans on record.",
                ["KickTradeBan"] = "You have a Steam Trade ban on record.",
                ["KickPrivateProfile"] = "Your Steam profile state is set to private.",
                ["KickLimitedAccount"] = "Your Steam account is limited.",
                ["KickNoProfile"] = "Set up your Steam community profile first.",
                ["KickMinSteamLevel"] = "Your Steam level is not high enough.",
                ["KickMinRustHoursPlayed"] = "You haven't played enough hours.",
                ["KickMaxRustHoursPlayed"] = "You have played too much Rust.",
                ["KickMinSteamHoursPlayed"] = "You didn't play enough Steam games (hours).",
                ["KickMinNonRustPlayed"] = "You didn't play enough Steam games besides Rust (hours).",
                ["KickHoursPrivate"] = "Your Steam profile is public, but the hours you played is hidden'.",
                ["KickGameCount"] = "You don't have enough Steam games.",
                ["KickMaxAccountCreationTime"] = "Your Steam account is too new.",
                
                ["KickGeneric"] = "Your Steam account fails our test.",
                ["DiscordMessage"] = "User failed Steam Checks"
            }, this);
        }
        #endregion

        #region SteamChecks.Test.cs
        private const string PluginPrefix = "[SteamChecks] ";
        
        #region Methods (Private)
        
        /// <summary>
        /// Command, which checks a steamid64 - with the same method when a user joins
        /// </summary>
        /// <param name="player"></param>
        /// <param name="command"></param>
        /// <param name="args">steamid64 to test for</param>
        [Command("steamcheck"), Permission("steamchecks.use")]
        private void SteamCheckCommand(IPlayer player, string command, string[] args)
        {
            if (args.Length != 1)
            {
                TestResult(player, "SteamCheckTests", "You have to provide a SteamID64 as first argument");
                return;
            }
            
            var steamId = args[0];
            
            CheckPlayer(steamId, (playerAllowed, reason) =>
            {
                if (playerAllowed)
                TestResult(player, "CheckPlayer", "The player would pass the checks");
                else
                {
                    webrequest.Enqueue($"https://steamcommunity.com/profiles/{steamId}?xml=1", string.Empty,
                    (code, result) =>
                    {
                        WebHookThumbnail thumbnail = null;
                        if (code >= 200 && code <= 204)
                        thumbnail = new WebHookThumbnail
                        {
                            Url = _steamAvatarRegex.Match(result).Value
                        };
                        SendDiscordMessage(steamId, "The player would not pass the checks. Reason: " + reason, thumbnail);
                    }, this);
                    
                    
                    TestResult(player, "CheckPlayer", "The player would not pass the checks. Reason: " + reason);
                }
            });
        }
        
        /// <summary>
        /// Unit tests for all Web API functions
        /// Returns detailed results of the queries.
        /// </summary>
        /// <param name="player"></param>
        /// <param name="command"></param>
        /// <param name="args">steamid64 to test for</param>
        [Command("steamcheck.runtests"), Permission("steamchecks.use")]
        private void SteamCheckTests(IPlayer player, string command, string[] args)
        {
            if (args.Length != 1)
            {
                TestResult(player, "SteamCheckTests", "You have to provide a SteamID64 as first argument");
                return;
            }
            
            var steamId = args[0];
            
            GetSteamLevel(steamId,
            (statusCode, response) =>
            {
                TestResult(player, "GetSteamLevel",
                $"Status {(StatusCode)statusCode} - Response {response}");
            });
            
            GetPlaytimeInformation(steamId,
            (statusCode, response) =>
            {
                TestResult(player, "GetPlaytimeInformation",
                $"Status {(StatusCode)statusCode} - Response {response}");
            });
            
            GetSteamPlayerSummaries(steamId,
            (statusCode, response) =>
            {
                TestResult(player, "GetSteamPlayerSummaries",
                $"Status {(StatusCode)statusCode} - Response {response}");
            });
            
            GetSteamBadges(steamId, (statusCode, response) =>
            {
                if ((StatusCode)statusCode == StatusCode.Success)
                {
                    var badgeLevel = ParseBadgeLevel(response, Badge.GamesOwned);
                    TestResult(player, "GetSteamBadges - Badge 13, Games owned",
                    $"Status {(StatusCode)statusCode} - Response {badgeLevel}");
                }
                else
                {
                    TestResult(player, "GetSteamBadges",
                    $"Status {(StatusCode)statusCode}");
                }
            });
            
            GetPlayerBans(steamId,
            (statusCode, response) =>
            {
                TestResult(player, "GetPlayerBans",
                $"Status {(StatusCode)statusCode} - Response {response}");
            });
        }
        
        private void TestResult(IPlayer player, string function, string result)
        {
            player.Reply(PluginPrefix + $"{function} - {result}");
        }
        
        #endregion
        #endregion

        #region SteamChecks.WebApi.cs
        /// <summary>
        /// Generic request to the Steam Web API
        /// </summary>
        /// <param name="steamRequestType"></param>
        /// <param name="endpoint">The specific endpoint, e.g. GetSteamLevel/v1</param>
        /// <param name="steamId64"></param>
        /// <param name="callback">Callback returning the HTTP status code <see cref="StatusCode"></see> and a JSON JObject</param>
        /// <param name="additionalArguments">Additional arguments, e.g. &foo=bar</param>
        private void SteamWebRequest(SteamRequestType steamRequestType, string endpoint, string steamId64,
        Action<int, string> callback, string additionalArguments = "")
        {
            var requestUrl = $"{apiURL}/{steamRequestType}/{endpoint}/?key={apiKey}&{(steamRequestType == SteamRequestType.IPlayerService ? "steamid" : "steamids")}={steamId64}{additionalArguments}";
            
            webrequest.Enqueue(requestUrl, "", (httpCode, response) =>
            {
                callback(httpCode, httpCode == (int)StatusCode.Success ? response : null);
            }, this, Core.Libraries.RequestMethod.GET, null, webTimeout);
        }
        
        /// <summary>
        /// Get the Steam level of a user
        /// </summary>
        /// <param name="steamId64">The users steamId64</param>
        /// <param name="callback">Callback with the statusCode <see cref="StatusCode"></see> and the steam level</param>
        private void GetSteamLevel(string steamId64, Action<int, int> callback)
        {
            SteamWebRequest(SteamRequestType.IPlayerService, "GetSteamLevel/v1", steamId64,
            (httpCode, response) =>
            {
                if (httpCode == (int)StatusCode.Success)
                {
                    callback(httpCode, JsonConvert.DeserializeObject<SteamLevelApiResponse>(response).Response.player_level);
                }
                else
                {
                    callback(httpCode, -1);
                }
            });
        }
        
        /// <summary>
        /// Get information about hours played in Steam
        /// </summary>
        /// <param name="steamId64">steamId64 of the user</param>
        /// <param name="callback">Callback with the statusCode <see cref="StatusCode"></see> and the <see cref="GameTimeInformation"></see></param>
        /// <remarks>
        /// Even when the user has his profile public, this can be hidden. This seems to be often the case.
        /// When hidden, the statusCode will be <see cref="StatusCode.GameInfoHidden"></see>
        /// </remarks>
        private void GetPlaytimeInformation(string steamId64, Action<int, GameTimeInformation> callback)
        {
            SteamWebRequest(SteamRequestType.IPlayerService, "GetOwnedGames/v1", steamId64,
            (httpCode, response) =>
            {
                var steamResponse = JsonConvert.DeserializeObject<SteamApiResponse>(response);
                if (httpCode == (int)StatusCode.Success)
                {
                    // We need to check if it is null, because the steam-user can hide game information
                    var gamesCount = steamResponse.Response.game_count;
                    if (gamesCount == null)
                    {
                        callback((int)StatusCode.GameInfoHidden, null);
                        return;
                    }
                    
                    var playtimeRust = steamResponse.Response.games
                    .FirstOrDefault(x => x.appid == 252490)?.playtime_forever;
                    
                    if (playtimeRust == null)
                    {
                        callback((int)StatusCode.GameInfoHidden, null);
                        return;
                    }
                    
                    var playtimeAll = steamResponse.Response.games
                    .Sum(x => x.playtime_forever);
                    callback(httpCode, new GameTimeInformation((int)gamesCount, (int)playtimeRust, playtimeAll));
                }
                else
                {
                    callback(httpCode, null);
                }
            }, "&include_appinfo=false"); // We don't need additional appinfos, like images
        }
        
        
        /// <summary>
        /// Get Summary information about the player, like if his profile is visible
        /// </summary>
        /// <param name="steamId64">steamId64 of the user</param>
        /// <param name="callback">Callback with the statusCode <see cref="StatusCode"></see> and the <see cref="PlayerSummary"></see></param>
        private void GetSteamPlayerSummaries(string steamId64, Action<int, PlayerSummary> callback)
        {
            SteamWebRequest(SteamRequestType.ISteamUser, "GetPlayerSummaries/v2", steamId64,
            (httpCode, response) =>
            {
                var steamResponse = JsonConvert.DeserializeObject<SteamApiResponse>(response);
                if (httpCode == (int)StatusCode.Success)
                {
                    if (steamResponse.Response.players.Count() != 1)
                    {
                        callback((int)StatusCode.PlayerNotFound, null);
                        return;
                    }
                    
                    var playerInfo = steamResponse.Response.players[0];
                    
                    var summary = new PlayerSummary
                    {
                        Visibility = (PlayerSummary.VisibilityType)playerInfo.communityvisibilitystate,
                        Profileurl = playerInfo.profileurl
                    };
                    
                    // Account creation time can be only fetched, when the profile is public
                    if (summary.Visibility == PlayerSummary.VisibilityType.Public)
                    summary.Timecreated = playerInfo.timecreated;
                    else
                    summary.Timecreated = -1;
                    
                    // We have to do a separate request to the steam community profile to get infos about limited and
                    // if they set up their profile
                    {
                        // Set defaults, which won't get the user kicked
                        summary.NoProfile = false;
                        summary.LimitedAccount = false;
                        
                        webrequest.Enqueue($"https://steamcommunity.com/profiles/{steamId64}/?xml=1", "",
                        (httpCodeCommunity, responseCommunity) =>
                        {
                            if (httpCodeCommunity == (int)StatusCode.Success)
                            {
                                // XML parser is disabled in uMod, so have to use contains
                                
                                // Has not set up their profile?
                                if (responseCommunity.Contains(
                                "This user has not yet set up their Steam Community profile."))
                                summary.NoProfile = true;
                                
                                if (responseCommunity.Contains("<isLimitedAccount>1</isLimitedAccount>"))
                                summary.LimitedAccount = true;
                                
                                callback(httpCode, summary);
                            }
                            else
                            {
                                ApiError(steamId64, "GetSteamPlayerSummaries - community xml",
                                httpCodeCommunity);
                                // We will send into the callback success, as the normal GetSteamPlayerSummaries worked in this case
                                // So it's information can be respected
                                callback((int)StatusCode.Success, summary);
                            }
                        }, this, Core.Libraries.RequestMethod.GET, null, webTimeout);
                    }
                }
                else
                {
                    callback(httpCode, null);
                }
            });
        }
        
        /// <summary>
        /// Utility function for printing a log when a HTTP API Error was encountered
        /// </summary>
        /// <param name="steamId">steamId64 for which user the request was</param>
        /// <param name="function">function name in the plugin</param>
        /// <param name="statusCode">see <see cref="StatusCode"></see></param>
        private void ApiError(string steamId, string function, int statusCode)
        {
            var detailedError = $" SteamID: {steamId} - Function: {function} - ErrorCode: {(StatusCode)statusCode}";
            LogWarning(Lang("ErrorHttp"), detailedError);
        }
        
        /// <summary>
        /// Get all Steam Badges
        /// </summary>
        /// <param name="steamId64">steamId64 of the user</param>
        /// <param name="callback">Callback with the statusCode <see cref="StatusCode"></see> and the result as JSON</param>
        private void GetSteamBadges(string steamId64, Action<int,string> callback)
        {
            SteamWebRequest(SteamRequestType.IPlayerService, "GetBadges/v1", steamId64, callback);
        }
        
        /// <summary>
        /// Fetched the level of a given badgeid from a JSON Web API result
        /// </summary>
        /// <param name="response"></param>
        /// <param name="badgeId">ID of the badge, see <see cref="Badge"></see></param>
        /// <returns>level of the badge, or 0 if badge not existing</returns>
        private int ParseBadgeLevel(string response, Badge badgeId)
        {
            var steamResponse = JsonConvert.DeserializeObject<SteamBadgeApiResponse>(response);
            return steamResponse.response.badges.FirstOrDefault(x => x.badgeid == (int)badgeId)?.level ?? 0;
        }
        
        /// <summary>
        /// Get the information about the bans the player has
        /// </summary>
        /// <param name="steamId64">steamId64 of the user</param>
        /// <param name="callback">Callback with the statusCode <see cref="StatusCode"></see> and the result as <see cref="PlayerBans"></see></param>
        /// <remarks>
        /// Getting the user bans is even possible, if the profile is private
        /// </remarks>
        private void GetPlayerBans(string steamId64, Action<int, PlayerBans> callback)
        {
            SteamWebRequest(SteamRequestType.ISteamUser, "GetPlayerBans/v1", steamId64,
            (httpCode, response) =>
            {
                if (httpCode == (int)StatusCode.Success)
                {
                    var steamResponse = JsonConvert.DeserializeObject<SteamBanApiResponse>(response);
                    if (steamResponse.players.Count() != 1)
                    {
                        callback((int)StatusCode.PlayerNotFound, null);
                        return;
                    }
                    
                    var playerInfo = steamResponse.players[0];
                    
                    var bans = new PlayerBans
                    {
                        CommunityBan = playerInfo.CommunityBanned,
                        VacBan = playerInfo.VACBanned,
                        VacBanCount = playerInfo.NumberOfVACBans,
                        LastBan = playerInfo.DaysSinceLastBan,
                        GameBanCount = playerInfo.NumberOfGameBans,
                        // can be none, probation or banned
                        EconomyBan = playerInfo.EconomyBan != "none"
                    };
                    
                    callback(httpCode, bans);
                }
                else
                {
                    callback(httpCode, null);
                }
            });
        }
        #endregion

    }

}


// --- End of file: SteamChecks.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/smooth-restarter ---
// --- Original File Path: S/SmoothRestarter/SmoothRestarter.cs ---

// #define UNITY_ASSERTIONS // Uncomment this if you have any issues with the plugin, assertion log can help locate problematic code
// #define SIMULATE_OXIDE_PATCH

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;

using ConVar;

using Newtonsoft.Json;

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;

using UnityEngine;
using UnityEngine.UI;

using Debug = UnityEngine.Debug;
using Pool = Facepunch.Pool;

namespace Oxide.Plugins
{
    [Info("SmoothRestarter", "2CHEVSKII", "3.2.0")]
    [Description("A reliable way to shutdown your server when you need it")]
    public class SmoothRestarter : CovalencePlugin
    {

        #region Permission names

        const string PERMISSION_STATUS  = "smoothrestarter.status",
                     PERMISSION_RESTART = "smoothrestarter.restart",
                     PERMISSION_CANCEL  = "smoothrestarter.cancel";

        #endregion

        #region LangAPI keys

        const string M_CHAT_PREFIX                = "Chat prefix",
                     M_NO_PERMISSION              = "No permission",
                     M_KICK_REASON                = "Kick reason",
                     M_HELP                       = "Help message",
                     M_HELP_HELP                  = "Help message: Help",
                     M_HELP_STATUS                = "Help message: Status",
                     M_HELP_RESTART               = "Help message: Restart",
                     M_HELP_CANCEL                = "Help message: Cancel",
                     M_RESTARTING_ALREADY         = "Restarting already",
                     M_NOT_RESTARTING             = "Not restarting",
                     M_CANCEL_SUCCESS             = "Cancelled successfully",
                     M_RESTART_REASON_TIMED       = "Restart reason: Timed",
                     M_RESTART_REASON_OXIDE       = "Restart reason: Oxide update",
                     M_RESTART_REASON_COMMAND     = "Restart reason: Command",
                     M_RESTART_REASON_API         = "Restart reason: API call",
                     M_ANNOUNCE_RESTART_INIT      = "Announcement: Restart initiated",
                     M_ANNOUNCE_COUNTDOWN_TICK    = "Announcement: Countdown tick",
                     M_ANNOUNCE_RESTART_CANCELLED = "Announcement: Restart cancelled",
                     M_RESTART_SUCCESS            = "Restart initiated",
                     M_STATUS_RESTARTING          = "Status: Restarting",
                     M_STATUS_RESTARTING_NATIVE   = "Status: Restarting (global.restart)",
                     M_STATUS_PLANNED             = "Status: Restart planned",
                     M_STATUS_NO_PLANNED          = "Status: No planned restarts",
                     M_UI_TITLE                   = "UI title",
                     M_UI_COUNTDOWN               = "UI countdown format";

        #endregion

#if SIMULATE_OXIDE_PATCH
        static readonly VersionNumber CurrentOxideRustVersion = new VersionNumber(0, 0, 0);
#else
        static readonly VersionNumber CurrentOxideRustVersion = Interface.Oxide.GetAllExtensions()
                                                                         .First(
                                                                             e => e.Name == "Rust"
                                                                         )
                                                                         .Version;
#endif
        static SmoothRestarter Instance;

        readonly FieldInfo nativeRestartRoutine = typeof(ServerMgr).GetField(
            "restartCoroutine",
            BindingFlags.Instance | BindingFlags.NonPublic
        );

        #region LangAPI EN dictionary

        readonly Dictionary<string, string> defaultMessagesEn = new Dictionary<string, string> {
            [M_CHAT_PREFIX] = "<color=#d9770f>Smooth Restarter</color>:",
            [M_NO_PERMISSION] = "<color=#f04c32>You</color> have no permission to use this command",
            [M_KICK_REASON] = "Server is restarting",
            [M_HELP] =
                "/sr <color=#1a97ba>[command]</color> <color=#1aba8f>[arguments]</color>\n" +
                "Commands: " +
                "<color=#1a97ba>help</color>, <color=#1a97ba>status</color>, <color=#1a97ba>restart</color>, <color=#1a97ba>cancel</color>\n" +
                "To get information about command usage, type '/sr <color=#1a97ba>help</color> <color=#1aba8f>[command]</color>'",
            [M_HELP_HELP] =
                "/sr <color=#1a97ba>help</color> <color=#1aba8f>[command]</color> - Outputs general help message or command usage help if command is specified",
            [M_HELP_STATUS] = "/sr <color=#1a97ba>status</color> - Outputs current restart status",
            [M_HELP_RESTART] =
                "/sr <color=#1a97ba>restart</color> <color=#1aba8f>[time]</color> - Initiates new restart process\n" +
                "Time must be in one of the following formats:\n" +
                "<color=#77ba20>123</color> - delay before restart in seconds\n" +
                "<color=#77ba20>123</color><h|m|s> - delay before restart in <hours|minutes|seconds>\n" +
                "<color=#77ba20>1</color>h <color=#77ba20>2</color>m <color=#77ba20>3</color>s - delay before restart in hr+min+sec, all optional\n" +
                "<color=#77ba20>1</color>:<color=#77ba20>23</color> - schedule restart on 1:23 (24hr format)",
            [M_HELP_CANCEL] = "/sr <color=#1a97ba>cancel</color> - Cancels current restart process",
            [M_RESTARTING_ALREADY] =
                "Cannot do restart - already restarting. Use '/sr <color=#1a97ba>status</color>' to get info about current restart process, or try '/sr <color=#1a97ba>cancel</color>' to cancel current restart before starting new one",
            [M_NOT_RESTARTING] =
                "Cannot cancel restart - plugin does not perform a restart currently.",
            [M_CANCEL_SUCCESS] = "Restart was successfully cancelled",
            [M_RESTART_REASON_TIMED] = "Planned",
            [M_RESTART_REASON_OXIDE] = "New Oxide update is out",
            [M_RESTART_REASON_COMMAND] = "Command from <color=#dbc30b>{0}</color>",
            [M_RESTART_REASON_API] = "API call from <color=#dbc30b>{0}</color>",
            [M_ANNOUNCE_RESTART_INIT] =
                "Server will be restarted in <color=#a4db0b>{0:sfmt::<hr?+ hours ><min?+ minutes ><sec?+ seconds>}</color> ({1})",
            [M_ANNOUNCE_COUNTDOWN_TICK] =
                "<color=#a4db0b>{0:sfmt::<hr?+h ><min?+min ><sec?+s>}</color> left before server restart",
            [M_ANNOUNCE_RESTART_CANCELLED] = "Server restart was cancelled",
            [M_RESTART_SUCCESS] = "Restart initiated successfully",
            [M_STATUS_RESTARTING] =
                "Server is restarting, <color=#a4db0b>{1:sfmt::<min#0.0!+ min ><sec?+ seconds>}</color> left",
            [M_STATUS_RESTARTING_NATIVE] = "Server is restarting natively",
            [M_STATUS_PLANNED] =
                "Server restart planned at <color=#a4db0b>{0:hh\\:mm}</color> (<color=#a4db0b>{1:sfmt::<hr?+ hours ><min?+ minutes ><sec?+ seconds>}</color> left)",
            [M_STATUS_NO_PLANNED] = "Server is not restarting, no planned restarts found",
            [M_UI_TITLE] = "SmoothRestarter",
            [M_UI_COUNTDOWN] = "{0:sfmt::<min#2!>:<sec#2>} left"
        };

        #endregion

        readonly Regex timeParseRegex = new Regex(
            @"^\s*(?:(\d+)|(\d+\s*[HhMmSs])|(?!$)((?:(?<h>\d+)[Hh])?\s*(?:(?<m>\d+)[Mm])?\s*(?:(?<s>\d+)[Ss])?)|(\d{1,2}:\d{1,2}))\s*$",
            RegexOptions.Compiled
        );

        SmoothRestart  component;
        PluginSettings settings;
        bool           isNewOxideOut;

        bool IsRestarting => IsRestartingNative || IsRestartingComponent;
        bool IsRestartingNative => ServerMgr.Instance.Restarting;
        bool IsRestartingComponent => component.IsRestarting;

        #region Oxide hooks

        // ReSharper disable UnusedMember.Local

        void Init()
        {
            if (!settings.EnableUi)
            {
                Unsubscribe(nameof(OnUserConnected));
                Unsubscribe(nameof(OnUserDisconnected));
            }

            permission.RegisterPermission(PERMISSION_STATUS, this);
            permission.RegisterPermission(PERMISSION_RESTART, this);
            permission.RegisterPermission(PERMISSION_CANCEL, this);

            AddCovalenceCommand(settings.Commands, "CommandHandler");
        }

        void OnServerInitialized()
        {
            component = ServerMgr.Instance.gameObject.AddComponent<SmoothRestart>();

            if (settings.EnableUi)
                foreach (var player in players.Connected)
                {
                    OnUserConnected(player);
                }
        }

        void OnUserConnected(IPlayer user)
        {
            var player = (BasePlayer) user.Object;

            player.gameObject.AddComponent<SmoothRestarterUi>();
        }

        void OnUserDisconnected(IPlayer user)
        {
            var player = (BasePlayer) user.Object;

            UnityEngine.Object.Destroy(player.GetComponent<SmoothRestarterUi>());
        }

        void Unload()
        {
            if (IsRestartingComponent)
            {
                component.CancelRestart(this);
            }

            if (settings.EnableUi)
            {
                SmoothRestarterUi.Cleanup();
            }

            UnityEngine.Object.Destroy(component);
            Instance = null;
        }

        // ReSharper restore UnusedMember.Local

        #endregion

        #region Command handler

        // ReSharper disable once UnusedMember.Local
        void CommandHandler(IPlayer player, string _, string[] args)
        {
            if (args.Length == 0)
            {
                Message(player, M_HELP);
            }
            else
            {
                var command = args[0];

                switch (command)
                {
                    case "status":
                        if (CheckPermission(player, PERMISSION_STATUS))
                        {
                            DateTime dateTime;
                            //Message(player, GetStatus(out dateTime), dateTime.TimeOfDay, (dateTime - DateTime.Now).TotalSeconds);
                            MessageWithCustomFormatter(
                                player,
                                SmoothTimeFormatter.Instance,
                                GetStatus(out dateTime),
                                dateTime.TimeOfDay,
                                (dateTime - DateTime.Now).TotalSeconds
                            );
                        }

                        break;

                    case "restart":
                        if (CheckPermission(player, PERMISSION_RESTART))
                        {
                            if (IsRestarting)
                            {
                                Message(player, M_RESTARTING_ALREADY);
                            }
                            else
                            {
                                TimeSpan time;
                                bool isTod;

                                if (args.Length == 1 ||
                                    !TryParseTime(
                                        string.Join(" ", args.Skip(1)),
                                        out time,
                                        out isTod
                                    ))
                                {
                                    Message(player, M_HELP_RESTART);

                                    return;
                                }

                                DateTime restartTime;

                                if (!isTod)
                                {
                                    restartTime = DateTime.Now + time;
                                }
                                else if (time < DateTime.Now.TimeOfDay)
                                {
                                    restartTime = DateTime.Today.AddDays(1) + time;
                                }
                                else
                                {
                                    restartTime = DateTime.Today + time;
                                }

                                component.DoRestart(restartTime, RestartReason.Command, player);
                                Message(player, M_RESTART_SUCCESS);
                            }
                        }

                        break;

                    case "cancel":
                        if (CheckPermission(player, PERMISSION_CANCEL))
                        {
                            if (IsRestartingNative)
                            {
                                CancelNativeRestart();
                            }
                            else if (IsRestartingComponent)
                            {
                                component.CancelRestart(player);
                            }
                            else
                            {
                                Message(player, M_NOT_RESTARTING);

                                return;
                            }

                            Message(player, M_CANCEL_SUCCESS);
                        }

                        break;

                    case "help":
                        Message(player, GetHelp(args.Skip(1)));

                        break;

                    default:
                        Message(player, M_HELP);

                        break;
                }
            }
        }

        string GetHelp(IEnumerable<string> args)
        {
            var arg = args.FirstOrDefault();

            if (arg != null)
            {
                switch (arg.ToLower())
                {
                    case "help":
                        return M_HELP_HELP;

                    case "status":
                        return M_HELP_STATUS;

                    case "restart":
                        return M_HELP_RESTART;

                    case "cancel":
                        return M_HELP_CANCEL;
                }
            }

            return M_HELP;
        }

        string GetStatus(out DateTime restartTime)
        {
            restartTime = default(DateTime);

            if (IsRestartingNative)
            {
                return M_STATUS_RESTARTING_NATIVE;
            }

            if (IsRestartingComponent)
            {
                restartTime = component.CurrentRestartTime.Value;

                return M_STATUS_RESTARTING;
            }

            if (settings.RestartTimes.Count > 0)
            {
                double _;
                restartTime = component.FindNextRestartTime(out _);

                return M_STATUS_PLANNED;
            }

            return M_STATUS_NO_PLANNED;
        }

        bool TryParseTime(string argString, out TimeSpan time, out bool isTod)
        {
            Match match = timeParseRegex.Match(argString);
            isTod = false;

            if (match.Groups[1].Success)
            {
                var seconds = int.Parse(match.Groups[1].Value);

                time = TimeSpan.FromSeconds(seconds);
            }
            else if (match.Groups[2].Success)
            {
                var str = match.Groups[2].Value;
                var specifier = str[str.Length - 1];
                var number = int.Parse(str.Remove(str.Length - 1).TrimEnd());

                switch (specifier)
                {
                    case 'H':
                    case 'h':
                        number *= 3600;

                        break;

                    case 'M':
                    case 'm':
                        number *= 60;

                        break;
                }

                time = TimeSpan.FromSeconds(number);
            }
            else if (match.Groups[3].Success)
            {
                var h = match.Groups["h"].Success ? int.Parse(match.Groups["h"].Value) : 0;
                var m = match.Groups["m"].Success ? int.Parse(match.Groups["m"].Value) : 0;
                var s = match.Groups["s"].Success ? int.Parse(match.Groups["s"].Value) : 0;

                time = new TimeSpan(h, m, s);
            }
            else if (TimeSpan.TryParse(match.Groups[4].Value, out time))
            {
                isTod = true;
            }
            else
            {
                time = default(TimeSpan);

                return false;
            }

            if (time.TotalSeconds == 0)
            {
                return false;
            }

            return true;
        }

        bool CheckPermission(IPlayer player, string perm)
        {
            if (player.HasPermission(perm))
            {
                return true;
            }

            Message(player, M_NO_PERMISSION);

            return false;
        }

        #endregion

        #region Utility

        void FetchLatestOxideRustVersion(Action<Exception, VersionNumber> callback)
        {
            PluginLog("Fetching latest Oxide.Rust version...");
            webrequest.Enqueue(
                "https://umod.org/games/rust.json",
                null,
                (responseCode, json) => {
                    if (responseCode != 200)
                    {
                        callback(
                            new Exception(
                                $"Failed to fetch latest Oxide.Rust version from uMod.org API - code {responseCode}"
                            ),
                            default(VersionNumber)
                        );
                    }
                    else
                    {
                        try
                        {
                            var response =
                                JsonConvert.DeserializeObject<Dictionary<string, object>>(json);

                            if (response == null)
                            {
                                throw new Exception("Response is null");
                            }

                            var latestVersionStr = response["latest_release_version"];

                            var array = ((string) latestVersionStr).Split('.');

                            var version = new VersionNumber(
                                int.Parse(array[0]),
                                int.Parse(array[1]),
                                int.Parse(array[2])
                            );

                            callback(null, version);
                        }
                        catch (Exception e)
                        {
                            callback(
                                new Exception(
                                    $"Failed to deserialize uMod.org API response: {e.Message}"
                                ),
                                default(VersionNumber)
                            );
                        }
                    }
                },
                this
            );
        }

        void PluginLog(string format, params object[] args)
        {
            if (settings.EnableLog)
            {
                Log(format, args);
            }
        }

        void KickAll()
        {
            foreach (var player in players.Connected.ToArray())
            {
                player.Kick(GetMessage(player, M_KICK_REASON));
            }
        }

        void CancelNativeRestart()
        {
            Debug.Assert(IsRestartingNative, "Cancelling native restart while !IsRestartingNative");

            var routine = (IEnumerator) nativeRestartRoutine.GetValue(ServerMgr.Instance);
            ServerMgr.Instance.StopCoroutine(routine);

            nativeRestartRoutine.SetValue(ServerMgr.Instance, null);

            ConsoleNetwork.BroadcastToAllClients(
                "chat.add",
                new object[] {
                    2,
                    0,
                    "<color=#fff>SERVER</color> Restart interrupted!"
                }
            );

            PluginLog("Native restart was cancelled");
        }

        #endregion

        #region Plugin API

        // ReSharper disable UnusedMember.Local

        [HookMethod(nameof(IsSmoothRestarting))]
        public bool IsSmoothRestarting()
        {
            return IsRestartingComponent;
        }

        [HookMethod(nameof(GetPlannedRestarts))]
        public IReadOnlyCollection<TimeSpan> GetPlannedRestarts()
        {
            return settings.RestartTimes;
        }

        [HookMethod(nameof(GetCurrentRestartTime))]
        public DateTime? GetCurrentRestartTime()
        {
            return component.CurrentRestartTime;
        }

        [HookMethod(nameof(GetCurrentRestartReason))]
        public int? GetCurrentRestartReason()
        {
            return (int?) component.CurrentRestartReason;
        }

        [HookMethod(nameof(GetCurrentRestartInitiator))]
        public object GetCurrentRestartInitiator()
        {
            return component.CurrentRestartInitiator;
        }

        [HookMethod(nameof(InitSmoothRestart))]
        public bool InitSmoothRestart(DateTime restartTime, Plugin initiator)
        {
            if (initiator == null || !initiator.IsLoaded)
            {
                return false;
            }

            if (restartTime < DateTime.Now)
            {
                return false;
            }

            if (IsRestartingComponent)
            {
                return false;
            }

            if (IsRestartingNative)
            {
                CancelNativeRestart();
            }

            component.DoRestart(restartTime, RestartReason.ApiCall, initiator);

            return true;
        }

        [HookMethod(nameof(CancelSmoothRestart))]
        public bool CancelSmoothRestart(Plugin canceller)
        {
            if (canceller == null || !canceller.IsLoaded)
            {
                return false;
            }

            if (!IsRestartingComponent)
            {
                return false;
            }

            component.CancelRestart(canceller);

            return true;
        }

        // ReSharper restore UnusedMember.Local

        #endregion

        #region LangAPI

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(defaultMessagesEn, this, "en");
        }

        string GetMessage(IPlayer player, string langKey)
        {
            return lang.GetMessage(langKey, this, player.Id);
        }

        void Message(IPlayer player, string langKey, params object[] args)
        {
            player.Message(GetMessage(player, langKey), GetMessage(player, M_CHAT_PREFIX), args);
        }

        void MessageWithCustomFormatter(
            IPlayer player,
            IFormatProvider formatProvider,
            string langKey,
            params object[] args
        )
        {
            var format = GetMessage(player, langKey);
            var message = string.Format(formatProvider, format, args);
            player.Message(message, GetMessage(player, M_CHAT_PREFIX));
        }

        void MessageRaw(IPlayer player, string message, params object[] args)
        {
            player.Message(message, GetMessage(player, M_CHAT_PREFIX), args);
        }

        void AnnounceRestartInit(float secondsLeft, RestartReason reason, object initiator = null)
        {
            foreach (IPlayer player in players.Connected)
            {
                var reasonStr = GetRestartReasonString(player, reason, initiator);

                //Message(player, M_ANNOUNCE_RESTART_INIT, secondsLeft.ToString("0"), reasonStr);
                MessageWithCustomFormatter(
                    player,
                    SmoothTimeFormatter.Instance,
                    M_ANNOUNCE_RESTART_INIT,
                    secondsLeft,
                    reasonStr
                );
            }
        }

        void Announce(string langKey, params object[] args)
        {
            foreach (IPlayer player in players.Connected)
            {
                Message(player, langKey, args);
            }
        }

        void AnnounceWithCustomFormatter(
            IFormatProvider formatProvider,
            string langKey,
            params object[] args
        )
        {
            foreach (IPlayer player in players.Connected)
            {
                MessageWithCustomFormatter(
                    player,
                    formatProvider,
                    langKey,
                    args
                );
            }
        }

        void AnnounceRaw(string message, params object[] args)
        {
            foreach (var player in players.Connected)
            {
                MessageRaw(player, message, args);
            }
        }

        string GetRestartReasonString(IPlayer player, RestartReason reason, object initiator = null)
        {
            Debug.Assert((int) reason < 2 || initiator != null);

            string reasonStr;

            switch (reason)
            {
                case RestartReason.Timed:
                    reasonStr = GetMessage(player, M_RESTART_REASON_TIMED);

                    break;

                case RestartReason.OxideUpdate:
                    reasonStr = GetMessage(player, M_RESTART_REASON_OXIDE);

                    break;

                case RestartReason.Command:
                    reasonStr = string.Format(
                        GetMessage(player, M_RESTART_REASON_COMMAND),
                        ((IPlayer) initiator).Name
                    );

                    break;

                default:
                    reasonStr = string.Format(
                        GetMessage(player, M_RESTART_REASON_API),
                        ((Plugin) initiator).Name
                    );

                    break;
            }
            
            return reasonStr;
        }

        #endregion

        #region Configuration

        protected override void LoadDefaultConfig()
        {
            settings = PluginSettings.GetDefaults();
            SaveConfig();
        }

        protected override void LoadConfig()
        {
            Instance = this;
            base.LoadConfig();

            try
            {
                settings = Config.ReadObject<PluginSettings>();

                if (settings == null)
                {
                    throw new Exception("Config is null");
                }

                if (!settings.Validate())
                {
                    LogWarning(
                        "Errors found in the configuration file, corrected values will be saved"
                    );

                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError("Error while loading configuration: {0}", e.Message);
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(settings);
        }

        #endregion

        #region Nested types

        enum RestartReason
        {
            Timed,
            OxideUpdate,
            Command,
            ApiCall
        }

        #region Configuration

        class PluginSettings
        {
            float[]           uiPosCached;
            HashSet<TimeSpan> restartTimesCached;

            [JsonProperty("Daily restarts")]
            public string[] DailyRestart { get; set; }
            [JsonProperty("Restart when new Oxide.Rust is out")]
            public bool OxideUpdateRestart { get; set; }
            [JsonProperty("Initiate countdown at")]
            public int RestartCountdownMax { get; set; }
            [JsonProperty("Enable UI")]
            public bool EnableUi { get; set; }
            [JsonProperty("UI position (X,Y)")]
            public string UiPosition { get; set; }
            [JsonProperty("UI scale")]
            public float UiScale { get; set; }
            [JsonProperty("Enable console logs")]
            public bool EnableLog { get; set; }
            [JsonProperty("Commands")]
            public string[] Commands { get; set; }
            [JsonProperty("Disable chat countdown notifications")]
            public bool DisableChatCountdown { get; set; }
            [JsonProperty("Custom countdown reference points")]
            public int[] CountdownRefPts { get; set; }
            [JsonProperty("Use custom countdown reference points")]
            public bool UseCustomCountdownRefPts { get; set; }
            [JsonProperty("Oxide update check interval in seconds")]
            public int OxideUpdateCheckInterval { get; set; }

            [JsonIgnore]
            public float UiX => uiPosCached[0];
            [JsonIgnore]
            public float UiY => uiPosCached[1];
            [JsonIgnore]
            public HashSet<TimeSpan> RestartTimes => restartTimesCached;

            public static PluginSettings GetDefaults()
            {
                return new PluginSettings {
                    DailyRestart = new[] {"0:00"},
                    OxideUpdateRestart = true,
                    RestartCountdownMax = 300,
                    EnableUi = true,
                    EnableLog = true,
                    UiPosition = "0.92, 0.92",
                    UiScale = 1.0f,
                    Commands = new[] {
                        "sr",
                        "srestart",
                        "smoothrestart",
                        "smoothrestarter"
                    },
                    DisableChatCountdown = false,
                    UseCustomCountdownRefPts = false,
                    CountdownRefPts = new[] {
                        60,
                        50,
                        40,
                        30,
                        25,
                        15,
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1
                    }
                };
            }

            #region Validation methods

            public bool Validate()
            {
                bool valid = true;

                if (DailyRestart == null)
                {
                    Instance.LogWarning("Daily restart times cannot be null");
                    DailyRestart = Array.Empty<string>();
                    valid = false;
                }

                if (!ParseRestartTimes(out restartTimesCached))
                {
                    DailyRestart = restartTimesCached.Select(rt => rt.ToString("hh\\:mm"))
                                                     .ToArray();

                    valid = false;
                }

                if (RestartCountdownMax < 0)
                {
                    Instance.LogWarning("Restart countdown cannot be less than zero");
                    RestartCountdownMax = 0;
                    valid = false;
                }

                if (UiScale < 0.3f)
                {
                    UiScale = 0.3f;
                    Instance.LogWarning("UI scale cannot be less than 0.3");
                    valid = false;
                }
                else if (UiScale > 3f)
                {
                    UiScale = 3f;
                    Instance.LogWarning("UI scale cannot be greater than 3");
                    valid = false;
                }

                uiPosCached = new float[2];

                if (!ParseUiPos(out uiPosCached[0], out uiPosCached[1]))
                {
                    uiPosCached[0] = 0.92f;
                    uiPosCached[1] = 0.92f;
                    UiPosition = "0.92, 0.92";
                    valid = false;
                }

                if (Commands == null || Commands.Length == 0)
                {
                    Commands = new[] {
                        "sr",
                        "srestart",
                        "smoothrestart",
                        "smoothrestarter"
                    };

                    valid = false;
                }

                if (CountdownRefPts == null)
                {
                    CountdownRefPts = new[] {
                        60,
                        50,
                        40,
                        30,
                        25,
                        15,
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1
                    };

                    valid = false;
                }

                if (UseCustomCountdownRefPts && CountdownRefPts.Length == 0)
                {
                    CountdownRefPts = new[] {
                        30,
                        10,
                        5
                    };

                    valid = false;
                }

                CountdownRefPts = CountdownRefPts.OrderByDescending(_ => _).ToArray();

                if (OxideUpdateCheckInterval < 600)
                {
                    Instance.LogWarning("Oxide update check interval must be greater than 10 minutes");
                    OxideUpdateCheckInterval = 600;

                    valid = false;
                }

                return valid;
            }

            bool ParseUiPos(out float fX, out float fY)
            {
                fX = fY = 0f;

                var array = UiPosition.Split(',');

                if (array.Length != 2)
                {
                    Instance.LogWarning("Invalid format of UI position: {0}", UiPosition);

                    return false;
                }

                bool valid = true;

                if (!float.TryParse(
                        array[0],
                        NumberStyles.Number,
                        CultureInfo.InvariantCulture,
                        out fX
                    ) ||
                    fX < 0f ||
                    fX > 1f)
                {
                    Instance.LogWarning(
                        "Invalid value for UI position X coordinate: {0}",
                        array[0]
                    );

                    valid = false;
                }

                if (!float.TryParse(
                        array[1],
                        NumberStyles.Number,
                        CultureInfo.InvariantCulture,
                        out fY
                    ) ||
                    fY < 0f ||
                    fY > 1f)
                {
                    Instance.LogWarning(
                        "Invalid value for UI position Y coordinate: {0}",
                        array[1]
                    );

                    valid = false;
                }

                return valid;
            }

            bool ParseRestartTimes(out HashSet<TimeSpan> restartTimes)
            {
                bool valid = true;
                restartTimes = new HashSet<TimeSpan>();

                foreach (var rt in DailyRestart)
                {
                    TimeSpan result;

                    if (!TimeSpan.TryParse(rt, out result))
                    {
                        valid = false;
                        Instance.LogWarning("Invalid time specifier: {0}", rt);
                    }

                    if (!restartTimes.Add(result))
                    {
                        valid = false;
                        Instance.LogWarning("Restart time duplication: {0}", rt);
                    }
                }

                return valid;
            }

            #endregion

        }

        #endregion

        #region SmoothRestarterUi

        class SmoothRestarterUi : MonoBehaviour
        {
            const string UI_BACKGROUND   = "smoothrestarter.ui::background",
                         UI_TITLE        = "smoothrestarter.ui::title",
                         UI_PROGRESS_BAR = "smoothrestarter.ui::progress_bar",
                         UI_SECONDS      = "smoothrestarter.ui::seconds_left";

            static HashSet<SmoothRestarterUi> AllComponents;
            static Dictionary<string, string> UiSecondsCache;
            static Dictionary<string, string> UiProgressbarCache;

            string     mainPanel;
            BasePlayer player;
            bool       isVisible;
            string     locale;

            bool IsVisible
            {
                set
                {
                    Debug.Assert(value != isVisible, "Double set isVisible to " + value);

                    SetVisible(value);
                }
            }

            public static void Cleanup()
            {
                if (AllComponents == null)
                {
                    return;
                }

                foreach (var component in AllComponents.ToArray())
                {
                    DestroyImmediate(component);
                }

                UiSecondsCache = null;
                UiProgressbarCache = null;
                AllComponents = null;
            }

            #region Unity methods

            void Awake()
            {
                if (AllComponents == null)
                {
                    AllComponents = new HashSet<SmoothRestarterUi>();
                }

                //if (mainPanel == null)
                //{

                //}

                player = GetComponent<BasePlayer>();
                locale = Instance.lang.GetLanguage(player.UserIDString);

                var uiTitle = Instance.GetMessage(player.IPlayer, M_UI_TITLE);

                var container = new CuiElementContainer {
                    new CuiElement {
                        FadeOut = 0.2f,
                        Name = UI_BACKGROUND,
                        Parent = "Hud",
                        Components = {
                            new CuiImageComponent {
                                Color = "0.2 0.2 0.2 0.3",
                                FadeIn = 0.2f,
                                ImageType = Image.Type.Simple,
                                Material = "assets/content/ui/uibackgroundblur.mat"
                            },
                            new CuiRectTransformComponent {
                                AnchorMin =
                                    $"{Instance.settings.UiX - 0.08f * Instance.settings.UiScale} " +
                                    $"{Instance.settings.UiY - 0.05f * Instance.settings.UiScale}",
                                AnchorMax =
                                    $"{Instance.settings.UiX + 0.08f * Instance.settings.UiScale} " +
                                    $"{Instance.settings.UiY + 0.05f * Instance.settings.UiScale}"
                            }
                        }
                    },
                    new CuiElement {
                        FadeOut = 0.2f,
                        Name = UI_TITLE,
                        Parent = UI_BACKGROUND,
                        Components = {
                            new CuiTextComponent {
                                Color = "0.8 0.8 0.8 0.95",
                                FadeIn = 0.2f,
                                Align = TextAnchor.MiddleCenter,
                                Font = "robotocondensed-bold.ttf",
                                FontSize = 16,
                                Text = uiTitle /*nameof(SmoothRestarter)*/
                            },
                            new CuiRectTransformComponent {
                                AnchorMin = "0 0.6",
                                AnchorMax = "1 1"
                            }
                        }
                    }
                };

                mainPanel = SerializeUi(container);

                if (UiSecondsCache == null)
                {
                    UiSecondsCache = new Dictionary<string, string>();
                }

                if (UiProgressbarCache == null)
                {
                    UiProgressbarCache = new Dictionary<string, string>();
                }

                AllComponents.Add(this);
            }

            void Start()
            {
                InvokeRepeating(nameof(UiTick), 1f, 1f);
            }

            void OnDestroy()
            {
                if (isVisible)
                {
                    IsVisible = false;
                }

                AllComponents?.Remove(this);
            }

            #endregion

            void SetVisible(bool visible)
            {
                Debug.Assert(player && player.IsConnected, "Player is null or disconnected");

                if (visible)
                {
                    CuiHelper.AddUi(player, mainPanel);
                }
                else
                {
                    CuiHelper.DestroyUi(player, UI_SECONDS);
                    CuiHelper.DestroyUi(player, UI_PROGRESS_BAR);
                    CuiHelper.DestroyUi(player, UI_TITLE);
                    CuiHelper.DestroyUi(player, UI_BACKGROUND);
                }

                isVisible = visible;
            }

            void UiTick()
            {
                if (Instance.IsRestartingComponent)
                {
                    if (!isVisible)
                    {
                        IsVisible = true;
                    }

                    var secondsLeft = (Instance.component.CurrentRestartTime.Value - DateTime.Now)
                        .TotalSeconds;

                    UpdateSeconds(secondsLeft);
                    UpdateProgressBar(GetFraction(secondsLeft));
                }
                else if (isVisible)
                {
                    IsVisible = false;
                }
            }

            #region Ui update methods

            void UpdateSeconds(double secondsLeft)
            {
                CuiHelper.DestroyUi(player, UI_SECONDS);
                CuiHelper.AddUi(
                    player,
                    LookupUiDictionary(
                        locale,
                        (int) secondsLeft,
                        UiSecondsCache,
                        CreateSeconds
                    )
                );
            }

            void UpdateProgressBar(float fraction)
            {
                Debug.Assert(
                    fraction >= 0f && fraction <= 1,
                    "Progress bar fraction is outside of 0..1 range: " + fraction
                );

                CuiHelper.DestroyUi(player, UI_PROGRESS_BAR);
                CuiHelper.AddUi(
                    player,
                    LookupUiDictionary(
                        "any",
                        fraction,
                        UiProgressbarCache,
                        CreateProgressBar
                    )
                );
            }

            string CreateSeconds(int secondsLeft)
            {
                return SerializeUi(
                    new CuiElementContainer {
                        new CuiElement {
                            FadeOut = 0.2f,
                            Name = UI_SECONDS,
                            Parent = UI_BACKGROUND,
                            Components = {
                                new CuiTextComponent {
                                    Color = "0.8 0.8 0.8 0.95",
                                    FadeIn = 0.2f,
                                    Align = TextAnchor.MiddleCenter,
                                    Font = "robotocondensed-bold.ttf",
                                    FontSize = 16,
                                    Text = string.Format(
                                        SmoothTimeFormatter.Instance,
                                        Instance.GetMessage(player.IPlayer, M_UI_COUNTDOWN),
                                        secondsLeft
                                    )
                                },
                                new CuiRectTransformComponent {
                                    AnchorMin = "0 0",
                                    AnchorMax = "1 0.45"
                                }
                            }
                        }
                    }
                );
            }

            string CreateProgressBar(float fraction)
            {
                return SerializeUi(
                    new CuiElementContainer {
                        new CuiElement {
                            FadeOut = 0.2f,
                            Name = UI_PROGRESS_BAR,
                            Parent = UI_BACKGROUND,
                            Components = {
                                new CuiImageComponent {
                                    Color = GetFractionColor(fraction),
                                    FadeIn = 0f,
                                    ImageType = Image.Type.Simple,
                                    Material = "assets/content/ui/namefontmaterial.mat"
                                },
                                new CuiRectTransformComponent {
                                    AnchorMin = $"{0.5f - fraction * 0.45f} 0.45",
                                    AnchorMax = $"{0.5f + fraction * 0.45f} 0.6"
                                }
                            }
                        }
                    }
                );
            }

            #endregion

            #region Utility

            float GetFraction(double secondsLeft)
            {
                var norm = Instance.settings.RestartCountdownMax;

                if (secondsLeft > norm)
                {
                    return 1f;
                }

                return (float) (secondsLeft / norm);
            }

            string GetFractionColor(float fraction)
            {
                Debug.Assert(
                    fraction <= 1 && fraction >= 0,
                    "GetFractionColor: fraction is not clamped"
                );

                float r;
                float g;

                if (fraction > 0.5f)
                {
                    r = Mathf.Lerp(.85f, .15f, fraction / 2);
                    g = 0.85f;
                }
                else
                {
                    r = 0.85f;
                    g = Mathf.Lerp(.15f, .85f, fraction * 2);
                }

                return $"{r} {g} 0.2 1";
            }

            static string LookupUiDictionary<T>(
                string locale,
                T value,
                Dictionary<string, string> dict,
                Func<T, string> createFunction
            )
            {
                string key = $"{locale}->{value}";
                string returnVal;

                if (!dict.TryGetValue(key, out returnVal))
                {
                    returnVal = createFunction(value);
                    dict[key] = returnVal;
                }

                return returnVal;
            }

            string SerializeUi(CuiElementContainer container)
            {
                return JsonConvert.SerializeObject(
                                      container,
                                      Formatting.None,
                                      new JsonSerializerSettings {
                                          DefaultValueHandling = DefaultValueHandling.Ignore
                                      }
                                  )
                                  .Replace("\\n", "\n");
            }

            #endregion

        }

        #endregion

        #region SmoothRestart

        class SmoothRestart : MonoBehaviour
        {
            IEnumerator     restartRoutine;
            Queue<DateTime> restartQueue;
            int             rtCountdownStart;
            bool            doTimedRestarts;
            bool            doRestartChecks;
            int             oxideVersionCheckInterval;

            public DateTime? CurrentRestartTime { get; private set; }
            public RestartReason? CurrentRestartReason { get; private set; }
            public object CurrentRestartInitiator { get; private set; }

            public bool IsRestarting => restartRoutine != null;

            bool DoRestartChecks
            {
                set
                {
                    Debug.Assert(
                        value != doRestartChecks,
                        "Double set DoRestartChecks to " + value
                    );

                    if (doRestartChecks != value)
                    {
                        doRestartChecks = value;

                        if (value)
                        {
                            InvokeRepeating(nameof(RestartCheck), 1f, 1f);
                        }
                        else
                        {
                            CancelInvoke(nameof(RestartCheck));
                        }
                    }
                }
            }

            #region Unity methods

            void Awake()
            {
                rtCountdownStart = Instance.settings.RestartCountdownMax;

                if (Instance.settings.RestartTimes.Count > 0)
                {
                    restartQueue = new Queue<DateTime>(
                        Instance.settings.RestartTimes.Select(ts => DateTime.Today + ts)
                    );

                    doTimedRestarts = true;

                    Instance.PluginLog(
                        "Loaded {0} restart time(s):\n{1}",
                        restartQueue.Count,
                        string.Join(
                            "\n",
                            restartQueue.Select(ts => ts.TimeOfDay.ToString("hh\\:mm").PadLeft(50))
                        )
                    );
                }

                if (Instance.settings.OxideUpdateRestart)
                {
                    oxideVersionCheckInterval = Instance.settings.OxideUpdateCheckInterval;
                    Invoke(nameof(OxideVersionCheck), 5f);
                }
            }

            void Start()
            {
                if (doTimedRestarts || Instance.settings.OxideUpdateRestart)
                {
                    DoRestartChecks = true;
                }
            }

            void OnDestroy()
            {
                if (IsRestarting)
                {
                    CancelRestart(Instance);
                }
            }

            #endregion

            #region Public API

            public void DoRestart(
                DateTime restartTime,
                RestartReason restartReason,
                object restartInitiator
            )
            {
                Debug.Assert(!Instance.IsRestarting, "DoRestart while restarting already");
                Debug.Assert(restartTime > DateTime.Now, "Initiating restart in the past");

                var totalSecondsLeft = (float) (restartTime - DateTime.Now).TotalSeconds;

                DoRestartChecks = false;
                restartRoutine = InitRestartRoutine(totalSecondsLeft);
                CurrentRestartTime = restartTime;
                CurrentRestartReason = restartReason;
                CurrentRestartInitiator = restartInitiator;

                StartCoroutine(restartRoutine);

                OnRestartInit(totalSecondsLeft, restartReason, restartInitiator);
            }

            public void CancelRestart(object canceller)
            {
                Debug.Assert(canceller != null, "Restart canceller is null");

                StopCoroutine(restartRoutine);

                if (CurrentRestartReason == RestartReason.OxideUpdate)
                {
                    Instance.isNewOxideOut = false;
                    Invoke(nameof(OxideVersionCheck), oxideVersionCheckInterval);
                }

                Cleanup();

                DoRestartChecks = true;

                OnRestartCancelled(canceller);
            }

            public DateTime FindNextRestartTime(out double diff)
            {
                DateTime restartTime;
                DateTime now = DateTime.Now;
                while ((restartTime = restartQueue.Peek()) < now)
                    CycleQueue();

                diff = (restartTime - now).TotalSeconds;

                return restartTime;
            }

            #endregion

            void OxideVersionCheck()
            {
                Debug.Assert(
                    Instance.settings.OxideUpdateRestart,
                    "OxideVersionCheck called when config value is false"
                );

                Debug.Assert(
                    !Instance.isNewOxideOut,
                    "OxideVersionCheck called when already new oxide patch detected"
                );

                Instance.FetchLatestOxideRustVersion(
                    (e, v) => {
                        if (e != null)
                        {
                            Instance.PluginLog(e.Message);
                            Instance.PluginLog("Scheduling check after 1 minute...");
                            Invoke(nameof(OxideVersionCheck), 60f);
                        }
                        else if (v > CurrentOxideRustVersion)
                        {
                            Instance.PluginLog(
                                "New Oxide.Rust version detected {0} -> {1}",
                                CurrentOxideRustVersion,
                                v
                            );

                            Instance.isNewOxideOut = true;
                        }
                        else
                        {
                            Instance.PluginLog(
                                $"Current Oxide.Rust version is up-to-date, scheduling check after {oxideVersionCheckInterval} seconds..."
                            );

                            Invoke(nameof(OxideVersionCheck), oxideVersionCheckInterval);
                        }
                    }
                );
            }

            void RestartCheck()
            {
                Debug.Assert(!IsRestarting, "Restart check while IsRestarting");

                if (Instance.IsRestartingNative)
                {
                    return; // since we have no observer on native restart routine, we do not pause invokes of this function, but simply interrupt it here
                    // might wanna think about a workaround to raise event when native restart has started/interrupted (Harmony patch probably)
                }

                if (Instance.isNewOxideOut)
                {
                    DoRestart(
                        DateTime.Now.AddSeconds(rtCountdownStart),
                        RestartReason.OxideUpdate,
                        null
                    );
                }
                else
                {
                    DateTime restartTime;

                    if (NeedsRestartOnTime(out restartTime))
                    {
                        CycleQueue();
                        DoRestart(restartTime, RestartReason.Timed, null);
                    }
                }
            }

            bool NeedsRestartOnTime(out DateTime restartTime)
            {
                if (restartQueue == null || restartQueue.Count == 0)
                {
                    restartTime = default(DateTime);

                    return false;
                }

                double diff;
                restartTime = FindNextRestartTime(out diff);

                if (diff <= rtCountdownStart)
                {
                    return true;
                }

                return false;
            }

            void CycleQueue() => restartQueue.Enqueue(restartQueue.Dequeue().AddDays(1));

            #region Component events

            void OnRestartInit(float secondsLeft, RestartReason reason, object initiator)
            {
                Instance.PluginLog(
                    "Server restart initiated in {0} seconds, reason: {1}, initiator: {2}",
                    secondsLeft,
                    reason,
                    initiator
                );

                if (Interface.CallHook(
                        "OnSmoothRestartInit",
                        secondsLeft,
                        reason,
                        initiator
                    ) ==
                    null)
                {
                    Instance.AnnounceRestartInit(secondsLeft, reason, initiator);
                }
            }

            void OnRestartTick(int secondsLeft)
            {
                Instance.PluginLog("Server restart in progress, {0} seconds left", secondsLeft);

                if (Interface.CallHook("OnSmoothRestartTick", secondsLeft) == null &&
                    !Instance.settings.DisableChatCountdown)
                {
                    // The code below is so harsh Im feeling embarassed with it, but it is a solution I came with at the moment
                    // which does not force me to rewrite the whole messaging system
                    //foreach (var player in Instance.players.Connected)
                    //{
                    //    var message = string.Format(
                    //        new IntTimeFormatter(),
                    //        Instance.GetMessage(player, M_ANNOUNCE_COUNTDOWN_TICK),
                    //        secondsLeft
                    //    );

                    //    Instance.MessageRaw(player, message);
                    //}

                    // I rewrote the messaging system :/
                    Instance.AnnounceWithCustomFormatter(
                        SmoothTimeFormatter.Instance,
                        M_ANNOUNCE_COUNTDOWN_TICK,
                        secondsLeft
                    );
                }
            }

            void OnRestartCancelled(object canceller)
            {
                Instance.PluginLog("Server restart was cancelled by {0}", canceller);

                Cleanup();

                if (Interface.CallHook("OnSmoothRestartCancelled", canceller) == null)
                {
                    Instance.Announce(M_ANNOUNCE_RESTART_CANCELLED);
                }
            }

            #endregion

            IEnumerator InitRestartRoutine(float totalSecondsLeft)
            {
                Debug.Assert(totalSecondsLeft > 0);

                while (totalSecondsLeft > 0)
                {
                    var nextCd = GetNextCountdownValue(Mathf.CeilToInt(totalSecondsLeft - 1f));

                    yield return new WaitForSecondsRealtime(totalSecondsLeft - nextCd);

                    OnRestartTick(nextCd);
                    totalSecondsLeft = nextCd;
                }

                Cleanup();
                RestartNow();
            }

            void Cleanup()
            {
                restartRoutine = null;
                CurrentRestartTime = null;
                CurrentRestartReason = null;
                CurrentRestartInitiator = null;
            }

            void RestartNow()
            {
                Instance.KickAll();
                Global.quit(null);
            }

            int GetNextCountdownValue(int secondsLeft)
            {
                Debug.Assert(secondsLeft > 0, "GetNextCountdownValue: Seconds left <= 0");

                if (secondsLeft > Instance.settings.RestartCountdownMax)
                {
                    return Instance.settings.RestartCountdownMax;
                }

                if (Instance.settings.UseCustomCountdownRefPts)
                {
                    Debug.Assert(
                        Instance.settings.CountdownRefPts.Length != 0,
                        "Empty countdown refpts array"
                    );

                    var next =
                        Instance.settings.CountdownRefPts.FirstOrDefault(p => p <= secondsLeft);

                    if (next < 0)
                    {
                        Debug.LogAssertion("Custom cdrefpt is < 0");
                        next = 0;
                    }

                    return next;
                }

                var divider = secondsLeft > 400
                                  ? 100
                                  : secondsLeft > 150
                                      ? 50
                                      : secondsLeft > 70
                                          ? 25
                                          : secondsLeft > 20
                                              ? 10
                                              : secondsLeft > 10
                                                  ? 5
                                                  : 1;

                var remainder = secondsLeft % divider;

                return secondsLeft - remainder;
            }
        }

        #endregion

        #region SmoothTimeFormatter

        class SmoothTimeFormatter : IFormatProvider, ICustomFormatter
        {
            public static SmoothTimeFormatter Instance = new SmoothTimeFormatter();

            static readonly Regex TemplateRegex = new Regex(
                @"<(?<tmpl>hr|min|sec)(?:#(?<pl>\d+)(?:\.(?<pr>\d+))?)?(?<mod>[!?])?(?:\+(?<append>.*?))?>",
                RegexOptions.Compiled
            );

            public string Format(string format, object arg, IFormatProvider formatProvider)
            {
                if (format != null && format.StartsWith("sfmt::"))
                {
                    format = format.Remove(0, 6);

                    if (string.IsNullOrWhiteSpace(format))
                    {
                        format = "<sec!>";
                    }

                    if (arg is TimeSpan)
                    {
                        return Format((TimeSpan) arg, format);
                    }

                    if (arg is int || arg is double || arg is float)
                    {
                        double nArg = Convert.ToDouble(arg);

                        return Format(TimeSpan.FromSeconds(nArg), format);
                    }
                }

                try
                {
                    if (arg is string)
                    {
                        return (string) arg;
                    }

                    if (arg is IFormattable)
                    {
                        return ((IFormattable) arg).ToString(format, CultureInfo.InvariantCulture);
                    }

                    throw new Exception();
                }
                catch
                {
                    throw new ArgumentException(
                        nameof(SmoothTimeFormatter) +
                        " does not support type " +
                        arg.GetType().Name,
                        nameof(arg)
                    );
                }
            }

            public object GetFormat(Type formatType)
            {
                return this;
            }

            static int GetDigits(int number)
            {
                if (number < 10)
                    return 1;

                if (number < 100)
                    return 2;

                if (number < 1000)
                    return 3;

                if (number < 10000)
                    return 4;

                if (number < 100000)
                    return 5;

                if (number < 1000000)
                    return 6;

                throw new ArgumentOutOfRangeException(
                    nameof(number),
                    "GetDigits does not support values >= 10e6"
                );
            }

            static int GetDigits(double number)
            {
                return BitConverter.GetBytes(
                    decimal.GetBits(new decimal(Math.Round(number, 6)))[3]
                )[2];
            }

            static string PadNumber(double value, int padding, int precision)
            {
                //string padding = "";
                int intPart = (int) value;
                int intPartDigits = GetDigits(intPart);
                int floatPartDigits = GetDigits(value);
                int floatPart = (int) (Math.Pow(10, floatPartDigits) * (value - intPart));

                //SmoothRestarter.Instance.Log("Int part of {0} is {1}, digits - {2}", value, intPart, intPartDigits);
                //SmoothRestarter.Instance.Log("Float part of {0} is {1}, digits - {2}", value, floatPart, floatPartDigits);

                StringBuilder builder = new StringBuilder();

                if (intPartDigits < padding)
                {
                    builder.Append('0', padding - intPartDigits);
                }

                builder.Append(intPart);

                if (precision != 0)
                {
                    builder.Append('.');
                    int fpi = builder.Length;
                    builder.Append(floatPart);

                    if (precision > floatPartDigits)
                    {
                        builder.Append('0', precision - floatPartDigits);
                    }
                    else if (precision < floatPartDigits)
                    {
                        var num = fpi + precision - 1;
                        builder.Remove(num + 1, builder.Length - num - 1);
                    }

                    //int floatPartIndex = builder.Length;

                    //if (precision > 0 && floatPartDigits < precision)
                    //{
                    //    builder.Append(floatPart);
                    //    builder.Append('0', precision - floatPartDigits);
                    //}
                    //else if (precision < 0 && floatPartDigits > (precision *= -1))
                    //{
                    //    builder.Append(floatPart);
                    //    int num = floatPartIndex + precision;
                    //    builder.Remove(num, builder.Length - num - 1);
                    //}
                }

                //SmoothRestarter.Instance.Log("Padded number {0} is {1}", value, builder.ToString());

                return builder.ToString();
            }

            static string Format(TimeSpan ts, string format)
            {
                var templates = Pool.GetList<Template>();
                templates.AddRange(OrderTemplates(GetTemplates(format)));

                var stringBuilder = new StringBuilder(format);

                for (var i = 0; i < templates.Count; i++)
                {
                    var tmpl = templates[i];

                    string replaceValue;

                    double value;

                    switch (tmpl.Name)
                    {
                        case "sec":
                            if (tmpl.Type == TemplateType.Total)
                                value = ts.TotalSeconds;
                            else
                                value = ts.Seconds;

                            break;

                        case "min":
                            if (tmpl.Type == TemplateType.Total)
                                value = ts.TotalMinutes;
                            else
                                value = ts.Minutes;

                            break;

                        default:
                            if (tmpl.Type == TemplateType.Total)
                                value = ts.TotalHours;
                            else
                                value = ts.Hours;

                            break;
                    }

                    if (tmpl.Type == TemplateType.Optional && value == 0)
                    {
                        replaceValue = string.Empty;
                    }
                    else
                    {
                        replaceValue = PadNumber(value, tmpl.PadLeft, tmpl.PadRight);

                        replaceValue += tmpl.Appender;
                    }

                    stringBuilder.Remove(tmpl.StartIndex, tmpl.Length);

                    stringBuilder.Insert(tmpl.StartIndex, replaceValue);

                    var lMut = replaceValue.Length - tmpl.Length;

                    for (var j = i + 1; j < templates.Count; j++)
                    {
                        var t = templates[j];
                        t.StartIndex += lMut;
                        //t.EndIndex += lMut;

                        templates[j] = t;
                    }
                }

                Pool.FreeList(ref templates);

                return stringBuilder.ToString();

                //var strSecondsTotal = ts.TotalSeconds.ToString("0");
                //var strMinutesTotal = ts.TotalMinutes.ToString("0.##");
                //var strHoursTotal = ts.TotalHours.ToString("0.###");

                //var strHours = ts.Hours.ToString("0");
                //var strMinutes = ts.Minutes.ToString("0");
                //var strSeconds = ts.Seconds.ToString("0");

                //var sb = new StringBuilder(format);

                //sb.Replace("<sec::t>", strSecondsTotal);
                //sb.Replace("<min::t>", strMinutesTotal);
                //sb.Replace("<hr::t>", strHoursTotal);

                //sb.Replace("<hr>", strHours);
                //sb.Replace("<min>", strMinutes);
                //sb.Replace("<sec>", strSeconds);

                //ReplaceOptionalTemplate(sb, "hr", ts.Hours > 0 ? strHours : string.Empty);
                //ReplaceOptionalTemplate(sb, "min", ts.Minutes > 0 ? strMinutes : string.Empty);
                //ReplaceOptionalTemplate(sb, "sec", ts.Seconds > 0 ? strSeconds : string.Empty);

                //return sb.ToString();
            }

            //static void ReplaceOptionalTemplate(StringBuilder builder, string template, string replaceValue)
            //{
            //    string templateFull = "<" + template + "?";
            //    string format = builder.ToString();

            //    int tIndex = 0;
            //    while ((tIndex = format.IndexOf(templateFull, tIndex)) != -1)
            //    {
            //        var cl = format.IndexOf('>', tIndex);
            //        if (cl == -1)
            //            cl = format.Length - 1;

            //        var length = cl - tIndex + 1;

            //        if (length > templateFull.Length + 1 && replaceValue.Length != 0)
            //        {
            //            replaceValue += format.Substring(tIndex + templateFull.Length, length - templateFull.Length - 1);
            //        }

            //        builder.Remove(tIndex, length);

            //        builder.Insert(tIndex, replaceValue);

            //        tIndex = cl + (replaceValue.Length - length) + 1;

            //        format = builder.ToString();
            //    }
            //}

            static IEnumerable<Template> GetTemplates(string format)
            {
                var matches = TemplateRegex.Matches(format);

                for (var i = 0; i < matches.Count; i++)
                {
                    var match = matches[i];

                    var template = new Template();

                    template.Name = match.Groups["tmpl"].Value;
                    template.Type = !match.Groups["mod"].Success
                                        ? TemplateType.Normal
                                        : match.Groups["mod"].Value == "!"
                                            ? TemplateType.Total
                                            : TemplateType.Optional;

                    if (match.Groups["pl"].Success)
                    {
                        template.PadLeft = int.Parse(match.Groups["pl"].Value);
                    }

                    if (match.Groups["pr"].Success)
                    {
                        template.PadRight = int.Parse(match.Groups["pr"].Value);
                    }

                    template.Appender = match.Groups["append"].Value;

                    template.StartIndex = match.Index;
                    template.Length = match.Length;

                    yield return template;
                }
            }

            static IEnumerable<Template> OrderTemplates(IEnumerable<Template> templates)
            {
                return templates.OrderBy(t => t.StartIndex);
            }

            enum TemplateType { Normal, Total, Optional }

            struct Template
            {
                public string       Name;
                public TemplateType Type;
                public int          PadLeft;
                public int          PadRight;
                public string       Appender;
                public int          StartIndex;
                public int          Length;
            }
        }

        #endregion

        #endregion

    }
}


// --- End of file: SmoothRestarter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sleeper-guard ---
// --- Original File Path: S/SleeperGuard/SleeperGuard.cs ---

﻿using System.Collections.Generic;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Sleeper Guard", "Wulf/lukespragg/Arainrr", "1.1.2")]
    [Description("Protects sleeping players from being hurt, killed, or looted")]
    public class SleeperGuard : RustPlugin
    {
        #region Fields

        [PluginReference] private readonly Plugin Friends, Clans;

        private const string permCanLoot = "sleeperguard.canloot";
        private const string permCanDamage = "sleeperguard.candamage";
        private const string permNPCIgnore = "sleeperguard.npcignore";
        private const string permNoTimeLimit = "sleeperguard.notimelimit";
        private const string permNoLootDelay = "sleeperguard.nolootdelay";
        private const string permNoDamageDelay = "sleeperguard.nodamagedelay";
        private const string permLootProtection = "sleeperguard.lootprotection";
        private const string permDamageProtection = "sleeperguard.damageprotection";

        private readonly Dictionary<ulong, float> noticeTimes = new Dictionary<ulong, float>();

        //Reduce boxing
        private static readonly object True = true, False = false, Null = null;

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            LoadData();
            permission.RegisterPermission(permCanLoot, this);
            permission.RegisterPermission(permCanDamage, this);
            permission.RegisterPermission(permNPCIgnore, this);
            permission.RegisterPermission(permNoTimeLimit, this);
            permission.RegisterPermission(permNoLootDelay, this);
            permission.RegisterPermission(permNoDamageDelay, this);
            permission.RegisterPermission(permLootProtection, this);
            permission.RegisterPermission(permDamageProtection, this);
            if (!configData.ignoreSleeper)
            {
                Unsubscribe(nameof(OnNpcTarget));
                Unsubscribe(nameof(CanBradleyApcTarget));
            }
        }

        private void OnServerInitialized()
        {
            if (storedData.lastSavedTimestamp > 0)
            {
                double unloadedPluginTime = TimeEx.currentTimestamp - storedData.lastSavedTimestamp;
                foreach (var entry in storedData.sleeperDatas)
                    entry.Value.ignoredTime += unloadedPluginTime;
            }
            foreach (var sleeper in BasePlayer.sleepingPlayerList)
                OnPlayerSleep(sleeper);
        }

        private void OnServerSave() => timer.Once(UnityEngine.Random.Range(0f, 60f), SaveData);

        private void Unload() => SaveData();

        private object OnNpcTarget(BaseEntity npc, BasePlayer player) => CanIgnoreSleeper(player) ? True : Null;

        private object CanBradleyApcTarget(BradleyAPC apc, BasePlayer player) => CanIgnoreSleeper(player) ? False : Null;

        private object OnEntityTakeDamage(BasePlayer target, HitInfo info)
        {
            if (target == null || !target.userID.IsSteamId()) return Null;
            if (target.IsSleeping())
            {
                BasePlayer attacker = info?.InitiatorPlayer;
                if (attacker != null && permission.UserHasPermission(attacker.UserIDString, permCanDamage)) return Null;
                if (permission.UserHasPermission(target.UserIDString, permDamageProtection))
                {
                    double timeleft;
                    if (CanGuardPlayer(target, false, out timeleft))
                    {
                        if (configData.notifyPlayer && attacker != null && CanNotice(attacker))
                        {
                            Print(attacker, Lang("NoDamage", attacker.UserIDString, timeleft.ToString("0.0")));
                        }
                        NullifyDamage(ref info);
                        return True;
                    }
                }
            }
            return Null;
        }

        private object CanLootPlayer(BasePlayer target, BasePlayer looter)
        {
            if (target == null || looter == null || !target.IsSleeping()) return Null;
            if (permission.UserHasPermission(looter.UserIDString, permCanLoot)) return Null;
            if (permission.UserHasPermission(target.UserIDString, permLootProtection))
            {
                double timeleft;
                if (CanGuardPlayer(target, true, out timeleft) && !AreFriends(target.userID, looter.userID))
                {
                    if (configData.notifyPlayer && CanNotice(looter))
                    {
                        Print(looter, Lang("NoLoot", looter.UserIDString, timeleft.ToString("0.0")));
                    }
                    return False;
                }
            }
            return Null;
        }

        private void OnPlayerSleep(BasePlayer player)
        {
            if (!storedData.sleeperDatas.ContainsKey(player.userID))
            {
                storedData.sleeperDatas.Add(player.userID, new StoredData.TimeData());
            }
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            storedData.sleeperDatas.Remove(player.userID);
        }

        #endregion Oxide Hooks

        #region Methods

        private bool CanGuardPlayer(BasePlayer sleeper, bool isLoot, out double timeleft)
        {
            StoredData.TimeData timeData;
            if (!storedData.sleeperDatas.TryGetValue(sleeper.userID, out timeData))
            {
                timeleft = 0;
                return false;
            }
            if (permission.UserHasPermission(sleeper.UserIDString, permNoTimeLimit))
            {
                timeleft = -1;
                return true;
            }
            double secondsSleeping = timeData.SecondsSleeping;
            if (isLoot)
            {
                if (configData.lootDelay <= 0 || secondsSleeping >= configData.lootDelay || permission.UserHasPermission(sleeper.UserIDString, permNoLootDelay))
                {
                    if (configData.lootGuardTime <= 0)
                    {
                        timeleft = -1;
                        return true;
                    }
                    timeleft = configData.lootGuardTime - secondsSleeping;
                    if (timeleft > 0)
                    {
                        return true;
                    }
                }
            }
            else
            {
                if (configData.damageDelay <= 0 || secondsSleeping >= configData.damageDelay || permission.UserHasPermission(sleeper.UserIDString, permNoDamageDelay))
                {
                    if (configData.damageGuardTime <= 0)
                    {
                        timeleft = -1;
                        return true;
                    }
                    timeleft = configData.damageGuardTime - secondsSleeping;
                    if (timeleft > 0)
                    {
                        return true;
                    }
                }
            }
            timeleft = 0;
            return false;
        }

        private bool CanIgnoreSleeper(BasePlayer player)
        {
            if (player == null || !player.userID.IsSteamId() || !player.IsSleeping()) return false;
            if (!permission.UserHasPermission(player.UserIDString, permNPCIgnore)) return false;
            double timeleft;
            return permission.UserHasPermission(player.UserIDString, permDamageProtection) && CanGuardPlayer(player, false, out timeleft);
        }

        private bool CanNotice(BasePlayer player)
        {
            float lastTime;
            if (!noticeTimes.TryGetValue(player.userID, out lastTime))
            {
                noticeTimes.Add(player.userID, Time.realtimeSinceStartup);
                return true;
            }
            if (Time.realtimeSinceStartup - lastTime >= configData.notifyInterval)
            {
                noticeTimes[player.userID] = Time.realtimeSinceStartup;
                return true;
            }
            return false;
        }

        #region AreFriends

        private bool AreFriends(ulong playerID, ulong friendID)
        {
            if (!playerID.IsSteamId()) return false;
            if (playerID == friendID) return true;
            if (configData.useTeams && SameTeam(playerID, friendID)) return true;
            if (configData.useFriends && HasFriend(playerID, friendID)) return true;
            if (configData.useClans && SameClan(playerID, friendID)) return true;
            return false;
        }

        private static bool SameTeam(ulong playerID, ulong friendID)
        {
            if (!RelationshipManager.TeamsEnabled()) return false;
            var playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(playerID);
            if (playerTeam == null) return false;
            var friendTeam = RelationshipManager.ServerInstance.FindPlayersTeam(friendID);
            if (friendTeam == null) return false;
            return playerTeam == friendTeam;
        }

        private bool HasFriend(ulong playerID, ulong friendID)
        {
            if (Friends == null) return false;
            return (bool)Friends.Call("HasFriend", playerID, friendID);
        }

        private bool SameClan(ulong playerID, ulong friendID)
        {
            if (Clans == null) return false;
            //Clans
            var isMember = Clans.Call("IsClanMember", playerID.ToString(), friendID.ToString());
            if (isMember != null) return (bool)isMember;
            //Rust:IO Clans
            var playerClan = Clans.Call("GetClanOf", playerID);
            if (playerClan == null) return false;
            var friendClan = Clans.Call("GetClanOf", friendID);
            if (friendClan == null) return false;
            return (string)playerClan == (string)friendClan;
        }

        #endregion AreFriends

        #endregion Methods

        #region Helpers

        private static void NullifyDamage(ref HitInfo info)
        {
            info.damageTypes = new DamageTypeList();
            info.HitMaterial = 0;
            info.PointStart = Vector3.zero;
        }

        #endregion Helpers

        #region ConfigurationFile

        private ConfigData configData;

        public class ConfigData
        {
            [JsonProperty(PropertyName = "Use Teams (Used For Loot)")]
            public bool useTeams = false;

            [JsonProperty(PropertyName = "Use Clans (Used For Loot)")]
            public bool useClans = true;

            [JsonProperty(PropertyName = "Use Friends (Used For Loot)")]
            public bool useFriends = true;

            [JsonProperty(PropertyName = "Damage delay (seconds) (0 to disable)")]
            public double damageDelay = 0;

            [JsonProperty(PropertyName = "Damage guard times (seconds) (0 to unlimit)")]
            public double damageGuardTime = 0;

            [JsonProperty(PropertyName = "Loot delay (seconds) (0 to disable)")]
            public double lootDelay = 0;

            [JsonProperty(PropertyName = "Loot guard times (seconds) (0 to unlimit)")]
            public double lootGuardTime = 0;

            [JsonProperty(PropertyName = "Notify player (true/false)")]
            public bool notifyPlayer = true;

            [JsonProperty(PropertyName = "Notification interval (seconds)")]
            public float notifyInterval = 5;

            [JsonProperty(PropertyName = "NPC ignores sleepers (Enabling it can cause server lag)")]
            public bool ignoreSleeper = false;

            [JsonProperty(PropertyName = "Chat Settings")]
            public ChatSettings chatS = new ChatSettings();

            public class ChatSettings
            {
                [JsonProperty(PropertyName = "Chat prefix")]
                public string prefix = "<color=#00FFFF>[SleeperGuard]</color>: ";

                [JsonProperty(PropertyName = "Chat steamID icon")]
                public ulong steamIDIcon = 0;
            }

            [JsonProperty(PropertyName = "Version")]
            public VersionNumber version;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
                else
                {
                    UpdateConfigValues();
                }
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
            configData.version = Version;
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        private void UpdateConfigValues()
        {
            if (configData.version < Version)
            {
                if (configData.version <= default(VersionNumber))
                {
                    string prefix, prefixColor;
                    if (GetConfigValue(out prefix, "Chat prefix") && GetConfigValue(out prefixColor, "Chat prefix color"))
                    {
                        configData.chatS.prefix = $"<color={prefixColor}>{prefix}</color>: ";
                    }
                }
                configData.version = Version;
            }
        }

        private bool GetConfigValue<T>(out T value, params string[] path)
        {
            var configValue = Config.Get(path);
            if (configValue == null)
            {
                value = default(T);
                return false;
            }
            value = Config.ConvertValue<T>(configValue);
            return true;
        }

        #endregion ConfigurationFile

        #region DataFile

        private StoredData storedData;

        private class StoredData
        {
            public double lastSavedTimestamp;
            public readonly Dictionary<ulong, TimeData> sleeperDatas = new Dictionary<ulong, TimeData>();

            public class TimeData
            {
                public double sleepStartTime;
                public double ignoredTime;
                [JsonIgnore] public double SecondsSleeping => TimeEx.currentTimestamp - sleepStartTime - ignoredTime;

                public TimeData()
                {
                    sleepStartTime = TimeEx.currentTimestamp;
                }
            }
        }

        private void LoadData()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                ClearData();
            }
        }

        private void ClearData()
        {
            storedData = new StoredData();
            SaveData();
        }

        private void SaveData()
        {
            storedData.lastSavedTimestamp = TimeEx.currentTimestamp;
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }

        private void OnNewSave(string filename) => ClearData();

        #endregion DataFile

        #region LanguageFile

        private void Print(BasePlayer player, string message) => Player.Message(player, message, configData.chatS.prefix, configData.chatS.steamIDIcon);

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoDamage"] = "You can't hurt this sleeping player. Protection time left: {0} seconds.",
                ["NoLoot"] = "You can't loot this sleeping player. Protection time left: {0} seconds.",
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoDamage"] = "您不能伤害这个睡眠玩家，剩余保护时间: {0} 秒",
                ["NoLoot"] = "您不能掠夺这个睡眠玩家，剩余保护时间: {0} 秒",
            }, this, "zh-CN");
        }

        #endregion LanguageFile
    }
}

// --- End of file: SleeperGuard.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/search-linked-accounts ---
// --- Original File Path: S/SearchLinkedAccounts/SearchLinkedAccounts.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Ext.Discord;
using Oxide.Ext.Discord.Attributes;
using Oxide.Ext.Discord.Builders;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Entities.Activities;
using Oxide.Ext.Discord.Entities.Gatway;
using Oxide.Ext.Discord.Entities.Gatway.Commands;
using Oxide.Ext.Discord.Entities.Gatway.Events;
using Oxide.Ext.Discord.Entities.Guilds;
using Oxide.Ext.Discord.Entities.Messages;
using Oxide.Ext.Discord.Entities.Messages.Embeds;
using Oxide.Ext.Discord.Entities.Permissions;
using Oxide.Ext.Discord.Libraries.Command;
using Oxide.Ext.Discord.Libraries.Linking;
using System;
using System.Collections.Generic;
using System.Linq;
namespace Oxide.Plugins
{
    [Info("Search Linked Accounts", "Farkas", "1.0.1")]
    [Description("Search DiscordAuth or DiscordCore linked accounts trough discord.")]
    public class SearchLinkedAccounts : CovalencePlugin
    {
        #region Global Variables
        [PluginReference] private Plugin DiscordAuth, DiscordCore;
        [DiscordClient] private DiscordClient _client;
        private DiscordGuild _guild;
        private DiscordRole _role;
        private readonly DiscordLink _link = GetLibrary<DiscordLink>();
        private readonly DiscordCommand _dcCommands = Interface.Oxide.GetLibrary<DiscordCommand>();
        #endregion

        #region Configuration
        private ConfigData _configData;
        class ConfigData
        {
            [JsonProperty(PropertyName = "Bot token")]
            public string Token = "";
            [JsonProperty(PropertyName = "Discord Guild ID (optional if the bot is in one guild)")]
            public Snowflake GuildId { get; set; }
            [JsonProperty(PropertyName = "Discord Role ID that can use the command")]
            public Snowflake RoleId { get; set; }
            [JsonProperty(PropertyName = "Discord Channel ID where the command can be used")]
            public Snowflake ChannelID { get; set; }
            [JsonProperty(PropertyName = "Set custom status and activity for the discord bot")]
            public bool EnableCustomStatus = true;
            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty(PropertyName = "Bot's activity type: (Game, Listening, Watching, Competing)")]
            public ActivityType ActivityType = ActivityType.Watching;
            [JsonProperty(PropertyName = "Bot's Status")]
            public string Status = "Linked Accounts";
            [JsonProperty(PropertyName = "Embed's color")]
            public string Color = "#FFFFFF";
        }
        protected override void LoadConfig()
        {
            try
            {
                base.LoadConfig();
                _configData = Config.ReadObject<ConfigData>();
                SaveConfig(_configData);
            }
            catch (Exception)
            {
                PrintError(Lang("ConfigIssue"));
                return;
            }
        }
        void Init()
        {
            if (string.IsNullOrEmpty(_configData.Token))
            {
                PrintError(Lang("NoToken"));
                return;
            }
        }

        protected override void LoadDefaultConfig()
        {
            Puts(Lang("NewConfig"));
            _configData = new ConfigData();
            SaveConfig(_configData);
        }

        void SaveConfig(ConfigData config)
        {
            Config.WriteObject(config, true);
        }
        #endregion

        #region Discord Bot Connection
        private void OnDiscordClientCreated()
        {
            DiscordSettings discordSettings = new DiscordSettings();
            discordSettings.ApiToken = _configData.Token;
            discordSettings.Intents = GatewayIntents.Guilds | GatewayIntents.GuildMembers | GatewayIntents.DirectMessages | GatewayIntents.GuildMessages;
            //remove below for debugging
            //discordSettings.LogLevel = DiscordLogLevel.Verbose;
            _client.Connect(discordSettings);
        }
        private void OnDiscordGatewayReady(GatewayReadyEvent ready)
        {
            if (ready.Guilds.Count == 0)
            {
                PrintError(Lang("InviteBot"));
                _client.Disconnect();
                return;
            }

            DiscordGuild guild = null;

            if (ready.Guilds.Count == 1 && !ready.Guilds.Values.Contains(ready.Guilds[_configData.GuildId]))
            {
                guild = ready.Guilds.Values.FirstOrDefault();
            }

            if (guild == null)
            {
                guild = ready.Guilds[_configData.GuildId];
            }

            if (guild == null)
            {

                _client.Disconnect();
                return;
            }

            _guild = guild;

            if (_configData.EnableCustomStatus)
            {
                _client.Bot.UpdateStatus(new UpdatePresenceCommand
                {
                    Activities = new List<DiscordActivity> { new DiscordActivity { Name = _configData.Status, Type = _configData.ActivityType } }
                });
            }

            if (string.IsNullOrEmpty(_configData.ChannelID.ToString()))
            {
                _dcCommands.AddGuildCommand("search", this, null, nameof(SearchCommand));
            }
            else
            {
                _dcCommands.AddGuildCommand("search", this, new List<Snowflake> { _configData.ChannelID }, nameof(SearchCommand));
            }

            Puts(Lang("Connected"));
        }
        void OnDiscordGuildMembersLoaded(DiscordGuild guild)
        {
            foreach (DiscordRole role in guild.Roles.Values)
            {
                if (role.Id == _configData.RoleId)
                {
                    _role = role;
                    break;
                }
            }

            if (_role == null)
            {
                PrintError(Lang("RoleNotFound"));
                _client.Disconnect();
            }
        }
        #endregion

        #region Commands
        void SearchCommand(DiscordMessage message, string cmd, string[] args)
        {
            if (!DiscordAuth && !DiscordCore)
            {
                message.Reply(_client, CreateEmbed(Lang("NoLinkerPluginTitle"), Lang("NoLinkerPluginContent"), "", "", _configData.Color));
                return;
            }
            if (!message.Member.HasRole(_role) || message.Author.Bot == true)
            {
                message.Reply(_client, CreateEmbed(Lang("NotAllowedTitle"), Lang("NotAllowedContent"), "", "", _configData.Color));
                return;
            }

            if (args.Length == 0)
            {
                message.Reply(_client, CreateEmbed(Lang("InvalidIDTitle"), Lang("InvalidIDContent"), "", "", _configData.Color));
                return;
            }

            if (message.Mentions.Count > 0)
            {
                FindSteam(message.Mentions.Keys.First().Id.ToString(), message);
            }
            else if (args[0].StartsWith("7656119") && args[0].Length == 17)
            {
                FindDiscord(args[0], message);
            }
            else if (!args[0].StartsWith("7656119") && args[0].Length > 15)
            {
                FindSteam(args[0], message);
            }
            else
            {
                message.Reply(_client, CreateEmbed(Lang("InvalidIDTitle"), Lang("InvalidIDContent"), "", "", _configData.Color));
            }
        }
        void FindSteam(string discordID, DiscordMessage message)
        {
            string steamID;
            steamID = _link.GetSteamId((Snowflake)discordID);

            if (!string.IsNullOrEmpty(steamID) && steamID != "0")
            {
                message.Reply(_client, CreateEmbed(Lang("ResultTitle"), "", steamID, discordID, _configData.Color));
            }
            else
            {
                message.Reply(_client, CreateEmbed(Lang("ResultTitle"), Lang("NoResult"), "", "", _configData.Color));
            }
        }
        void FindDiscord(string steamID, DiscordMessage message)
        {
            string discordID;
            discordID = _link.GetDiscordId(steamID);
            if (!string.IsNullOrEmpty(discordID) && discordID != "0")
            {
                message.Reply(_client, CreateEmbed(Lang("ResultTitle"), "", steamID, discordID, _configData.Color));
            }
            else
            {
                message.Reply(_client, CreateEmbed(Lang("ResultTitle"), Lang("NoResult"), "", "", _configData.Color));
            }
        }
        #endregion

        #region Helper Methods
        private string Lang(string key, string id = null) => lang.GetMessage(key, this, id);
        private DiscordEmbed CreateEmbed(string title, string message, string steamID, string discordID, string color)
        {
            DiscordEmbedBuilder Embed = new DiscordEmbedBuilder();
            Embed.AddTitle(title);
            if (!string.IsNullOrEmpty(message))
            {
                Embed.AddDescription(message);
            }
            if (!string.IsNullOrEmpty(steamID))
            {
                Embed.AddField("SteamID", steamID, true);
            }
            if (!string.IsNullOrEmpty(discordID))
            {
                Embed.AddField("DiscordID", discordID, true);
            }
            Embed.AddColor(color);
            return Embed.Build();
        }
        #endregion

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoLinkerPluginTitle"] = "Something went wrong..",
                ["NoLinkerPluginContent"] = "There is no linking system loaded at the moment.\nPlease install/load DiscordAuth or DiscordCore.",
                ["NotAllowedTitle"] = "Not allowed.",
                ["NotAllowedContent"] = "You are not allowed to use this command.",
                ["InvalidIDTitle"] = "The given ID is invalid.",
                ["InvalidIDContent"] = "Please use !search <steamID/discordID>",
                ["ResultTitle"] = "Linked Accounts",
                ["NoResult"] = "No users found.",
                ["Connected"] = "Discord bot connected.",
                ["NoToken"] = "Please set the discord bot token and reload the plugin to continue.",
                ["ConfigIssue"] = "Config file issue detected. Please delete file, or check syntax and fix.",
                ["NewConfig"] = "Creating new config file.",
                ["RoleNotFound"] = "The role with the given id can not be found. Please change the role in the config file."
            }, this, "en");
        }
        #endregion
    }
}

// --- End of file: SearchLinkedAccounts.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/small-shelves ---
// --- Original File Path: S/SmallShelves/SmallShelves.cs ---

﻿using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Small Shelves", "Wulf", "1.1.2")]
    [Description("Allow players to place smaller shelves")]
    public class SmallShelves : CovalencePlugin
    {
        #region Initialization

        private readonly List<string> activatedIDs = new List<string>();

        private const string permUse = "smallshelves.use";
        private const string prefab = "assets/scripts/entity/misc/visualstoragecontainer/visualshelvestest.prefab";

        private void Init()
        {
            permission.RegisterPermission(permUse, this);

            AddLocalizedCommand(nameof(CommandSmallShelves));
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandSmallShelves"] = "smallshelves",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["PlacementActivated"] = "Small shelf placement activated",
                ["PlacementDeactivated"] = "Small shelf placement de-activated"
            }, this);
        }

        #endregion Initialization

        #region Entity Handling

        private void SpawnSmallShelves(Vector3 pos, Quaternion rot, DecayEntity floor, ulong ownerId = 0uL)
        {
            BaseEntity entity = GameManager.server.CreateEntity(prefab, pos, rot);
            if (entity != null)
            {
                LootContainer lootContainer = entity.GetComponent<LootContainer>();
                lootContainer.destroyOnEmpty = false;
                lootContainer.initialLootSpawn = false;
                lootContainer.SetFlag(BaseEntity.Flags.Locked, true);
                entity.GetComponent<DecayEntity>().AttachToBuilding(floor);
                entity.gameObject.AddComponent<DestroyOnGroundMissing>();
                GroundWatch groundWatch = entity.gameObject.AddComponent<GroundWatch>();
                groundWatch.InvokeRepeating("OnPhysicsNeighbourChanged", 0f, 0.15f);
                entity.OwnerID = ownerId;
                entity.Spawn();
            }
        }

        private void OnEntitySpawned(BaseEntity entity)
        {
            if (entity.ShortPrefabName != "shelves" || !activatedIDs.Contains(entity.OwnerID.ToString()))
            {
                return;
            }

            NextFrame(() => entity.Kill());

            RaycastHit hit;
            Physics.Raycast(entity.transform.position + new Vector3(0, 0.1f, 0), Vector3.down, out hit, 3f);
            DecayEntity decayEntity = hit.GetEntity()?.GetComponent<DecayEntity>();
            if (decayEntity != null)
            {
                SpawnSmallShelves(entity.transform.position - (entity.transform.forward * 0.35f), entity.transform.rotation, decayEntity, entity.OwnerID);
            }
        }

        private object CanAcceptItem(ItemContainer container)
        {
            VisualStorageContainer storageContainer = container?.entityOwner?.GetComponent<VisualStorageContainer>();
            if (storageContainer != null)
            {
                return ItemContainer.CanAcceptResult.CannotAccept;
            }

            return null;
        }

        #endregion Entity Handling

        #region Commands

        private void CommandSmallShelves(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permUse))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (activatedIDs.Contains(player.Id))
            {
                activatedIDs.Remove(player.Id);
                Message(player, "PlacementDeactivated");
            }
            else
            {
                activatedIDs.Add(player.Id);
                Message(player, "PlacementActivated");
            }
        }

        #endregion Commands

        #region Helpers

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (message.Key.Equals(command))
                    {
                        if (!string.IsNullOrEmpty(message.Value))
                        {
                            AddCovalenceCommand(message.Value, command);
                        }
                    }
                }
            }
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string textOrLang, params object[] args)
        {
            if (player.IsConnected)
            {
                string message = GetLang(textOrLang, player.Id, args);
                player.Reply(message != textOrLang ? message : textOrLang);
            }
        }

        #endregion Helpers
    }
}


// --- End of file: SmallShelves.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/spawn-heli ---
// --- Original File Path: S/SpawnHeli/SpawnHeli.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Facepunch;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Spawn Heli", "SpooksAU", "3.1.1")]
    [Description("Allows players to spawn helicopters")]
    internal class SpawnHeli : CovalencePlugin
    {
        #region Fields

        private const string LegacyPluginName = "SpawnMini";
        private const string LegacyPermissionPrefix = "spawnmini.";

        private const string PermissionMinicopter = "minicopter";
        private const string PermissionScrapHeli = "scraptransport";
        private const string PermissionAttackHeli = "attackhelicopter";

        private const int SpawnPointLayerMask = Rust.Layers.Solid | Rust.Layers.Mask.Water;
        private const int SpaceCheckLayerMask = Rust.Layers.Solid;

        private const float VerticalSpawnOffset = 1;

        private SaveData _data;
        private Configuration _config;
        private readonly VehicleInfoManager _vehicleInfoManager;

        private readonly object True = true;
        private readonly object False = false;

        public SpawnHeli()
        {
            _vehicleInfoManager = new VehicleInfoManager(this);
        }

        #endregion

        #region Hooks

        private void Init()
        {
            _data = SaveData.Load();
            _config.Init();

            foreach (var perm in VehicleInfo.All.GetAllPermissions())
            {
                permission.RegisterPermission(perm, this);
            }

            _vehicleInfoManager.Init();

            if (!_vehicleInfoManager.AnyOwnerOnly)
            {
                Unsubscribe(nameof(CanMountEntity));
            }

            if (!_vehicleInfoManager.AnyDespawnOnDisconnect)
            {
                Unsubscribe(nameof(OnPlayerDisconnected));
                Unsubscribe(nameof(OnEntityDismounted));
            }

            if (!_vehicleInfoManager.AnyInstantTakeoff)
            {
                Unsubscribe(nameof(OnEngineStarted));
            }
        }

        private void OnServerInitialized()
        {
            if (plugins.PluginManager.GetPlugin(LegacyPluginName) != null)
            {
                LogWarning($"Detected conflicting plugin {LegacyPluginName}. Please remove that plugin to avoid issues.");
            }

            _vehicleInfoManager.OnServerInitialized();

            foreach (var networkable in BaseNetworkable.serverEntities)
            {
                var heli = networkable as PlayerHelicopter;
                if (heli == null)
                    continue;

                var vehicleInfo = _vehicleInfoManager.GetVehicleInfo(heli);
                if (vehicleInfo == null || !vehicleInfo.Data.HasVehicle(heli))
                    continue;

                SetupHeli(heli);

                if (heli.OwnerID != 0 && HasPermission(heli.OwnerID.ToString(), vehicleInfo.Permissions.UnlimitedFuel, VehicleInfo.All.UnlimitedFuel))
                {
                    EnableUnlimitedFuel(heli);
                }
            }

            _data.Clean();
        }

        private void Unload()
        {
            _data.SaveIfChanged();
        }

        private void OnServerSave()
        {
            _data.SaveIfChanged();
        }

        private void OnNewSave()
        {
            _data.Reset();
            _data.SaveIfChanged();
        }

        private void OnEntityKill(PlayerHelicopter heli)
        {
            var vehicleInfo = _vehicleInfoManager.GetVehicleInfo(heli);
            if (vehicleInfo == null)
                return;

            var ownerIdString = heli.OwnerID.ToString();
            var playerVehicle = vehicleInfo.Data.GetVehicle(ownerIdString);
            if (playerVehicle == null || playerVehicle != heli)
                return;

            _data.UnregisterVehicle(vehicleInfo, ownerIdString);

            var basePlayer = BasePlayer.FindByID(heli.OwnerID);
            if (basePlayer != null)
            {
                basePlayer.ChatMessage(GetMessage(basePlayer.UserIDString, vehicleInfo.Messages.Destroyed));
            }
        }

        private object OnEntityTakeDamage(PlayerHelicopter heli, HitInfo info)
        {
            if (heli == null || info == null || heli.OwnerID == 0)
                return null;

            if (!IsPlayerVehicle(heli, out var vehicleInfo))
                return null;

            if (info.damageTypes.Has(Rust.DamageType.Decay)
                && HasPermission(heli.OwnerID.ToString(), vehicleInfo.Permissions.NoDecay, VehicleInfo.All.NoDecay))
                return True;

            return null;
        }

        private object CanMountEntity(BasePlayer player, BaseVehicleMountPoint mountPoint)
        {
            if (player == null || mountPoint == null)
                return null;

            var heli = mountPoint.GetParentEntity() as PlayerHelicopter;
            if (heli == null
                || heli.OwnerID == 0
                || !IsPlayerVehicle(heli, out var vehicleInfo)
                || !vehicleInfo.Config.OnlyOwnerAndTeamCanMount)
                return null;

            // Vehicle owner is allowed to mount.
            if (heli.OwnerID == player.userID)
                return null;

            // Team members are allowed to mount.
            if (player.Team != null && player.Team.members.Contains(heli.OwnerID))
                return null;

            player.ChatMessage(GetMessage(player.UserIDString, LangEntry.ErrorCannotMount));
            return False;
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (player == null)
                return;

            if (_config.Minicopter.DespawnOnDisconnect)
            {
                var heli = _data.Minicopter.GetVehicle(player.UserIDString);
                if (heli != null)
                {
                    ScheduleDespawnVehicleIfUnmounted(heli);
                }
            }

            if (_config.ScrapTransportHelicopter.DespawnOnDisconnect)
            {
                var heli = _data.ScrapTransportHelicopter.GetVehicle(player.UserIDString);
                if (heli != null)
                {
                    ScheduleDespawnVehicleIfUnmounted(heli);
                }
            }

            if (_config.AttackHelicopter.DespawnOnDisconnect)
            {
                var heli = _data.AttackHelicopter.GetVehicle(player.UserIDString);
                if (heli != null)
                {
                    ScheduleDespawnVehicleIfUnmounted(heli);
                }
            }
        }

        private void ScheduleDespawnVehicleIfUnmounted(PlayerHelicopter heli)
        {
            NextTick(() =>
            {
                // Despawn vehicle when the owner disconnects.
                // If mounted, we will despawn it later when all players dismount.
                if (heli == null || heli.AnyMounted())
                    return;

                heli.Kill();
            });
        }

        private void OnEntityDismounted(BaseVehicleSeat seat)
        {
            if (seat == null)
                return;

            var heli = seat.GetParentEntity() as PlayerHelicopter;
            if (heli == null
                || !heli.AnyMounted()
                || !IsPlayerVehicle(heli, out var vehicleInfo)
                || !vehicleInfo.Config.DespawnOnDisconnect)
                return;

            // Despawn minicopter when fully dismounted, if the owner player has disconnected.
            var ownerPlayer = BasePlayer.FindByID(heli.OwnerID);
            if (ownerPlayer != null && ownerPlayer.IsConnected)
                return;

            heli.Kill();
        }

        private void CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if (container == null || !container.IsLocked())
                return;

            var heli = container.GetParentEntity() as PlayerHelicopter;
            if (heli == null || !IsPlayerVehicle(heli, out var vehicleInfo))
                return;

            if (!HasPermission(heli.OwnerID.ToString(), vehicleInfo.Permissions.UnlimitedFuel, VehicleInfo.All.UnlimitedFuel))
                return;

            player.ChatMessage(GetMessage(player.UserIDString, LangEntry.ErrorUnlimitedFuel));
        }

        private void OnEngineStarted(PlayerHelicopter heli, BasePlayer player)
        {
            if (!heli.engineController.IsStarting)
                return;

            if (!IsPlayerVehicle(heli, out var vehicleInfo))
                return;

            if (!vehicleInfo.Config.InstantTakeoff.Enabled)
                return;

            if (vehicleInfo.Config.InstantTakeoff.RequirePermission
                && !HasPermission(player, vehicleInfo.Permissions.InstantTakeoff, VehicleInfo.All.InstantTakeoff))
                return;

            heli.CancelInvoke(heli.engineController.FinishStartingEngine);
            heli.engineController.FinishStartingEngine();
        }

        #endregion

        #region Commands

        private void CommandSpawnMinicopter(IPlayer player, string cmd, string[] args)
        {
            SpawnCommandInternal(_vehicleInfoManager.Minicopter, player, cmd, args);
        }

        private void CommandSpawnScrapTransportHelicopter(IPlayer player, string cmd, string[] args)
        {
            SpawnCommandInternal(_vehicleInfoManager.ScrapTransportHelicopter, player, cmd, args);
        }

        private void CommandSpawnAttackHelicopter(IPlayer player, string cmd, string[] args)
        {
            SpawnCommandInternal(_vehicleInfoManager.AttackHelicopter, player, cmd, args);
        }

        private void SpawnCommandInternal(VehicleInfo vehicleInfo, IPlayer player, string command, string[] args)
        {
            if (vehicleInfo == null
                || !VerifyPlayer(player, out var basePlayer)
                || !VerifyPermission(player, vehicleInfo.Permissions.Spawn, VehicleInfo.All.Spawn))
                return;

            var heli = FindPlayerVehicle(vehicleInfo, basePlayer);
            if (heli != null)
            {
                if (vehicleInfo.Config.AutoFetch && HasPermission(player, vehicleInfo.Permissions.Fetch, VehicleInfo.All.Fetch))
                {
                    FetchVehicle(vehicleInfo, player, basePlayer, heli);
                }
                else
                {
                    player.Reply(GetMessage(player.Id, vehicleInfo.Messages.AlreadySpawned));
                }

                return;
            }

            if (_config.LimitPlayersToOneHelicopterType)
            {
                foreach (var otherVehicleInfo in _vehicleInfoManager.AllVehicles)
                {
                    if (otherVehicleInfo == vehicleInfo)
                        continue;

                    var otherVehicle = otherVehicleInfo.Data.GetVehicle(player.Id);
                    if (otherVehicle == null || otherVehicle.IsDestroyed)
                        continue;

                    if (!TryDespawnHeli(otherVehicleInfo, otherVehicle, basePlayer))
                    {
                        player.Reply(GetMessage(player.Id, LangEntry.ErrorConflictingHeli));
                        return;
                    }

                    otherVehicle.Kill();
                }
            }

            if (!VerifyOffCooldown(vehicleInfo, basePlayer, vehicleInfo.Config.SpawnCooldowns, vehicleInfo.Data.SpawnCooldowns)
                || !vehicleInfo.Config.CanSpawnBuildingBlocked && !VerifyNotBuildingBlocked(player, basePlayer)
                || SpawnWasBlocked(vehicleInfo, basePlayer)
                || !VerifyValidSpawnOrFetchPosition(vehicleInfo, basePlayer, out var position, out var rotation))
                return;

            heli = SpawnVehicle(vehicleInfo, basePlayer, position, rotation);
            if (heli == null)
                return;

            if (!HasPermission(basePlayer, vehicleInfo.Permissions.NoCooldown, VehicleInfo.All.NoCooldown))
            {
                _data.StartSpawnCooldown(vehicleInfo, basePlayer);
            }
        }

        private void CommandFetchMinicopter(IPlayer player, string cmd, string[] args)
        {
            FetchCommandInternal(_vehicleInfoManager.Minicopter, player, cmd, args);
        }

        private void CommandFetchScrapTransportHelicopter(IPlayer player, string cmd, string[] args)
        {
            FetchCommandInternal(_vehicleInfoManager.ScrapTransportHelicopter, player, cmd, args);
        }

        private void CommandFetchAttackHelicopter(IPlayer player, string cmd, string[] args)
        {
            FetchCommandInternal(_vehicleInfoManager.AttackHelicopter, player, cmd, args);
        }

        private void FetchCommandInternal(VehicleInfo vehicleInfo, IPlayer player, string command, string[] args)
        {
            if (vehicleInfo == null
                || !VerifyPlayer(player, out var basePlayer)
                || !VerifyPermission(player, vehicleInfo.Permissions.Fetch, VehicleInfo.All.Fetch)
                || !VerifyVehicleExists(player, basePlayer, vehicleInfo, out var heli))
                return;

            FetchVehicle(vehicleInfo, player, basePlayer, heli);
        }

        private void CommandDespawnMinicopter(IPlayer player, string cmd, string[] args)
        {
            DespawnCommandInternal(_vehicleInfoManager.Minicopter, player, cmd, args);
        }

        private void CommandDespawnScrapTransportHelicopter(IPlayer player, string cmd, string[] args)
        {
            DespawnCommandInternal(_vehicleInfoManager.ScrapTransportHelicopter, player, cmd, args);
        }

        private void CommandDespawnAttackHelicopter(IPlayer player, string cmd, string[] args)
        {
            DespawnCommandInternal(_vehicleInfoManager.AttackHelicopter, player, cmd, args);
        }

        private void DespawnCommandInternal(VehicleInfo vehicleInfo, IPlayer player, string command, string[] args)
        {
            if (vehicleInfo == null
                || !VerifyPlayer(player, out var basePlayer)
                || !VerifyPermission(player, vehicleInfo.Permissions.Despawn, VehicleInfo.All.Despawn)
                || !VerifyVehicleExists(player, basePlayer, vehicleInfo, out var heli))
                return;

            if (!vehicleInfo.Config.CanDespawnWhileOccupied && IsHeliOccupied(heli))
            {
                player.Reply(GetMessage(player.Id, LangEntry.ErrorHeliOccupied));
                return;
            }

            if (!VerifyVehicleWithinDistance(player, basePlayer, heli, vehicleInfo.Config.MaxDespawnDistance)
                || DespawnWasBlocked(vehicleInfo, basePlayer, heli))
                return;

            heli.Kill();
        }

        // Old command for backwards compatibility.
        [Command("spawnmini.give")]
        private void CommandGiveMinicopter(IPlayer player, string cmd, string[] args)
        {
            GiveCommandInternal(_vehicleInfoManager.Minicopter, player, cmd, args);
        }

        private void CommandGiveScrapTransportHelicopter(IPlayer player, string cmd, string[] args)
        {
            GiveCommandInternal(_vehicleInfoManager.ScrapTransportHelicopter, player, cmd, args);
        }

        private void CommandGiveAttackHelicopter(IPlayer player, string cmd, string[] args)
        {
            GiveCommandInternal(_vehicleInfoManager.AttackHelicopter, player, cmd, args);
        }

        private void GiveCommandInternal(VehicleInfo vehicleInfo, IPlayer player, string cmd, string[] args)
        {
            if (!player.IsServer)
                return;

            if (args.Length < 1)
            {
                PrintError($"Syntax: {cmd} <name or steamid>");
                return;
            }

            var recipientPlayer = BasePlayer.Find(args[0]);
            if (recipientPlayer == null)
            {
                PrintError($"{cmd}: No player found matching '{args[0]}'");
                return;
            }

            if (args.Length > 1)
            {
                if (args.Length < 4 ||
                    !float.TryParse(args[1], out var x) ||
                    !float.TryParse(args[2], out var y) ||
                    !float.TryParse(args[3], out var z))
                {
                    Puts($"Syntax: {cmd} <name or steamid> <x> <y> <z>");
                    return;
                }

                GiveVehicle(vehicleInfo, recipientPlayer, new Vector3(x, y, z));
                return;
            }

            GiveVehicle(vehicleInfo, recipientPlayer);
        }

        #endregion

        #region Helpers/Functions

        private static class StringUtils
        {
            public static string StripPrefix(string subject, string prefix)
            {
                return subject.StartsWith(prefix) ? subject[prefix.Length..] : subject;
            }

            public static string StripPrefixes(string subject, params string[] prefixes)
            {
                foreach (var prefix in prefixes)
                {
                    subject = StripPrefix(subject, prefix);
                }

                return subject;
            }
        }

        private static class NetworkUtils
        {
            public static void SendUpdateImmediateRecursive(BaseEntity entity)
            {
                entity.SendNetworkUpdateImmediate();

                foreach (var child in entity.children)
                {
                    SendUpdateImmediateRecursive(child);
                }
            }
        }

        private static class Ddraw
        {
            public static void Sphere(BasePlayer player, Vector3 origin, float radius, Color color, float duration) =>
                player.SendConsoleCommand("ddraw.sphere", duration, color, origin, radius);

            public static void Line(BasePlayer player, Vector3 origin, Vector3 target, Color color, float duration) =>
                player.SendConsoleCommand("ddraw.line", duration, color, origin, target);

            public static void Box(BasePlayer player, Vector3 center, Quaternion rotation, Vector3 extents, Color color, float duration)
            {
                var sphereRadius = 0.1f;

                var forwardUpperLeft = center + rotation * extents.WithX(-extents.x);
                var forwardUpperRight = center + rotation * extents;
                var forwardLowerLeft = center + rotation * extents.WithX(-extents.x).WithY(-extents.y);
                var forwardLowerRight = center + rotation * extents.WithY(-extents.y);

                var backLowerRight = center + rotation * -extents.WithX(-extents.x);
                var backLowerLeft = center + rotation * -extents;
                var backUpperRight = center + rotation * -extents.WithX(-extents.x).WithY(-extents.y);
                var backUpperLeft = center + rotation * -extents.WithY(-extents.y);

                Sphere(player, forwardUpperLeft, sphereRadius, color, duration);
                Sphere(player, forwardUpperRight, sphereRadius, color, duration);
                Sphere(player, forwardLowerLeft, sphereRadius, color, duration);
                Sphere(player, forwardLowerRight, sphereRadius, color, duration);

                Sphere(player, backLowerRight, sphereRadius, color, duration);
                Sphere(player, backLowerLeft, sphereRadius, color, duration);
                Sphere(player, backUpperRight, sphereRadius, color, duration);
                Sphere(player, backUpperLeft, sphereRadius, color, duration);

                Line(player, forwardUpperLeft, forwardUpperRight, color, duration);
                Line(player, forwardLowerLeft, forwardLowerRight, color, duration);
                Line(player, forwardUpperLeft, forwardLowerLeft, color, duration);
                Line(player, forwardUpperRight, forwardLowerRight, color, duration);

                Line(player, backUpperLeft, backUpperRight, color, duration);
                Line(player, backLowerLeft, backLowerRight, color, duration);
                Line(player, backUpperLeft, backLowerLeft, color, duration);
                Line(player, backUpperRight, backLowerRight, color, duration);

                Line(player, forwardUpperLeft, backUpperLeft, color, duration);
                Line(player, forwardLowerLeft, backLowerLeft, color, duration);
                Line(player, forwardUpperRight, backUpperRight, color, duration);
                Line(player, forwardLowerRight, backLowerRight, color, duration);
            }

            public static void Box(BasePlayer player, OBB obb, Color color, float duration)
            {
                Box(player, obb.position, obb.rotation, obb.extents, color, duration);
            }
        }

        public static void LogWarning(string message) => Interface.Oxide.LogWarning($"[Spawn Heli] {message}");
        public static void LogError(string message) => Interface.Oxide.LogError($"[Spawn Heli] {message}");

        private static bool VerifyPlayer(IPlayer player, out BasePlayer basePlayer)
        {
            if (player.IsServer)
            {
                basePlayer = null;
                return false;
            }

            basePlayer = player.Object as BasePlayer;
            return true;
        }

        private static void TryMountPlayer(BasePlayer player, PlayerHelicopter heli)
        {
            foreach (var mountPoint in heli.mountPoints)
            {
                if (mountPoint.isDriver)
                {
                    mountPoint.mountable.AttemptMount(player, doMountChecks: false);
                    break;
                }
            }
        }

        private bool HasPermission(string playerId, string perm1, string perm2 = null)
        {
            return permission.UserHasPermission(playerId, perm1)
                   || (perm2 != null && permission.UserHasPermission(playerId, perm2));
        }

        private bool HasPermission(BasePlayer player, string perm1, string perm2 = null)
        {
            return HasPermission(player.UserIDString, perm1, perm2);
        }

        private bool HasPermission(IPlayer player, string perm1, string perm2 = null)
        {
            return HasPermission(player.Id, perm1, perm2);
        }

        private bool VerifyPermission(IPlayer player, string perm1, string perm2 = null)
        {
            if (HasPermission(player, perm1, perm2))
                return true;

            player.Reply(GetMessage(player.Id, LangEntry.ErrorNoPermission));
            return false;
        }

        private bool VerifyVehicleExists(IPlayer player, BasePlayer basePlayer, VehicleInfo vehicleInfo, out PlayerHelicopter heli)
        {
            heli = FindPlayerVehicle(vehicleInfo, basePlayer);
            if (heli != null)
                return true;

            player.Reply(GetMessage(player.Id, vehicleInfo.Messages.NotFound));
            return false;
        }

        private bool VerifyVehicleWithinDistance(IPlayer player, BasePlayer basePlayer, PlayerHelicopter heli, float maxDistance)
        {
            if (maxDistance < 0 || Vector3.Distance(basePlayer.transform.position, heli.transform.position) < maxDistance)
                return true;

            player.Reply(GetMessage(player.Id, LangEntry.ErrorHeliDistance));
            return false;
        }

        private static bool CheckBox(OBB obb, int layerMask, BaseEntity ignoreEntity = null)
        {
            if (ignoreEntity == null)
                return Physics.CheckBox(obb.position, obb.extents, obb.rotation, layerMask, QueryTriggerInteraction.Ignore);

            var colliderList = Pool.GetList<Collider>();
            Vis.Colliders(obb, colliderList, layerMask, QueryTriggerInteraction.Ignore);
            var hitSomething = false;

            foreach (var collider in colliderList)
            {
                var hitEntity = collider.ToBaseEntity();
                if (hitEntity == ignoreEntity || hitEntity?.GetParentEntity() == ignoreEntity)
                    continue;

                hitSomething = true;
                break;
            }

            Pool.FreeList(ref colliderList);
            return hitSomething;
        }

        private bool VerifyValidSpawnOrFetchPosition(VehicleInfo vehicleInfo, BasePlayer player, out Vector3 position, out Quaternion rotation, PlayerHelicopter existingHeli = null)
        {
            position = Vector3.zero;
            rotation = Quaternion.identity;

            if (vehicleInfo.Config.FixedSpawnDistanceConfig.Enabled)
            {
                position = GetFixedPositionForPlayer(vehicleInfo, player);
                rotation = GetFixedRotationForPlayer(vehicleInfo, player);
            }
            else
            {
                if (!Physics.Raycast(player.eyes.HeadRay(), out var hit, Mathf.Infinity, SpawnPointLayerMask))
                {
                    player.ChatMessage(GetMessage(player.UserIDString, LangEntry.ErrorNoSpawnLocationFound));
                    return false;
                }

                if (hit.distance > vehicleInfo.Config.MaxSpawnDistance)
                {
                    player.ChatMessage(GetMessage(player.UserIDString, LangEntry.ErrorSpawnDistance));
                    return false;
                }

                position = hit.point + Vector3.up * VerticalSpawnOffset;
            }

            var mainExtents = vehicleInfo.Bounds.extents;
            var mainCenter = position + rotation * vehicleInfo.Bounds.center;
            var mainObb = new OBB(mainCenter, 2 * mainExtents, rotation);

            var playerObb = new OBB(
                mainCenter - new Vector3(0, mainExtents.y + VerticalSpawnOffset / 2f, 0),
                2 * mainExtents.WithY(VerticalSpawnOffset / 2f),
                rotation
            );

            var tailCenter = mainCenter + rotation * new Vector3(0, 0, -mainExtents.z - vehicleInfo.TailLength / 2);
            tailCenter.y = position.y + vehicleInfo.TailYOffset;
            var tailExtents = new Vector3(vehicleInfo.TailThickness, vehicleInfo.TailThickness, vehicleInfo.TailLength / 2);
            var tailObb = new OBB(tailCenter, 2 * tailExtents, rotation);

            if (_config.AdminDebugBounds && player.IsAdmin)
            {
                Ddraw.Box(player, mainObb, Color.magenta, 5f);
                Ddraw.Box(player, tailObb, Color.magenta, 5f);
                Ddraw.Box(player, playerObb, Color.cyan, 5f);
            }

            if (CheckBox(mainObb, SpaceCheckLayerMask, existingHeli)
                || CheckBox(tailObb, SpaceCheckLayerMask, existingHeli)
                || CheckBox(playerObb, Rust.Layers.Mask.Player_Server, player))
            {
                player.ChatMessage(GetMessage(player.UserIDString, LangEntry.InsufficientSpace));
                return false;
            }

            return true;
        }

        private bool VerifyOffCooldown(VehicleInfo vehicleInfo, BasePlayer player, CooldownConfig cooldownConfig, Dictionary<string, DateTime> cooldownMap)
        {
            if (!cooldownMap.TryGetValue(player.UserIDString, out var cooldownStart)
                || HasPermission(player.UserIDString, vehicleInfo.Permissions.NoCooldown))
                return true;

            var timeRemaining = CeilingTimeSpan(cooldownStart.AddSeconds(GetPlayerCooldownSeconds(cooldownConfig, player)) - DateTime.Now);
            if (timeRemaining.TotalSeconds <= 0)
            {
                _data.RemoveCooldown(cooldownMap, player);
                return true;
            }

            player.ChatMessage(GetMessage(player.UserIDString, LangEntry.ErrorOnCooldown, timeRemaining.ToString("g")));
            return false;
        }

        private bool VerifyNotBuildingBlocked(IPlayer player, BasePlayer basePlayer)
        {
            if (!basePlayer.IsBuildingBlocked())
                return true;

            player.Reply(GetMessage(basePlayer.UserIDString, LangEntry.ErrorBuildingBlocked));
            return false;
        }

        private static bool SpawnWasBlocked(VehicleInfo vehicleInfo, BasePlayer player)
        {
            return Interface.CallHook(vehicleInfo.Hooks.Spawn, player) is false;
        }

        private static bool FetchWasBlocked(VehicleInfo vehicleInfo, BasePlayer player, PlayerHelicopter heli)
        {
            return Interface.CallHook(vehicleInfo.Hooks.Fetch, player, heli) is false;
        }

        private static bool DespawnWasBlocked(VehicleInfo vehicleInfo, BasePlayer player, PlayerHelicopter heli)
        {
            return Interface.CallHook(vehicleInfo.Hooks.Despawn, player, heli) is false;
        }

        private static TimeSpan CeilingTimeSpan(TimeSpan timeSpan)
        {
            return new TimeSpan((long)Math.Ceiling(1.0 * timeSpan.Ticks / 10000000) * 10000000);
        }

        private static Vector3 GetFixedPositionForPlayer(VehicleInfo vehicleInfo, BasePlayer player)
        {
            var forward = player.eyes.BodyForward();
            forward.y = 0;
            return player.transform.position + forward.normalized * vehicleInfo.Config.FixedSpawnDistanceConfig.Distance + Vector3.up * VerticalSpawnOffset;
        }

        private static Quaternion GetFixedRotationForPlayer(VehicleInfo vehicleInfo, BasePlayer player)
        {
            return Quaternion.Euler(0, player.eyes.rotation.eulerAngles.y - vehicleInfo.Config.FixedSpawnDistanceConfig.RotationAngle, 0);
        }

        private static void SetupHeli(PlayerHelicopter heli)
        {
            UnityEngine.Object.Destroy(heli.GetComponent<MagnetLiftable>());
        }

        private static void EnableUnlimitedFuel(PlayerHelicopter heli)
        {
            if (heli.GetFuelSystem() is not EntityFuelSystem fuelSystem)
                return;

            fuelSystem.cachedHasFuel = true;
            fuelSystem.nextFuelCheckTime = float.MaxValue;
            fuelSystem.GetFuelContainer().SetFlag(BaseEntity.Flags.Locked, true);
        }

        private static bool AnyParentedPlayers(PlayerHelicopter heli)
        {
            foreach (var entity in heli.children)
            {
                if (entity is BasePlayer)
                    return true;
            }

            return false;
        }

        private static bool IsHeliOccupied(PlayerHelicopter heli)
        {
            return heli.AnyMounted() || AnyParentedPlayers(heli);
        }

        private static void UnparentPlayers(PlayerHelicopter heli)
        {
            var tempList = Pool.GetList<BasePlayer>();

            try
            {
                foreach (var entity in heli.children)
                {
                    var player = entity as BasePlayer;
                    if (player == null)
                        continue;

                    tempList.Add(player);
                }

                foreach (var player in tempList)
                {
                    player.SetParent(null, worldPositionStays: true);
                }
            }
            finally
            {
                Pool.FreeList(ref tempList);
            }
        }

        private bool IsPlayerVehicle(PlayerHelicopter heli, out VehicleInfo vehicleInfo)
        {
            vehicleInfo = _vehicleInfoManager.GetVehicleInfo(heli);
            return vehicleInfo != null && vehicleInfo.Data.HasVehicle(heli);
        }

        private PlayerHelicopter FindPlayerVehicle(VehicleInfo vehicleInfo, BasePlayer player)
        {
            if (!vehicleInfo.Data.Vehicles.TryGetValue(player.UserIDString, out var heliNetId))
                return null;

            var heli = BaseNetworkable.serverEntities.Find(new NetworkableId(heliNetId)) as PlayerHelicopter;
            if (heli == null)
            {
                _data.UnregisterVehicle(vehicleInfo, player.UserIDString);
            }

            return heli;
        }

        private bool ShouldAutoMount(VehicleInfo vehicleInfo, BasePlayer player)
        {
            var mountConfig = vehicleInfo.Config.AutoMount;
            if (!mountConfig.Enabled)
                return false;

            return !mountConfig.RequirePermission
                   || HasPermission(player, vehicleInfo.Permissions.AutoMount, VehicleInfo.All.AutoMount);
        }

        private void MaybeAutoMount(VehicleInfo vehicleInfo, BasePlayer player, PlayerHelicopter heli)
        {
            if (!ShouldAutoMount(vehicleInfo, player))
                return;

            TryMountPlayer(player, heli);
        }

        private void FetchVehicle(VehicleInfo vehicleInfo, IPlayer player, BasePlayer basePlayer, PlayerHelicopter heli)
        {
            var isOccupied = IsHeliOccupied(heli);
            if (isOccupied && (!vehicleInfo.Config.CanFetchWhileOccupied
                               || basePlayer.GetMountedVehicle() == heli
                               || basePlayer.GetParentEntity() == heli))
            {
                basePlayer.ChatMessage(GetMessage(basePlayer.UserIDString, LangEntry.ErrorHeliOccupied));
                return;
            }

            if (!VerifyVehicleWithinDistance(player, basePlayer, heli, vehicleInfo.Config.MaxFetchDistance)
                || !VerifyOffCooldown(vehicleInfo, basePlayer, vehicleInfo.Config.FetchCooldowns, vehicleInfo.Data.FetchCooldowns)
                || !vehicleInfo.Config.CanFetchBuildingBlocked && !VerifyNotBuildingBlocked(player, basePlayer)
                || FetchWasBlocked(vehicleInfo, basePlayer, heli)
                || !VerifyValidSpawnOrFetchPosition(vehicleInfo, basePlayer, out var position, out var rotation, heli))
                return;

            if (isOccupied)
            {
                foreach (var mountPoint in heli.mountPoints)
                {
                    mountPoint.mountable?.DismountAllPlayers();
                }
            }

            if (AnyParentedPlayers(heli))
            {
                UnparentPlayers(heli);
            }

            if (vehicleInfo.Config.RepairOnFetch && vehicleInfo.Config.SpawnHealth > 0)
            {
                heli.SetHealth(Math.Max(heli.Health(), vehicleInfo.Config.SpawnHealth));
            }

            // Terminate on client so it doesn't animate from the previous location, since that can hinder stealth.
            heli.TerminateOnClient(BaseNetworkable.DestroyMode.None);

            heli.rigidBody.velocity = Vector3.zero;
            heli.transform.SetPositionAndRotation(position, rotation);
            heli.rigidBody.WakeUp();
            heli.timeSinceLastPush = 0f;
            heli.UpdateNetworkGroup();
            NetworkUtils.SendUpdateImmediateRecursive(heli);

            if (!HasPermission(basePlayer, vehicleInfo.Permissions.NoCooldown, VehicleInfo.All.NoCooldown))
            {
                _data.StartFetchCooldown(vehicleInfo, basePlayer);
            }

            MaybeAutoMount(vehicleInfo, basePlayer, heli);
        }

        private PlayerHelicopter SpawnVehicle(VehicleInfo vehicleInfo, BasePlayer player, Vector3 position, Quaternion rotation, bool allowAutoMount = true)
        {
            var heli = GameManager.server.CreateEntity(vehicleInfo.PrefabPath, position, rotation) as PlayerHelicopter;
            if (heli == null)
                return null;

            heli.OwnerID = player.userID;
            if (vehicleInfo.Config.SpawnHealth > 0)
            {
                heli.startHealth = vehicleInfo.Config.SpawnHealth;
            }

            SetupHeli(heli);
            heli.Spawn();

            if (HasPermission(player, vehicleInfo.Permissions.UnlimitedFuel, VehicleInfo.All.UnlimitedFuel))
            {
                EnableUnlimitedFuel(heli);
            }
            else
            {
                AddInitialFuel(vehicleInfo, heli, player);
            }

            _data.RegisterVehicle(vehicleInfo, player.UserIDString, heli);
            if (allowAutoMount)
            {
                MaybeAutoMount(vehicleInfo, player, heli);
            }

            return heli;
        }

        private void GiveVehicle(VehicleInfo vehicleInfo, BasePlayer player, Vector3? customPosition = null)
        {
            // Note: The give command does not auto fetch, but that could be changed in the future.
            if (FindPlayerVehicle(vehicleInfo, player) != null)
            {
                player.ChatMessage(GetMessage(player.UserIDString, vehicleInfo.Messages.AlreadySpawned));
                return;
            }

            var position = customPosition ?? GetFixedPositionForPlayer(vehicleInfo, player);
            var rotation = customPosition.HasValue ? Quaternion.identity : GetFixedRotationForPlayer(vehicleInfo, player);
            SpawnVehicle(vehicleInfo, player, position, rotation, allowAutoMount: false);
        }

        private bool TryDespawnHeli(VehicleInfo vehicleInfo, PlayerHelicopter heli, BasePlayer basePlayer)
        {
            if (!_config.AutoDespawnOtherHelicopterTypes)
                return false;

            if (!vehicleInfo.Config.CanDespawnWhileOccupied && IsHeliOccupied(heli))
                return false;

            if (DespawnWasBlocked(vehicleInfo, basePlayer, heli))
                return false;

            return true;
        }

        private float GetPlayerCooldownSeconds(CooldownConfig cooldownConfig, BasePlayer player)
        {
            var profileList = cooldownConfig.CooldownProfiles;
            if (profileList != null)
            {
                for (var i = profileList.Length - 1; i >= 0; i--)
                {
                    var profile = profileList[i];
                    if (profile.Permission != null && HasPermission(player, profile.Permission))
                        return profile.CooldownSeconds;
                }
            }

            return cooldownConfig.DefaultCooldown;
        }

        private int GetPlayerAllowedFuel(VehicleInfo vehicleInfo, BasePlayer player)
        {
            var fuelConfig = vehicleInfo.Config.FuelConfig;
            var profileList = fuelConfig.FuelProfiles;
            if (profileList != null)
            {
                for (var i = profileList.Length - 1; i >= 0; i--)
                {
                    var profile = profileList[i];
                    if (profile.Permission != null && HasPermission(player, profile.Permission))
                        return profile.FuelAmount;
                }
            }

            return fuelConfig.DefaultFuelAmount;
        }

        private void AddInitialFuel(VehicleInfo vehicleInfo, PlayerHelicopter heli, BasePlayer player)
        {
            var fuelAmount = GetPlayerAllowedFuel(vehicleInfo, player);
            if (fuelAmount == 0)
                return;

            if (heli.GetFuelSystem() is not EntityFuelSystem fuelSystem)
                return;

            var fuelContainer = fuelSystem.GetFuelContainer();
            if (fuelAmount < 0)
            {
                // Value of -1 is documented to represent max stack size.
                fuelAmount = fuelContainer.allowedItem.stackable;
            }

            fuelContainer.inventory.AddItem(fuelContainer.allowedItem, fuelAmount);
        }

        #endregion

        #region Vehicle Info

        private class VehicleInfo
        {
            public static PermissionSet All = PermissionSet.ForVehicle("all");

            public class PermissionSet
            {
                public static PermissionSet ForVehicle(string vehicleName)
                {
                    return new PermissionSet
                    {
                        Spawn = BuildPermission(vehicleName, "spawn"),
                        Fetch = BuildPermission(vehicleName, "fetch"),
                        Despawn = BuildPermission(vehicleName, "despawn"),
                        UnlimitedFuel = BuildPermission(vehicleName, "unlimitedfuel"),
                        NoDecay = BuildPermission(vehicleName, "nodecay"),
                        NoCooldown = BuildPermission(vehicleName, "nocooldown"),
                        AutoMount = BuildPermission(vehicleName, "automount"),
                        InstantTakeoff = BuildPermission(vehicleName, "instanttakeoff"),
                    };
                }

                private static string BuildPermission(string vehicleName, string featureName)
                {
                    return $"{nameof(SpawnHeli)}.{vehicleName}.{featureName}".ToLower();
                }

                public string Spawn { get; private set; }
                public string Fetch { get; private set; }
                public string Despawn { get; private set; }
                public string UnlimitedFuel { get; private set; }
                public string NoDecay { get; private set; }
                public string NoCooldown { get; private set; }
                public string AutoMount { get; private set; }
                public string InstantTakeoff { get; private set; }

                private PermissionSet() {}

                public IEnumerable<string> GetAllPermissions()
                {
                    yield return Spawn;
                    yield return Fetch;
                    yield return Despawn;
                    yield return UnlimitedFuel;
                    yield return NoDecay;
                    yield return NoCooldown;
                    yield return AutoMount;
                    yield return InstantTakeoff;
                }
            }

            public class HookSet
            {
                public string Spawn;
                public string Fetch;
                public string Despawn;
            }

            public class MessageSet
            {
                public LangEntry Destroyed;
                public LangEntry AlreadySpawned;
                public LangEntry NotFound;
            }

            public string VehicleName { private get; set; }
            public string PrefabPath;
            public Bounds Bounds;
            public float TailLength;
            public float TailThickness;
            public float TailYOffset;
            public string GiveCommand  { get; private set; }
            public VehicleConfig Config;
            public VehicleData Data;
            public uint PrefabId { get; private set; }
            public PermissionSet Permissions;
            public HookSet Hooks;
            public MessageSet Messages;

            public void Init(SpawnHeli plugin)
            {
                GiveCommand = $"{nameof(SpawnHeli)}.{VehicleName}.give".ToLower();
                Permissions = PermissionSet.ForVehicle(VehicleName);

                foreach (var perm in Permissions.GetAllPermissions())
                {
                    plugin.permission.RegisterPermission(perm, plugin);
                }

                if (Config.FuelConfig.FuelProfiles != null)
                {
                    foreach (var profile in Config.FuelConfig.FuelProfiles)
                    {
                        if (profile.Permission != null)
                        {
                            plugin.permission.RegisterPermission(profile.Permission, plugin);
                        }
                    }
                }

                if (Config.SpawnCooldowns.CooldownProfiles != null)
                {
                    foreach (var profile in Config.SpawnCooldowns.CooldownProfiles)
                    {
                        if (profile.Permission != null)
                        {
                            plugin.permission.RegisterPermission(profile.Permission, plugin);
                        }
                    }
                }

                if (Config.FetchCooldowns.CooldownProfiles != null)
                {
                    foreach (var profile in Config.FetchCooldowns.CooldownProfiles)
                    {
                        if (profile.Permission != null)
                        {
                            plugin.permission.RegisterPermission(profile.Permission, plugin);
                        }
                    }
                }
            }

            public void OnServerInitialized()
            {
                PrefabId = GameManager.server.FindPrefab(PrefabPath)?.GetComponent<BaseEntity>()?.prefabID ?? 0;
            }
        }

        private class VehicleInfoManager
        {
            public VehicleInfo Minicopter { get; private set; }
            public VehicleInfo ScrapTransportHelicopter { get; private set; }
            public VehicleInfo AttackHelicopter { get; private set; }
            public VehicleInfo[] AllVehicles { get; private set; }

            private readonly SpawnHeli _plugin;
            private readonly Dictionary<uint, VehicleInfo> _prefabIdToVehicleInfo = new();

            public bool AnyOwnerOnly => AllVehicles.Any(vehicleInfo => vehicleInfo.Config.OnlyOwnerAndTeamCanMount);
            public bool AnyDespawnOnDisconnect => AllVehicles.Any(vehicleInfo => vehicleInfo.Config.DespawnOnDisconnect);
            public bool AnyInstantTakeoff => AllVehicles.Any(vehicleInfo => vehicleInfo.Config.InstantTakeoff.Enabled);

            private Configuration _config => _plugin._config;
            private SaveData _data => _plugin._data;

            public VehicleInfoManager(SpawnHeli plugin)
            {
                _plugin = plugin;
            }

            public void Init()
            {
                AllVehicles = new[]
                {
                    Minicopter = new VehicleInfo
                    {
                        VehicleName = PermissionMinicopter,
                        PrefabPath = "assets/content/vehicles/minicopter/minicopter.entity.prefab",
                        Config = _config.Minicopter,
                        Data = _data.Minicopter,
                        Hooks = new VehicleInfo.HookSet
                        {
                            Spawn = "OnMyMiniSpawn",
                            Fetch = "OnMyMiniFetch",
                            Despawn = "OnMyMiniDespawn",
                        },
                        Messages = new VehicleInfo.MessageSet
                        {
                            Destroyed = LangEntry.MiniDestroyed,
                            AlreadySpawned = LangEntry.ErrorMiniExists,
                            NotFound = LangEntry.ErrorMiniNotFound,
                        },
                        Bounds = new Bounds
                        {
                            center = new Vector3(0f, 1.11f, 0.5f),
                            extents = new Vector3(1.3f, 0.85f, 1.7f),
                        },
                        TailLength = 1.5f,
                        TailThickness = 0.35f,
                        TailYOffset = 1f,
                    },
                    ScrapTransportHelicopter = new VehicleInfo
                    {
                        VehicleName = PermissionScrapHeli,
                        PrefabPath = "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab",
                        Config = _config.ScrapTransportHelicopter,
                        Data = _data.ScrapTransportHelicopter,
                        Hooks = new VehicleInfo.HookSet
                        {
                            Spawn = "OnMyScrapHeliSpawn",
                            Fetch = "OnMyScrapHeliFetch",
                            Despawn = "OnMyScrapHeliDespawn",
                        },
                        Messages = new VehicleInfo.MessageSet
                        {
                            Destroyed = LangEntry.ScrapHeliDestroyed,
                            AlreadySpawned = LangEntry.ErrorScrapHeliExist,
                            NotFound = LangEntry.ErrorScrapHeliNotFound,
                        },
                        Bounds = new Bounds
                        {
                            center = new Vector3(0, 2.25f, 0.65f),
                            extents = new Vector3(2.2f, 2.25f, 4f),
                        },
                        TailLength = 4.7f,
                        TailThickness = 0.5f,
                        TailYOffset = 2.9f,
                    },
                    AttackHelicopter = new VehicleInfo
                    {
                        VehicleName = PermissionAttackHeli,
                        PrefabPath = "assets/content/vehicles/attackhelicopter/attackhelicopter.entity.prefab",
                        Config = _config.AttackHelicopter,
                        Data = _data.AttackHelicopter,
                        Hooks = new VehicleInfo.HookSet
                        {
                            Spawn = "OnMyAttackHeliSpawn",
                            Fetch = "OnMyAttackHeliFetch",
                            Despawn = "OnMyAttackHeliDespawn",
                        },
                        Messages = new VehicleInfo.MessageSet
                        {
                            Destroyed = LangEntry.AttackHeliDestroyed,
                            AlreadySpawned = LangEntry.ErrorAttackHeliExists,
                            NotFound = LangEntry.ErrorAttackHeliNotFound,
                        },
                        Bounds = new Bounds
                        {
                            center = new Vector3(0, 1.65f, 0f),
                            extents = new Vector3(1.3f, 1.65f, 1.9f),
                        },
                        TailLength = 4.8f,
                        TailThickness = 0.6f,
                        TailYOffset = 1.9f,
                    },
                };

                foreach (var vehicleInfo in AllVehicles)
                {
                    vehicleInfo.Init(_plugin);
                }

                _plugin.AddCovalenceCommand(Minicopter.Config.SpawnCommands, nameof(CommandSpawnMinicopter));
                _plugin.AddCovalenceCommand(Minicopter.Config.FetchCommands, nameof(CommandFetchMinicopter));
                _plugin.AddCovalenceCommand(Minicopter.Config.DespawnCommands, nameof(CommandDespawnMinicopter));
                _plugin.AddCovalenceCommand(Minicopter.GiveCommand, nameof(CommandGiveMinicopter));

                _plugin.AddCovalenceCommand(ScrapTransportHelicopter.Config.SpawnCommands, nameof(CommandSpawnScrapTransportHelicopter));
                _plugin.AddCovalenceCommand(ScrapTransportHelicopter.Config.FetchCommands, nameof(CommandFetchScrapTransportHelicopter));
                _plugin.AddCovalenceCommand(ScrapTransportHelicopter.Config.DespawnCommands, nameof(CommandDespawnScrapTransportHelicopter));
                _plugin.AddCovalenceCommand(ScrapTransportHelicopter.GiveCommand, nameof(CommandGiveScrapTransportHelicopter));

                _plugin.AddCovalenceCommand(AttackHelicopter.Config.SpawnCommands, nameof(CommandSpawnAttackHelicopter));
                _plugin.AddCovalenceCommand(AttackHelicopter.Config.FetchCommands, nameof(CommandFetchAttackHelicopter));
                _plugin.AddCovalenceCommand(AttackHelicopter.Config.DespawnCommands, nameof(CommandDespawnAttackHelicopter));
                _plugin.AddCovalenceCommand(AttackHelicopter.GiveCommand, nameof(CommandGiveAttackHelicopter));
            }

            public void OnServerInitialized()
            {
                foreach (var vehicleInfo in AllVehicles)
                {
                    vehicleInfo.OnServerInitialized();

                    if (vehicleInfo.PrefabId != 0)
                    {
                        _prefabIdToVehicleInfo[vehicleInfo.PrefabId] = vehicleInfo;
                    }
                    else
                    {
                        LogError($"Unable to determine Prefab ID for prefab: {vehicleInfo.PrefabPath}");
                    }
                }
            }

            public VehicleInfo GetVehicleInfo(BaseEntity entity)
            {
                return _prefabIdToVehicleInfo.TryGetValue(entity.prefabID, out var vehicleInfo)
                    ? vehicleInfo
                    : null;
            }
        }

        #endregion

        #region Data

        [JsonObject(MemberSerialization.OptIn)]
        private class LegacySaveData
        {
            private const string Filename = LegacyPluginName;

            public static LegacySaveData LoadIfExists()
            {
                return Interface.Oxide.DataFileSystem.ExistsDatafile(Filename)
                    ? Interface.Oxide.DataFileSystem.ReadObject<LegacySaveData>(Filename)
                    : null;
            }

            [JsonProperty("playerMini")]
            public Dictionary<string, ulong> playerMini = new();

            [JsonProperty("spawnCooldowns")]
            public Dictionary<string, DateTime> spawnCooldowns = new();

            [JsonProperty("cooldown")]
            private Dictionary<string, DateTime> deprecatedCooldown
            {
                set => spawnCooldowns = value;
            }

            [JsonProperty("fetchCooldowns")]
            public Dictionary<string, DateTime> fetchCooldowns = new();

            public void Delete()
            {
                Interface.Oxide.DataFileSystem.DeleteDataFile(Filename);
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class VehicleData
        {
            [JsonProperty("Vehicles")]
            public Dictionary<string, ulong> Vehicles = new();

            [JsonProperty("SpawnCooldowns")]
            public Dictionary<string, DateTime> SpawnCooldowns = new();

            [JsonProperty("FetchCooldowns")]
            public Dictionary<string, DateTime> FetchCooldowns = new();

            public PlayerHelicopter GetVehicle(string playerId)
            {
                return Vehicles.TryGetValue(playerId, out var netId)
                    ? BaseNetworkable.serverEntities.Find(new NetworkableId(netId)) as PlayerHelicopter
                    : null;
            }

            public bool HasVehicle(BaseEntity vehicle)
            {
                return Vehicles.ContainsValue(vehicle.net.ID.Value);
            }

            public bool RegisterVehicle(string playerId, ulong netId)
            {
                return Vehicles.TryAdd(playerId, netId);
            }

            public bool UnregisterVehicle(string playerId)
            {
                return Vehicles.Remove(playerId);
            }

            public void SetSpawnCooldown(string playerId, DateTime dateTime)
            {
                SpawnCooldowns[playerId] = dateTime;
            }

            public void SetFetchCooldown(string playerId, DateTime dateTime)
            {
                FetchCooldowns[playerId] = dateTime;
            }

            public bool Clean()
            {
                if (Vehicles.Count == 0)
                    return false;

                var changed = false;

                foreach (var entry in Vehicles.ToList())
                {
                    var entity = BaseNetworkable.serverEntities.Find(new NetworkableId(entry.Value)) as PlayerHelicopter;
                    if (entity != null)
                        continue;

                    Vehicles.Remove(entry.Key);
                    changed = true;
                }

                return changed;
            }

            public bool Reset()
            {
                var result = Vehicles.Count > 0 || SpawnCooldowns.Count > 0 || FetchCooldowns.Count > 0;
                Vehicles.Clear();
                SpawnCooldowns.Clear();
                FetchCooldowns.Clear();
                return result;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class SaveData
        {
            private const string Filename = nameof(SpawnHeli);

            public static SaveData Load()
            {
                var exists = Interface.Oxide.DataFileSystem.ExistsDatafile(Filename);
                var data = Interface.Oxide.DataFileSystem.ReadObject<SaveData>(Filename) ?? new SaveData();
                if (!exists)
                {
                    var legacyData = LegacySaveData.LoadIfExists();
                    if (legacyData != null)
                    {
                        data.Minicopter.Vehicles = legacyData.playerMini;
                        data.Minicopter.SpawnCooldowns = legacyData.spawnCooldowns;
                        data.Minicopter.FetchCooldowns = legacyData.fetchCooldowns;
                        data.SaveIfChanged();
                        legacyData.Delete();
                    }
                }

                return data;
            }

            private bool _dirty;

            [JsonProperty("Minicopter")]
            public VehicleData Minicopter = new();

            [JsonProperty("ScrapTransportHelicopter")]
            public VehicleData ScrapTransportHelicopter = new();

            [JsonProperty("AttackHelicopter")]
            public VehicleData AttackHelicopter = new();

            public void Clean()
            {
                _dirty |= Minicopter.Clean();
                _dirty |= ScrapTransportHelicopter.Clean();
                _dirty |= AttackHelicopter.Clean();
            }

            public void Reset()
            {
                _dirty |= Minicopter.Reset();
                _dirty |= ScrapTransportHelicopter.Reset();
                _dirty |= AttackHelicopter.Reset();
            }

            public void SaveIfChanged()
            {
                if (!_dirty)
                    return;

                Interface.Oxide.DataFileSystem.WriteObject(Filename, this);
                _dirty = false;
            }

            public void StartSpawnCooldown(VehicleInfo vehicleInfo, BasePlayer player)
            {
                vehicleInfo.Data.SetSpawnCooldown(player.UserIDString, DateTime.Now);
                _dirty = true;
            }

            public void StartFetchCooldown(VehicleInfo vehicleInfo, BasePlayer player)
            {
                vehicleInfo.Data.SetFetchCooldown(player.UserIDString, DateTime.Now);
                _dirty = true;
            }

            public void RegisterVehicle(VehicleInfo vehicleInfo, string playerId, PlayerHelicopter heli)
            {
                vehicleInfo.Data.RegisterVehicle(playerId, heli.net.ID.Value);
                _dirty = true;
            }

            public void UnregisterVehicle(VehicleInfo vehicleInfo, string playerId)
            {
                vehicleInfo.Data.UnregisterVehicle(playerId);
                _dirty = true;
            }

            public void RemoveCooldown(Dictionary<string, DateTime> cooldownMap, BasePlayer player)
            {
                cooldownMap.Remove(player.UserIDString);
                _dirty = true;
            }
        }

        #endregion

        #region Configuration

        [JsonObject(MemberSerialization.OptIn)]
        private class BasePermissionAmount
        {
            [JsonProperty("Permission suffix")]
            protected string PermissionSuffix;

            [JsonIgnore]
            public string Permission { get; protected set; }

            public void Init(string permissionInfix)
            {
                if (!string.IsNullOrWhiteSpace(PermissionSuffix))
                {
                    Permission = $"{nameof(SpawnHeli)}.{permissionInfix}.{PermissionSuffix}".ToLower();
                }
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class FuelProfile : BasePermissionAmount
        {
            [JsonProperty("Fuel amount")]
            public int FuelAmount;

            // Default constructor for JSON, necessary because there's another constructor.
            public FuelProfile() { }

            public FuelProfile(string permissionSuffix, int fuelAmount)
            {
                PermissionSuffix = permissionSuffix;
                FuelAmount = fuelAmount;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class FuelConfig
        {
            [JsonProperty("Default fuel amount")]
            public int DefaultFuelAmount;

            [JsonProperty("Fuel profiles requiring permission")]
            public FuelProfile[] FuelProfiles =
            {
                new("100", 100),
                new("500", 500),
                new("1000", 1000),
            };

            public void Init(string vehicleName)
            {
                if (FuelProfiles != null)
                {
                    foreach (var profile in FuelProfiles)
                    {
                        profile.Init($"{vehicleName}.fuel");
                    }
                }
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class CooldownProfile : BasePermissionAmount
        {
            [JsonProperty("Cooldown (seconds)")]
            public float CooldownSeconds;

            // Default constructor for JSON, necessary because there's another constructor.
            public CooldownProfile() { }

            public CooldownProfile(string permissionSuffix, float cooldownSeconds)
            {
                PermissionSuffix = permissionSuffix;
                CooldownSeconds = cooldownSeconds;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class CooldownConfig
        {
            [JsonProperty("Default cooldown (seconds)")]
            public float DefaultCooldown;

            [JsonProperty("Cooldown profiles requiring permission")]
            public CooldownProfile[] CooldownProfiles;

            public void Init(string vehicleName, string cooldownType)
            {
                if (CooldownProfiles != null)
                {
                    foreach (var profile in CooldownProfiles)
                    {
                        profile.Init($"{vehicleName}.cooldown.{cooldownType}");
                    }
                }
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class FixedSpawnDistanceConfig
        {
            [JsonProperty("Enabled")]
            public bool Enabled = true;

            [JsonProperty("Distance from player")]
            public float Distance = 3;

            [JsonProperty("Helicopter rotation angle")]
            public float RotationAngle = 90;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class AutoMountConfig
        {
            [JsonProperty("Enabled")]
            public bool Enabled;

            [JsonProperty("Require permission")]
            public bool RequirePermission;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class InstantTakeoffConfig
        {
            [JsonProperty("Enabled")]
            public bool Enabled;

            [JsonProperty("Require permission")]
            public bool RequirePermission;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class VehicleConfig
        {
            [JsonProperty("Spawn commands")]
            public string[] SpawnCommands;

            [JsonProperty("Fetch commands")]
            public string[] FetchCommands;

            [JsonProperty("Despawn commands")]
            public string[] DespawnCommands;

            [JsonProperty("Can despawn while occupied")]
            public bool CanDespawnWhileOccupied;

            [JsonProperty("Can fetch while occupied")]
            public bool CanFetchWhileOccupied;

            [JsonProperty("Can spawn while building blocked")]
            public bool CanSpawnBuildingBlocked;

            [JsonProperty("Can fetch while building blocked")]
            public bool CanFetchBuildingBlocked;

            [JsonProperty("Auto fetch")]
            public bool AutoFetch;

            [JsonProperty("Repair on fetch")]
            public bool RepairOnFetch;

            [JsonProperty("Max spawn distance")]
            public float MaxSpawnDistance = 5f;

            [JsonProperty("Max fetch distance")]
            public float MaxFetchDistance = -1;

            [JsonProperty("Max despawn distance")]
            public float MaxDespawnDistance = -1;

            [JsonProperty("Fixed spawn distance")]
            public FixedSpawnDistanceConfig FixedSpawnDistanceConfig = new();

            [JsonProperty("Auto mount")]
            public AutoMountConfig AutoMount = new();

            [JsonProperty("Instant takeoff")]
            public InstantTakeoffConfig InstantTakeoff = new();

            [JsonProperty("Only owner and team can mount")]
            public bool OnlyOwnerAndTeamCanMount;

            [JsonProperty("Spawn health")]
            public float SpawnHealth;

            [JsonProperty("Destroy on disconnect")]
            public bool DespawnOnDisconnect;

            [JsonProperty("Fuel")]
            public FuelConfig FuelConfig = new();

            [JsonProperty("Spawn cooldowns")]
            public CooldownConfig SpawnCooldowns = new()
            {
                DefaultCooldown = 3600f,
                CooldownProfiles = new[]
                {
                    new CooldownProfile("1hr", 3600),
                    new CooldownProfile("10m", 600),
                    new CooldownProfile("10s", 10),
                },
            };

            [JsonProperty("Fetch cooldowns")]
            public CooldownConfig FetchCooldowns = new()
            {
                DefaultCooldown = 10f,
                CooldownProfiles = new[]
                {
                    new CooldownProfile("1hr", 3600),
                    new CooldownProfile("10m", 600),
                    new CooldownProfile("10s", 10),
                },
            };

            public void Init(string vehicleName)
            {
                FuelConfig?.Init(vehicleName);
                SpawnCooldowns?.Init(vehicleName, "spawn");
                FetchCooldowns?.Init(vehicleName, "fetch");
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : SerializableConfiguration
        {
            [JsonProperty("Admin debug bounds", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool AdminDebugBounds;

            [JsonProperty("Limit players to one helicopter type at a time")]
            public bool LimitPlayersToOneHelicopterType;

            [JsonProperty("Try to auto despawn other helicopter types")]
            public bool AutoDespawnOtherHelicopterTypes;

            [JsonProperty("Minicopter")]
            public VehicleConfig Minicopter = new()
            {
                SpawnCommands = new[] { "mymini" },
                FetchCommands = new[] { "fmini" },
                DespawnCommands = new[] { "nomini" },
                SpawnHealth = 750,
            };

            [JsonProperty("ScrapTransportHelicopter")]
            public VehicleConfig ScrapTransportHelicopter = new()
            {
                SpawnCommands = new[] { "myheli" },
                FetchCommands = new[] { "fheli" },
                DespawnCommands = new[] { "noheli" },
                SpawnHealth = 1000,
            };

            [JsonProperty("AttackHelicopter")]
            public VehicleConfig AttackHelicopter = new()
            {
                SpawnCommands = new[] { "myattack" },
                FetchCommands = new[] { "fattack" },
                DespawnCommands = new[] { "noattack" },
                SpawnHealth = 850,
            };

            public bool Migrate()
            {
                var changed = false;

                if (DeprecatedCanDespawnWhileOccupied)
                {
                    Minicopter.CanDespawnWhileOccupied = DeprecatedCanDespawnWhileOccupied;
                    DeprecatedCanDespawnWhileOccupied = false;
                    changed = true;
                }

                if (DeprecatedCanFetchWhileOccupied)
                {
                    Minicopter.CanFetchWhileOccupied = DeprecatedCanFetchWhileOccupied;
                    DeprecatedCanFetchWhileOccupied = false;
                    changed = true;
                }

                if (DeprecatedCanSpawnBuildingBlocked)
                {
                    Minicopter.CanSpawnBuildingBlocked = DeprecatedCanSpawnBuildingBlocked;
                    DeprecatedCanSpawnBuildingBlocked = DeprecatedCanFetchWhileOccupied;
                    changed = true;
                }

                if (!DeprecatedCanFetchBuildingBlocked)
                {
                    Minicopter.CanFetchBuildingBlocked = DeprecatedCanFetchBuildingBlocked;
                    DeprecatedCanFetchBuildingBlocked = true;
                    changed = true;
                }

                if (DeprecatedAutoFetch)
                {
                    Minicopter.AutoFetch = DeprecatedAutoFetch;
                    DeprecatedAutoFetch = false;
                    changed = true;
                }

                if (DeprecatedRepairOnFetch)
                {
                    Minicopter.RepairOnFetch = DeprecatedRepairOnFetch;
                    DeprecatedRepairOnFetch = false;
                    changed = true;
                }

                if (DeprecatedFuelAmount != 0)
                {
                    Minicopter.FuelConfig.DefaultFuelAmount = DeprecatedFuelAmount;
                    DeprecatedFuelAmount = 0;
                    changed = true;
                }

                if (DeprecatedFuelAmountsRequiringPermission != null)
                {
                    Minicopter.FuelConfig.FuelProfiles = DeprecatedFuelAmountsRequiringPermission
                        .Select(amount => new FuelProfile(amount.ToString(), amount))
                        .ToArray();

                    DeprecatedFuelAmountsRequiringPermission = null;
                    changed = true;
                }

                if (DeprecatedNoMiniDistance != 0)
                {
                    Minicopter.MaxDespawnDistance = DeprecatedNoMiniDistance;
                    Minicopter.MaxFetchDistance = DeprecatedNoMiniDistance;
                    DeprecatedNoMiniDistance = 0;
                    changed = true;
                }

                if (DeprecatedMaxSpawnDistance != 0)
                {
                    Minicopter.MaxSpawnDistance = DeprecatedMaxSpawnDistance;
                    DeprecatedMaxSpawnDistance = 0;
                    changed = true;
                }

                if (!DeprecatedUseFixedSpawnDistance)
                {
                    Minicopter.FixedSpawnDistanceConfig.Enabled = false;
                    DeprecatedUseFixedSpawnDistance = true;
                    changed = true;
                }

                if (DeprecatedFixedSpawnDistance != 0)
                {
                    Minicopter.FixedSpawnDistanceConfig.Distance = DeprecatedFixedSpawnDistance;
                    DeprecatedFixedSpawnDistance = 0;
                    changed = true;
                }

                if (DeprecatedFixedSpawnRotationAngle != 0)
                {
                    Minicopter.FixedSpawnDistanceConfig.RotationAngle = DeprecatedFixedSpawnRotationAngle;
                    DeprecatedFixedSpawnRotationAngle = 0;
                    changed = true;
                }

                if (DeprecatedOwnerOnly)
                {
                    Minicopter.OnlyOwnerAndTeamCanMount = DeprecatedOwnerOnly;
                    DeprecatedOwnerOnly = false;
                    changed = true;
                }

                if (DeprecatedDefaultSpawnCooldown != 0)
                {
                    Minicopter.SpawnCooldowns.DefaultCooldown = DeprecatedDefaultSpawnCooldown;
                    DeprecatedDefaultSpawnCooldown = 0;
                    changed = true;
                }

                if (DeprecatedSpawnPermissionCooldowns != null)
                {
                    Minicopter.SpawnCooldowns.CooldownProfiles = DeprecatedSpawnPermissionCooldowns
                        .Select(entry => new CooldownProfile(StringUtils.StripPrefixes(entry.Key, LegacyPermissionPrefix), entry.Value))
                        .ToArray();

                    DeprecatedSpawnPermissionCooldowns = null;
                    changed = true;
                }

                if (DeprecatedDefaultFetchCooldown != 0)
                {
                    Minicopter.FetchCooldowns.DefaultCooldown = DeprecatedDefaultFetchCooldown;
                    DeprecatedDefaultFetchCooldown = 0;
                    changed = true;
                }

                if (DeprecatedFetchPermissionCooldowns != null)
                {
                    Minicopter.FetchCooldowns.CooldownProfiles = DeprecatedFetchPermissionCooldowns
                        .Select(entry => new CooldownProfile(StringUtils.StripPrefixes(entry.Key, LegacyPermissionPrefix, "fetch."), entry.Value))
                        .ToArray();

                    DeprecatedFetchPermissionCooldowns = null;
                    changed = true;
                }

                if (DeprecatedSpawnHealth != 0)
                {
                    Minicopter.SpawnHealth = DeprecatedSpawnHealth;
                    DeprecatedSpawnHealth = 0;
                    changed = true;
                }

                if (DeprecatedDespawnOnDisconnect)
                {
                    Minicopter.DespawnOnDisconnect = DeprecatedDespawnOnDisconnect;
                    DeprecatedDespawnOnDisconnect = false;
                    changed = true;
                }

                return changed;
            }

            [JsonProperty("CanDespawnWhileOccupied", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private bool DeprecatedCanDespawnWhileOccupied;

            [JsonProperty("CanFetchWhileOccupied", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private bool DeprecatedCanFetchWhileOccupied;

            [JsonProperty("CanSpawnBuildingBlocked", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private bool DeprecatedCanSpawnBuildingBlocked;

            [JsonProperty("CanFetchBuildingBlocked", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(true)]
            private bool DeprecatedCanFetchBuildingBlocked = true;

            [JsonProperty("AutoFetch", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private bool DeprecatedAutoFetch;

            [JsonProperty("RepairOnFetch", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private bool DeprecatedRepairOnFetch;

            [JsonProperty("FuelAmount", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private int DeprecatedFuelAmount;

            [JsonProperty("FuelAmountsRequiringPermission", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private int[] DeprecatedFuelAmountsRequiringPermission;

            [JsonProperty("MaxNoMiniDistance", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private float DeprecatedNoMiniDistance;

            [JsonProperty("MaxSpawnDistance", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private float DeprecatedMaxSpawnDistance;

            [JsonProperty("UseFixedSpawnDistance", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(true)]
            private bool DeprecatedUseFixedSpawnDistance = true;

            [JsonProperty("FixedSpawnDistance", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private float DeprecatedFixedSpawnDistance;

            [JsonProperty("FixedSpawnRotationAngle", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private float DeprecatedFixedSpawnRotationAngle;

            [JsonProperty("OwnerAndTeamCanMount", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private bool DeprecatedOwnerOnly;

            [JsonProperty("DefaultSpawnCooldown", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private float DeprecatedDefaultSpawnCooldown;

            [JsonProperty("PermissionSpawnCooldowns", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private Dictionary<string, float> DeprecatedSpawnPermissionCooldowns;

            [JsonProperty("DefaultFetchCooldown", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private float DeprecatedDefaultFetchCooldown;

            [JsonProperty("PermissionFetchCooldowns", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private Dictionary<string, float> DeprecatedFetchPermissionCooldowns;

            [JsonProperty("SpawnHealth", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private float DeprecatedSpawnHealth;

            [JsonProperty("DestroyOnDisconnect", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private bool DeprecatedDespawnOnDisconnect;

            public void Init()
            {
                Minicopter.Init(PermissionMinicopter);
                ScrapTransportHelicopter.Init(PermissionScrapHeli);
                AttackHelicopter.Init(PermissionAttackHeli);
            }
        }

        private Configuration GetDefaultConfig() => new();

        #region Configuration Helpers

        internal class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        internal static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;
                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        // Don't update nested keys since the cooldown tiers might be customized
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                    throw new JsonException();

                if (MaybeUpdateConfig(_config) | _config.Migrate())
                {
                    PrintWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                PrintError(e.Message);
                PrintWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Puts($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion

        #region Localization

        private class LangEntry
        {
            public enum Lang
            {
                en,
            }

            public static readonly List<LangEntry> AllLangEntries = new();

            public static readonly LangEntry ErrorNoPermission = new("error_no_permission", new Dictionary<Lang, string>
            {
                [Lang.en] = "You do not have permission to use this command.",
            });
            public static readonly LangEntry ErrorBuildingBlocked = new("error_building_blocked", new Dictionary<Lang, string>
            {
                [Lang.en] = "Cannot do that while building blocked.",
            });
            public static readonly LangEntry ErrorOnCooldown = new("error_on_cooldown", new Dictionary<Lang, string>
            {
                [Lang.en] = "You have <color=red>{0}</color> until your cooldown ends.",
            });
            public static readonly LangEntry InsufficientSpace = new("error_insufficient_space", new Dictionary<Lang, string>
            {
                [Lang.en] = "Not enough space.",
            });
            public static readonly LangEntry ErrorConflictingHeli = new("error_conflicting_heli", new Dictionary<Lang, string>
            {
                [Lang.en] = "You must first destroy your other helicopter(s) before you can spawn a new one.",
            });

            public static readonly LangEntry ErrorSpawnDistance = new("error_spawn_distance", new Dictionary<Lang, string>
            {
                [Lang.en] = "You cannot spawn the helicopter that far away.",
            });
            public static readonly LangEntry ErrorNoSpawnLocationFound = new("error_spawn_location", new Dictionary<Lang, string>
            {
                [Lang.en] = "No suitable spawn location found.",
            });
            public static readonly LangEntry ErrorHeliOccupied = new("error_heli_occupied", new Dictionary<Lang, string>
            {
                [Lang.en] = "The helicopter is currently occupied.",
            });
            public static readonly LangEntry ErrorHeliDistance = new("error_heli_distance", new Dictionary<Lang, string>
            {
                [Lang.en] = "The helicopter is too far away.",
            });
            public static readonly LangEntry ErrorCannotMount = new("error_cannot_mount", new Dictionary<Lang, string>
            {
                [Lang.en] = "You are not the owner of this helicopter or in the owner's team.",
            });
            public static readonly LangEntry ErrorUnlimitedFuel = new("error_unlimited_fuel", new Dictionary<Lang, string>
            {
                [Lang.en] = "That helicopter doesn't need fuel.",
            });

            public static readonly LangEntry MiniDestroyed = new("info_mini_destroyed", new Dictionary<Lang, string>
            {
                [Lang.en] = "Your Minicopter has been destroyed.",
            });
            public static readonly LangEntry ScrapHeliDestroyed = new("info_scrap_heli_destroyed", new Dictionary<Lang, string>
            {
                [Lang.en] = "Your Scrap Heli has been destroyed.",
            });
            public static readonly LangEntry AttackHeliDestroyed = new("info_attack_heli_destroyed", new Dictionary<Lang, string>
            {
                [Lang.en] = "Your Attack Heli has been destroyed.",
            });

            public static readonly LangEntry ErrorMiniExists = new("error_mini_exists", new Dictionary<Lang, string>
            {
                [Lang.en] = "You already have a Minicopter.",
            });
            public static readonly LangEntry ErrorScrapHeliExist = new("error_scrap_heli_exists", new Dictionary<Lang, string>
            {
                [Lang.en] = "You already have a Scrap Heli.",
            });
            public static readonly LangEntry ErrorAttackHeliExists = new("error_attack_heli_exists", new Dictionary<Lang, string>
            {
                [Lang.en] = "You already have an Attack Heli.",
            });

            public static readonly LangEntry ErrorMiniNotFound = new("error_mini_not_found", new Dictionary<Lang, string>
            {
                [Lang.en] = "You do not have a Minicopter.",
            });
            public static readonly LangEntry ErrorScrapHeliNotFound = new("error_scrap_heli_not_found", new Dictionary<Lang, string>
            {
                [Lang.en] = "You do not have a Scrap Heli.",
            });
            public static readonly LangEntry ErrorAttackHeliNotFound = new("error_attack_heli_not_found", new Dictionary<Lang, string>
            {
                [Lang.en] = "You do not have an Attack Heli.",
            });

            public readonly string Name;
            public readonly Dictionary<Lang, string> PhrasesByLanguage;

            private LangEntry(string name, Dictionary<Lang, string> phrasesByLanguage)
            {
                Name = name;
                PhrasesByLanguage = phrasesByLanguage;

                AllLangEntries.Add(this);
            }
        }

        private string GetMessage(string playerId, LangEntry langEntry)
        {
            return lang.GetMessage(langEntry.Name, this, playerId);
        }

        private string GetMessage(string playerId, LangEntry langEntry, object arg1)
        {
            return string.Format(GetMessage(playerId, langEntry), arg1);
        }

        protected override void LoadDefaultMessages()
        {
            var langKeysByLanguage = new Dictionary<string, Dictionary<string, string>>();

            foreach (var langEntry in LangEntry.AllLangEntries)
            {
                foreach (var phraseEntry in langEntry.PhrasesByLanguage)
                {
                    var langName = phraseEntry.Key.ToString();
                    if (!langKeysByLanguage.TryGetValue(langName, out var langKeys))
                    {
                        langKeys = new Dictionary<string, string>();
                        langKeysByLanguage[langName] = langKeys;
                    }

                    langKeys[langEntry.Name] = phraseEntry.Value;
                }
            }

            foreach (var langKeysEntry in langKeysByLanguage)
            {
                lang.RegisterMessages(langKeysEntry.Value, this, langKeysEntry.Key);
            }
        }

        #endregion
    }
}


// --- End of file: SpawnHeli.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/secure-admin ---
// --- Original File Path: S/SecureAdmin/SecureAdmin.cs ---

﻿/*
 * TODO:
 * Add "banlist" command support
 * Add "banlistex" command support
 * Add "bans" command support
 * Add "kickall" command support
 * Add "mutechat" command support
 * Add "revoke" command support
 * Add "unmutechat" command support
 */

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Secure Admin", "Wulf/lukespragg", "1.1.8", ResourceId = 1449)]
    [Description("Restricts the basic admin commands to players with permission")]
    public class SecureAdmin : CovalencePlugin
    {
        #region Initialization

        private const string permBan = "secureadmin.ban"; // global.ban, global.banlist, global.banlistex, global.listid, global.bans
        private const string permKick = "secureadmin.kick"; // global.kick, global.kickall
        private const string permSay = "secureadmin.say"; // global.mutechat, global.say, global.unmutechat
        private const string permUnban = "secureadmin.unban"; // global.banlist, global.bans, global.unban

        private bool broadcastBans;
        private bool broadcastKicks;
        private bool commandBan;
        private bool commandKick;
        private bool commandSay;
        private bool commandUnban;
        private bool protectAdmin;

        protected override void LoadDefaultConfig()
        {
            Config["Broadcast Bans (true/false)"] = broadcastBans = GetConfig("Broadcast Bans (true/false)", true);
            Config["Broadcast Kicks (true/false)"] = broadcastKicks = GetConfig("Broadcast Kicks (true/false)", true);
            Config["Enable Ban Command (true/false)"] = commandBan = GetConfig("Enable Ban Command (true/false)", true);
            Config["Enable Kick Command (true/false)"] = commandKick = GetConfig("Enable Kick Command (true/false)", true);
            Config["Enable Say Command (true/false)"] = commandSay = GetConfig("Enable Say Command (true/false)", true);
            Config["Enable Unban Command (true/false)"] = commandUnban = GetConfig("Enable Unban Command (true/false)", true);
            Config["Protect Admin (true/false)"] = protectAdmin = GetConfig("Protect Admin (true/false)", true);

            SaveConfig();
        }

        private void Init()
        {
            LoadDefaultConfig();

            permission.RegisterPermission(permBan, this);
            permission.RegisterPermission(permKick, this);
            permission.RegisterPermission(permSay, this);
            permission.RegisterPermission(permUnban, this);

            if (commandBan) AddCovalenceCommand("ban", "BanCommand");
            if (commandKick) AddCovalenceCommand("kick", "KickCommand");
            if (commandSay) AddCovalenceCommand("say", "SayCommand");
            if (commandUnban) AddCovalenceCommand("unban", "UnbanCommand");
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["PlayerAlreadyBanned"] = "{0} is already banned",
                ["PlayerBanned"] = "{0} has been banned for '{1}'",
                ["PlayerIsAdmin"] = "{0} is admin and cannot be banned or kicked",
                ["PlayerKicked"] = "{0} has been kicked for '{1}'",
                ["PlayerNotBanned"] = "{0} is not banned",
                ["PlayerNotFound"] = "No players were found with that name or ID",
                ["PlayerUnbanned"] = "{0} has been unbanned",
                ["PlayersFound"] = "Multiple players were found, please specify: {0}",
                ["ReasonUnknown"] = "Unknown",
                ["UsageBan"] = "Usage: {0} <name or id> <reason>",
                ["UsageKick"] = "Usage: {0} <name or id> <reason>",
                ["UsageSay"] = "Usage: {0} <message>",
                ["UsageUnban"] = "Usage: {0} <name or id>",
            }, this);

            // French
            /*lang.RegisterMessages(new Dictionary<string, string>
            {
                // TODO
            }, this, "fr");*/

            // German
            /*lang.RegisterMessages(new Dictionary<string, string>
            {
                // TODO
            }, this, "de");*/

            // Russian
            /*lang.RegisterMessages(new Dictionary<string, string>
            {
                // TODO
            }, this, "ru");*/

            // Spanish
            /*lang.RegisterMessages(new Dictionary<string, string>
            {
                // TODO
            }, this, "es");*/
        }

        #endregion

        #region Ban Command

        private void BanCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permBan))
            {
                player.Reply(Lang("NotAllowed", player.Id, command));
                return;
            }

            if (args.Length < 1)
            {
                player.Reply(Lang("UsageBan", player.Id, command));
                return;
            }

            ulong targetId;
            ulong.TryParse(args[0], out targetId);
            var foundPlayers = players.FindPlayers(args[0]).ToArray();
            if (foundPlayers.Length > 1)
            {
                player.Reply("PlayersFound", player.Id, string.Concat(", ", foundPlayers.Select(p => p.Name).ToArray()));
                return;
            }
            var target = foundPlayers.Length == 1 ? foundPlayers[0] : null;
            if (target != null) ulong.TryParse(target.Id, out targetId);

            if (!targetId.IsSteamId())
            {
                player.Reply(Lang("PlayerNotFound", player.Id, args[0].Sanitize()));
                return;
            }

            if (server.IsBanned(targetId.ToString()))
            {
                player.Reply(Lang("PlayerAlreadyBanned", player.Id, args[0].Sanitize()));
                return;
            }

            if (protectAdmin && target != null && target.IsAdmin)
            {
                player.Reply(Lang("PlayerIsAdmin", player.Id, target.Name.Sanitize()));
                return;
            }

            var reason = args.Length >= 2 ? string.Join(" ", args.Skip(1).ToArray()) : Lang("ReasonUnknown", targetId.ToString());
            if (target != null && target.IsConnected) target.Ban(reason);
            else server.Ban(targetId.ToString(), reason);

            var targetName = target != null ? $"{target.Name.Sanitize()} ({target.Id})" : args[0].Sanitize();
            if (broadcastBans) Broadcast("PlayerBanned", targetName, reason);
            else player.Reply(Lang("PlayerBanned", player.Id, targetName, reason));
        }

        #endregion

        #region Kick Command

        private void KickCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permKick))
            {
                player.Reply(Lang("NotAllowed", player.Id, command));
                return;
            }

            if (args.Length < 1)
            {
                player.Reply(Lang("UsageKick", player.Id, command));
                return;
            }

            var foundPlayers = players.FindPlayers(args[0]).ToArray();
            if (foundPlayers.Length > 1)
            {
                player.Reply("PlayersFound", player.Id, string.Concat(", ", foundPlayers.Select(p => p.Name).ToArray()));
                return;
            }
            var target = foundPlayers.Length == 1 ? foundPlayers[0] : null;
            if (target == null || !target.IsConnected)
            {
                player.Reply(Lang("PlayerNotFound", player.Id, args[0].Sanitize()));
                return;
            }

            if (protectAdmin && target.IsAdmin)
            {
                player.Reply(Lang("PlayerIsAdmin", player.Id, target.Name.Sanitize()));
                return;
            }

            var reason = args.Length >= 2 ? string.Join(" ", args.Skip(1).ToArray()) : Lang("ReasonUnknown", target.Id);
            target.Kick(reason);

            var targetName = $"{target.Name.Sanitize()} ({target.Id})";
            if (broadcastKicks) Broadcast("PlayerKicked", targetName, reason);
            else player.Reply(Lang("PlayerKicked", player.Id, targetName, reason));
        }

        #endregion

        #region Say Command

        private void SayCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permSay))
            {
                player.Reply(Lang("NotAllowed", player.Id, command));
                return;
            }

            if (args.Length < 1)
            {
                player.Reply(Lang("UsageSay", player.Id, command));
                return;
            }

            var message = string.Join(" ", args.ToArray());
            server.Broadcast(message);
        }

        #endregion

        #region Unban Command

        private void UnbanCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permUnban))
            {
                player.Reply(Lang("NotAllowed", player.Id, command));
                return;
            }

            if (args.Length < 1)
            {
                player.Reply(Lang("UsageUnban", player.Id, command));
                return;
            }

            ulong targetId;
            ulong.TryParse(args[0], out targetId);
            var foundPlayers = players.FindPlayers(args[0]).ToArray();
            if (foundPlayers.Length > 1)
            {
                player.Reply("PlayersFound", player.Id, string.Concat(", ", foundPlayers.Select(p => p.Name).ToArray()));
                return;
            }
            var target = foundPlayers.Length == 1 ? foundPlayers[0] : null;
            if (target != null) ulong.TryParse(target.Id, out targetId);

            if (!targetId.IsSteamId())
            {
                player.Reply(Lang("PlayerNotFound", player.Id, args[0].Sanitize()));
                return;
            }

            var targetName = target != null ? $"{target.Name.Sanitize()} ({target.Id})" : args[0].Sanitize();

            if (!server.IsBanned(targetId.ToString()))
            {
                player.Reply(Lang("PlayerNotBanned", player.Id, targetName));
                return;
            }

            server.Unban(targetId.ToString());

            player.Reply(Lang("PlayerUnbanned", player.Id, targetName));
        }

        #endregion

        #region Helpers

        private T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private void Broadcast(string key, params object[] args)
        {
            foreach (var player in players.Connected.Where(p => p.IsConnected)) player.Message(Lang(key, player.Id, args));
            Interface.Oxide.LogInfo(Lang(key, null, args));
        }

        #endregion
    }
}

// --- End of file: SecureAdmin.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/slack-chat ---
// --- Original File Path: S/SlackChat/SlackChat.cs ---

// Requires: Slack

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("SlackChat", "Wulf/lukespragg", "0.1.2", ResourceId = 1953)]
    [Description("Sends all chat messages or keyword-based chat to Slack channel")]

    class SlackChat : CovalencePlugin
    {
        // Do NOT edit this file, instead edit SlackChat.json in oxide/config

        [PluginReference] Plugin Slack;

        void Init() => LoadDefaultConfig();

        #region Configuration

        string channel;
        List<object> keywords;
        bool keywordsOnly;
        string style;

        protected override void LoadDefaultConfig()
        {
            Config["Channel"] = channel = GetConfig("Channel", "");
            Config["Keywords"] = keywords = GetConfig("Keywords", new List<object> { "admin", "cheat" });
            Config["KeywordsOnly"] = keywordsOnly = GetConfig("KeywordsOnly", false);
            Config["Style"] = style = GetConfig("Style", "fancy");
            SaveConfig();
        }

        #endregion

        #region Chat Sending

        void OnUserChat(IPlayer player, string message)
        {
            var keyword = keywords.Any(o => message.Contains((string)o));
            if (keywordsOnly && !keyword) return;
            Slack.Call(style.ToLower() == "fancy" ? "FancyMessage" : "SimpleMessage", message, player, channel);
        }

        #endregion

        #region Helpers

        T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null) return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        #endregion
    }
}

// --- End of file: SlackChat.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sign-ban ---
// --- Original File Path: S/SignBan/SignBan.cs ---

﻿using System;
using System.Linq;
using System.Collections.Generic;

using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Sign Ban", "Tori1157", "1.0.1", ResourceId = 2727)]
    [Description("Prevents users from updating signs")]

    class SignBan : CovalencePlugin
    {
        #region Fields

        public const string BanPermission = "signban.banning";

        #endregion Fields

        #region Initializing

        [PluginReference] Plugin SignArtist, ZoneManager;

        private void Init()
        {
            permission.RegisterPermission(BanPermission, this);

            LoadData(ref bannedply);
            SaveData(bannedply);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Player Try Update"] = "[#red]You are banned from updating signs![/#]",
                ["Player Banning User"] = "You have banned '[#cyan]{0}[/#]' from signs.",
                ["Player Unbanning User"] = "You have unbanned '[#cyan]{0}[/#]' from using signs.",
                ["Target Banned"] = "You have been banned from updating sigs.",
                ["Target Unbanned"] = "You have been unbanned from updating signs.",
                ["Player Already Banned"] = "'[#cyan]{0}[/#]' is already banned.",
                ["Target Not Banned"] = "'[#cyan]{0}[/#]' isn't banned.",
                ["No Permission"] = "You do not have permission to the '[#cyan]{0}[/#]' command!",
                ["Invalid Parameter"] = "'[#cyan]{0}[/#]' is an invalid parameter.",
                ["Invalid Syntax Ban"] = "Invalid Syntax!  |  /sign ban \"user name\"",
                ["Invalid Syntax Unban"] = "Invalid Syntax!  |  /sign unban \"user name\"",
                ["Default Message"] = "This plugin prevents users from updating signs.\n\n[#lightblue]Available Commands:[/#]\n- [#ffa500]/sign[/#] [i](Displays info & help message (This message).)[/i]\n- [#ffa500]/sign ban \"user name\"[/#] [i](Bans user from updating signs.)[/i]\n- [#ffa500]/sign unban \"user name\"[/#] [i](Unbans users from updating signs.)[/i]",
                ["SteamID Not Found"] = "SteamID '[#cyan]{0}[/#]' could not be found.",
                ["Player Not Found"] = "Player '[#cyan]{0}[/#]' could not be found.",
                ["Multiple Players Found"] = "Multiple users found!\n\n{0}",
            }, this);
        }

        #endregion Initializing

        #region Commands

        [Command("sign")]
        private void SignCommand(IPlayer player, string command, string[] args)
        {
            if (!CanBanSign(player) && !player.IsServer)
            {
                SendChatMessage(player, Lang("No Permission", player.Id, command)); 
                return;
            }

            if (args.Length == 0)
            {
                SendChatMessage(player, Lang("Default Message", player.Id));
                return;
            }

            var CommandArg = args[0].ToLower();
            var CommandInfo = $"{command} {args[0]}";
            var CaseArgs = (new List<object>
            {
                "ban", "unban"
            });

            if (!CaseArgs.Contains(CommandArg))
            {
                SendChatMessage(player, Lang("Invalid Parameter", player.Id, CommandInfo));
                return;
            }

            switch (CommandArg)
            {
                #region Ban
                case "ban":

                    if (args.Length == 1)
                    {
                        SendChatMessage(player, Lang("Invalid Syntax Ban", player.Id));
                        return;
                    }

                    IPlayer Btarget;
                    Btarget = GetPlayer(args[1], player);

                    if (Btarget == null) return;

                    if (SignBanInfo.IsSignBanned(Btarget))
                    {
                        SendChatMessage(player, Lang("Player Already Banned", player.Id, Btarget.Name));
                        return;
                    }

                    SendChatMessage(player, Lang("Player Banning User", player.Id, Btarget.Name));
                    SendChatMessage(Btarget, Lang("Target Banned", Btarget.Id));
                    bannedply[Btarget.Id] = new SignBanInfo();
                    SaveData(bannedply);

                return;
                #endregion Ban

                #region Unban
                case "unban":

                    if (args.Length == 1)
                    {
                        SendChatMessage(player, Lang("Invalid Syntax Ban", player.Id));
                        return;
                    }

                    IPlayer Utarget;
                    Utarget = GetPlayer(args[1], player);

                    if (Utarget == null) return;

                    if (!SignBanInfo.IsSignBanned(Utarget))
                    {
                        SendChatMessage(player, Lang("Target Not Banned", player.Id, Utarget.Name));
                        return;
                    }

                    SendChatMessage(player, Lang("Player Unbanning User", player.Id, Utarget.Name));
                    SendChatMessage(Utarget, Lang("Target Unbanned", Utarget.Id));
                    bannedply.Remove(Utarget.Id);
                    SaveData(bannedply);

                return;
                #endregion Unban
            }
        }

        #endregion Commands

        #region Functions

        private bool CanUpdateSign(BasePlayer player, Signage sign)
        {
            if (SignBanInfo.IsSignBanned(player.IPlayer))
            {
                SendChatMessage(player.IPlayer, Lang("Player Try Update", player.UserIDString));
                return false;
            }

            if (ZoneManager != null && ZMNoSignUpdates(player) == true) return false;
            else return true;
        }

        private bool CanBanSign(IPlayer player)
        {
            return (player.HasPermission(BanPermission));
        }

        private object OnPlayerCommand(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null) return false;
            if (SignArtist == null) return null;

            var command = arg.cmd.FullName;
            var args = arg.GetString(0);
            var player = arg.Connection.player as BasePlayer;

            if (args.StartsWith("/sil") && SignBanInfo.IsSignBanned(player.IPlayer))
            {
                SendChatMessage(player.IPlayer, Lang("Player Try Update", player.UserIDString));
                return false;
            }
            return null;
        }

        #endregion Functions

        #region Helpers

        #region Player Finding
        private IPlayer GetPlayer(string nameOrID, IPlayer player)
        {
            if (nameOrID.IsSteamId() == true)
            {
                IPlayer result = players.All.ToList().Find((p) => p.Id == nameOrID);

                if (result == null)
                    SendChatMessage(player, Lang("SteamID Not Found", player.Id, nameOrID));

                return result;
            }

            List<IPlayer> foundPlayers = new List<IPlayer>();

            foreach (IPlayer current in players.Connected)
            {
                if (current.Name.ToLower() == nameOrID.ToLower())
                    return current;

                if (current.Name.ToLower().Contains(nameOrID.ToLower()))
                    foundPlayers.Add(current);
            }

            switch (foundPlayers.Count)
            {
                case 0:
                    SendChatMessage(player, Lang("Player Not Found", player.Id, nameOrID));
                break;

                case 1:
                    return foundPlayers[0];

                default:
                    string[] names = (from current in foundPlayers select current.Name).ToArray();
                    SendChatMessage(player, Lang("Multiple Players Found", player.Id, string.Join(", ", names)));
                break;
            }
            return null;
        }

        private bool IsParseableTo<T>(object s)
        {
            try
            {
                var parsed = (T)Convert.ChangeType(s, typeof(T));
                return true;
            }
            catch
            {
                return false;
            }
        }
        #endregion

        private static Dictionary<string, SignBanInfo> bannedply = new Dictionary<string, SignBanInfo>();

        public class SignBanInfo
        {
            public static bool IsSignBanned(IPlayer player) => bannedply.ContainsKey(player.Id);

            public SignBanInfo() { }
        }

        private bool ZMNoSignUpdates(BasePlayer player)
        {
            return (bool)ZoneManager.CallHook("EntityHasFlag", player, "nosignupdates");
        }

        private void LoadData<T>(ref T data, string filename = null) => data = Interface.Oxide.DataFileSystem.ReadObject<T>(filename ?? Name);
        private void SaveData<T>(T data, string filename = null) => Interface.Oxide.DataFileSystem.WriteObject(filename ?? Name, data);

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion Helpers

        #region Messaging

        private void SendChatMessage(IPlayer player, string message)
        {
            player.Reply(message);
        }

        #endregion Messaging
    }
}

// --- End of file: SignBan.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/steam-groups ---
// --- Original File Path: S/SteamGroups/SteamGroups.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;

// TODO: Add queue for old member removal
// TODO: Add log rotation support for cleanup
// TODO: Cache members in data file and compare when updating

namespace Oxide.Plugins
{
    [Info("Steam Groups", "Wulf/lukespragg", "0.4.1")]
    [Description("Automatically adds members of Steam group(s) to a permissions group")]
    public class SteamGroups : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Group Setup")]
            public List<GroupInfo> GroupSetup { get; set; } = new List<GroupInfo>();

            [JsonProperty(PropertyName = "Update Interval in seconds")]
            public int UpdateInterval { get; set; } = 300;

            [JsonProperty(PropertyName = "Log member changes to console")]
            public bool LogToConsole { get; set; } = true;

            [JsonProperty(PropertyName = "Log member changes to file")]
            public bool LogToFile { get; set; } = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            string configPath = $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Name}.json";
            LogWarning($"Could not load a valid configuration file, creating a new configuration file at {configPath}");
            config = new Configuration();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion Configuration

        #region Localization

        private new void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandGroup"] = "steamgroup",
                ["CommandMembers"] = "steammembers",
                ["CommandUsageGroup"] = "Usage: {0} <add/remove> <steam group> [oxide group]",
                ["CheckingGroups"] = "Checking for new Steam group members...",
                ["GroupAdded"] = "Steam group '{0}' will be added to Oxide group '{1}'",
                ["GroupExists"] = "Steam group '{0}' and Oxide group '{1}' setup already exists",
                ["GroupRemoved"] = "Steam group '{0}' has been removed and will not longer be checked"
            }, this);
        }

        #endregion Localization

        #region Initialization

        private readonly Dictionary<string, string> steamGroups = new Dictionary<string, string>();
        private readonly Dictionary<string, string> groups = new Dictionary<string, string>();
        private readonly HashSet<string> members = new HashSet<string>();
        private readonly Queue<Member> membersQueue = new Queue<Member>();
        private readonly Regex idRegex = new Regex(@"<steamID64>(?<id>.+)</steamID64>");
        private readonly Regex pageRegex = new Regex(@"<currentPage>(?<page>.+)</currentPage>");
        private readonly Regex pagesRegex = new Regex(@"<totalPages>(?<pages>.+)</totalPages>");

        private const string permAdmin = "steamgroups.admin";

        private bool backoffPoll = false;

        public class GroupInfo
        {
            public readonly string Oxide;
            public readonly string Steam;

            public GroupInfo(string oxide, string steam)
            {
                Oxide = oxide.ToLower();
                Steam = steam.ToLower();
            }
        }

        private class Member
        {
            public readonly string Id;
            public readonly string Group;

            public Member(string id, string group)
            {
                Id = id;
                Group = group;
            }
        }

        private void OnServerInitialized()
        {
            foreach (GroupInfo group in config.GroupSetup)
            {
                if (!permission.GroupExists(group.Oxide))
                {
                    permission.CreateGroup(group.Oxide, group.Oxide, 0);
                }

                AddSteamGroup(group.Steam, group.Oxide);
            }

            permission.RegisterPermission(permAdmin, this);

            AddLocalizedCommand("CommandGroup", "GroupCommand");
            AddLocalizedCommand("CommandMembers", "MembersCommand");

            // Start the timed group checking (only once, will be enabled entire plugin lifecycle)
            StartTimedChecking();

            // Trigger check of Steam members immediately
            QueueWorkerThread(worker => CheckSteamGroups());

            // Start member dequeue/cleanup loop
            RunQueueAndCleanup();
        }

        #endregion Initialization

        #region Group Handling

        private void AddSteamGroup(string steamGroup, string oxideGroup)
        {
            ulong result;
            const string urlFormat = "http://steamcommunity.com/{0}/{1}/memberslistxml/?xml=1";
            string url = string.Format(urlFormat, ulong.TryParse(steamGroup, out result) ? "gid" : "groups", steamGroup);

            string groupValue;
            if (!(groups.TryGetValue(steamGroup, out groupValue) && groupValue == oxideGroup))
            {
                groups.Add(steamGroup, oxideGroup);
            }

            if (!steamGroups.ContainsKey(steamGroup))
            {
                steamGroups.Add(steamGroup, url);
            }
        }

        private void ProcessQueuedMembers()
        {
            QueueWorkerThread(worker =>
            {
                try
                {
                    Member member = membersQueue.Dequeue();

                    // Check if player is already in appropriate Oxide group, else add
                    if (!permission.UserHasGroup(member.Id, groups[member.Group]))
                    {
                        permission.AddUserGroup(member.Id, groups[member.Group]);
                        Log($"{member.Id} from {member.Group} added to '{groups[member.Group]}' group", "additions");
                    }
                }
                catch (Exception e)
                {
                    Puts($"An error occurred while processing queue: {e}");
                }
            });
        }

        private void RunQueueAndCleanup()
        {
            timer.Every(1f, () =>
            {
                if (membersQueue.Count != 0)
                {
                    ProcessQueuedMembers();
                }
                else
                {
                    //RemoveOldMembers();
                }
            });
        }

        #endregion Group Handling

        #region Group Cleanup

        private void RemoveOldMembers()
        {
            foreach (KeyValuePair<string, string> group in groups)
            {
                foreach (string user in permission.GetUsersInGroup(group.Value))
                {
                    string id = Regex.Replace(user, "[^0-9]", "");
                    if (!members.Contains(id))
                    {
                        permission.RemoveUserGroup(id, group.Value);
                        Log($"{id} from '{group.Value}' group", "removals");
                    }
                }
            }
        }

        #endregion Group Cleanup

        #region Member Checking

        private void StartTimedChecking()
        {
            timer.Every(config.UpdateInterval, () =>
            {
                // While backoff is enabled, we do not want to check members
                if (backoffPoll)
                {
                    Puts("Currently in backoff state, will not poll Steam group(s) for members");
                    return;
                }

                try
                {
                    QueueWorkerThread(worker => CheckSteamGroups());
                }
                catch (Exception e)
                {
                    Puts($"Exception occurred: {e}");
                }
            });
        }

        private void CheckSteamGroups()
        {
            try
            {
                Puts("Polling Steam group(s) to get member list");

                foreach (KeyValuePair<string, string> group in steamGroups)
                {
                    const int page = 1;

                    // One group at the time, no additional threading, we don't want to flood the API
                    Puts($"Checking Steam group {group.Key}, starting from page {page}");
                    QueueWebRequest(group.Key, group.Value, page);
                }
            }
            catch (Exception e)
            {
                Puts($"Exception occurred: {e}");
            }
        }

        private void QueueWebRequest(string groupName, string baseUrl, int page)
        {
            try
            {
                // Queue web request to get member list for Steam group
                webrequest.Enqueue($"{baseUrl}&p={page}", null, (code, response) =>
                {
                    WebRequestCallback(code, response, baseUrl, groupName);
                }, this, RequestMethod.GET, null, 10000f);
            }
            catch (Exception e)
            {
                Puts($"Exception occurred: {e}");
            }
        }

        private void WebRequestCallback(int code, string response, string baseUrl, string groupName)
        {
            if (code == 403 || code == 429)
            {
                Puts($"Steam is currently not allowing connections from your server! code={code}. Aborting this call");
                ToggleBackoff();
                return;
            }

            if (code != 200 || response == null)
            {
                Puts($"Checking for Steam group members failed! code={code}. Aborting this call");
                ToggleBackoff();
                return;
            }

            MatchCollection ids = idRegex.Matches(response);
            Log($"Found {ids.Count} member(s) in {groupName} to check");

            int newMembers = 0;
            foreach (Match match in ids)
            {
                string id = match.Groups["id"].Value;
                if (!members.Contains(id))
                {
                    newMembers++;
                    members.Add(id);
                    membersQueue.Enqueue(new Member(id, groupName));
                }
            }
            Puts($"Added {newMembers} member(s) in {groupName} to queue");

            int currentPage;
            int totalPages;
            int.TryParse(pageRegex.Match(response).Groups[1].Value, out currentPage);
            int.TryParse(pagesRegex.Match(response).Groups[1].Value, out totalPages);

            if (currentPage != 0 && totalPages != 0 && currentPage < totalPages)
            {
                QueueWorkerThread(worker => QueueWebRequest(groupName, baseUrl, currentPage + 1));
            }
        }

        private void ToggleBackoff()
        {
            if (!backoffPoll)
            {
                backoffPoll = true;
                timer.Once(600f, () => QueueWorkerThread(worker => ToggleBackoff()));
                Puts("Backoff polling state enabled");
            }
            else
            {
                backoffPoll = false;
                Puts("Backoff polling state disabled");
            }
        }

        #endregion Member Checking

        #region Commands

        private void GroupCommand(IPlayer player, string command, string[] args)
        {
            if (player.HasPermission(permAdmin))
            {
                if (args.Length < 2)
                {
                    Message(player, "CommandUsageGroup", command);
                    return;
                }

                string steamGroup = args[1].ToLower();
                string oxideGroup = args.Length >= 3 ? args[2].ToLower() : Interface.Oxide.Config.Options.DefaultGroups.Players.ToLower();

                switch (args[0].ToLower())
                {
                    case "+":
                    case "add":
                        {
                            if (!config.GroupSetup.Any(g => g.Steam == steamGroup && g.Oxide == oxideGroup))
                            {
                                config.GroupSetup.Add(new GroupInfo(oxideGroup, args[1]));
                                Message(player, "GroupAdded", args[1], oxideGroup);
                            }
                            else
                            {
                                Message(player, "GroupExists", args[1], oxideGroup);
                                return;
                            }

                            break;
                        }

                    case "-":
                    case "del":
                    case "delete":
                    case "remove":
                        {
                            config.GroupSetup.RemoveAll(g => g.Oxide == args[1] || g.Steam == args[1]);
                            Message(player, "GroupRemoved", args[1]);
                            break;
                        }

                    default:
                        {
                            Message(player, "CommandUsageGroup", command);
                            return;
                        }
                }
                SaveConfig();
            }
        }

        private void MembersCommand(IPlayer player, string command, string[] args)
        {
            if (player.HasPermission(permAdmin))
            {
                // Trigger check of Steam members immediately
                QueueWorkerThread(worker => CheckSteamGroups());

                Message(player, "CheckingGroups");
            }
        }

        #endregion Commands

        #region Helpers

        private string Lang(string key, string id = null, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        private void AddLocalizedCommand(string key, string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages.Where(m => m.Key.Equals(key)))
                {
                    if (!string.IsNullOrEmpty(message.Value))
                    {
                        AddCovalenceCommand(message.Value, command);
                    }
                }
            }
        }

        private void Log(string text, string filename)
        {
            if (config.LogToConsole)
            {
                Puts(text);
            }

            if (config.LogToFile)
            {
                LogToFile(filename, $"[{DateTime.Now}] {text}", this);
            }
        }

        private void Message(IPlayer player, string key, params object[] args)
        {
            player.Reply(Lang(key, player.Id, args));
        }

        #endregion Helpers
    }
}


// --- End of file: SteamGroups.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/structure-refund ---
// --- Original File Path: S/StructureRefund/StructureRefund.cs ---

﻿/*
 * TODO:
 * Add check to make sure structure is destroyed before refunding
 * Add option to allow/disallow refunds if not the owner
 * Check to make sure refunds given when using hammer
 */

using System;

namespace Oxide.Plugins
{
    [Info("StructureRefund", "Wulf/lukespragg", "1.3.0", ResourceId = 1692)]
    [Description("Refunds previous build materials when demolishing and/or upgrading")]

    class StructureRefund : CovalencePlugin
    {
        #region Initialization

        const string permDemolish = "structurerefund.demolish";
        const string permUpgrade = "structurerefund.upgrade";

        bool demolishRefunds;
        bool upgradeRefunds;

        protected override void LoadDefaultConfig()
        {
            foreach (var grade in Enum.GetNames(typeof(BuildingGrade.Enum)))
            {
                if (grade.Equals("None") || grade.Equals("Count")) continue;
                Config[$"Refund {grade} (true/false)"] = GetConfig($"Refund {grade} (true/false)", true);
            }

            // Options
            Config["Refund for Demolish (true/false)"] = demolishRefunds = GetConfig("Refund for Demolish (true/false)", true);
            Config["Refund for Upgrade (true/false)"] = upgradeRefunds = GetConfig("Refund for Upgrade (true/false)", true);

            // Cleanup
            Config.Remove("DemolishRefunds");
            Config.Remove("UpgradeRefunds");
            Config.Remove("RefundMetal");
            Config.Remove("RefundStone");
            Config.Remove("RefundTopTier");
            Config.Remove("RefundTwigs");
            Config.Remove("RefundWood");

            SaveConfig();
        }

        void Init()
        {
            LoadDefaultConfig();
            permission.RegisterPermission(permDemolish, this);
            permission.RegisterPermission(permUpgrade, this);

            if (!demolishRefunds) Unsubscribe("OnStructureDemolish");
            if (!upgradeRefunds) Unsubscribe("OnStructureUpgrade");
        }

        #endregion

        #region Refunding

        void RefundMaterials(BuildingBlock block, BasePlayer player)
        {
            if (block.OwnerID != player.userID || player.inventory.containerMain.IsFull()) return;

            foreach (var item in block.blockDefinition.grades[(int)block.grade].costToBuild)
                player.GiveItem(ItemManager.CreateByItemID(item.itemid, (int)item.amount));
        }

        void OnStructureDemolish(BuildingBlock block, BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, permDemolish)) RefundMaterials(block, player);
        }

        void OnStructureUpgrade(BuildingBlock block, BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, permUpgrade)) RefundMaterials(block, player);
        }

        #endregion

        #region Helpers

        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        #endregion    }
}

// --- End of file: StructureRefund.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/structure-grades ---
// --- Original File Path: S/StructureGrades/StructureGrades.cs ---

using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("StructureGrades", "Wulf/lukespragg", "1.0.0", ResourceId = 1511)]
    [Description("Limits which structure grades players can build")]

    public class StructureGrades : RustPlugin
    {
        // Do NOT edit this file, instead edit StructureGrades.json in oxide/config and StructureGrades.en.json in the oxide/lang directory,
        // or create a new language file for another language using the 'en' file as a default.

        #region Initialization

        void Init()
        {
            var grades = new List<string>();
            foreach (var grade in Enum.GetNames(typeof(BuildingGrade.Enum)))
            {
                if (grade.Equals("None") || grade.Equals("Count")) continue;
                grades.Add(grade);

                // Permissions
                permission.RegisterPermission($"{Title}.{grade}", this);

                // Configuration
                Config[grade] = GetConfig(grade, true);
                SaveConfig();
            }
            Puts("Allowed: " + string.Join(", ", grades.ToArray()));

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "<color=yellow>{0}</color> has been <color=red>disabled</color>"
            }, this);
        }

        protected override void LoadDefaultConfig()
        {
        }

        #endregion

        object OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum gradeEnum)
        {
            var grade = gradeEnum.ToString();
            if ((bool)Config[grade] || IsAllowed(player.UserIDString, $"{Title}.{grade}")) return null;
            PrintToChat(player, Lang("NotAllowed", player.UserIDString, grade));
            return true;
        }

        #region Helpers

        T GetConfig<T>(string name, T defaultValue) => Config[name] == null ? defaultValue : (T)Convert.ChangeType(Config[name], typeof(T));

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        bool IsAllowed(string id, string perm) => permission.UserHasPermission(id, perm);

        #endregion
    }
}

// --- End of file: StructureGrades.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/skin-blocker ---
// --- Original File Path: S/SkinBlocker/SkinBlocker.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SkinBlocker", "redBDGR", "1.0.0")]
    [Description("Block certain skins from being applied to items / deployables")]

    class SkinBlocker : RustPlugin
    {
        private static bool Changed = false;

        #region Configuration

        private class ConfigFile
        {
            public static List<ulong> itemSkinBlacklist = new List<ulong>();
            public static List<ulong> deployableSkinBlacklist = new List<ulong>();

            public static List<object> GetDefaultItemSkinList()
            {
                List<object> x = new List<object>();
                x.Add(12345);
                x.Add(54321);
                return x;
            }

            public static List<object> GetDefaultDeployableSkinList()
            {
                List<object> x = new List<object>();
                x.Add(12345);
                x.Add(54321);
                return x;
            }
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        private void LoadVariables()
        {
            var itemSkins = (List<object>)GetConfig("Settings", "Item skins blacklist", ConfigFile.GetDefaultItemSkinList());
            foreach (var entry in itemSkins)
                ConfigFile.itemSkinBlacklist.Add(Convert.ToUInt64(entry));

            var entitySkins = (List<object>)GetConfig("Settings", "Deployable skins blacklist", ConfigFile.GetDefaultDeployableSkinList());
            foreach(var entry in entitySkins)
                ConfigFile.deployableSkinBlacklist.Add(Convert.ToUInt64(entry));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        #endregion

        #region Hooks

        private void Init()
        {
            LoadVariables();
        }

        private void OnServerInitialized()
        {
            ScanAllItems();
        }

        private void OnItemAddedToContainer(ItemContainer container, Item item) => CheckItem(item);

        private void OnEntitySpawned(BaseNetworkable entity) => CheckEntity(entity.GetComponent<BaseEntity>());

        #endregion

        #region Methods

        private bool CheckEntity(BaseEntity ent)
        {
            if (ent == null)
                return false;
            if (ConfigFile.deployableSkinBlacklist.Contains(ent.skinID))
            {
                ent.skinID = 0;
                ent.SendNetworkUpdateImmediate();
                return true;
            }
            else
                return false;
        }

        private bool CheckItem(Item item)
        {
            if (item == null)
                return false;
            if (ConfigFile.itemSkinBlacklist.Contains(item.skin))
            {
                item.skin = 0;
                item.MarkDirty();
                return true;
            }
            else
                return false;
        }

        private void ScanAllItems()
        {
            ServerMgr.Instance.StartCoroutine(CheckAllEntities());
            ServerMgr.Instance.StartCoroutine(CheckAllItems());
        }

        private IEnumerator CheckAllEntities()
        {
            foreach(BaseEntity entity in UnityEngine.Object.FindObjectsOfType<BaseEntity>())
            {
                yield return new WaitForSeconds(.01f);
                CheckEntity(entity);
            }
        }

        private IEnumerator CheckAllItems()
        {
            foreach (StorageContainer entity in UnityEngine.Object.FindObjectsOfType<StorageContainer>())
            {
                yield return new WaitForSeconds(.01f);
                foreach(Item item in entity.inventory.itemList)
                {
                    yield return new WaitForSeconds(.01f);
                    CheckItem(item);
                }
            }
        }

        #endregion
    }
}


// --- End of file: SkinBlocker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sign-history ---
// --- Original File Path: S/SignHistory/SignHistory.cs ---

using System;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
	[Info("SignHistory", "collect_vood", "1.1.4")]
	[Description("Creates a changelog for signs")]

	public class SignHistory : CovalencePlugin
	{
        #region Constants

        private const string AdminPerm = "signhistory.allow";

		#endregion

		#region Localization

		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>()
			{
				{ "NotAllowed", "You don't have permission to use this command." },
				{ "NoSign", "No sign found." },
				{ "NoHistory", "No history found for this sign." },
				{ "Owner", "Owner: {0}" },
				{ "OwnerPart", "{0} ({1})" },
				{ "Changes", "Changes: {0}" },
				{ "ChangePart", "- {0} : {1} ({2})\n" }
			}, this);
		}

		#endregion

		#region Data

		private StoredData storedData;

		private Dictionary<ulong, Sign> Signs => storedData.Signs;

		private class StoredData
		{
			[JsonProperty("Signs (Updated 04/05/23)")]
			public Dictionary<ulong, Sign> Signs = new Dictionary<ulong, Sign>();
		}

		private class Sign
		{
			[JsonProperty("OwnerId")]
			public string OwnerId;
			[JsonProperty("Changes", ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public List<Change> Changes = new List<Change>();

			public Sign(string ownerId)
			{
				OwnerId = ownerId;
			}

			public class Change
			{
				[JsonProperty("Timestamp")]
				public DateTime Timestamp = DateTime.Now;
				[JsonProperty("UserId")]
				public string Id;

				public Change(string playerId)
				{
					Id = playerId;
				}
			}
		}
		

		private void SaveData() 
			=> Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
		
		private void Unload() 
			=> SaveData();

		private void OnServerSave()
			=> SaveData();

		#endregion

		#region Hooks

		private void Init()
		{
			permission.RegisterPermission(AdminPerm, this);

			storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);

			SaveData();
		}

		private void OnNewSave(string filename)
		{
			PrintWarning("Map wipe detected! Resetting all sign data.");

			storedData.Signs = new Dictionary<ulong, Sign>();
			SaveData();
		}

		private void OnSignUpdated(BaseEntity sign, BasePlayer player)
			=> LogSignChange(sign, player);

		#endregion

		#region Methods

		private string GetMessage(string key, IPlayer player, params string[] args) 
			=> String.Format(lang.GetMessage(key, this, player.Id), args);

		private bool HasPerm(IPlayer player, string perm) 
			=> player.IsAdmin || permission.UserHasPermission(player.Id, perm);

		private void LogSignChange(BaseEntity sign, BasePlayer player)
		{
			if (sign == null || player == null) 
				return;

			var netId = sign.net.ID.Value;

			if (!Signs.ContainsKey(netId)) 
			{
				if (sign.OwnerID == 0) 
					return;

				Signs.Add(netId, new Sign(sign.OwnerID.ToString()));
			}

			Signs[netId].Changes.Add(new Sign.Change(player.UserIDString));
		}

        #endregion

        #region Commands

        [Command("history")]
		private void cmdHistory(IPlayer player, string command, string[] args)
		{
			if (player.IsServer)
			{
				player.Reply("Cannot use this command from console.");
				return;
			}

			BasePlayer bPlayer;
			if (player == null || (bPlayer = player.Object as BasePlayer) == null) return;

			if (!HasPerm(player, AdminPerm)) 
			{
				player.Reply(GetMessage("NotAllowed", player));
				return;
			}

			RaycastHit hit;
			BaseEntity sign;
			if (!Physics.Raycast(bPlayer.eyes.HeadRay(), out hit, 4.0f) 
				|| (sign = hit.GetEntity()) == null) 
			{
				player.Reply(GetMessage("NoSign", player));
				return;
			}

			if (sign.Categorize() != "sign")
			{
				player.Reply(GetMessage("NoSign", player));
				return;
			}

			var netId = sign.net.ID.Value;
			if (!Signs.ContainsKey(netId)) 
			{
				player.Reply(GetMessage("NoHistory", player));
				return;
			}

			var signData = Signs[netId];

			string changes = "\n";
			foreach (var change in signData.Changes)
			{
				var user = covalence.Players.FindPlayerById(change.Id);
				if (user == null) 
					continue;

				changes += GetMessage("ChangePart", user, change.Timestamp.ToString(), user.Name, user.Id);
			}

			string ownerString = signData.OwnerId;

			var owner = covalence.Players.FindPlayerById(signData.OwnerId);
			if (owner != null)
			{
				ownerString = GetMessage("OwnerPart", owner, owner.Name, owner.Id);
			}

			player.Reply($"{GetMessage("Owner", player, ownerString)}\n" +
				$"{GetMessage("Changes", player, changes)}");
		}

		#endregion
	}
}

// --- End of file: SignHistory.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sleeper-count ---
// --- Original File Path: S/SleeperCount/SleeperCount.cs ---

﻿using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;

namespace Oxide.Plugins
{
	[Info("Sleeper Count", "NubbbZ", "1.2.1")]
	[Description("Returns the total number of sleepers!")]
	class SleeperCount : CovalencePlugin
	{
		private void Init()
		{
			permission.RegisterPermission("sleepercount.use", this);
		}

		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["denied"] = "You don't have permission to use that command!",
				["none"] = "There are currently no sleepers on the server!",
				["single"] = "There is {0} sleeping player!",
				["multiple"] = "There are {0} sleeping players!"
			}, this);
		}

		[Command("sleepers")]
		private void TestCommand(IPlayer player, string command, string[] args)
		{
			int Sleeper_Count = BasePlayer.sleepingPlayerList.Count;

			if (player.HasPermission("sleeperlist.use"))
			{
				if (BasePlayer.sleepingPlayerList.Count == 0)
				{
					player.Reply(lang.GetMessage("none", this, player.Id));
				} 
				else
				{
					if (BasePlayer.sleepingPlayerList.Count == 1) 
					{
						player.Reply(string.Format(lang.GetMessage("single", this, player.Id), Sleeper_Count.ToString()));
					} 
					else 
					{
						player.Reply(string.Format(lang.GetMessage("multiple", this, player.Id), Sleeper_Count.ToString()));
					}
				}
			}
			else
			{
				player.Reply(lang.GetMessage("denied", this, player.Id));
			}
		}
	}
}

// --- End of file: SleeperCount.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/survey-my-spot ---
// --- Original File Path: S/SurveyMySpot/SurveyMySpot.cs ---

using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Linq;
using System.Collections.Generic; // list function
using Oxide.Core.Libraries.Covalence;
using System;   //toshorttimestring
using System.Globalization;
using Oxide.Core;
using Rust; 
using System.Text;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Survey My Spot", "BuzZ[PHOQUE]", "1.0.0")]
    [Description("Set a spot to survey, it will log enter/exit of players & npc")]

/*======================================================================================================================= 
*
*   1.0.0   20190908    +code refresh
*
*    THANKS TO THE OXIDE TEAM for coding quality and time spent for community
*
*=======================================================================================================================*/

    public class SurveyMySpot : RustPlugin
    {

        [PluginReference] Plugin ZoneManager;

        bool debug = false;
        string version = "version 1.0.0";

        public Dictionary<ulong, int> reading = new Dictionary<ulong, int>();    


    class StoredData
    {

        public Dictionary<ulong, Dataz> ulongdata = new Dictionary<ulong, Dataz>();    
        
        public StoredData()
        {
        }
    }

        private StoredData storedData;

    class Dataz
    {

        public string playerspot;    
        public bool playeronly;    
        public bool playerchat; 
        public int playerenter; 
        public int playerexit; 
        public int npcenter; 
        public int npcexit; 
        public List<string> loglist = new List<string>();
        
        public Dataz()
        {
        }
    }

        private Dataz dataz;


        bool IsPlayerOnSpot(string spotID, BasePlayer player) => (bool)ZoneManager?.Call("isPlayerInZone", spotID, player);
        string CheckZoneID(string checkID) => (string)ZoneManager?.Call("CheckZoneID", checkID);

        static string SurveyPanel;
        static string LogPanel;
        private bool ConfigChanged;


        string Prefix = "[SMS] :";           // CHAT PLUGIN PREFIX
        string PrefixColor = "#d47600";         // CHAT PLUGIN PREFIX COLOR
        string ChatColor = "#ffba64";           // CHAT MESSAGE COLOR

        ulong SteamIDIcon = 76561198383370822;          // SteamID FOR PLUGIN ICON
        bool PlayerOnly;                        // LOG NPC & PLAYER, OR PLAYER ONLY
        //int logpage;
        //string logpagestring;
        const string SurveyPermission = "surveymyspot.use"; 

#region INITIALISATION

		private void OnServerInitialized()
        {
            LoadVariables();
            permission.RegisterPermission(SurveyPermission, this);

        }

        void Loaded()
        {
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>("SurveyMySpot");
            if (ZoneManager == false)
                    {
                        PrintError("ZoneManager.cs is needed and not present.");
                    }
        }

        void Unload()
        {
            Interface.Oxide.DataFileSystem.WriteObject("SurveyMySpot", storedData);
        }
#endregion

#region MESSAGES / LANG

        void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {

                {"EnterPlayerMsg", "-> ENTER PLAYER :"}, 
                {"EnterNPCMsg", "-> ENTER NPC :"}, 
                {"ExitPlayerMsg", "-> EXIT PLAYER :"}, 
                {"ExitNPCMsg", "-> EXIT NPC :"}, 
                {"ZMNeededMsg", "Error : ZoneManager plugin is needed to start SurveyMySpot."}, 
                {"SpotSetMsg", "Setting your spot at your location."}, 
                {"SpotVerifMsg", "Your spot has been set and verified."}, 
                {"SpotErrorMsg", "An error occured. Please re try."}, 
                {"SpotDstryMsg", "Spot has been removed, and log cleared."}, 
                {"NoPermMsg", "You don't have the permission for this."}, 
                {"PanelSurveyMsg", "MY SURVEY SPOT PANEL"}, 
                {"PanelSurveyUnderMsg", "Set & Survey your spot -"}, 
                {"ZoneAlreadyMsg", "ERROR : Zone already exists."}, 

            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>
            {

                {"EnterPlayerMsg", "-> ENTREE JOUEUR :"},
                {"EnterNPCMsg", "-> ENTREE NPC :"}, 
                {"ExitPlayerMsg", "-> SORTIE PLAYER :"}, 
                {"ExitNPCMsg", "-> SORTIE NPC :"}, 
                {"ZMNeededMsg", "Erreur : le plugin ZoneManager doit être installé pour utiliser SurveyMySpot."},
                {"SpotSetMsg", "Mise en place de votre spot sur votre position."}, 
                {"SpotVerifMsg", "Votre spot est prêt et vérifié."}, 
                {"SpotErrorMsg", "Une erreur est survenue, veuillez re essayer."}, 
                {"SpotDstryMsg", "Votre spot a été supprimé, et votre log effacé."}, 
                {"NoPermMsg", "Vous n'y êtes pas autorisé."}, 
                {"PanelSurveyMsg", "MON SPOT SOUS SURVEILLANCE"},
                {"PanelSurveyUnderMsg", "Créez & surveillez votre spot -"},
                {"ZoneAlreadyMsg", "ERREUR : la Zone existe déjà."}, 

            }, this, "fr");
        }

#endregion

#region CONFIG

    protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        private void LoadVariables()
        {

            Prefix = Convert.ToString(GetConfig("Chat Settings", "Prefix", "[SMS] :"));                       // CHAT PLUGIN PREFIX
            PrefixColor = Convert.ToString(GetConfig("Chat Settings", "PrefixColor", "#d47600"));                // CHAT PLUGIN PREFIX COLOR
            ChatColor = Convert.ToString(GetConfig("Chat Settings", "ChatColor", "#ffba64"));                    // CHAT MESSAGE COLOR
            //SteamIDIcon = Convert.ToUlong(GetConfig("Settings", "SteamIDIcon", 76561198383370822));        // SteamID FOR PLUGIN ICON - STEAM PROFILE CREATED FOR THIS PLUGIN / 76561198842176097 /

            if (!ConfigChanged) return;
            SaveConfig();
            ConfigChanged = false;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                ConfigChanged = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                ConfigChanged = true;
            }
            return value;
        }

#endregion

#region ON ENTER SPOT

        void OnEnterZone(string ZoneID, BasePlayer player)//            if (player.userID.IsSteamId() == false)
        {
            string gender;
            if (player.userID.IsSteamId() == false) gender = "npc";
            else gender = "human";
            SomethingHappenedOnZone (ZoneID, player, "enter", gender);
        }

#region ON EXIT SPOT
        void OnExitZone(string ZoneID, BasePlayer player)
        {
             string gender;
            if (player.userID.IsSteamId() == false) gender = "npc";
            else gender = "human";
            SomethingHappenedOnZone (ZoneID, player, "exit", gender);
        }

#endregion

        void SomethingHappenedOnZone (string ZoneID, BasePlayer player, string reason, string gender)
        {

            //if (player.userID.IsSteamId() == false) return;           
//          string TimeIs = DateTime.Now.ToString("dd,hh,mm");
            string TimeIs = DateTime.Now.ToString();
string logstring = string.Empty;
string msg = string.Empty;
            if (reason =="enter")
            {
                logstring = $"{TimeIs} : {ZoneID} {lang.GetMessage("EnterPlayerMsg", this, player.UserIDString)} {player.displayName} {player.userID}";
                msg = $"<color={ChatColor}>{ZoneID} {lang.GetMessage("EnterPlayerMsg", this, player.UserIDString)} {player.displayName}</color>";
            }
            if (reason == "exit")
            {
                logstring = $"{TimeIs} : {ZoneID} {lang.GetMessage("ExitPlayerMsg", this, player.UserIDString)} {player.displayName} {player.userID}";
                msg = $"<color={ChatColor}>{ZoneID} {lang.GetMessage("ExitPlayerMsg", this, player.UserIDString)} {player.displayName}</color>";
            }
                foreach (var spotsofdaplugin in storedData.ulongdata)
                {
                    if (spotsofdaplugin.Value.playeronly && gender == "npc") return;
                    if (spotsofdaplugin.Value.playerspot == ZoneID)
                    {
                        if (debug == true) Puts($"-> LOGGED IN {ZoneID} : PLAYER {player.displayName}");

                        if (spotsofdaplugin.Value.playerchat)    
                        {
                            foreach(BasePlayer player2 in BasePlayer.activePlayerList)
                            {
                                if (player.userID == player2.userID)
                                {
                                    Player.Message(player2, msg,$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                                }
                            }
                        }
                        int count = spotsofdaplugin.Value.playerenter;
                        count = count + 1;
                        spotsofdaplugin.Value.playerenter = count;
                        spotsofdaplugin.Value.loglist.Add(logstring);
                        if (gender == "human" && reason == "enter") spotsofdaplugin.Value.playerenter = spotsofdaplugin.Value.playerenter + 1;
                        if (gender == "npc" && reason == "enter") spotsofdaplugin.Value.npcenter = spotsofdaplugin.Value.npcenter + 1;
                        if (gender == "human" && reason == "exit") spotsofdaplugin.Value.playerexit = spotsofdaplugin.Value.playerexit + 1;
                        if (gender == "npc" && reason == "exit") spotsofdaplugin.Value.npcexit = spotsofdaplugin.Value.npcexit + 1;
                        KeepHundred(ZoneID, spotsofdaplugin.Key);
                        return;
                    }
                }
        }

#endregion



#region PLAYERONLY PREF

        [ConsoleCommand("MySurveySpotPlayerOnly")]
        private void MySurveySpotOnly(ConsoleSystem.Arg arg)       
        {
                var player = arg.Connection.player as BasePlayer;
                    storedData.ulongdata[player.userID].playeronly = !storedData.ulongdata[player.userID].playeronly;
                    if (debug) Puts($"-> CHANGED NPC/HUMAN log preference");
                    CuiHelper.DestroyUi(player, SurveyPanel);             
                    SurveyCui(player, null, null);   
                    return;           

        }
#endregion

#region PLAYER CHAT PREF

        [ConsoleCommand("MySurveySpotChat")]
        private void MySurveySpotChat(ConsoleSystem.Arg arg)       
        {

                var player = arg.Connection.player as BasePlayer;
                    storedData.ulongdata[player.userID].playerchat = !storedData.ulongdata[player.userID].playerchat;
                    if (debug) Puts($"-> CHANGED NPC/HUMAN log preference");
                    CuiHelper.DestroyUi(player, SurveyPanel);             
                    SurveyCui(player, null, null);   
                    return;     

        }
#endregion

#region BACK TO PANEL

        [ConsoleCommand("MySurveySpotBackToPanel")]
        private void MySurveySpotBackTo(ConsoleSystem.Arg arg)       
        {
                var player = arg.Connection.player as BasePlayer;
                CuiHelper.DestroyUi(player, LogPanel);             
                SurveyCui(player, null, null);            
        }
#endregion

#region PURGE PLAYER LOG

        [ConsoleCommand("MySurveySpotPurgeMyLog")]
        private void MySurveySpotPurge(ConsoleSystem.Arg arg)       
        {
                var player = arg.Connection.player as BasePlayer;
            ulong playerID = player.userID;
            RemoveLog (storedData.ulongdata[player.userID].playerspot, player.userID);
                CuiHelper.DestroyUi(player, SurveyPanel);             
                SurveyCui(player, null, null);          
        }

        private void RemoveLog(string spot, ulong playerID)       
        {
                storedData.ulongdata[playerID].playerenter = 0;
                storedData.ulongdata[playerID].playerexit = 0;
                storedData.ulongdata[playerID].npcenter = 0;
                storedData.ulongdata[playerID].npcexit = 0;
                storedData.ulongdata[playerID].loglist.Clear();

                    if (debug == true) 
                        Puts($"-> PURGE LOG FROM SPOT {spot}");
        }
#endregion

#region LOG 100 LIMIT

        private void KeepHundred(string zoneID, ulong spotowner)       
        {
            List<string> thisloglist = storedData.ulongdata[spotowner].loglist;
            List<string> hundredloglist = new List<string>();

            int count = thisloglist.Count;
            if (count > 100)
            {
                int todel = count - 100;
                string[] logarray = thisloglist.ToArray(); 
                int Round = 1;
                int round = -1;
                for (Round = 1; Round <= todel ; Round++)            
                {
                    round = round + 1;
                    hundredloglist.Add(logarray[round]);
                }
                foreach (string value in hundredloglist)
                {
                    storedData.ulongdata[spotowner].loglist.Remove(value);
                }                    
            }
        }

#endregion

#region SPOTZONE

        [ConsoleCommand("MySurveySpotZone")]
        private void MySurveySpot(ConsoleSystem.Arg arg)       
        {

            var player = arg.Connection.player as BasePlayer;
            ulong playerID = player.userID;
            string playerIDstring = playerID.ToString();
            string playername = player.displayName;
            string shortplayerID = playerIDstring.Substring(10, 6);
            string shortplayername = playername;
            string spot;
            bool verify;
            var position = player.transform.position;
            if (shortplayername.Length > 8) shortplayername = shortplayername.Substring(0,8);
            if (ZoneManager == false)
                {
                    Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("ZMNeededMsg", this, player.UserIDString)}</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                    return;
                }
            string[] Flags;
            Flags = new string[] { "name", $"[SPOT]{shortplayername}", "enter_message" ,null, "radius", "5" };             

            if (string.IsNullOrEmpty(storedData.ulongdata[player.userID].playerspot) == true)
            {
                spot = $"999666{shortplayerID}";
                string checkingfirst = CheckZoneID(spot);  
                if (checkingfirst == spot)
                {
                    Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("ZoneAlreadyMsg", this, player.UserIDString)}</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                    return;
                }
                Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("SpotSetMsg", this, player.UserIDString)}</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                ZoneManager?.Call("CreateOrUpdateZone", $"{spot}", Flags, position);
                string checking = CheckZoneID(spot);  
                if (checking == spot) Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("SpotVerifMsg", this, player.UserIDString)}</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                if (checking == null)
                {
                    Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("SpotErrorMsg", this, player.UserIDString)}</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                    return;                    
                }
                storedData.ulongdata[player.userID].playerspot = spot;
                if (debug == true) Puts($"-> NEW SPOT {spot} from {shortplayername}");
                CuiHelper.DestroyUi(player, SurveyPanel);
                SurveyCui(player, null, null);
                return;
            }

            else
            {
                Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("SpotDstryMsg", this, player.UserIDString)}</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                spot = storedData.ulongdata[player.userID].playerspot;
                RemoveLog(spot, playerID);
                storedData.ulongdata[player.userID].playerspot = string.Empty;
                spot = $"999666{shortplayerID}";                
                ZoneManager?.Call("EraseZone", $"{spot}");
                if (debug == true) Puts($"-> REMOVED SPOT {spot} from {shortplayername}");
                CuiHelper.DestroyUi(player, SurveyPanel);
                SurveyCui(player, null, null);                
            }
       }



#endregion

#region PANEL MY SURVEY

        [ChatCommand("mysurvey")]
        private void SurveyCui(BasePlayer player, string command, string[] args)
        {
            ulong playerID = player.userID;
            string playername = player.displayName;
            string shortplayername = playername.Substring(0,8);

            var debutcolonnegauche = 0.05;
            var fincolonnegauche = 0.35;
            var debutcolonnemilieu = 0.37;
            var fincolonnemilieu = 0.58;
            var debutcolonnedroite = 0.60;
            var fincolonnedroite = 0.85;
            var debutcolonnemenu = 0.87;
            var fincolonnemenu = 0.98;

            string PanelColor = "1.0 0.8 0.5 0.5";
            string buttonColor = "1.0 0.8 0.5 0.8";
            string buttonCloseColor = "0.6 0.26 0.2 1";
            string statuscolor = "1.0 0.1 0.1 1";
            string idcolor = "1.0 0.1 0.1 1";
            string namecolor = "1.0 0.1 0.1 1";

            string Green = "0.5 1.0 0.0 1";
            //string Red = "1.0 0.1 0.1 1";

            string StatusSpot = "OFF";
            string buttononly = "NO";
            string buttonchat = "NO";

            string spot = "NONE";
            string spotname = "NONE";
            bool ChatMsg;
            //logpage = 1;
            //logpagestring = "from 001 to 025";
            reading.Remove(player.userID);
            reading.Add(player.userID, 1);

            int playerenter = 0;
            int playerexit = 0;      
            int npcenter = 0;
            int npcexit = 0;
            List<string> thisloglist = new List<string>();
            int logcount = 0;

            if (!storedData.ulongdata.ContainsKey(player.userID))
            {
                Dataz newdata = new Dataz {};
                storedData.ulongdata.Add(player.userID, newdata);
            }

                playerenter = storedData.ulongdata[player.userID].playerenter;
                playerexit = storedData.ulongdata[player.userID].playerexit;            
                npcenter = storedData.ulongdata[player.userID].npcenter;
                npcexit = storedData.ulongdata[player.userID].npcexit;

                if (storedData.ulongdata[player.userID].playeronly == true)
                {
                    buttononly = "YES";
                }

            if (storedData.ulongdata[player.userID].playerchat == true) buttonchat = "YES";
            thisloglist = storedData.ulongdata[player.userID].loglist;
            if (string.IsNullOrEmpty(storedData.ulongdata[player.userID].playerspot) == false)
            {  
                StatusSpot = "ON";
                spot = storedData.ulongdata[player.userID].playerspot;               
                statuscolor = Green;   
                idcolor = Green;
                namecolor = Green;
                spotname = $"[SPOT]{shortplayername}";
            }

            bool hasperm = permission.UserHasPermission(player.UserIDString, SurveyPermission);
            if (hasperm == false)
            {
                Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("NoPermMsg", this, player.UserIDString)}</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                return;
            }
            if (thisloglist.Count > 0) logcount = thisloglist.Count;
            var CuiElement = new CuiElementContainer();
            SurveyPanel = CuiElement.Add(new CuiPanel { Image = { Color = $"{PanelColor}"}, RectTransform = { AnchorMin = "0.25 0.25", AnchorMax = "0.75 0.8"}, CursorEnabled = true});
            var closeButton = new CuiButton { Button = { Close = SurveyPanel, Color = $"{buttonCloseColor}" },
                RectTransform = { AnchorMin = "0.85 0.85", AnchorMax = "0.95 0.95" },
                Text = { Text = "[X]\nClose", FontSize = 16, Align = TextAnchor.MiddleCenter }};
            CuiElement.Add(closeButton, SurveyPanel);
            var ButtonInfo = CuiElement.Add(new CuiButton
            {
                Button = { Command = "MySurveySpotLog", Color = $"0.0 0.5 1.0 0.5" },
                RectTransform = { AnchorMin = "0.73 0.85", AnchorMax = "0.83 0.95" },
                Text = { Text = $"LOG", Color = "0.8 1.0 1.0 1", FontSize = 14, Align = TextAnchor.MiddleCenter}
            }, SurveyPanel);
            var TextLineIntro1 = CuiElement.Add(new CuiLabel
            {
                Text = { Text = $"{lang.GetMessage("PanelSurveyMsg", this, player.UserIDString)}", FontSize = 30, Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"{debutcolonnegauche} 0.85", AnchorMax = $"0.71 0.95" }
            }, SurveyPanel);

            var TextLineIntro2 = CuiElement.Add(new CuiLabel
            {
                Text = { Text = $"<i>{lang.GetMessage("PanelSurveyUnderMsg", this, player.UserIDString)} {version}</i>", FontSize = 14, Align = TextAnchor.MiddleCenter},
                RectTransform = { AnchorMin = $"{debutcolonnegauche} 0.78", AnchorMax = $"0.71 0.84" }
            }, SurveyPanel);

            var TextLine1 = CuiElement.Add(new CuiLabel
            {
                Text = { Text = "YOUR SPOT IS :", Color = "0.0 0.0 0.0 1.0", FontSize = 18, Align = TextAnchor.MiddleRight},
                RectTransform = { AnchorMin = $"{debutcolonnegauche} 0.65", AnchorMax = $"{fincolonnegauche} 0.70"}
            }, SurveyPanel);

            var TextLine1b = CuiElement.Add(new CuiLabel
            {
                Text = { Text = "<i>Click to toggle ON/OFF your spot.</i>", Color = "0.0 0.0 0.0 1.0", FontSize = 12, Align = TextAnchor.MiddleLeft},
                RectTransform = { AnchorMin = $"{debutcolonnedroite} 0.65", AnchorMax = $"{fincolonnemenu} 0.70"}
            }, SurveyPanel);

            var ButtonLine1 = CuiElement.Add(new CuiButton
            {
                Button = { Command = "MySurveySpotZone", Color = $"{statuscolor}" },
                RectTransform = { AnchorMin = $"{debutcolonnemilieu} 0.65", AnchorMax = $"{fincolonnemilieu} 0.70" },
                Text = { Text = $"{StatusSpot}", Color = "0.0 0.0 0.0 1.0", FontSize = 18, Align = TextAnchor.MiddleCenter}
            }, SurveyPanel);

            var TextLine2 = CuiElement.Add(new CuiLabel
            {
                Text = { Text = "ZONE ID : ", Color = "0.0 0.0 0.0 1.0", FontSize = 18, Align = TextAnchor.MiddleRight },
                RectTransform = { AnchorMin = $"{debutcolonnegauche} 0.55",
                    AnchorMax = $"{fincolonnegauche} 0.60"
                }
            }, SurveyPanel);

            var ButtonLine2 = CuiElement.Add(new CuiButton
            {
                Button =
                {
                    Command = "",
                    Color = $"{idcolor}"
                },
                RectTransform =
                {
                    AnchorMin = $"{debutcolonnemilieu} 0.55",
                    AnchorMax = $"{fincolonnemilieu} 0.60"
                },
                Text =
                {
                    Text = $"{spot}",
                    Color = "0.0 0.0 0.0 1.0",
                    FontSize = 14,
                    Align = TextAnchor.MiddleCenter
                }
            }, SurveyPanel);

            var ButtonLine2b = CuiElement.Add(new CuiButton
            {
                Button =
                {
                    Command = "",
                    Color = $"{buttonColor}"
                },
                Text =
                {
                    Text = $"** TOTAL ** PLAYER : {playerenter} ENTER / {playerexit} EXIT **",
                    Color = "0.0 0.0 0.0 1.0",
                    FontSize = 12,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = $"{debutcolonnedroite} 0.55",
                    AnchorMax = $"{fincolonnemenu} 0.60"
                }
            }, SurveyPanel);

            var TextLine3 = CuiElement.Add(new CuiLabel
            {
                Text =
                {
                    Text = "ZONE NAME : ",
                    Color = "0.0 0.0 0.0 1.0",
                    FontSize = 18,
                    Align = TextAnchor.MiddleRight
                },
                RectTransform =
                {
                    AnchorMin = $"{debutcolonnegauche} 0.45",
                    AnchorMax = $"{fincolonnegauche} 0.50"
                }
            }, SurveyPanel);

            var ButtonLine3 = CuiElement.Add(new CuiButton
            {
                Button =
                {
                    Command = "",
                    Color = $"{namecolor}"
                },
                RectTransform =
                {
                    AnchorMin = $"{debutcolonnemilieu} 0.45",
                    AnchorMax = $"{fincolonnemilieu} 0.50"
                },
                Text =
                {
                    Text = $"{spotname}",
                    Color = "0.0 0.0 0.0 1.0",
                    FontSize = 12,
                    Align = TextAnchor.MiddleCenter
                }
            }, SurveyPanel);

            var ButtonLine3b = CuiElement.Add(new CuiButton
            {
                Button =
                {
                    Command = "",
                    Color = $"{buttonColor}"
                },
                Text =
                {
                    Text = $"** TOTAL ** NPC : {npcenter} ENTER / {npcexit} EXIT **",
                    Color = "0.0 0.0 0.0 1.0",
                    FontSize = 12,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = $"{debutcolonnedroite} 0.45",
                    AnchorMax = $"{fincolonnemenu} 0.50"
                }
            }, SurveyPanel);

            var TextLine4 = CuiElement.Add(new CuiLabel
            {
                Text =
                {
                    Text = "ENTRIES IN YOUR LOG :",
                    Color = "0.0 0.0 0.0 1.0",
                    FontSize = 16,
                    Align = TextAnchor.MiddleRight
                },
                RectTransform =
                {
                    AnchorMin = $"{debutcolonnegauche} 0.35",
                    AnchorMax = $"{fincolonnegauche} 0.40"
                }
            }, SurveyPanel);

            var TextLine4b = CuiElement.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = $"{debutcolonnedroite} 0.35",
                    AnchorMax = $"{fincolonnemenu} 0.40"
                },
                Text =
                {
                    Text = $"<i>LOG will display 100 last records.</i>",
                    Color = "0.0 0.0 0.0 1.0",
                    FontSize = 12, 
                    Align = TextAnchor.MiddleLeft
                }
            }, SurveyPanel);

            var ButtonLine4 = CuiElement.Add(new CuiButton
            {
                Button =
                {
                    Command = "",
                    Color = $"{buttonColor}"
                },
                RectTransform =
                {
                    AnchorMin = $"{debutcolonnemilieu} 0.35",
                    AnchorMax = $"{fincolonnemilieu} 0.40"
                },
                Text =
                {
                    Text = $"{logcount.ToString()} / 100",
                    Color = "0.0 0.0 0.0 1.0",
                    FontSize = 16, 
                    Align = TextAnchor.MiddleCenter
                }
            }, SurveyPanel);



            var TextLine5 = CuiElement.Add(new CuiLabel
            {
                Text =
                {
                    Text = "CLEAN YOUR LOG :",
                    Color = "0.0 0.0 0.0 1.0",
                    FontSize = 16,
                    Align = TextAnchor.MiddleRight
                },
                RectTransform =
                {
                    AnchorMin = $"{debutcolonnegauche} 0.25",
                    AnchorMax = $"{fincolonnegauche} 0.30"
                }
            }, SurveyPanel);

            var TextLine5b = CuiElement.Add(new CuiLabel
            {
                Text =
                {
                    Text = "<i>Click to clean your log</i>",
                    Color = "0.0 0.0 0.0 1.0",
                    FontSize = 12,
                    Align = TextAnchor.MiddleLeft
                },
                RectTransform =
                {
                    AnchorMin = $"{debutcolonnedroite} 0.25",
                    AnchorMax = $"{fincolonnemenu} 0.30"
                }
            }, SurveyPanel);

            var ButtonLine5 = CuiElement.Add(new CuiButton
            {
                Button =
                {
                    Command = "MySurveySpotPurgeMyLog",
                    Color = $"{buttonColor}"
                },
                RectTransform =
                {
                    AnchorMin = $"{debutcolonnemilieu} 0.25",
                    AnchorMax = $"{fincolonnemilieu} 0.30"
                },
                Text =
                {
                    Text = "PURGE NOW",
                    Color = "1.0 0.1 0.1 1.0",
                    FontSize = 16, 
                    Align = TextAnchor.MiddleCenter
                }
            }, SurveyPanel);

            var TextLine6 = CuiElement.Add(new CuiLabel
            {
                Text =
                {
                    Text = "NOTIFY IN CHAT :",
                    Color = "0.0 0.0 0.0 1.0",
                    FontSize = 16,
                    Align = TextAnchor.MiddleRight
                },
                RectTransform =
                {
                    AnchorMin = $"{debutcolonnegauche} 0.15",
                    AnchorMax = $"{fincolonnegauche} 0.20"
                }
            }, SurveyPanel);

            var TextLine6b = CuiElement.Add(new CuiLabel
            {
                Text =
                {
                    Text = "<i>Chat message at enter/exit of your spot</i>",
                    Color = "0.0 0.0 0.0 1.0",
                    FontSize = 12,
                    Align = TextAnchor.MiddleLeft
                },
                RectTransform =
                {
                    AnchorMin = $"{debutcolonnedroite} 0.15",
                    AnchorMax = $"{fincolonnemenu} 0.20"
                }
            }, SurveyPanel);

            var ButtonLine6 = CuiElement.Add(new CuiButton
            {
                Button =
                {
                    Command = "MySurveySpotChat",
                    Color = $"{buttonColor}"
                },
                RectTransform =
                {
                    AnchorMin = $"{debutcolonnemilieu} 0.15",
                    AnchorMax = $"{fincolonnemilieu} 0.20"
                },
                Text =
                {
                    Text = $"{buttonchat}",
                    Color = "0.0 0.0 0.0 1.0",
                    FontSize = 16, 
                    Align = TextAnchor.MiddleCenter
                }
            }, SurveyPanel);

            var TextLine7 = CuiElement.Add(new CuiLabel
            {
                Text =
                {
                    Text = "LOG & CHAT REAL PLAYERS ONLY :",
                    Color = "0.0 0.0 0.0 1.0",
                    FontSize = 12,
                    Align = TextAnchor.MiddleRight
                },
                RectTransform =
                {
                    AnchorMin = $"{debutcolonnegauche} 0.05",
                    AnchorMax = $"{fincolonnegauche} 0.10"
                }
            }, SurveyPanel);

            var TextLine7b = CuiElement.Add(new CuiLabel
            {
                Text =
                {
                    Text = "<i> NPC & PLAYER or PLAYER only</i>",
                    Color = "0.0 0.0 0.0 1.0",
                    FontSize = 12,
                    Align = TextAnchor.MiddleLeft
                },
                RectTransform =
                {
                    AnchorMin = $"{debutcolonnedroite} 0.05",
                    AnchorMax = $"{fincolonnemenu} 0.10"
                }
            }, SurveyPanel);

            var ButtonLine7 = CuiElement.Add(new CuiButton
            {
                Button =
                {
                    Command = "MySurveySpotPlayerOnly",
                    Color = $"{buttonColor}"
                },
                RectTransform =
                {
                    AnchorMin = $"{debutcolonnemilieu} 0.05",
                    AnchorMax = $"{fincolonnemilieu} 0.10"
                },
                Text =
                {
                    Text = $"{buttononly}",
                    Color = "0.0 0.0 0.0 1.0",
                    FontSize = 16, 
                    Align = TextAnchor.MiddleCenter
                }
            }, SurveyPanel);

            CuiHelper.AddUi(player, CuiElement);
        }

#endregion

#region LOGPAGE

        [ConsoleCommand("SurveyMySpotPage1")]
        private void SurveyMySpotPage1(ConsoleSystem.Arg arg) 
        {
           var player = arg.Connection.player as BasePlayer;
                reading.Remove(player.userID);
                reading.Add(player.userID, 1);
                if (debug == true) Puts($"-> LOG PAGE 1");
                CuiHelper.DestroyUi(player, LogPanel);             
                MySurveyLog(arg);   
        }
        [ConsoleCommand("SurveyMySpotPage2")]

        private void SurveyMySpotPage2(ConsoleSystem.Arg arg) 
        {
           var player = arg.Connection.player as BasePlayer;
                reading.Remove(player.userID);
                reading.Add(player.userID, 2);
                    if (debug == true)    
                    {
                        Puts($"-> LOG PAGE 2");
                    }
                CuiHelper.DestroyUi(player, LogPanel);             
                MySurveyLog(arg);   
        }
        [ConsoleCommand("SurveyMySpotPage3")]

        private void SurveyMySpotPage3(ConsoleSystem.Arg arg) 
        {
           var player = arg.Connection.player as BasePlayer;
                reading.Remove(player.userID);
                reading.Add(player.userID, 3);
                    if (debug == true)    
                    {
                        Puts($"-> LOG PAGE 3");
                    }
                CuiHelper.DestroyUi(player, LogPanel);             
                MySurveyLog(arg);   
        }

        [ConsoleCommand("SurveyMySpotPage4")]
        private void SurveyMySpotPage4(ConsoleSystem.Arg arg) 
        {
           var player = arg.Connection.player as BasePlayer;
                reading.Remove(player.userID);
                reading.Add(player.userID, 4);
                    if (debug == true)    
                    {
                        Puts($"-> LOG PAGE 4");
                    }
                CuiHelper.DestroyUi(player, LogPanel);             
                MySurveyLog(arg);   
        }
#endregion

#region LOG PANEL

        [ConsoleCommand("MySurveySpotLog")]
        private void MySurveyLog(ConsoleSystem.Arg arg) 
        {
            Interface.Oxide.DataFileSystem.WriteObject("SurveyMySpot", storedData);

            var player = arg.Connection.player as BasePlayer;
            ulong playerID = player.userID;
            string playerIDstring = playerID.ToString();
            string playername = player.displayName;
            string shortplayerID = playerIDstring.Substring(10, 6);
            string shortplayername = playername.Substring(0,8);
            string spot = $"999666{shortplayerID}";

            var debutcolonnegauche = 0.05;
            var fincolonnegauche = 0.35;
            var debutcolonnemilieu = 0.37;
            var fincolonnemilieu = 0.58;
            var debutcolonnedroite = 0.60;
            var fincolonnedroite = 0.85;
            var debutcolonnemenu = 0.87;
            var fincolonnemenu = 0.98;

            string PanelColor = "0.5 0.5 0.5 0.5";
            string buttonCloseColor = "0.6 0.26 0.2 1";

            string logdisplayold;
            string logdisplay = "";
            string logdisplay1 = "";
            string logdisplay2 = "";
            string logdisplay3 = "";
            string logdisplay4 = "";

            List<string> thisloglist = storedData.ulongdata[player.userID].loglist;
            
            string[] logarray;
            logarray = thisloglist.ToArray();

            int logline = thisloglist.Count;
            int logline1;
            int logline2;
            int logline3;
            int logline4;
            int logpage = 1;
            string logpagestring = string.Empty;

            int Round = 1;
            int round = logline;

            if (logline <= 25)
            {

                for (Round = 1; Round <= logline ; Round++)            
                {
                    round = round - 1;
                    logdisplayold = $"{logarray[round]}";
                    logdisplay1 = $"{logdisplay1}\n{logdisplayold}";
                }
            }
          if (logline > 25)
            {
                logline1 = 25;
                logline2 = logline - 25;
                logline3 = logline - 50;
                logline4 = logline - 75;

                for (Round = 1; Round <= logline1 ; Round++)            
                {
                    round = round - 1;
                    logdisplayold = $"{logarray[round]}";
                    logdisplay1 = $"{logdisplay1}\n{logdisplayold}";
                }

                int round2 = logline2;

                for (Round = 1; Round <= logline2 ; Round++)            
                {
                    round2 = round2 - 1;
                    logdisplayold = $"{logarray[round2]}";
                    logdisplay2 = $"{logdisplay2}\n{logdisplayold}";
                }

                if (logline >50)
                {
                    int round3 = logline3;

                    for (Round = 1; Round <= logline3 ; Round++)            
                    {
                        round3 = round3 - 1;
                        logdisplayold = $"{logarray[round3]}";
                        logdisplay3 = $"{logdisplay3}\n{logdisplayold}";
                    }

                    if (logline >75)
                    {
                        int round4 = logline4;

                        if (logline >100)
                        {
                            logline4 = 25;
                        }
                        for (Round = 1; Round <= logline4 ; Round++)            
                        {
                            round4 = round4 - 1;
                            logdisplayold = $"{logarray[round4]}";
                            logdisplay4 = $"{logdisplay4}\n{logdisplayold}";
                        }

                    }
                }
            }
            if (reading.ContainsKey(player.userID))
            {
                reading.TryGetValue(player.userID, out logpage);
            }
            if (logpage == 1)
            {
                logdisplay = logdisplay1;
                logpagestring = "from 001 to 025";
            }
            if (logpage == 2)
            {
                logdisplay = logdisplay2;
                logpagestring = "from 025 to 050";
            }
            if (logpage == 3)
            {
                logdisplay = logdisplay3;
                logpagestring = "from 050 to 075";

            }
            if (logpage == 4)
            {
                logdisplay = logdisplay4;
                logpagestring = "from 075 to 100";

            }

            CuiHelper.DestroyUi(player, SurveyPanel);

            var CuiElement = new CuiElementContainer();

            LogPanel = CuiElement.Add(new CuiPanel

            {
                Image =
                {
                    //Color = "0.1 0.1 0.1 1"
                    Color = $"{PanelColor}"
                },
                RectTransform =
                {
                    AnchorMin = "0.25 0.25",
                    AnchorMax = "0.75 0.8"
                },
                CursorEnabled = true
            });

            var closeButton = new CuiButton
            {
                Button =
                {
                    Close = LogPanel,
                    Color = $"{buttonCloseColor}"
                },
                RectTransform =
                {
                    AnchorMin = "0.85 0.85",
                    AnchorMax = "0.95 0.95"
                },
                Text =
                {
                    Text = "[X]\nClose",
                    FontSize = 16,
                    Align = TextAnchor.MiddleCenter
                }
            };

            CuiElement.Add(closeButton, LogPanel);

            var ButtonInfo = CuiElement.Add(new CuiButton
            {
                Button =
                {
                    Command = "MySurveySpotBackToPanel",
                    Color = $"0.0 0.5 1.0 0.5"
                },
                RectTransform =
                {
                    AnchorMin = "0.73 0.85",   
                    AnchorMax = "0.83 0.95"
                },
                Text =
                {
                    Text = $"BACK",
                    Color = "0.8 1.0 1.0 1",
                    FontSize = 14,
                    Align = TextAnchor.MiddleCenter
                }
            }, LogPanel);

            var Page1 = CuiElement.Add(new CuiButton
            {
                Button =
                {
                    Command = "SurveyMySpotPage1",
                    Color = "0.25 0.25 0.65 0.5"
                },
                RectTransform =
                {
                    AnchorMin = "0.73 0.80",   
                    AnchorMax = "0.83 0.84"
                },
                Text =
                {
                    Text = $"001->025",
                    Color = "0.8 1.0 1.0 1",
                    FontSize = 14,
                    Align = TextAnchor.MiddleCenter
                }
            }, LogPanel);

            var Page2 = CuiElement.Add(new CuiButton
            {
                Button =
                {
                    Command = "SurveyMySpotPage2",
                    Color = "0.25 0.25 0.65 0.5"
                },
                RectTransform =
                {
                    AnchorMin = "0.85 0.80",   
                    AnchorMax = "0.95 0.84"
                },
                Text =
                {
                    Text = $"025->050",
                    Color = "0.8 1.0 1.0 1",
                    FontSize = 14,
                    Align = TextAnchor.MiddleCenter
                }
            }, LogPanel);

            var Page3 = CuiElement.Add(new CuiButton
            {
                Button =
                {
                    Command = "SurveyMySpotPage3",
                    Color = "0.25 0.25 0.65 0.5"
                },
                RectTransform =
                {
                    AnchorMin = "0.73 0.75",   
                    AnchorMax = "0.83 0.79"
                },
                Text =
                {
                    Text = $"050->075",
                    Color = "0.8 1.0 1.0 1",
                    FontSize = 14,
                    Align = TextAnchor.MiddleCenter
                }
            }, LogPanel);

            var Page4 = CuiElement.Add(new CuiButton
            {
                Button =
                {
                    Command = "SurveyMySpotPage4",
                    Color = "0.25 0.25 0.65 0.5"
                },
                RectTransform =
                {
                    AnchorMin = "0.85 0.75",   
                    AnchorMax = "0.95 0.79"
                },
                Text =
                {
                    Text = $"075->100",
                    Color = "0.8 1.0 1.0 1",
                    FontSize = 14,
                    Align = TextAnchor.MiddleCenter
                }
            }, LogPanel);


            var TextLineIntro1 = CuiElement.Add(new CuiLabel
            {
                Text =
                {
                    Text = "MY SURVEY SPOT PANEL",
                    FontSize = 30,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = $"{debutcolonnegauche} 0.85",   
                    AnchorMax = $"0.71 0.95"
                }
            }, LogPanel);

            var TextLineIntro2 = CuiElement.Add(new CuiLabel
            {
                Text =
                {
                    Text = $"<i>Watch your Spot' Log {logpagestring}</i>",
                    FontSize = 14,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = $"{debutcolonnegauche} 0.78",   
                    AnchorMax = $"0.71 0.84"
                }
            }, LogPanel);

            var TextLine1 = CuiElement.Add(new CuiLabel
            {
                Text =
                {
                    Text = $"{logdisplay}",
                    FontSize = 10,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = $"0.01 0.01",   
                    AnchorMax = $"0.99 0.73"
                }
            }, LogPanel);

            CuiHelper.AddUi(player, CuiElement);
        }
#endregion

    }
}

// --- End of file: SurveyMySpot.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/simple-time ---
// --- Original File Path: S/SimpleTime/SimpleTime.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Core;
using System;
using System.Text;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Simple Time", "MadKingCraig", "1.1.2")]
    [Description("Provides a chat command for the current game time")]
    public class SimpleTime : RustPlugin
    {
        private bool _initialized;
        private int _componentSearchAttempts;

        private const string CanUsePermission = "simpletime.use";

        #region Oxide Hooks
        private void Init()
        {
            permission.RegisterPermission(CanUsePermission, this);
        }

        private void Loaded()
        {
            _initialized = false;
        }

        private void OnServerInitialized()
        {
            if (TOD_Sky.Instance == null)
            {
                _componentSearchAttempts++;
                if (_componentSearchAttempts < 10)
                    timer.Once(1, OnServerInitialized);
                else
                    PrintWarning("Could not find required component after 10 attempts. Plugin disabled");
                return;
            }
            if (TOD_Sky.Instance.Components.Time == null)
            {
                PrintWarning("Could not fetch time component. Plugin disabled");
                return;
            }

            _initialized = true;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Time"] = "Current Time: {0}",
                ["NoPermission"] = "You do not have permission to use this command."
            }, this);
        }
        #endregion

        #region Hooks
        [HookMethod("GetSimpleTime")]
        public string GetSimpleTime()
        {
            return TOD_Sky.Instance.Cycle.DateTime.ToString("HH:mm");
        }
        #endregion

        #region Commands
        [ChatCommand("time")]
		private void TimeCommand(BasePlayer player, string command, string[] args)
		{
            if (!_initialized)
                return;

            string PlayerID = player.UserIDString;

            if (!permission.UserHasPermission(PlayerID, CanUsePermission))
            {
                SendReply(player, lang.GetMessage("NoPermission", this, PlayerID));
                return;
            }

            string currentTime = TOD_Sky.Instance.Cycle.DateTime.ToString("HH:mm");
            SendReply(player, string.Format(lang.GetMessage("Time", this, PlayerID), currentTime));
        }
        #endregion
    }
}


// --- End of file: SimpleTime.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/simple-bradley-kill-feed ---
// --- Original File Path: S/SimpleBradleyKillFeed/SimpleBradleyKillFeed.cs ---

using System;
using UnityEngine.Networking;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Simple Bradley Kill Feed", "chrome", "1.0.2")]
    [Description("Logs who killed bradley to a webhook.")]
    public class SimpleBradleyKillFeed : RustPlugin
    {
        private DynamicConfigFile _config;
        private string _webhookurl;

        public class PluginConfig
        {
            [JsonProperty("webhookurl")]
            public string WebhookUrl { get; set; }
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(new PluginConfig { WebhookUrl = "https://discord.com/api/webhooks/your_webhook_url" }, true);
        }

        private void Init()
        {
            Unsubscribe(nameof(OnEntityDeath));
        }

        private void OnServerInitialized()
        {
            var config = Config.ReadObject<PluginConfig>();
            _webhookurl = config.WebhookUrl;

            if (_webhookurl != "https://discord.com/api/webhooks/your_webhook_url")
            {
                Subscribe(nameof(OnEntityDeath));
            }
        }

        private void OnEntityDeath(BradleyAPC entity, HitInfo info)
        {
            var player = info?.InitiatorPlayer;
            {
                SendDiscordEmbed(player);
            }
        }

        private void SendDiscordEmbed(BasePlayer player)
        {
            if (player != null)
            {
                var json = $"{{\"content\":\"{player.displayName} ({player.UserIDString}) has just destroyed Bradley!\"}}";
                var request = new UnityWebRequest(_webhookurl, "POST");
                byte[] jsonToSend = new System.Text.UTF8Encoding().GetBytes(json);
                request.uploadHandler = new UploadHandlerRaw(jsonToSend);
                request.downloadHandler = new DownloadHandlerBuffer();
                request.SetRequestHeader("Content-Type", "application/json");
                request.SendWebRequest();
                if (request.isNetworkError || request.isHttpError)
                {
                    PrintError("Error sending webhook: " + request.error);
                }
            }
        }
    }
}


// --- End of file: SimpleBradleyKillFeed.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/stack-item-storage ---
// --- Original File Path: S/StackItemStorage/StackItemStorage.cs ---

//Requires: StackModifier

using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Core.Plugins;

/*
 * Credits
 * Original Author/Creator Garsia up to 1.0.3
 * Current Maintainer Khan
 */

/*
 * Todo
 * Add checks for when they reduce the storage sizes it drops excess items or stacks them higher.
 * If they set it back to -1 i need to reset the storages back to the correct panel names etc.
 */

/*
 * This update 1.0.4
 * Seperated into 2 lists to fix slot number issues with other storages
 * Added displayname info this can be names anything if adding new ones.
 * Bug fixes
 *
 * This update 1.0.5
 * Added Backpack Support
 * Removed Additional Hook.
 * Now only relies on 1 hook to function
 *
 * Patch For Rust Update
 * 
 * Patch For Rust Update
 */

namespace Oxide.Plugins
{
    [Info("Stack Item Storage", "Khan", "1.0.8")]
    [Description("Change specific item stack capacity on specific storages.")]
    class StackItemStorage : RustPlugin
    {
        #region Fields

        [PluginReference] private Plugin StackModifier;

        private Configuration _config;
        private const string BackpackPrefab = "assets/prefabs/player/player.prefab";
        private Dictionary<ulong, int> _itemStack = new Dictionary<ulong, int>();
        private Dictionary<string, string> _include = new Dictionary<string, string>
        {
            ["assets/prefabs/player/player.prefab"] = "Backpack",
            ["assets/prefabs/deployable/bbq/bbq.deployed.prefab"] = "Barbeque",
            //["assets/bundled/prefabs/static/bbq.static.prefab"] = "Barbeque static",
            ["assets/prefabs/deployable/campfire/campfire.prefab"] = "Camp Fire",
            //["assets/bundled/prefabs/static/campfire_static.prefab"] = "Camp Fire Static",
            ["assets/prefabs/misc/casino/slotmachine/slotmachinestorage.prefab"] = "Casino SlotMachines Storage",
            ["assets/prefabs/deployable/composter/composter.prefab"] = "Composter",
            ["assets/prefabs/misc/halloween/cursed_cauldron/cursedcauldron.deployed.prefab"] = "Cursed Cauldron",
            ["assets/prefabs/deployable/dropbox/dropbox.deployed.prefab"] = "Drop Box",
            ["assets/bundled/prefabs/radtown/foodbox.prefab"] = "Food Box",
            ["assets/prefabs/deployable/fridge/fridge.deployed.prefab"] = "Fridge",
            ["assets/prefabs/misc/xmas/giftbox/giftbox_loot.prefab"] = "Gift Box",
            ["assets/prefabs/deployable/hitch & trough/hitchtrough.deployed.prefab"] = "Hitch & Trough",
            ["assets/prefabs/misc/twitch/hobobarrel/hobobarrel.deployed.prefab"] = "Hobo Barrel",
           // ["assets/bundled/prefabs/static/hobobarrel_static.prefab"] = "Hobo Barrel static",
            ["assets/prefabs/vehicle/seats/saddletest.prefab"] = "Horse Inventory", //??
            ["assets/prefabs/deployable/furnace.large/furnace.large.prefab"] = "Large Furnace",
            ["assets/prefabs/deployable/furnace/furnace.prefab"] = "Small Furnace",
            //["assets/bundled/prefabs/static/furnace_static.prefab"] = "Static Furnace",
            ["assets/prefabs/deployable/planters/planter.large.deployed.prefab"] = "Large Planter Box",
            ["assets/prefabs/deployable/planters/planter.small.deployed.prefab"] = "Small Planter Box",
            ["assets/prefabs/misc/xmas/stockings/stocking_large_deployed.prefab"] = "SUPER Stocking",
            ["assets/prefabs/misc/xmas/stockings/stocking_small_deployed.prefab"] = "Small Stocking",
            ["assets/prefabs/deployable/tool cupboard/cupboard.tool.deployed.prefab"] = "Tool Cupboard",
            ["assets/prefabs/deployable/small stash/small_stash_deployed.prefab"] = "Small Stash",
            ["assets/prefabs/deployable/locker/locker.deployed.prefab"] = "Locker",
            ["assets/prefabs/deployable/mailbox/mailbox.deployed.prefab"] = "Mail Box",
            ["assets/prefabs/deployable/mixingtable/mixingtable.deployed.prefab"] = "Mixing Table",
            ["assets/prefabs/npc/sam_site_turret/sam_site_turret_deployed.prefab"] = "Sam Site Turret", //???
            ["assets/prefabs/npc/sam_site_turret/rocket_sam.prefab"] = "Sam Site Rocket",
            ["assets/prefabs/deployable/single shot trap/guntrap.deployed.prefab"] = "Shotgun Trap",
            ["assets/prefabs/misc/halloween/skull_fire_pit/skull_fire_pit.prefab"] = "Skull Fire Pit",
            ["assets/prefabs/deployable/oil refinery/refinery_small_deployed.prefab"] = "Small Oil Refinery", //think this is correct?? idk if it works?
            //["assets/bundled/prefabs/static/small_refinery_static.prefab"] = "Small Oil Refinery Static",
            ["assets/prefabs/deployable/survivalfishtrap/survivalfishtrap.deployed.prefab"] = "Survival Fish Trap",
            ["assets/prefabs/deployable/vendingmachine/vendingmachine.deployed.prefab"] = "Vending Machine",
            ["assets/prefabs/deployable/liquidbarrel/waterbarrel.prefab"] = "Water Barrel",
            ["assets/prefabs/weapons/waterbucket/waterbucket.entity.prefab"] = "Water Bucket", //??
            ["assets/prefabs/food/water jug/waterjug.entity.prefab"] = "Water Jug", //???
            ["assets/prefabs/misc/xmas/snow_machine/models/snowmachine.prefab"] = "Snow Machine",
            ["assets/prefabs/misc/halloween/pumpkin_bucket/pumpkin_basket.entity.prefab"] = "Pumpkin Basket"
        };
        private Dictionary<string, string> _includeSpecial = new Dictionary<string, string>
        {
            ["assets/prefabs/misc/halloween/coffin/coffinstorage.prefab"] = "Coffin",
            ["assets/prefabs/deployable/large wood storage/box.wooden.large.prefab"] = "Large Box",
            ["assets/prefabs/deployable/woodenbox/woodbox_deployed.prefab"] = "Wood Box",
        };

        #endregion
        
        #region Classes
        private class ItemMaxStack
        {
            public string ShortName;
            public int MaxStackSize;
            public ItemMaxStack(string ShotName, int MaxStackSizes)
            {
                ShortName = ShotName;
                MaxStackSize = MaxStackSizes;
            }
        }
        private class Container
        {
            public string DisplayName;
            public List<ItemMaxStack> Items;
        }
        private class Container2
        {
            public string DisplayName;
            public int MaxCapacity;
            public List<ItemMaxStack> Items;
            public Container2()
            {
                MaxCapacity = -1;
            }
        }
        private class Configuration
        {
            [JsonProperty(PropertyName = "Customize Slot Sizes - Higher/Lower Storage Slots")]
            public Dictionary<string, Container2> ContainersSpecial;
            
            [JsonProperty(PropertyName = "Custom Stack Sizes per Container")]
            public Dictionary<string, Container> Containers;
        }

        #endregion

        #region Config
        private void CheckConfig()
        {
            foreach (var prefab in _includeSpecial)
            {
                string storageName = prefab.Key;

                Container2 storages;
                
                if (!_config.ContainersSpecial.TryGetValue(storageName, out storages))
                {
                    _config.ContainersSpecial[storageName] = storages = new Container2
                    {
                        DisplayName = prefab.Value
                    };
                    _config.ContainersSpecial[storageName].Items = new List<ItemMaxStack>();
                    _config.ContainersSpecial[storageName].Items.Add(new ItemMaxStack("shortname", -1));
                }
            }
         
            foreach (var prefab in _include)
            {
                string storageName = prefab.Key;

                Container storages;

                if (!_config.Containers.TryGetValue(storageName, out storages))
                {
                    _config.Containers[storageName] = storages = new Container
                    {
                        DisplayName = prefab.Value
                    };
                    _config.Containers[storageName].Items = new List<ItemMaxStack>();
                    _config.Containers[storageName].Items.Add(new ItemMaxStack("shortname", -1));
                }
            }
            
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            _config = new Configuration
            {
                ContainersSpecial = new Dictionary<string, Container2>(),
                Containers = new Dictionary<string, Container>()
            };
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();

            if (_config == null)
            {
                LoadDefaultConfig();
                SaveConfig();
            }
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        #endregion

        #region Hooks
        private void CheckStorage(StorageContainer T)
        {
            if (T == null || T.PrefabName == null) return;
            if (!_config.ContainersSpecial.ContainsKey(T.PrefabName) || _config.ContainersSpecial[T.PrefabName].MaxCapacity <= -1 ) return;
            T.inventory.capacity = _config.ContainersSpecial[T.PrefabName].MaxCapacity;
            T.panelName = "generic_resizable";
            if (T.inventory.capacity > 36)
            {
                T.panelName = "generic_resizable";
            }
            T.SendNetworkUpdate();
        }

        private void OnServerInitialized()
        {
            CheckConfig();
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                if (!(entity is StorageContainer)) continue;
                StorageContainer storage = (StorageContainer)entity;
                if (storage != null)
                {
                    CheckStorage(storage);
                }
            }
        }
        
        private int OnMaxStackable(Item item)
        {
            if (_itemStack.ContainsKey(item.uid.Value))
            {
                int t = _itemStack[item.uid.Value];
                _itemStack.Remove(item.uid.Value);
                return t;
            }

            if (item.parent?.entityOwner != null && item.info.itemType != ItemContainer.ContentsType.Liquid && !item.parent.HasFlag(ItemContainer.Flag.IsPlayer) && item?.GetRootContainer()?.entityOwner.PrefabName == BackpackPrefab)
            {
                if (_config.Containers.ContainsKey(BackpackPrefab))
                {
                    foreach (ItemMaxStack Item in _config.Containers[BackpackPrefab].Items)
                    {
                        if (Item.ShortName == item.info.shortname)
                        {
                            if (Item.MaxStackSize > -1)
                            {
                                item.GetRootContainer().maxStackSize = Item.MaxStackSize;
                            }
                        }
                    }
                }
            }
            
            if (item.parent != null && item.parent.entityOwner != null && item.parent.entityOwner.PrefabName != BackpackPrefab)
            {
                if (_config.Containers.ContainsKey(item.parent.entityOwner.name))
                {
                    foreach (ItemMaxStack Item in _config.Containers[item.parent.entityOwner.name].Items)
                    {
                        if (Item.ShortName == item.info.shortname)
                        {
                            if (Item.MaxStackSize > -1)
                            {
                                return Item.MaxStackSize;
                            }
                        }
                    }
                }
                if (_config.ContainersSpecial.ContainsKey(item.parent.entityOwner.name))
                {
                    foreach (ItemMaxStack Item in _config.ContainersSpecial[item.parent.entityOwner.name].Items)
                    {
                        if (Item.ShortName == item.info.shortname)
                        {
                            if (Item.MaxStackSize > -1)
                            {
                                return Item.MaxStackSize;
                            }
                        }
                    }
                }
            }

            int num = item.info.stackable;
            if (item.parent != null && item.parent.maxStackSize > 0)
            {
                num = Mathf.Min(item.parent.maxStackSize, num);
            }
            return num;
        }
        
        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            StorageContainer T = go.GetComponent<StorageContainer>();
            CheckStorage(T);
        }

        #endregion

    }
}

// --- End of file: StackItemStorage.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/spawns-database ---
// --- Original File Path: S/Spawns/Spawns.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Newtonsoft.Json.Converters;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Spawns", "Reneb / k1lly0u", "2.0.36"), Description("A database of sets of spawn points, created by a user and used by other plugins")]
    class Spawns : RustPlugin
    {
        #region Fields
        private SpawnsData _spawnsData;

        private Dictionary<string, List<Vector3>> _loadedSpawnfiles = new Dictionary<string, List<Vector3>>();

        private Dictionary<ulong, List<Vector3>> _spawnFileCreators = new Dictionary<ulong, List<Vector3>>();

        private List<ulong> _isEditing = new List<ulong>();
        #endregion

        #region Oxide Hooks
        private void Loaded() => LoadData();
        
        protected override void LoadDefaultMessages() => lang.RegisterMessages(Messages, this);

        private void OnServerInitialized() => VerifyFilesExist();
        #endregion

        #region Functions
        private void VerifyFilesExist()
        {
            bool hasChanged = false;
            for (int i = 0; i < _spawnsData.Spawnfiles.Count; i++)
            {
                string name = _spawnsData.Spawnfiles[i];

                if (!Interface.Oxide.DataFileSystem.ExistsDatafile($"SpawnsDatabase/{name}"))
                {
                    _spawnsData.Spawnfiles.Remove(name);
                    hasChanged = true;
                } 
                else 
                {                    
                    if (LoadSpawns(name) != null)
                    {
                        _spawnsData.Spawnfiles.Remove(name);
                        hasChanged = true;
                    }
                    else if (_loadedSpawnfiles[name].Count == 0)
                    {
                        _spawnsData.Spawnfiles.Remove(name);
                        hasChanged = true;
                    }
                }               
            }

            if (hasChanged)
                SaveData();
        }
        
        private object LoadSpawns(string name)
        {
            if (string.IsNullOrEmpty(name))
                return Message("noFile");

            if (!_loadedSpawnfiles.ContainsKey(name))
            {                
                object success = LoadSpawnFile(name);
                if (success == null)                
                    return Message("noFile");                
                else _loadedSpawnfiles.Add(name, (List<Vector3>)success);
            }
            return null;
        }
        #endregion

        #region API
        private object GetSpawnsCount(string filename)
        {
            object success = LoadSpawns(filename);
            if (success != null)
                return (string)success;

            return _loadedSpawnfiles[filename].Count;
        }

        private object GetRandomSpawn(string filename)
        {
            object success = LoadSpawns(filename);
            if (success != null)
                return (string)success;

            return _loadedSpawnfiles[filename].GetRandom();
        }

        private object GetRandomSpawnRange(string filename, int min, int max)
        {
            object success = LoadSpawns(filename);
            if (success != null)
                return (string)success;

            List<Vector3> list = _loadedSpawnfiles[filename];

            return list[UnityEngine.Random.Range(Mathf.Clamp(min, 0, list.Count - 1), Mathf.Clamp(max, 0, list.Count - 1))];
        }

        private object GetSpawn(string filename, int number)
        {
            object success = LoadSpawns(filename);
            if (success != null)
                return (string)success;

            List<Vector3> list = _loadedSpawnfiles[filename];

            return list[Mathf.Clamp(number, 0, list.Count - 1)];
        }

        private string[] GetSpawnfileNames() => _spawnsData.Spawnfiles.ToArray();
        #endregion

        #region Chat Commands
        [ChatCommand("spawns")]
        void cmdSpawns(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < 1)
            {
                SendReply(player, Message("noAccess", player.UserIDString));
                return;
            }
           
            if (args == null || args.Length == 0)
            {
                SendHelpText(player);
                return;
            }

            if (args.Length >= 1)
            {
                switch (args[0].ToLower())
                {
                    case "new":
                        if (IsCreatingFile(player))
                        {
                            SendReply(player, Message("alreadyCreating", player.UserIDString));
                            return;
                        }

                        _spawnFileCreators.Add(player.userID, new List<Vector3>());

                        SendReply(player, Message("newCreating", player.UserIDString));
                        return;

                    case "open":
                        if (args.Length >= 2)
                        {
                            if (IsCreatingFile(player))
                            {
                                SendReply(player, Message("isCreating", player.UserIDString));
                                return;
                            }
                            object spawns = LoadSpawnFile(args[1]);
                            if (spawns != null)
                            {
                                _spawnFileCreators.Add(player.userID, (List<Vector3>)spawns);
                                SendReply(player, string.Format(Message("opened", player.UserIDString), _spawnFileCreators[player.userID].Count));
                                _isEditing.Add(player.userID);
                            }
                            else SendReply(player, Message("invalidFile", player.UserIDString));                            
                        }
                        else SendReply(player, Message("fileName", player.UserIDString));
                        return;

                    case "add":
                        if (!IsCreatingFile(player))
                        {
                            SendReply(player, Message("notCreating", player.UserIDString));
                            return;
                        }
                        else
                        {                            
                            _spawnFileCreators[player.userID].Add(player.transform.position);
                            int number = _spawnFileCreators[player.userID].Count;
                            DDrawPosition(player, _spawnFileCreators[player.userID][number - 1], number.ToString());
                            SendReply(player, string.Format("Added Spawn n°{0}", _spawnFileCreators[player.userID].Count));
                        }
                        return;

                    case "remove":
                        if (args.Length >= 2)
                        {
                            if (!IsCreatingFile(player))
                            {
                                SendReply(player, Message("notCreating", player.UserIDString));
                                return;
                            }

                            if (_spawnFileCreators[player.userID].Count > 0)
                            {
                                int number;
                                if (int.TryParse(args[1], out number))
                                {
                                    if (number <= _spawnFileCreators[player.userID].Count)
                                    {
                                        _spawnFileCreators[player.userID].RemoveAt(number - 1);
                                        SendReply(player, string.Format(Message("remSuccess", player.UserIDString), number));
                                    }
                                    else SendReply(player, Message("nexistNum", player.UserIDString));
                                }
                                else SendReply(player, Message("noNum", player.UserIDString));
                            }
                            else SendReply(player, Message("noSpawnpoints", player.UserIDString));
                        }
                        else SendReply(player, "/spawns remove <number>");
                        return;

                    case "save":
                        if (args.Length >= 2)
                        {
                            if (!IsCreatingFile(player))
                            {
                                SendReply(player, Message("noCreate", player.UserIDString));
                                return;
                            }
                            if (_spawnFileCreators.ContainsKey(player.userID) && _spawnFileCreators[player.userID].Count > 0)
                            {
                                if (!_spawnsData.Spawnfiles.Contains(args[1]) && !_loadedSpawnfiles.ContainsKey(args[1]))
                                {
                                    SendReply(player, string.Format(Message("saved", player.UserIDString), _spawnFileCreators[player.userID].Count, args[1]));
                                    SaveSpawnFile(player, args[1]);
                                    return;                                    
                                }

                                if (_isEditing.Contains(player.userID))
                                {
                                    SaveSpawnFile(player, args[1]);
                                    SendReply(player, string.Format(Message("overwriteSuccess", player.UserIDString), args[1]));
                                    _isEditing.Remove(player.userID);
                                    return;
                                }

                                SendReply(player, Message("spawnfileExists", player.UserIDString));
                                return;
                            }
                            else SendReply(player, Message("noSpawnpoints", player.UserIDString));
                        }
                        else SendReply(player, "/spawns save <filename>");
                        return;

                    case "close":
                        if (!IsCreatingFile(player))
                        {
                            SendReply(player, Message("noCreate", player.UserIDString));
                            return;
                        }
                        _spawnFileCreators.Remove(player.userID);
                        SendReply(player, Message("noSave", player.UserIDString));
                        return;

                    case "show":
                        if (!IsCreatingFile(player))
                        {
                            SendReply(player, Message("notCreating", player.UserIDString));
                            return;
                        }
                        if (_spawnFileCreators[player.userID].Count > 0)
                        {
                            float time = 10f;
                            if (args.Length > 1)
                                float.TryParse(args[1], out time);

                            for (int i = 0; i < _spawnFileCreators[player.userID].Count; i++)                            
                                DDrawPosition(player, _spawnFileCreators[player.userID][i], i.ToString(), time);
                            
                            return;
                        }
                        else SendReply(player, Message("noSp", player.UserIDString));
                        return;

                    default:
                        SendHelpText(player);
                        break;
                }
            }
        }

        private void DDrawPosition(BasePlayer player, Vector3 point, string name, float time = 10f)
        {
            player.SendConsoleCommand("ddraw.text", time, Color.green, point + new Vector3(0, 1.5f, 0), $"<size=40>{name}</size>");
            player.SendConsoleCommand("ddraw.box", time, Color.green, point, 1f);
        }

        private void SendHelpText(BasePlayer player)
        {
            SendReply(player, Message("newSyn", player.UserIDString));
            SendReply(player, Message("openSyn", player.UserIDString));
            SendReply(player, Message("addSyn", player.UserIDString));
            SendReply(player, Message("remSyn", player.UserIDString));
            SendReply(player, Message("saveSyn", player.UserIDString));
            SendReply(player, Message("closeSyn", player.UserIDString));
            SendReply(player, Message("showSyn", player.UserIDString));
        }

        private bool IsCreatingFile(BasePlayer player) => _spawnFileCreators.ContainsKey(player.userID);
        #endregion

        #region Data Management
        private DynamicConfigFile data;

        private void SaveData() => data.WriteObject(_spawnsData);

        private void LoadData()
        {
            data = Interface.Oxide.DataFileSystem.GetFile("SpawnsDatabase/spawns_data");

            try
            {
                _spawnsData = data.ReadObject<SpawnsData>();
            }
            catch
            {
                _spawnsData = new SpawnsData();
            }
        }

        private void SaveSpawnFile(BasePlayer player, string name)
        {
            DynamicConfigFile configFile = Interface.Oxide.DataFileSystem.GetFile($"SpawnsDatabase/{name}");
            configFile.Clear();
            configFile.Settings.Converters = new JsonConverter[] { new StringEnumConverter(), new UnityVector3Converter() };

            Spawnfile spawnFile = new Spawnfile();

            for (int i1 = 0; i1 < _spawnFileCreators[player.userID].Count; i1++)
            {
                Vector3 spawnpoint = _spawnFileCreators[player.userID][i1];

                spawnFile.spawnPoints.Add(i1.ToString(), spawnpoint);
            }

            configFile.WriteObject(spawnFile);

            if (!_spawnsData.Spawnfiles.Contains(name))
                _spawnsData.Spawnfiles.Add(name);

            if (!_loadedSpawnfiles.ContainsKey(name))
                _loadedSpawnfiles.Add(name, _spawnFileCreators[player.userID]);
            else _loadedSpawnfiles[name] = _spawnFileCreators[player.userID];

            SaveData();
            
            _spawnFileCreators.Remove(player.userID);
        }

        private object LoadSpawnFile(string name)
        {
            if (!Interface.Oxide.DataFileSystem.ExistsDatafile($"SpawnsDatabase/{name}"))
                return null;

            DynamicConfigFile configFile = Interface.GetMod().DataFileSystem.GetDatafile($"SpawnsDatabase/{name}");
            configFile.Settings.Converters = new JsonConverter[] { new StringEnumConverter(), new UnityVector3Converter() };

            Spawnfile spawnFile = new Spawnfile();
            spawnFile = configFile.ReadObject<Spawnfile>();

            List<Vector3> list = spawnFile.spawnPoints.Values.ToList();
            if (list.Count < 1)
                return null;

            return list;
        }

        private class SpawnsData
        {
            public List<string> Spawnfiles = new List<string>();
        }

        private class Spawnfile
        {
            public Dictionary<string, Vector3> spawnPoints = new Dictionary<string, Vector3>();
        }

        private class UnityVector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                Vector3 vector = (Vector3)value;
                writer.WriteValue($"{vector.x} {vector.y} {vector.z}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    string[] values = reader.Value.ToString().Trim().Split(' ');
                    return new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]));
                }
                JObject o = JObject.Load(reader);
                return new Vector3(Convert.ToSingle(o["x"]), Convert.ToSingle(o["y"]), Convert.ToSingle(o["z"]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        }
        #endregion

        #region Messaging
        private string Message(string key, string ID = null) => lang.GetMessage(key, this, ID);

        private readonly Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"noFile", "This file doesn't exist" },
            {"alreadyCreating", "You are already creating a spawn file" },
            {"newCreating", "You now creating a new spawn file" },
            {"isCreating", "You must save/close your current spawn file first. Type /spawns for more information" },
            {"opened", "Opened spawnfile with {0} spawns" },
            {"invalidFile", "This spawnfile is empty or not valid" },
            {"fileName", "You must enter a filename" },
            {"notCreating", "You must create/open a new Spawn file first /spawns for more information" },
            {"remSuccess", "Successfully removed spawn n°{0}" },
            {"nexistNum", "This spawn number doesn't exist" },
            {"noNum", "You must enter a spawn point number" },
            {"noSpawnpoints", "You haven't set any spawn points yet" },
            {"noCreate", "You must create a new Spawn file first. Type /spawns for more information" },
            {"noSave", "Spawn file closed without saving" },
            {"noSp", "You must add spawnpoints first" },
            {"newSyn", "/spawns new - Create a new spawn file" },
            {"openSyn", "/spawns open - Open a existing spawn file for editing" },
            {"addSyn", "/spawns add - Add a new spawn point" },
            {"remSyn", "/spawns remove <number> - Remove a spawn point" },
            {"saveSyn", "/spawns save <filename> - Saves your spawn file" },
            {"closeSyn", "/spawns close - Cancel spawn file creation" },
            {"showSyn", "/spawns show <opt:time> - Display a box at each spawnpoint" },
            {"noAccess", "You are not allowed to use this command" },
            {"saved", "{0} spawnpoints saved into {1}" },
            {"spawnfileExists", "A spawn file with that name already exists" },
            {"overwriteSuccess", "You have successfully edited the spawnfile {0}" }
        };
        #endregion
    }
}


// --- End of file: Spawns.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sirens ---
// --- Original File Path: S/Sirens/Sirens.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Rust.Instruments;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using static InstrumentKeyController;

namespace Oxide.Plugins
{
	[Info("Sirens", "ZockiRR", "2.2.0")]
	[Description("Gives players the ability to attach sirens to vehicles")]
	class Sirens : CovalencePlugin
	{
		#region variables
		private const string PERMISSION_ATTACHSIRENS = "sirens.attachsirens";
		private const string PERMISSION_DETACHSIRENS = "sirens.detachsirens";
		private const string PERMISSION_ATTACHSIRENS_GLOBAL = "sirens.attachallsirens";
		private const string PERMISSION_DETACHSIRENS_GLOBAL = "sirens.detachallsirens";

		private const string I18N_MISSING_SIREN = "NoSirenForName";
		private const string I18N_COULD_NOT_ATTACH = "CouldNotAttach";
		private const string I18N_NOT_SUPPORTED = "NotSupported";
		private const string I18N_ATTACHED = "Attached";
		private const string I18N_ATTACHED_GLOBAL = "AttachedGlobal";
		private const string I18N_DETACHED = "Detached";
		private const string I18N_DETACHED_GLOBAL = "DetachedGlobal";
		private const string I18N_NOT_A_VEHICLE = "NotAVehicle";
		private const string I18N_SIRENS = "Sirens";
		private const string I18N_PLAYERS_ONLY = "PlayersOnly";

		// Initial prefabs
		private const string PREFAB_COCKPIT = "assets/content/vehicles/modularcar/module_entities/1module_cockpit.prefab";
		private const string PREFAB_COCKPIT_ARMORED = "assets/content/vehicles/modularcar/module_entities/1module_cockpit_armored.prefab";
		private const string PREFAB_COCKPIT_WITH_ENGINE = "assets/content/vehicles/modularcar/module_entities/1module_cockpit_with_engine.prefab";
		private const string PREFAB_BUTTON = "assets/prefabs/deployable/playerioents/button/button.prefab";
		private const string PREFAB_FLASHERLIGHT = "assets/prefabs/deployable/playerioents/lights/flasherlight/electric.flasherlight.deployed.prefab";
		private const string PREFAB_SIRENLIGHT = "assets/prefabs/deployable/playerioents/lights/sirenlight/electric.sirenlight.deployed.prefab";
		private const string PREFAB_SIRENLIGHT_ORANGE = "assets/prefabs/io/electric/lights/sirenlightorange.prefab";
		private const string PREFAB_SIRENLIGHT_GREEN = "assets/prefabs/io/electric/lights/sirenlightgreen.prefab";
		private const string PREFAB_SIRENLIGHT_BLUE = "assets/prefabs/io/electric/lights/sirenlightblue.prefab";
		private const string PREFAB_TRUMPET = "assets/prefabs/instruments/trumpet/trumpet.weapon.prefab";

		private const string PREFAB_SEDAN = "assets/content/vehicles/sedan_a/sedantest.entity.prefab";
		private const string PREFAB_SEDAN_RAIL = "assets/content/vehicles/sedan_a/sedanrail.entity.prefab";
		private const string PREFAB_MINICOPTER = "assets/content/vehicles/minicopter/minicopter.entity.prefab";
		private const string PREFAB_TRANSPORTHELI = "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab";
		private const string PREFAB_RHIB = "assets/content/vehicles/boats/rhib/rhib.prefab";
		private const string PREFAB_ROWBOAT = "assets/content/vehicles/boats/rowboat/rowboat.prefab";
		private const string PREFAB_WORKCART = "assets/content/vehicles/trains/workcart/workcart.entity.prefab";
		private const string PREFAB_WORKCART_ABOVE_GROUND = "assets/content/vehicles/trains/workcart/workcart_aboveground.entity.prefab";
		private const string PREFAB_WORKCART_COVERED = "assets/content/vehicles/trains/workcart/workcart_aboveground2.entity.prefab";
		private const string PREFAB_MAGNETCRANE = "assets/content/vehicles/crane_magnet/magnetcrane.entity.prefab";
		private const string PREFAB_HORSE = "assets/rust.ai/nextai/testridablehorse.prefab";
		private const string PREFAB_ATTACKHELI = "assets/content/vehicles/attackhelicopter/attackhelicopter.entity.prefab";
		private const string PREFAB_TUGBOAT = "assets/content/vehicles/boats/tugboat/tugboat.prefab";

		private const string KEY_MODULAR_CAR = "MODULAR_CAR";

		private const string DATAPATH_SIRENS = "sirens/";

		// Preconfigured sirens
		private static readonly Siren SIREN_DEFAULT = new Siren("police-germany",
			new Dictionary<string, Attachment[]>
			{
				[PREFAB_COCKPIT] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.05f, 0.68f, 0.2f), new Vector3(200f, 0f, 0f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(-0.4f, 1.4f, -0.9f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(0.4f, 1.4f, -0.9f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(-0.08f, 1.4f, -0.9f), new Vector3(148f, 150f, 30f))
				},
				[PREFAB_COCKPIT_ARMORED] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.05f, 0.68f, 0.2f), new Vector3(200f, 0f, 0f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(-0.4f, 1.4f, -0.9f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(0.4f, 1.4f, -0.9f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(-0.08f, 1.4f, -0.9f), new Vector3(148f, 150f, 30f))
				},
				[PREFAB_COCKPIT_WITH_ENGINE] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.05f, 0.68f, 0.2f), new Vector3(200f, 0f, 0f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(-0.4f, 1.4f, -0.9f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(0.4f, 1.4f, -0.9f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(-0.08f, 1.4f, -0.9f), new Vector3(148f, 150f, 30f))
				}
			},
			new Dictionary<string, Attachment[]>
			{
				[PREFAB_SEDAN] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.0f, 1.0f, 1.32f), new Vector3(210f, 0f, 0f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(-0.4f, 1.65f, 0.2f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(0.4f, 1.65f, 0.2f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(-0.08f, 1.68f, 0.2f), new Vector3(148f, 150f, 30f))
				},
				[PREFAB_SEDAN_RAIL] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.0f, 1.23f, 0.56f), new Vector3(210f, 0f, 0f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(-0.4f, 1.9f, -0.555f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(0.4f, 1.9f, -0.555f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(-0.08f, 1.92f, -0.555f), new Vector3(148f, 150f, 30f))
				},
				[PREFAB_MINICOPTER] = new Attachment[] {
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(0.0f, 2.235f, -0.025f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(0.0f, 0.832f, -2.7f), new Vector3(272f, 0f, 0f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.09f, 0.78f, -0.9f), new Vector3(148f, 330f, 30f))
				},
				[PREFAB_TRANSPORTHELI] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.012f, 1.215f, 2.86f), new Vector3(242f, 0f, 0f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(-0.3f, 3.15f, -7.65f), new Vector3(0f, 0f, 90f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(0.1f, 3.15f, -7.65f), new Vector3(0f, 0f, 270f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(0.0f, 0.55f, 3.6f), new Vector3(180f, 0f, 0f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.0f, 0.58f, 2.5f), new Vector3(328f, 30f, 30f))
				},
				[PREFAB_RHIB] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(-0.43f, 2.23f, 0.62f), new Vector3(210f, 0f, 0f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(-0.55f, 2.83f, 0.62f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(0.55f, 2.83f, 0.62f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.8f, 1.16f, 0.5f), new Vector3(148f, 150f, 30f))
				},
				[PREFAB_ROWBOAT] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(-0.5f, 0.495f, -1.8f), new Vector3(270f, 270f, 0f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(0.0f, 0.8f, 2.18f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.5f, 0.1f, -0.4f), new Vector3(148f, 150f, 30f))
				},
				[PREFAB_WORKCART] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.185f, 2.405f, 3.95f), new Vector3(235f, 0f, 0f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(0.1f, 3.93f, 4.13f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(1.25f, 3.93f, 4.13f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(-1.49f, 2.5f, -4.58f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(1.51f, 2.5f, -4.58f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.59f, 3.82f, 4.13f), new Vector3(148f, 150f, 30f))
				},
				[PREFAB_WORKCART_ABOVE_GROUND] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.185f, 2.405f, 3.95f), new Vector3(235f, 0f, 0f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(0.1f, 3.93f, 4.13f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(1.25f, 3.93f, 4.13f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(-1.49f, 2.5f, -4.58f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(1.51f, 2.5f, -4.58f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.59f, 3.82f, 4.13f), new Vector3(148f, 150f, 30f))
				},
				[PREFAB_WORKCART_COVERED] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.185f, 2.405f, 3.95f), new Vector3(235f, 0f, 0f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(0.1f, 3.93f, 4.13f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(1.25f, 3.93f, 4.13f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.59f, 3.82f, 4.13f), new Vector3(148f, 150f, 30f))
				},
				[PREFAB_MAGNETCRANE] = new Attachment[] {
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(-0.95f, 4.25f, 0.5f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(-0.08f, 1.4f, 0.0f), new Vector3(148f, 150f, 30f))
				},
				[PREFAB_HORSE] = new Attachment[] {
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(0.0f, 1.7f, 1.2f), new Vector3(25f, 0f, 0f), "head"),
					new Attachment(PREFAB_TRUMPET, new Vector3(-0.06f, 1.15f, 1.3f), new Vector3(90f, 150f, 90f), "lip_lower")
				},
				[PREFAB_ATTACKHELI] = new Attachment[] {
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(0.0f, 2.48f, -0.3f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(0.1f, 2.3f, -6.5f), new Vector3(0f, 0f, 90f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.09f, 0.78f, -0.9f), new Vector3(148f, 330f, 30f))
				},
				[PREFAB_TUGBOAT] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(1.15f, 6.76f, 3.8f), new Vector3(-52f, 222f, 0f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(0.0f, 8.3f, 4.98f), new Vector3(45f, 0f, 0f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(2.88f, 3.08f, -8.08f)),
					new Attachment(PREFAB_FLASHERLIGHT, new Vector3(-2.88f, 3.08f, -8.08f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.7f, 4.4f, 5.75f), new Vector3(148f, 150f, 30f))
				}
			}, new Tone(Notes.A, NoteType.Regular, 4, 1f), new Tone(Notes.D, NoteType.Regular, 5, 1f));
		private static readonly Siren SIREN_SILENT = new Siren("warning-lights",
			new Dictionary<string, Attachment[]>
			{
				[PREFAB_COCKPIT] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.05f, 0.68f, 0.2f), new Vector3(200f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(-0.4f, 1.4f, -0.9f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(0.4f, 1.4f, -0.9f))
				},
				[PREFAB_COCKPIT_ARMORED] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.05f, 0.68f, 0.2f), new Vector3(200f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(-0.4f, 1.4f, -0.9f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(0.4f, 1.4f, -0.9f))
				},
				[PREFAB_COCKPIT_WITH_ENGINE] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.05f, 0.68f, 0.2f), new Vector3(200f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(-0.4f, 1.4f, -0.9f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(0.4f, 1.4f, -0.9f))
				}
			},
			new Dictionary<string, Attachment[]>
			{
				[PREFAB_SEDAN] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.0f, 1.0f, 1.32f), new Vector3(210f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(-0.4f, 1.64f, 0.2f), new Vector3(0f, 0f, 3f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(0.4f, 1.64f, 0.2f), new Vector3(0f, 0f, 357f))
				},
				[PREFAB_SEDAN_RAIL] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.0f, 1.23f, 0.56f), new Vector3(210f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(-0.4f, 1.885f, -0.555f), new Vector3(0f, 0f, 3f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(0.4f, 1.885f, -0.555f), new Vector3(0f, 0f, 357f))
				},
				[PREFAB_MINICOPTER] = new Attachment[] {
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(0.0f, 2.235f, -0.025f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(0.0f, 0.832f, -2.7f), new Vector3(272f, 0f, 0f))
				},
				[PREFAB_TRANSPORTHELI] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.012f, 1.215f, 2.86f), new Vector3(242f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(-0.3f, 3.15f, -7.65f), new Vector3(0f, 0f, 90f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(0.1f, 3.15f, -7.65f), new Vector3(0f, 0f, 270f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(0.0f, 0.55f, 3.6f), new Vector3(180f, 0f, 0f))
				},
				[PREFAB_RHIB] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(-0.43f, 2.23f, 0.62f), new Vector3(210f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(0.0f, 1.55f, 4.15f))
				},
				[PREFAB_ROWBOAT] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(-0.5f, 0.495f, -1.8f), new Vector3(270f, 270f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(0.0f, 0.8f, 2.18f))
				},
				[PREFAB_WORKCART] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.185f, 2.405f, 3.95f), new Vector3(235f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(1.24f, 3.78f, 4.13f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(-1.49f, 2.5f, -4.58f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(1.51f, 2.5f, -4.58f))
				},
				[PREFAB_WORKCART_ABOVE_GROUND] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.185f, 2.405f, 3.95f), new Vector3(235f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(1.24f, 3.78f, 4.13f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(-1.49f, 2.5f, -4.58f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(1.51f, 2.5f, -4.58f))
				},
				[PREFAB_WORKCART_COVERED] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.185f, 2.405f, 3.95f), new Vector3(235f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(1.24f, 3.78f, 4.13f))
				},
				[PREFAB_MAGNETCRANE] = new Attachment[] {
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(-0.95f, 4.25f, 0.5f))
				},
				[PREFAB_HORSE] = new Attachment[] {
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(0.0f, 1.7f, 1.2f), new Vector3(25f, 0f, 0f), "head"),
					new Attachment(PREFAB_TRUMPET, new Vector3(-0.06f, 1.15f, 1.3f), new Vector3(90f, 150f, 90f), "lip_lower")
				},
				[PREFAB_ATTACKHELI] = new Attachment[] {
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(0.0f, 2.48f, -0.37f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(0.11f, 2.2f, -6.45f), new Vector3(0f, 0f, -90f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.09f, 0.78f, -0.9f), new Vector3(148f, 330f, 30f))
				},
				[PREFAB_TUGBOAT] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(1.15f, 6.76f, 3.8f), new Vector3(-52f, 222f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(0.0f, 8.3f, 4.98f), new Vector3(45f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(2.88f, 3.08f, -8.08f)),
					new Attachment(PREFAB_SIRENLIGHT, new Vector3(-2.88f, 3.08f, -8.08f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.7f, 4.4f, 5.75f), new Vector3(148f, 150f, 30f))
				}
			});
		private static readonly Siren SIREN_ORANGE = new Siren("orange-lights",
			new Dictionary<string, Attachment[]>
			{
				[PREFAB_COCKPIT] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.05f, 0.68f, 0.2f), new Vector3(200f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(-0.4f, 1.4f, -0.9f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(0.4f, 1.4f, -0.9f))
				},
				[PREFAB_COCKPIT_ARMORED] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.05f, 0.68f, 0.2f), new Vector3(200f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(-0.4f, 1.4f, -0.9f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(0.4f, 1.4f, -0.9f))
				},
				[PREFAB_COCKPIT_WITH_ENGINE] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.05f, 0.68f, 0.2f), new Vector3(200f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(-0.4f, 1.4f, -0.9f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(0.4f, 1.4f, -0.9f))
				}
			},
			new Dictionary<string, Attachment[]>
			{
				[PREFAB_SEDAN] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.0f, 1.0f, 1.32f), new Vector3(210f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(-0.4f, 1.64f, 0.2f), new Vector3(0f, 0f, 3f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(0.4f, 1.64f, 0.2f), new Vector3(0f, 0f, 357f))
				},
				[PREFAB_SEDAN_RAIL] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.0f, 1.23f, 0.56f), new Vector3(210f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(-0.4f, 1.885f, -0.555f), new Vector3(0f, 0f, 3f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(0.4f, 1.885f, -0.555f), new Vector3(0f, 0f, 357f))
				},
				[PREFAB_MINICOPTER] = new Attachment[] {
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(0.0f, 2.235f, -0.025f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(0.0f, 0.832f, -2.7f), new Vector3(272f, 0f, 0f))
				},
				[PREFAB_TRANSPORTHELI] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.012f, 1.215f, 2.86f), new Vector3(242f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(-0.3f, 3.15f, -7.65f), new Vector3(0f, 0f, 90f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(0.1f, 3.15f, -7.65f), new Vector3(0f, 0f, 270f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(0.0f, 0.55f, 3.6f), new Vector3(180f, 0f, 0f))
				},
				[PREFAB_RHIB] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(-0.43f, 2.23f, 0.62f), new Vector3(210f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(0.0f, 1.55f, 4.15f))
				},
				[PREFAB_ROWBOAT] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(-0.5f, 0.495f, -1.8f), new Vector3(270f, 270f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(0.0f, 0.8f, 2.18f))
				},
				[PREFAB_WORKCART] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.185f, 2.405f, 3.95f), new Vector3(235f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(1.24f, 3.78f, 4.13f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(-1.49f, 2.5f, -4.58f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(1.51f, 2.5f, -4.58f))
				},
				[PREFAB_WORKCART_ABOVE_GROUND] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.185f, 2.405f, 3.95f), new Vector3(235f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(1.24f, 3.78f, 4.13f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(-1.49f, 2.5f, -4.58f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(1.51f, 2.5f, -4.58f))
				},
				[PREFAB_WORKCART_COVERED] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.185f, 2.405f, 3.95f), new Vector3(235f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(1.24f, 3.78f, 4.13f))
				},
				[PREFAB_MAGNETCRANE] = new Attachment[] {
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(-0.95f, 4.25f, 0.5f))
				},
				[PREFAB_HORSE] = new Attachment[] {
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(0.0f, 1.7f, 1.2f), new Vector3(25f, 0f, 0f), "head"),
					new Attachment(PREFAB_TRUMPET, new Vector3(-0.06f, 1.15f, 1.3f), new Vector3(90f, 150f, 90f), "lip_lower")
				},
				[PREFAB_ATTACKHELI] = new Attachment[] {
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(0.0f, 2.48f, -0.37f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(0.11f, 2.2f, -6.45f), new Vector3(0f, 0f, -90f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.09f, 0.78f, -0.9f), new Vector3(148f, 330f, 30f))
				},
				[PREFAB_TUGBOAT] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(1.15f, 6.76f, 3.8f), new Vector3(-52f, 222f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(0.0f, 8.3f, 4.98f), new Vector3(45f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(2.88f, 3.08f, -8.08f)),
					new Attachment(PREFAB_SIRENLIGHT_ORANGE, new Vector3(-2.88f, 3.08f, -8.08f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.7f, 4.4f, 5.75f), new Vector3(148f, 150f, 30f))
				}
			});
		private static readonly Siren SIREN_GREEN = new Siren("green-lights",
			new Dictionary<string, Attachment[]>
			{
				[PREFAB_COCKPIT] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.05f, 0.68f, 0.2f), new Vector3(200f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(-0.4f, 1.4f, -0.9f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(0.4f, 1.4f, -0.9f))
				},
				[PREFAB_COCKPIT_ARMORED] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.05f, 0.68f, 0.2f), new Vector3(200f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(-0.4f, 1.4f, -0.9f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(0.4f, 1.4f, -0.9f))
				},
				[PREFAB_COCKPIT_WITH_ENGINE] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.05f, 0.68f, 0.2f), new Vector3(200f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(-0.4f, 1.4f, -0.9f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(0.4f, 1.4f, -0.9f))
				}
			},
			new Dictionary<string, Attachment[]>
			{
				[PREFAB_SEDAN] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.0f, 1.0f, 1.32f), new Vector3(210f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(-0.4f, 1.64f, 0.2f), new Vector3(0f, 0f, 3f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(0.4f, 1.64f, 0.2f), new Vector3(0f, 0f, 357f))
				},
				[PREFAB_SEDAN_RAIL] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.0f, 1.23f, 0.56f), new Vector3(210f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(-0.4f, 1.885f, -0.555f), new Vector3(0f, 0f, 3f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(0.4f, 1.885f, -0.555f), new Vector3(0f, 0f, 357f))
				},
				[PREFAB_MINICOPTER] = new Attachment[] {
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(0.0f, 2.235f, -0.025f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(0.0f, 0.832f, -2.7f), new Vector3(272f, 0f, 0f))
				},
				[PREFAB_TRANSPORTHELI] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.012f, 1.215f, 2.86f), new Vector3(242f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(-0.3f, 3.15f, -7.65f), new Vector3(0f, 0f, 90f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(0.1f, 3.15f, -7.65f), new Vector3(0f, 0f, 270f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(0.0f, 0.55f, 3.6f), new Vector3(180f, 0f, 0f))
				},
				[PREFAB_RHIB] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(-0.43f, 2.23f, 0.62f), new Vector3(210f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(0.0f, 1.55f, 4.15f))
				},
				[PREFAB_ROWBOAT] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(-0.5f, 0.495f, -1.8f), new Vector3(270f, 270f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(0.0f, 0.8f, 2.18f))
				},
				[PREFAB_WORKCART] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.185f, 2.405f, 3.95f), new Vector3(235f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(1.24f, 3.78f, 4.13f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(-1.49f, 2.5f, -4.58f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(1.51f, 2.5f, -4.58f))
				},
				[PREFAB_WORKCART_ABOVE_GROUND] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.185f, 2.405f, 3.95f), new Vector3(235f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(1.24f, 3.78f, 4.13f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(-1.49f, 2.5f, -4.58f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(1.51f, 2.5f, -4.58f))
				},
				[PREFAB_WORKCART_COVERED] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.185f, 2.405f, 3.95f), new Vector3(235f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(1.24f, 3.78f, 4.13f))
				},
				[PREFAB_MAGNETCRANE] = new Attachment[] {
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(-0.95f, 4.25f, 0.5f))
				},
				[PREFAB_HORSE] = new Attachment[] {
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(0.0f, 1.7f, 1.2f), new Vector3(25f, 0f, 0f), "head"),
					new Attachment(PREFAB_TRUMPET, new Vector3(-0.06f, 1.15f, 1.3f), new Vector3(90f, 150f, 90f), "lip_lower")
				},
				[PREFAB_ATTACKHELI] = new Attachment[] {
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(0.0f, 2.48f, -0.37f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(0.11f, 2.2f, -6.45f), new Vector3(0f, 0f, -90f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.09f, 0.78f, -0.9f), new Vector3(148f, 330f, 30f))
				},
				[PREFAB_TUGBOAT] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(1.15f, 6.76f, 3.8f), new Vector3(-52f, 222f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(0.0f, 8.3f, 4.98f), new Vector3(45f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(2.88f, 3.08f, -8.08f)),
					new Attachment(PREFAB_SIRENLIGHT_GREEN, new Vector3(-2.88f, 3.08f, -8.08f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.7f, 4.4f, 5.75f), new Vector3(148f, 150f, 30f))
				}
			});
		private static readonly Siren SIREN_BLUE = new Siren("blue-sirens",
			new Dictionary<string, Attachment[]>
			{
				[PREFAB_COCKPIT] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.05f, 0.68f, 0.2f), new Vector3(200f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(-0.4f, 1.4f, -0.9f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(0.4f, 1.4f, -0.9f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(-0.08f, 1.4f, -0.9f), new Vector3(148f, 150f, 30f))
				},
				[PREFAB_COCKPIT_ARMORED] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.05f, 0.68f, 0.2f), new Vector3(200f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(-0.4f, 1.4f, -0.9f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(0.4f, 1.4f, -0.9f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(-0.08f, 1.4f, -0.9f), new Vector3(148f, 150f, 30f))
				},
				[PREFAB_COCKPIT_WITH_ENGINE] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.05f, 0.68f, 0.2f), new Vector3(200f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(-0.4f, 1.4f, -0.9f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(0.4f, 1.4f, -0.9f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(-0.08f, 1.4f, -0.9f), new Vector3(148f, 150f, 30f))
				}
			},
			new Dictionary<string, Attachment[]>
			{
				[PREFAB_SEDAN] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.0f, 1.0f, 1.32f), new Vector3(210f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(-0.4f, 1.64f, 0.2f), new Vector3(0f, 0f, 3f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(0.4f, 1.64f, 0.2f), new Vector3(0f, 0f, 357f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(-0.08f, 1.68f, 0.2f), new Vector3(148f, 150f, 30f))
				},
				[PREFAB_SEDAN_RAIL] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.0f, 1.23f, 0.56f), new Vector3(210f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(-0.4f, 1.885f, -0.555f), new Vector3(0f, 0f, 3f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(0.4f, 1.885f, -0.555f), new Vector3(0f, 0f, 357f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(-0.08f, 1.92f, -0.555f), new Vector3(148f, 150f, 30f))
				},
				[PREFAB_MINICOPTER] = new Attachment[] {
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(0.0f, 2.235f, -0.025f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(0.0f, 0.832f, -2.7f), new Vector3(272f, 0f, 0f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.09f, 0.78f, -0.9f), new Vector3(148f, 330f, 30f))
				},
				[PREFAB_TRANSPORTHELI] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.012f, 1.215f, 2.86f), new Vector3(242f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(-0.3f, 3.15f, -7.65f), new Vector3(0f, 0f, 90f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(0.1f, 3.15f, -7.65f), new Vector3(0f, 0f, 270f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(0.0f, 0.55f, 3.6f), new Vector3(180f, 0f, 0f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.0f, 0.58f, 2.5f), new Vector3(328f, 30f, 30f))
				},
				[PREFAB_RHIB] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(-0.43f, 2.23f, 0.62f), new Vector3(210f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(0.0f, 1.55f, 4.15f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.8f, 1.16f, 0.5f), new Vector3(148f, 150f, 30f))
				},
				[PREFAB_ROWBOAT] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(-0.5f, 0.495f, -1.8f), new Vector3(270f, 270f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(0.0f, 0.8f, 2.18f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.5f, 0.1f, -0.4f), new Vector3(148f, 150f, 30f))
				},
				[PREFAB_WORKCART] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.185f, 2.405f, 3.95f), new Vector3(235f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(1.24f, 3.78f, 4.13f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(-1.49f, 2.5f, -4.58f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(1.51f, 2.5f, -4.58f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.59f, 3.82f, 4.13f), new Vector3(148f, 150f, 30f))
				},
				[PREFAB_WORKCART_ABOVE_GROUND] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.185f, 2.405f, 3.95f), new Vector3(235f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(1.24f, 3.78f, 4.13f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(-1.49f, 2.5f, -4.58f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(1.51f, 2.5f, -4.58f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.59f, 3.82f, 4.13f), new Vector3(148f, 150f, 30f))
				},
				[PREFAB_WORKCART_COVERED] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(0.185f, 2.405f, 3.95f), new Vector3(235f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(1.24f, 3.78f, 4.13f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.59f, 3.82f, 4.13f), new Vector3(148f, 150f, 30f))
				},
				[PREFAB_MAGNETCRANE] = new Attachment[] {
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(-0.95f, 4.25f, 0.5f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(-0.08f, 1.4f, 0.0f), new Vector3(148f, 150f, 30f))
				},
				[PREFAB_HORSE] = new Attachment[] {
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(0.0f, 1.7f, 1.2f), new Vector3(25f, 0f, 0f), "head"),
					new Attachment(PREFAB_TRUMPET, new Vector3(-0.06f, 1.15f, 1.3f), new Vector3(90f, 150f, 90f), "lip_lower")
				},
				[PREFAB_ATTACKHELI] = new Attachment[] {
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(0.0f, 2.48f, -0.37f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(0.11f, 2.2f, -6.45f), new Vector3(0f, 0f, -90f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.09f, 0.78f, -0.9f), new Vector3(148f, 330f, 30f))
				},
				[PREFAB_TUGBOAT] = new Attachment[] {
					new Attachment(PREFAB_BUTTON, new Vector3(1.15f, 6.76f, 3.8f), new Vector3(-52f, 222f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(0.0f, 8.3f, 4.98f), new Vector3(45f, 0f, 0f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(2.88f, 3.08f, -8.08f)),
					new Attachment(PREFAB_SIRENLIGHT_BLUE, new Vector3(-2.88f, 3.08f, -8.08f)),
					new Attachment(PREFAB_TRUMPET, new Vector3(0.7f, 4.4f, 5.75f), new Vector3(148f, 150f, 30f))
				}
			}, new Tone(Notes.A, NoteType.Regular, 4, 1f), new Tone(Notes.D, NoteType.Regular, 5, 1f));
		#endregion variables

		#region data
		private class DataContainer
		{
			// Map BaseVehicle.net.ID -> SirenInfos
			public Dictionary<ulong, VehicleContainer> VehicleSirenMap = new Dictionary<ulong, VehicleContainer>();
		}

		private class VehicleContainer
		{
			public string SirenName = SIREN_DEFAULT.Name;
			public SirenController.States State = SirenController.States.OFF;
			public HashSet<ulong> NetIDs = new HashSet<ulong>();

			public VehicleContainer()
			{
			}

			public VehicleContainer(string aSirenName, SirenController.States aState, IEnumerable<NetworkableId> someNetIDs)
			{
				SirenName = aSirenName;
				State = aState;
				NetIDs.UnionWith(someNetIDs.Select(eachNetID => eachNetID.Value));
			}
		}
		#endregion data

		#region configuration
		private Configuration config;
		private IDictionary<string, Siren> SirenDictionary { get; } = new Dictionary<string, Siren>();

		private class Configuration
		{
			[JsonProperty("MountNeeded")]
			public bool MountNeeded = true;

			[JsonProperty("SoundEnabled")]
			public bool SoundEnabled = true;

			[JsonProperty("SirenSpawnProbability")]
			public Dictionary<string, float> SirenSpawnProbability = new Dictionary<string, float>
			{
				[KEY_MODULAR_CAR] = 0f,
				[PREFAB_HORSE] = 0f,
				[PREFAB_MAGNETCRANE] = 0f,
				[PREFAB_MINICOPTER] = 0f,
				[PREFAB_RHIB] = 0f,
				[PREFAB_ROWBOAT] = 0f,
				[PREFAB_SEDAN] = 0f,
				[PREFAB_SEDAN_RAIL] = 0f,
				[PREFAB_TRANSPORTHELI] = 0f,
				[PREFAB_WORKCART] = 0f,
				[PREFAB_WORKCART_ABOVE_GROUND] = 0f,
				[PREFAB_WORKCART_COVERED] = 0f
			};

			[JsonConverter(typeof(StringEnumConverter))]
			[JsonProperty("DefaultState")]
			public SirenController.States DefaultState = SirenController.States.OFF;

			public string ToJson() => JsonConvert.SerializeObject(this);

			public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
		}

		private class Tone
		{
			public Tone(Notes aNote = Notes.A, NoteType aNoteType = NoteType.Regular, int anOctave = 4, float aDuration = 1f)
			{
				Note = aNote;
				NoteType = aNoteType;
				Octave = anOctave;
				Duration = aDuration;
			}

			[JsonConverter(typeof(StringEnumConverter))]
			[JsonProperty("Note")]
			public Notes Note;

			[JsonConverter(typeof(StringEnumConverter))]
			[JsonProperty("NoteType")]
			public NoteType NoteType;

			[JsonProperty("Octave")]
			public int Octave;

			[JsonProperty("Duration")]
			public float Duration;

			public string ToJson() => JsonConvert.SerializeObject(this);

			public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
		}

		private class Siren
		{
			public Siren(string aName, Dictionary<string, Attachment[]> someModules, Dictionary<string, Attachment[]> someVehicles, params Tone[] someTones)
			{
				Name = aName;
				Modules = someModules;
				Vehicles = someVehicles;
				Tones = someTones;
			}

			[JsonProperty("Name")]
			public string Name;

			[JsonProperty("Tones")]
			public Tone[] Tones;

			[JsonProperty("Modules")]
			public Dictionary<string, Attachment[]> Modules;

			[JsonProperty("Vehicles")]
			public Dictionary<string, Attachment[]> Vehicles;

			public string ToJson() => JsonConvert.SerializeObject(this);

			public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
		}

		private class Attachment
		{
			public Attachment(string aPrefab, Vector3 aPosition, Vector3 anAngle = new Vector3(), string aBone = null)
			{
				Prefab = aPrefab;
				Position = aPosition;
				Angle = anAngle;
				Bone = aBone;
			}

			[JsonProperty("Prefab")]
			public string Prefab;

			[JsonProperty("Position")]
			public Vector3 Position;

			[JsonProperty("Angle")]
			public Vector3 Angle;

			[JsonProperty("Bone")]
			public string Bone;

			public string ToJson() => JsonConvert.SerializeObject(this);

			public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
		}

		protected override void LoadDefaultConfig()
		{
			config = new Configuration();
			SirenDictionary.Clear();
			SirenDictionary.Add(SIREN_DEFAULT.Name, SIREN_DEFAULT);
			SirenDictionary.Add(SIREN_SILENT.Name, SIREN_SILENT);
			SirenDictionary.Add(SIREN_ORANGE.Name, SIREN_ORANGE);
			SirenDictionary.Add(SIREN_GREEN.Name, SIREN_GREEN);
			SirenDictionary.Add(SIREN_BLUE.Name, SIREN_BLUE);
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				config = Config.ReadObject<Configuration>();
				if (config == null)
				{
					throw new JsonException();
				}

				SaveDefaultSirens();
				try
				{
					foreach (string eachSirenFile in Interface.Oxide.DataFileSystem.GetFiles(DATAPATH_SIRENS, "*.json"))
					{
						string theFilename = eachSirenFile.Basename(".json");
						try
						{
							Siren theSiren = Interface.Oxide.DataFileSystem.ReadObject<Siren>(DATAPATH_SIRENS + theFilename);
							SirenDictionary.Add(theSiren.Name, theSiren);
						}
						catch
						{
							PrintWarning($"Siren file {theFilename}.json is invalid; ignoring");
						}
					}
				}
				catch
				{

				}
				Puts("Loaded sirens: " + string.Join(", ", SirenDictionary.Keys));


				if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
				{
					PrintWarning("Configuration appears to be outdated; updating and saving");
					SaveConfig();
				}

			}
			catch
			{
				PrintWarning($"Configuration file {Name}.json is invalid; using defaults");
				LoadDefaultConfig();
			}
		}

		protected override void SaveConfig()
		{
			PrintWarning($"Configuration changes saved to {Name}.json");
			Config.WriteObject(config, true);
		}

		protected void SaveDefaultSirens()
		{
			PrintWarning($"Saved default sirens");
			Interface.Oxide.DataFileSystem.WriteObject(DATAPATH_SIRENS + SIREN_DEFAULT.Name, SIREN_DEFAULT);
			Interface.Oxide.DataFileSystem.WriteObject(DATAPATH_SIRENS + SIREN_SILENT.Name, SIREN_SILENT);
			Interface.Oxide.DataFileSystem.WriteObject(DATAPATH_SIRENS + SIREN_ORANGE.Name, SIREN_ORANGE);
			Interface.Oxide.DataFileSystem.WriteObject(DATAPATH_SIRENS + SIREN_GREEN.Name, SIREN_GREEN);
			Interface.Oxide.DataFileSystem.WriteObject(DATAPATH_SIRENS + SIREN_BLUE.Name, SIREN_BLUE);
		}
		#endregion configuration

		#region localization
		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				[I18N_MISSING_SIREN] = "No siren was found for the given name (using {0} instead)",
				[I18N_COULD_NOT_ATTACH] = "Could not attach '{0}'",
				[I18N_ATTACHED] = "Attached siren '{0}'",
				[I18N_ATTACHED_GLOBAL] = "Attached siren '{0}' to all existing cars",
				[I18N_DETACHED] = "Detached siren",
				[I18N_DETACHED_GLOBAL] = "Detached all existing sirens",
				[I18N_NOT_A_VEHICLE] = "This entity is not a (supported) vehicle",
				[I18N_SIRENS] = "Available sirens: {0}",
				[I18N_PLAYERS_ONLY] = "Command '{0}' can only be used by a player",
				[I18N_NOT_SUPPORTED] = "The siren '{0}' has no configuration for '{1}'"
			}, this);
		}
		#endregion localization

		#region commands
		[Command("attachsirens"), Permission(PERMISSION_ATTACHSIRENS)]
		private void AttachCarSirens(IPlayer aPlayer, string aCommand, string[] someArgs)
		{
			if (aPlayer.IsServer)
			{
				Message(aPlayer, I18N_PLAYERS_ONLY, aCommand);
				return;
			}

			BaseVehicle theVehicle = RaycastVehicle(aPlayer);
			if (theVehicle)
			{
				Siren theSiren = someArgs.Length > 0 ? FindSirenForName(someArgs[0], aPlayer) : SirenDictionary.Values.First();
				if (AttachSirens(theVehicle, theSiren, config.DefaultState, aPlayer))
				{
					Message(aPlayer, I18N_ATTACHED, theSiren.Name);
				}
			}
		}

		[Command("detachsirens"), Permission(PERMISSION_DETACHSIRENS)]
		private void DetachCarSirens(IPlayer aPlayer, string aCommand, string[] _)
		{
			if (aPlayer.IsServer)
			{
				Message(aPlayer, I18N_PLAYERS_ONLY, aCommand);
				return;
			}

			BaseVehicle theVehicle = RaycastVehicle(aPlayer);
			if (theVehicle && DetachSirens(theVehicle))
			{
				Message(aPlayer, I18N_DETACHED);
			}
		}

		[Command("attachallsirens"), Permission(PERMISSION_ATTACHSIRENS_GLOBAL)]
		private void AttachAllCarSirens(IPlayer aPlayer, string _, string[] someArgs)
		{
			Siren theSiren = someArgs.Length > 0 ? FindSirenForName(someArgs[0], aPlayer) : SirenDictionary.Values.First();
			bool theAtLeastOneSuccessful = false;
			foreach (BaseVehicle eachVehicle in BaseNetworkable.serverEntities.OfType<BaseVehicle>())
			{
				theAtLeastOneSuccessful |= AttachSirens(eachVehicle, theSiren, config.DefaultState, aPlayer);
			}
			if (theAtLeastOneSuccessful)
			{
				Message(aPlayer, I18N_ATTACHED_GLOBAL, theSiren.Name);
			}
		}

		[Command("detachallsirens"), Permission(PERMISSION_DETACHSIRENS_GLOBAL)]
		private void DetachAllCarSirens(IPlayer aPlayer, string _, string[] _1)
		{
			foreach (BaseVehicle eachVehicle in BaseNetworkable.serverEntities.OfType<BaseVehicle>())
			{
				DetachSirens(eachVehicle);
			}
			Message(aPlayer, I18N_DETACHED_GLOBAL);
		}

		[Command("listsirens")]
		private void ListSirens(IPlayer aPlayer, string _, string[] _1)
		{
			Message(aPlayer, I18N_SIRENS, string.Join(", ", SirenDictionary.Keys));
		}

		[Command("togglesirens")]
		private void ToggleSirens(IPlayer aPlayer, string aCommand, string[] _)
		{
			if (aPlayer.IsServer)
			{
				Message(aPlayer, I18N_PLAYERS_ONLY, aCommand);
				return;
			}

			BasePlayer thePlayer = aPlayer.Object as BasePlayer;
			BaseVehicle theVehicle = thePlayer?.GetMountedVehicle();
			if (theVehicle)
			{
				theVehicle.GetComponent<SirenController>()?.ChangeState();
			}
			else if (!config.MountNeeded)
			{
				RaycastVehicle(aPlayer)?.GetComponent<SirenController>()?.ChangeState(); ;
			}
		}
		#endregion commands

		#region hooks
		private void Unload()
		{
			OnServerSave();

			foreach (BaseVehicle eachVehicle in BaseNetworkable.serverEntities.OfType<BaseVehicle>())
			{
				DetachSirens(eachVehicle);
			}
		}

		private void OnServerSave()
		{
			DataContainer thePersistentData = new DataContainer();
			foreach (BaseVehicle eachCar in BaseNetworkable.serverEntities.OfType<BaseVehicle>())
			{
				SirenController theController = eachCar.GetComponent<SirenController>();
				thePersistentData.VehicleSirenMap.Add(eachCar.net.ID.Value, theController ? new VehicleContainer(theController.Siren.Name, theController.State, theController.NetIDs) : null);
			}
			Interface.Oxide.DataFileSystem.WriteObject(Name, thePersistentData);
		}

		private void OnServerInitialized(bool _)
		{
			bool theSpawnRandomlyFlag = config.SirenSpawnProbability.Any(entry => entry.Value > 0f);
			if (!theSpawnRandomlyFlag)
			{
				Unsubscribe("OnEntitySpawned");
			}

			// Reattach on server restart
			DataContainer thePersistentData = Interface.Oxide.DataFileSystem.ReadObject<DataContainer>(Name);
			foreach (BaseVehicle eachVehicle in BaseNetworkable.serverEntities.OfType<BaseVehicle>())
			{
				if (thePersistentData.VehicleSirenMap.TryGetValue(eachVehicle.net.ID.Value, out VehicleContainer theContainer))
				{
					if (theContainer != null)
					{
						if (SirenDictionary.TryGetValue(theContainer.SirenName, out Siren theSiren))
						{
							CreateSirenController(eachVehicle, theSiren, theContainer.NetIDs);
							AttachSirens(eachVehicle, theSiren, theContainer.State);
						}
						else
						{
							CreateSirenController(eachVehicle, null, theContainer.NetIDs);
							DetachSirens(eachVehicle);
							PrintWarning($"Missing siren for name \"{theContainer.SirenName}\". Ignoring...");
						}
					}
				}
				else if (theSpawnRandomlyFlag)
				{
					SirenController theController = eachVehicle.GetComponent<SirenController>();
					if (!theController)
					{
						if (config.SirenSpawnProbability.TryGetValue(eachVehicle is ModularCar ? KEY_MODULAR_CAR : eachVehicle.PrefabName, out float theProbability) && Core.Random.Range(0f, 1f) < theProbability)
						{
							AttachSirens(eachVehicle, SirenDictionary.Values.First(), config.DefaultState);
						}
					}
				}
			}
		}

		private object OnButtonPress(PressButton aButton, BasePlayer aPlayer)
		{
			BaseVehicle theVehicle = aButton.GetComponentInParent<BaseVehicleModule>()?.Vehicle;
			theVehicle = theVehicle ? theVehicle : aButton.GetComponentInParent<BaseVehicle>();
			if (theVehicle)
			{
				SirenController theController = theVehicle.GetComponent<SirenController>();
				if (theController)
				{
					if ((config.MountNeeded && aPlayer.GetMountedVehicle() != theVehicle) || !theController.NetIDs.Contains(aButton.net.ID))
					{
						return false;
					}
					theController.ChangeState();
				}
			}
			return null;
		}

		private void OnEntitySpawned(BaseVehicle aVehicle)
		{
			SirenController theController = aVehicle.GetComponent<SirenController>();
			if (!theController)
			{
				if (config.SirenSpawnProbability.TryGetValue(aVehicle is ModularCar ? KEY_MODULAR_CAR : aVehicle.PrefabName, out float theProbability) && Core.Random.Range(0f, 1f) < theProbability)
				{
					AttachSirens(aVehicle, SirenDictionary.Values.First(), config.DefaultState);
				}
			}
		}
		#endregion hooks

		#region methods
		/// <summary>
		/// Tries to attach the given siren to the vehicle, replacing any existing siren.
		/// </summary>
		/// <param name="aVehicle">The vehicle.</param>
		/// <param name="aSiren">The siren.</param>
		/// <param name="anInitialState">The initial siren state.</param>
		/// <param name="aPlayer">The calling player.</param>
		/// <returns>True, if successful.</returns>
		private bool AttachSirens(BaseVehicle aVehicle, Siren aSiren, SirenController.States anInitialState, IPlayer aPlayer = null)
		{
			DetachSirens(aVehicle);
			SirenController theController = CreateSirenController(aVehicle, aSiren);
			if (aVehicle as ModularCar)
			{
				if (aSiren.Modules == null)
				{
					Message(aPlayer, I18N_NOT_SUPPORTED, aSiren.Name, KEY_MODULAR_CAR);
					DetachSirens(aVehicle);
					return false;
				}
				foreach (BaseVehicleModule eachModule in aVehicle.GetComponentsInChildren<BaseVehicleModule>())
				{
					SpawnAttachments(aSiren.Modules, aPlayer, theController, eachModule);
				}
			}
			else if (!SpawnAttachments(aSiren.Vehicles, aPlayer, theController, aVehicle))
			{
				Message(aPlayer, I18N_NOT_SUPPORTED, aSiren.Name, aVehicle.PrefabName);
				DetachSirens(aVehicle);
				return false;
			}
			theController.SetState(anInitialState);
			return true;
		}

		/// <summary>
		/// Spawns the attachments for the given dictionary for the given parent entity.
		/// </summary>
		/// <param name="someAttachments">The dictionary.</param>
		/// <param name="aPlayer">The calling player.</param>
		/// <param name="theController">The SirenController of the Parent.</param>
		/// <param name="aParent">The Parent.</param>
		/// <returns>True, if the parent has an entry in the dictionary with at least one Attachment.</returns>
		private bool SpawnAttachments(IDictionary<string, Attachment[]> someAttachments, IPlayer aPlayer, SirenController theController, BaseEntity aParent)
		{
			if (someAttachments == null)
			{
				return false;
			}

			if (someAttachments.TryGetValue(aParent.PrefabName, out Attachment[] theAttachments))
			{
				foreach (Attachment eachAttachment in theAttachments)
				{
					BaseEntity theNewEntity = AttachEntity(aParent, eachAttachment.Prefab, eachAttachment.Position, eachAttachment.Angle, eachAttachment.Bone);
					if (theNewEntity)
					{
						theController.NetIDs.Add(theNewEntity.net.ID);
					}
					else if (aPlayer != null)
					{
						Message(aPlayer, I18N_COULD_NOT_ATTACH, eachAttachment.Prefab);
					}
				}
				return !theAttachments.IsEmpty();
			}
			return false;
		}

		/// <summary>
		/// Creates or replaces the SirenController of the given vehicle.
		/// </summary>
		/// <param name="aVehicle">The vehicle.</param>
		/// <param name="aSiren">The Siren.</param>
		/// <param name="someNetIDs">Already existing siren entities.</param>
		/// <returns>The newly created SirenController.</returns>
		private SirenController CreateSirenController(BaseVehicle aVehicle, Siren aSiren, IEnumerable<ulong> someNetIDs = null)
		{
			SirenController theController = aVehicle.GetComponent<SirenController>();
			if (theController)
			{
				UnityEngine.Object.DestroyImmediate(theController);
			}
			theController = aVehicle.gameObject.AddComponent<SirenController>();
			theController.Config = config;
			theController.Siren = aSiren;
			if (someNetIDs != null)
			{
				theController.NetIDs.UnionWith(someNetIDs.Select(eachNetID => new NetworkableId(eachNetID)));
			}
			return theController;
		}

		/// <summary>
		/// Detaches the siren from a vehicle and removes all corresponding entities.
		/// </summary>
		/// <param name="aVehicle"> The vehicle.</param>
		/// <returns>True, if a siren was removed.</returns>
		private bool DetachSirens(BaseVehicle aVehicle)
		{
			SirenController theController = aVehicle.GetComponent<SirenController>();
			if (theController)
			{
				foreach (BaseEntity eachEntity in aVehicle.GetComponentsInChildren<BaseEntity>())
				{
					if (theController.NetIDs.Contains(eachEntity.net.ID))
					{
						Destroy(eachEntity);
					}
				}
				UnityEngine.Object.DestroyImmediate(theController);
				return true;
			}
			return false;
		}

		/// <summary>
		/// Destroys the entity.
		/// </summary>
		/// <param name="anEntity">The entity.</param>
		private static void Destroy(BaseEntity anEntity)
		{
			if (!anEntity.IsDestroyed)
			{
				anEntity.Kill();
			}
		}

		/// <summary>
		/// Attaches the prefab entity at the given local position and angles to the parent.
		/// </summary>
		/// <param name="aParent">The parent.</param>
		/// <param name="aPrefab">The prefab for the new entity.</param>
		/// <param name="aPosition">The local position.</param>
		/// <param name="anAngle">The local angles.</param>
		/// <returns></returns>
		private BaseEntity AttachEntity(BaseEntity aParent, string aPrefab, Vector3 aPosition, Vector3 anAngle = new Vector3(), string aBone = null)
		{
			BaseEntity theNewEntity = GameManager.server.CreateEntity(aPrefab, aParent.transform.position);
			if (!theNewEntity)
			{
				return null;
			}

			theNewEntity.Spawn();
			Transform theBone = aParent.FindBone(aBone);
			if (theBone == null && aBone != null)
			{
				PrintWarning($"No bone found for name '{aBone}'");
				PrintWarning("Valid bone names: " + string.Join(", ", aParent.GetBones().Select(eachBone => eachBone.name)));
			}

			if (theBone != null && theBone != aParent.transform)
			{
				theNewEntity.SetParent(aParent, theBone.name);
				theNewEntity.transform.localPosition = theBone.InverseTransformPoint(aParent.transform.TransformPoint(aPosition));
				theNewEntity.transform.localRotation = Quaternion.Inverse(theBone.rotation) * (aParent.transform.rotation * Quaternion.Euler(anAngle));
			}
			else
			{
				theNewEntity.transform.localPosition = aPosition;
				theNewEntity.transform.localEulerAngles = anAngle;
				theNewEntity.SetParent(aParent);
			}
			//Puts(theNewEntity.ShortPrefabName + ": (" + theNewEntity.GetComponents<Component>().Length + ") " + string.Join(", ", theNewEntity.GetComponents<Component>().Select(eachComp => eachComp.GetType().Name)));
			UnityEngine.Object.DestroyImmediate(theNewEntity.GetComponent<DestroyOnGroundMissing>());
			UnityEngine.Object.DestroyImmediate(theNewEntity.GetComponent<GroundWatch>());
			UnityEngine.Object.DestroyImmediate(theNewEntity.GetComponent<BoxCollider>());
			UnityEngine.Object.DestroyImmediate(theNewEntity.GetComponent<InstrumentKeyController>());
			theNewEntity.OwnerID = 0;
			BaseCombatEntity theCombatEntity = theNewEntity as BaseCombatEntity;
			if (theCombatEntity)
			{
				theCombatEntity.pickup.enabled = false;
			}
			PressButton theButton = theNewEntity as PressButton;
			if (theButton)
			{
				theButton.pressDuration = 0.2f;
			}

			theNewEntity.EnableSaving(true);
			theNewEntity.SendNetworkUpdateImmediate();
			return theNewEntity;
		}

		/// <summary>
		/// Toggles the IOEntity.
		/// </summary>
		/// <param name="anIOEntity">The IOEntity.</param>
		/// <param name="theEnabledFlag">The new state.</param>
		private static void ToogleSirens(IOEntity anIOEntity, bool theEnabledFlag)
		{
			anIOEntity.UpdateHasPower(theEnabledFlag ? anIOEntity.ConsumptionAmount() : 0, 0);
			anIOEntity.SetFlag(BaseEntity.Flags.On, theEnabledFlag);
		}
		#endregion methods

		#region helpers
		private BaseVehicle RaycastVehicle(IPlayer aPlayer)
		{
			if (!Physics.Raycast((aPlayer.Object as BasePlayer).eyes.HeadRay(), out RaycastHit theHit, 5f))
			{
				return null;
			}

			BaseVehicle theVehicle = theHit.GetEntity()?.GetComponentInParent<BaseVehicle>();
			if (!theVehicle)
			{
				Message(aPlayer, I18N_NOT_A_VEHICLE);
			}
			return theVehicle;
		}

		private Siren FindSirenForName(string aName, IPlayer aPlayer)
		{
			if (!SirenDictionary.TryGetValue(aName, out Siren theSiren))
			{
				theSiren = SirenDictionary.Values.First();
				Message(aPlayer, I18N_MISSING_SIREN, theSiren.Name);
			}
			return theSiren;
		}

		private string GetText(string aKey, string aPlayerId = null, params object[] someArgs) => string.Format(lang.GetMessage(aKey, this, aPlayerId), someArgs);

		private void Message(IPlayer aPlayer, string anI18nKey, params object[] someArgs)
		{
			if (aPlayer.IsConnected)
			{
				string theText = GetText(anI18nKey, aPlayer.Id, someArgs);
				aPlayer.Reply(theText != anI18nKey ? theText : anI18nKey);
			}
		}

		private void Message(BasePlayer aPlayer, string anI18nKey, params object[] someArgs)
		{
			if (aPlayer.IsConnected)
			{
				string theText = GetText(anI18nKey, aPlayer.UserIDString, someArgs);
				aPlayer.ChatMessage(theText != anI18nKey ? theText : anI18nKey);
			}
		}
		#endregion helpers

		#region controllers
		private class SirenController : FacepunchBehaviour
		{
			public enum States
			{
				OFF,
				ON,
				LIGHTS_ONLY
			}

			private BaseVehicle vehicle;
			private InstrumentTool trumpet;
			public Configuration Config { get; set; }
			public States State { get; private set; }
			public Siren Siren { get; set; }
			public ISet<NetworkableId> NetIDs { get; } = new HashSet<NetworkableId>();

			public States ChangeState()
			{
				SetState(State >= States.LIGHTS_ONLY ? States.OFF : State + 1);
				return State;
			}

			public void SetState(States aState)
			{
				State = aState;
				if ((!Config.SoundEnabled || Siren?.Tones?.Length < 1 || !GetTrumpet()) && State == States.ON)
				{
					State++;
				}
				RefreshSirenState();
			}

			public void RefreshSirenState()
			{
				if (State == States.ON)
				{
					PlayTone(0);
				}
				bool theLightsOnFlag = State > States.OFF;
				foreach (IOEntity eachEntity in GetVehicle().GetComponentsInChildren<IOEntity>())
				{
					if (NetIDs.Contains(eachEntity.net.ID) && !(eachEntity is PressButton))
					{
						ToogleSirens(eachEntity, theLightsOnFlag);
					}
				}
			}

			private InstrumentTool GetTrumpet()
			{
				if (trumpet == null || trumpet.IsDestroyed)
				{
					trumpet = GetVehicle().GetComponentInChildren<InstrumentTool>();
				}
				return trumpet;
			}

			private BaseVehicle GetVehicle()
			{
				if (vehicle == null)
				{
					vehicle = GetComponentInParent<BaseVehicle>();
				}
				return vehicle;
			}

			private void PlayTone(int anIndex)
			{
				if (State != States.ON || !GetTrumpet())
				{
					return;
				}
				if (anIndex >= Siren.Tones.Length)
				{
					anIndex = 0;
				}
				Tone theTone = Siren.Tones[anIndex];
				GetTrumpet().ClientRPC(RpcTarget.NetworkGroup("Client_PlayNote"), (int)theTone.Note, (int)theTone.NoteType, theTone.Octave, 1f);
				Invoke(() => GetTrumpet().ClientRPC(RpcTarget.NetworkGroup("Client_StopNote"), (int)theTone.Note, (int)theTone.NoteType, theTone.Octave), theTone.Duration - 0.1f);
				Invoke(() => PlayTone(++anIndex), theTone.Duration);
			}
		}
		#endregion controllers
	}
}


// --- End of file: Sirens.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/smooth-restarter-rejoin-rewards ---
// --- Original File Path: S/SmoothRestarterRejoinRewards/SmoothRestarterRejoinRewards.cs ---

﻿// #define DEBUG

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

using Facepunch;

using Newtonsoft.Json;

using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Smooth Restarter Rejoin Rewards", "2CHEVSKII", "1.1.0")]
    [Description("Reward players if they re-join after restart")]
    public class SmoothRestarterRejoinRewards : CovalencePlugin
    {
        #region Fields

        const string PERMISSION_PREFIX = "smoothrestarterrejoinrewards.";

        const string M_PREFIX             = "Chat prefix",
                     M_REWARDS            = "Chance to claim rewards",
                     M_UNCLAIMED          = "Has unclaimed rewards",
                     M_NO_REWARDS         = "No unclaimed rewards",
                     M_NO_SPACE           = "Not enough space",
                     M_CLAIMED            = "All rewards claimed",
                     M_RECEIVED_ITEMS     = "Received items",
                     M_RECEIVED_ECONOMICS = "Received Economics points",
                     M_RECEIVED_SR_POINTS = "Received ServerRewards points";

        [PluginReference] Plugin                            SmoothRestarter;
        [PluginReference] Plugin                            ServerRewards;
        [PluginReference] Plugin                            Economics;
        PluginSettings                                      settings;
        Dictionary<string, List<PluginSettings.RewardItem>> delayedItems;
        Dictionary<string, PluginSettings.PointReward>      delayedPoints;
        List<string>                                        rewardClaimers;
        Timer                                               notificationTimer;
        DateTime                                            currentRestartTime;
        bool                                                isRestarting;

        #endregion

        #region Oxide hooks

        void Init()
        {
            foreach (var perm in settings.Rewards.Keys)
            {
                if (perm == string.Empty)
                {
                    continue;
                }

                permission.RegisterPermission(ConstructPermission(perm), this);
            }

            AddCovalenceCommand("rjrewards", nameof(CommandHandler));
            rewardClaimers = new List<string>();
        }

        void OnServerInitialized()
        {
            bool srLoaded = SmoothRestarter != null && SmoothRestarter.IsLoaded;

            if (!srLoaded)
            {
                LogWarning(
                    "This plugin needs SmoothRestarter in order to work. " +
                    "Install it from https://umod.org/plugins/smooth-restarter and reload the plugin"
                );
            }

            delayedItems = LoadRewards();
            delayedPoints = LoadPoints();

            if (settings.ReconnectThreshold > 0)
            {
                timer.Once(
                    settings.ReconnectThreshold,
                    delegate {
                        delayedItems.Clear();
                        delayedPoints.Clear();
                    }
                );
            }
        }

        void OnUserDisconnected(IPlayer player)
        {
            if (isRestarting)
            {
                AddRewardClaimer(player);
            }
        }

        void Unload()
        {
            SaveData();
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!player || player.IsDead() || !player.userID.IsSteamId())
            {
                return;
            }

            NotifyUnclaimedRewards(player.IPlayer);
        }

        #region SmoothRestarter API

        void OnSmoothRestartInit()
        {
            currentRestartTime = SmoothRestarter.Call<DateTime>("GetCurrentRestartTime");
            isRestarting = true;

            Debug("Restart initiated, restartTime: {0}", currentRestartTime);

            NotifyRewardsChance();
            if (settings.NotificationFrequency > 0)
            {
                notificationTimer = timer.Every(settings.NotificationFrequency, NotifyRewardsChance);
            }

        }

        void OnSmoothRestartTick()
        {
            if (settings.NotificationFrequency <= 0)
            {
                NotifyRewardsChance();
            }
        }

        void OnSmoothRestartCancelled()
        {
            isRestarting = false;

            Debug("Restart cancelled");

            timer.Destroy(ref notificationTimer);

            rewardClaimers.Clear();
        }

        #endregion

        #endregion

        #region Notifications

        void NotifyRewardsChance()
        {
            foreach (var player in players.Connected)
            {
                var rewards = GetRewardsForPlayer(player.Id);

                if (rewards.Count > 0)
                {
                    var fmt = string.Join(", ", rewards);

                    Message(player, M_REWARDS, fmt);
                }
            }
        }

        void NotifyUnclaimedRewards(IPlayer player)
        {
            if (!HasUnclaimedRewards(player))
            {
                return;
            }

            //var rewards = delayedItems[player.Id];
            //var fmt = string.Join(", ", rewards);


            Message(player, M_UNCLAIMED);
        }

        void NotifyReceivedRewards(IPlayer player, List<PluginSettings.RewardItem> items, PluginSettings.PointReward points)
        {
            if (items.Any())
            {
                Message(player, M_RECEIVED_ITEMS, string.Join(", ", items.Select(item => item.ToString())));
            }

            if (points.serverRewardsPoints > 0)
            {
                Message(player, M_RECEIVED_SR_POINTS, points.serverRewardsPoints);
            }

            if (points.economicsPoints > 0)
            {
                Message(player, M_RECEIVED_ECONOMICS, points.economicsPoints);
            }
        }

        #endregion

        #region Command handler

        void CommandHandler(IPlayer player)
        {
            if (!HasUnclaimedRewards(player))
            {
                Message(player, M_NO_REWARDS);
            }
            else
            {
                List<PluginSettings.RewardItem> itemRewards = Pool.GetList<PluginSettings.RewardItem>();
                PluginSettings.PointReward pointReward = default(PluginSettings.PointReward);

                var basePlayer = (BasePlayer)player.Object;

                if (delayedItems.ContainsKey(player.Id))
                {
                    var rewards = delayedItems[player.Id];

                    while (rewards.Count > 0)
                    {
                        var container = GetFreeContainer(basePlayer);

                        if (container == null)
                        {
                            break;
                        }

                        var rwd = rewards[0];

                        itemRewards.Add(rwd);

                        var item = rwd.CreateItem();
                        rewards.RemoveAt(0);

                        item.MoveToContainer(container, ignoreStackLimit: true);
                        item.MarkDirty();
                        container.MarkDirty();
                        basePlayer.SendConsoleCommand(
                            "note.inv",
                            item.info.itemid,
                            item.amount,
                            item.name,
                            2
                        );
                    }

                    if (rewards.Count > 0)
                    {
                        Message(player, M_NO_SPACE, rewards.Count);
                    }
                    else
                    {
                        delayedItems.Remove(player.Id);
                        NextTick(() => Message(player, M_CLAIMED)); // make all claimed message appear after notification about received rewards
                    }
                }

                if (delayedPoints.ContainsKey(player.Id))
                {
                    var reward = delayedPoints[player.Id];

                    AddEconomicsPoints(player, reward.economicsPoints);
                    AddServerRewardsPoints(basePlayer, reward.serverRewardsPoints);

                    delayedPoints.Remove(player.Id);

                    pointReward = reward;
                }

                NotifyReceivedRewards(player, itemRewards, pointReward);
                Pool.FreeList(ref itemRewards);
            }
        }

        #endregion

        #region Util

        bool HasSlotsInInventory(BasePlayer player, bool beltContainer = false)
        {
            if (!beltContainer)
            {
                return player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count > 0;
            }

            return player.inventory.containerBelt.capacity - player.inventory.containerBelt.itemList.Count > 0;
        }

        ItemContainer GetFreeContainer(BasePlayer player)
        {
            if (HasSlotsInInventory(player, false))
            {
                return player.inventory.containerMain;
            }

            if (HasSlotsInInventory(player, true))
            {
                return player.inventory.containerBelt;
            }

            return null;
        }

        bool HasUnclaimedRewards(IPlayer player)
        {
            return delayedItems.ContainsKey(player.Id) || delayedPoints.ContainsKey(player.Id);
        }

        void AddRewardClaimer(IPlayer player)
        {
            if (rewardClaimers.Contains(player.Id))
            {
                return;
            }

            rewardClaimers.Add(player.Id);
        }

        [Conditional("DEBUG")]
        void Debug(string format, params object[] args)
        {
            Log(string.Format("DEBUG: " + format, args));
        }

        #endregion

        #region Data

        void SaveData()
        {
            var dataFile = Interface.Oxide.DataFileSystem.GetFile(nameof(SmoothRestarterRejoinRewards));

            dataFile.WriteObject((IEnumerable<string>)rewardClaimers ?? Array.Empty<string>());
        }

        List<string> LoadData()
        {
            var list = new List<string>();
            DynamicConfigFile dataFile;

            if (Interface.Oxide.DataFileSystem.ExistsDatafile(nameof(SmoothRestarterRejoinRewards)))
            {
                dataFile = Interface.Oxide.DataFileSystem.GetFile(nameof(SmoothRestarterRejoinRewards));

                try
                {
                    var strings = dataFile.ReadObject<List<string>>();

                    if (strings == null)
                    {
                        throw new Exception("Data is null");
                    }

                    list.AddRange(strings.Where(s => !string.IsNullOrWhiteSpace(s)));
                }
                catch
                {
                    LogError("Failed to load plugin data, rewards for previous restart will not be available.");
                }
            }
            else
            {
                dataFile = Interface.Oxide.DataFileSystem.GetFile(nameof(SmoothRestarterRejoinRewards));
            }

            dataFile.Clear();
            dataFile.WriteObject(Array.Empty<string>());

            return list;
        }

        #endregion

        #region Rewards

        Dictionary<string, List<PluginSettings.RewardItem>> LoadRewards()
        {
            var dictionary = new Dictionary<string, List<PluginSettings.RewardItem>>();

            var userids = LoadData();

            foreach (var userid in userids)
            {
                var rewards = GetRewardsForPlayer(userid);

                if (rewards.Count > 0)
                {
                    dictionary.Add(userid, rewards);
                }
            }

            return dictionary;
        }

        Dictionary<string, PluginSettings.PointReward> LoadPoints()
        {
            var dictionary = new Dictionary<string, PluginSettings.PointReward>();

            var userids = LoadData();

            foreach (var userid in userids)
            {
                var points = GetPointsForPlayer(userid);

                if (points.serverRewardsPoints > 0 || points.economicsPoints > 0)
                {
                    dictionary.Add(userid, points);
                }
            }

            return dictionary;
        }

        PluginSettings.PointReward GetPointsForPlayer(string userid)
        {
            var reward = new PluginSettings.PointReward();

            var defaultReward = GetDefaultPoints();

            reward.serverRewardsPoints += defaultReward.serverRewardsPoints;
            reward.economicsPoints += defaultReward.economicsPoints;

            var perms = GetPermissionGroups(userid);

            foreach (var perm in perms)
            {
                var permReward = GetPointsForPermission(perm);

                reward.serverRewardsPoints += permReward.serverRewardsPoints;
                reward.economicsPoints += permReward.economicsPoints;
            }

            return reward;
        }

        List<PluginSettings.RewardItem> GetRewardsForPlayer(string userid)
        {
            var list = new List<PluginSettings.RewardItem>();

            list.AddRange(GetDefaultRewards());

            var perms = GetPermissionGroups(userid);

            foreach (var perm in perms)
            {
                list.AddRange(GetRewardsForPermission(perm));
            }

            return list;
        }

        PluginSettings.PointReward GetDefaultPoints()
        {
            return GetPoints(string.Empty);
        }

        IEnumerable<PluginSettings.RewardItem> GetDefaultRewards()
        {
            return GetRewards(string.Empty);
        }

        IEnumerable<PluginSettings.RewardItem> GetRewardsForPermission(string perm)
        {
            var p = DeconstructPermission(perm);

            return GetRewards(p);
        }

        PluginSettings.PointReward GetPointsForPermission(string perm)
        {
            var p = DeconstructPermission(perm);

            return GetPoints(p);
        }

        PluginSettings.RewardItem[] GetRewards(string key)
        {
            PluginSettings.RewardItem[] rewards;
            if (!settings.Rewards.TryGetValue(key, out rewards))
            {
                rewards = Array.Empty<PluginSettings.RewardItem>();
            }

            return rewards;
        }

        PluginSettings.PointReward GetPoints(string key)
        {
            PluginSettings.PointReward item;
            if (!settings.RewardPoints.TryGetValue(key, out item))
            {
                item = default(PluginSettings.PointReward);
            }

            return item;
        }

        #endregion

        #region ServerRewards integration

        void AddServerRewardsPoints(BasePlayer player, int points)
        {
            if (ServerRewards != null && ServerRewards.IsLoaded)
            {
                var success = ServerRewards.Call("AddPoints", player.userID, points);
                if (success == null)
                {
                    LogWarning("Could not add ServerRewards points for player {0} [{1}]", player.displayName, player.UserIDString);
                }
            }
        }

        #endregion

        #region Economics integration

        void AddEconomicsPoints(IPlayer player, int points)
        {
            if (Economics != null && Economics.IsLoaded)
            {
                bool success = Economics.Call<bool>("Deposit", player.Id, points);

                if (!success)
                {
                    LogWarning("Could not add Economics points for player {0} [{1}]", player.Name, player.Id);
                }
            }
        }

        #endregion

        #region Permissions

        IEnumerable<string> GetPermissionGroups(string userid)
        {
            return permission.GetUserPermissions(userid).Where(p => p.StartsWith(PERMISSION_PREFIX));
        }

        string ConstructPermission(string perm)
        {
            return PERMISSION_PREFIX + perm;
        }

        string DeconstructPermission(string perm)
        {
            return perm.Substring(PERMISSION_PREFIX.Length);
        }

        #endregion

        #region LangAPI

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(
                new Dictionary<string, string>
                {
                    { M_PREFIX, "<color=#ffa04f>Rejoin Rewards</color>:" },
                    { M_REWARDS, "If you rejoin after the server restart, you will receive rewards:\n{0}" },
                    { M_UNCLAIMED, "You currently have unclaimed rejoin rewards, use /rjrewards to claim them" },
                    { M_NO_REWARDS, "You do not have any unclaimed rewards" },
                    {
                        M_NO_SPACE,
                        "You do not have enough space in your inventory, some rewards ({0}) were not claimed. " +
                        "Free up some space and use /rjrewards to claim the remaining items"
                    },
                    { M_CLAIMED, "All rewards were claimed" },
                    { M_RECEIVED_ITEMS, "You were rewarded with items: {0}" },
                    { M_RECEIVED_ECONOMICS, "Your Economics balance was funded with {0} points" },
                    { M_RECEIVED_SR_POINTS, "You've received {0} points on your ServerRewards balance" }
                },
                this
            );
        }

        void Message(IPlayer player, string langKey, params object[] args)
        {
            var format = GetMessage(player, langKey);

            player.Message(format, GetMessage(player, M_PREFIX), args);
        }

        string GetMessage(IPlayer player, string langKey)
        {
            return lang.GetMessage(langKey, this, player.Id);
        }

        #endregion

        #region Configuration

        protected override void LoadDefaultConfig()
        {
            settings = PluginSettings.Default;
            SaveConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                settings = Config.ReadObject<PluginSettings>();

                if (settings == null || settings.Rewards == null)
                {
                    throw new Exception("Configuration or rewards dictionary is null");
                }

                if (PluginSettings.NeedsUpdate(settings))
                {
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError("Configuration load fail: {0}", e.Message);
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(settings);
        }

        #endregion

        #region Nested types

        class PluginSettings
        {
            public static PluginSettings Default =>
                new PluginSettings {
                    NotificationFrequency = 30f,
                    ReconnectThreshold = 600f,
                    Rewards = new Dictionary<string, RewardItem[]> {
                        [string.Empty] = new[]
                        {
                            new RewardItem
                            {
                                shortname = "rifle.ak",
                                quantity = 1,
                                durability = 0.3f,
                                skin = 0ul
                            },
                            new RewardItem
                            {
                                shortname = "ammo.rifle",
                                quantity = 60,
                                durability = 1f,
                                skin = 0ul
                            }
                        }
                    },
                    RewardPoints = new Dictionary<string, PointReward> {
                        [string.Empty] = new PointReward {
                            serverRewardsPoints = 0,
                            economicsPoints = 0
                        }
                    }
                };

            [JsonProperty("Notification frequency")]
            public float NotificationFrequency { get; set; }
            [JsonProperty("Reconnect threshold")]
            public float ReconnectThreshold { get; set; }
            [JsonProperty("Rewards")]
            public Dictionary<string, RewardItem[]> Rewards { get; set; }
            [JsonProperty("ServerRewards and economics points")]
            public Dictionary<string, PointReward> RewardPoints { get; set; }

            public static bool NeedsUpdate(PluginSettings settings)
            {
                if (settings.RewardPoints == null)
                {
                    settings.RewardPoints = new Dictionary<string, PointReward> {
                        [string.Empty] = new PointReward {
                            serverRewardsPoints = 0,
                            economicsPoints = 0
                        }
                    };

                    return true;
                }

                return false;
            }

            public struct PointReward
            {
                public int serverRewardsPoints;
                public int economicsPoints;

                public bool IsNotEmpty()
                {
                    return serverRewardsPoints > 0 || economicsPoints > 0;
                }
            }

            public struct RewardItem
            {
                public string shortname;
                public int    quantity;
                public float  durability;
                public ulong  skin;

                public override string ToString()
                {
                    return shortname + ": " + quantity;
                }

                public Item CreateItem()
                {
                    if (quantity < 1)
                    {
                        throw new InvalidOperationException("Cannot create item with quantity less than 1");
                    }

                    var def = ItemManager.FindItemDefinition(shortname);

                    if (def == null)
                    {
                        throw new Exception($"Could not find ItemDefinition for shortname {shortname}");
                    }

                    var item = ItemManager.Create(def, quantity, skin);

                    if (durability > 0f)
                    {
                        item.conditionNormalized = Mathf.Clamp01(durability);
                        item.MarkDirty();
                    }

                    return item;
                }
            }
        }

        #endregion
    }
}


// --- End of file: SmoothRestarterRejoinRewards.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/staffmode ---
// --- Original File Path: S/Staffmode/Staffmode.cs ---

﻿using UnityEngine; 
using System;
using System.Collections.Generic;
using System.Reflection;
using Oxide.Core;
using Oxide.Game.Rust.Libraries;

namespace Oxide.Plugins
{
    [Info("Staffmode", "Canopy Sheep", "1.2.3", ResourceId = 2263)]
    [Description("Toggle on/off staff mode")]
    class Staffmode : RustPlugin
    {
        #region Helpers
        private string Version = "1.2.0";
        readonly Dictionary<ulong, string> groupEditor = new Dictionary<ulong, string>();

        readonly List<string> editValues = new List<string>()
        {
            "authlevel",
            "offdutygroup",
            "ondutygroup",
            "permission"
        };

        static string UppercaseFirst(string s)
        {
            if (string.IsNullOrEmpty(s))
                return string.Empty;
            s = s.ToLower();
            var a = s.ToCharArray();
            a[0] = char.ToUpper(a[0]);
            return new string(a);
        }

        bool CheckPermission(BasePlayer player, string perm)
		{
			if(permission.UserHasPermission(player.UserIDString, perm)) return true;
			return false;
		}

        #endregion
        #region Data

        class Data
		{
			public Dictionary<string, StaffData> StaffData = new Dictionary<string, StaffData>();
		}
		
		Data data;

		class GroupData
		{
			public Dictionary<string, Group> Groups = new Dictionary<string, Group>();
		}
		
		GroupData groupData; 
		
		class StaffData
		{
			public bool EnabledOffDutyMode;
			
			public StaffData(BasePlayer player)
			{
				EnabledOffDutyMode = false;
			}
		}
		
		class Group
		{
			public string GroupName;
			public int AuthLevel;
			public string OffDutyGroup;
			public string OnDutyGroup;
			public string PermissionNode;
		}

        #endregion
        #region Config

        private int AuthLevel;
        private string OffDutygroup;
        private string OnDutygroup;
        private string Permissionnode;
		private string groupname;
        private int groupcount = 0;
	    private int possibletotalerrors = 0;
        private int possiblemajorerrors = 0;
		private bool AlreadyPowered = false;
		private bool AlreadyAnnounced = false;
		private bool PermissionDenied = false;
		private bool AlreadyToggled = false;
        private ConfigData configData;

        class ConfigData
		{
			public SettingsData Settings { get; set; }
            public GamePlayeSettingsData GameplaySettings { get; set; }
            public DebugData Debug { get; set; }
            public string ConfigVersion { get; set; }
		}

		class SettingsData
		{
			public string PluginPrefix { get; set; }
			public string EditPermission { get; set; }
            public string Command { get; set; }
			public bool AnnounceOnToggle { get; set; }
			public bool LogOnToggle { get; set; }
			public bool DisconnectOnToggle { get; set; }
			public bool EnableGroupToggle { get; set; }
		}

        class GamePlayeSettingsData
        {
            public bool ShowMessages { get; set; }
            public bool CanAttack { get; set; }
            public bool CanBeTargetedByHeliAndTurrets { get; set; }
            public bool CanLootPlayer { get; set; }
        }

        class DebugData
        {
            public bool CheckGroupDataOnLoad { get; set; }
            public bool Dev { get; set; }
        }

        void TryConfig()
        {
            try
            {
                configData = Config.ReadObject<ConfigData>();
            }
            catch (Exception)
            {
                Puts("Corrupt config");
                LoadDefaultConfig();
            }
            if (configData.ConfigVersion != Version || configData.ConfigVersion == null)
            {
                PrintWarning("A config update is available, please regenerate a new config.");
            }
        }

        void LoadConfig()
        {
            Config.WriteObject(new ConfigData
            {
                Settings = new SettingsData
                {
                    PluginPrefix = "<color=orange>[StaffMode]</color>",
                    EditPermission = "staffmode.canedit",
                    Command = "staffmode",
                    AnnounceOnToggle = true,
                    LogOnToggle = true,
                    DisconnectOnToggle = true,
                    EnableGroupToggle = true
                },
                GameplaySettings = new GamePlayeSettingsData
                {
                    ShowMessages = true,
                    CanAttack = true,
                    CanBeTargetedByHeliAndTurrets = true,
                    CanLootPlayer = true
                },
                Debug = new DebugData
                {
                    CheckGroupDataOnLoad = false,
                    Dev = false
                },
                ConfigVersion = "1.2.0",
            }, true);
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Generating a new config file...");
            LoadConfig();
        }

        #endregion
        #region Language

        internal string Replace(string source, string name) => source.Replace(source, name);

        string Lang(string key, object userID = null) => lang.GetMessage(key, this, userID == null ? null : userID.ToString());

        private void Language()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "ToggleOnAnnounce", "{player.name} has switched to staff mode. They can now use staff commands."},
                { "ToggleOffAnnounce", "{player.name} has switched to player mode. They can no longer use staff commands."},
                { "ToggleOn", "You have switched to staff mode!"},
                { "ToggleOff", "You have switched to player mode!"},
                { "Disconnect", "You will be disconnected in {seconds}, please reconnect to update your auth level."},
                { "ToggleOnLog", "{player.name} is now in staff mode."},
                { "ToggleOffLog", "{player.name} is now out of staff mode."},
                { "NoPermission", "You do not have permission to use this command."},
                { "Reconnect", "You will be kicked in 5 seconds to update your status. Please reconnect!"},
                { "Corrupt", "A group you tried to toggle into is corrupt, please check console for more information."},
                { "Usage", "Usage: /{0} {1} {2} {3}"},
                { "AlreadyExists", "This group already exists."},
                { "DoesNotExist", "This group doesn't exists."},
                { "RemovedGroup", "Removed group '{group}' successfully"},
                { "CreatedGroup", "Created group '{group}' successfully."},
                { "NoGroups", "No groups have been configured properly. Check console for data check."},
                { "EditingGroup", "Now editing group '{group}.'"},
                { "NotEditingGroup", "You are not editing a group."},
                { "UpdatedValue", "Updated '{0}' to '{1}' for group '{2}.'"},
                { "OnAttack", "You cannot attack while in staff mode."},
                { "OnLootPlayer", "You cannot loot another player while in staff mode."}
            }, this);
        }

        #endregion
        #region Hooks
        void Init()
        {	
			LoadData();
			Language();
			TryConfig();   
			RegisterPermissions();
			CheckData(1);

            var command = Interface.Oxide.GetLibrary<Command>();
            command.AddChatCommand(configData.Settings.Command, this, "StaffToggleCommand");
        }

		void RegisterPermissions()
		{
			foreach (var group in groupData.Groups.Values)
            {
                if (!string.IsNullOrEmpty(group.PermissionNode))
                    permission.RegisterPermission(group.PermissionNode, this);
            }
			permission.RegisterPermission(configData.Settings.EditPermission, this);
		}

        void LoadData()
        {
            data = Interface.Oxide.DataFileSystem.ReadObject<Data>("Staffmode_PlayerData");
            var groupdata = Interface.Oxide.DataFileSystem.GetFile("Staffmode_Groups");
            try
            {
                groupData = groupdata.ReadObject<GroupData>();
                var update = new List<string>();
            }
            catch
            {
                groupData = new GroupData();
            }
        }

        void SaveData() 
		{
			Interface.Oxide.DataFileSystem.WriteObject("Staffmode_PlayerData", data);
		}
		
		void SaveGroups()
		{
			Interface.Oxide.DataFileSystem.WriteObject("Staffmode_Groups", groupData);
		}

		void CheckData(int value)
		{
			groupcount = 0;
			possibletotalerrors = 0;
			possiblemajorerrors = 0;
            if (!(configData.Debug.CheckGroupDataOnLoad) && value == 1) 
			{
				foreach (var group in groupData.Groups.Values)
				{
					groupcount++;
				}
				return;
			}

			Puts("Checking groups...");
			foreach (var group in groupData.Groups.Values)
			{
				groupcount++;
				if (configData.Settings.EnableGroupToggle)
				{
                    if (!(group.OnDutyGroup == null))
                    {
                        try
                        {
                            if (!(permission.GroupExists(group.OnDutyGroup))) { Puts("Permission Group '" + group.OnDutyGroup.ToString() + "' does not exist. Check to make sure this permission group exists."); possibletotalerrors++; }
                        }
                        catch (NullReferenceException)
                        {
                            Puts("Check could not continue for group '" + group.GroupName.ToString() + ".' Check for any 'null' settings.");
                            possibletotalerrors++;
                            possiblemajorerrors++;
                            continue;
                        }
                    }
                    else { Puts("Group '" + group.GroupName.ToString() + "' OnDutyGroup is null with GroupToggling enabled."); possibletotalerrors++; }

                    if (!(group.OffDutyGroup == null))
                    {
                        try
                        {
                            if (!(permission.GroupExists(group.OffDutyGroup))) { Puts("Permission Group '" + group.OffDutyGroup.ToString() + "' does not exist. Check to make sure this permission group exists."); possibletotalerrors++; }
                        }
                        catch (NullReferenceException)
                        {
                            Puts("Check could not continue for group '" + group.GroupName.ToString() + ".' Check for any 'null' settings.");
                            possibletotalerrors++;
                            possiblemajorerrors++;
                            continue;
                        }
                    }
                    else { Puts("Group '" + group.GroupName.ToString() + "' OffDutyGroup is null with GroupToggling enabled."); possibletotalerrors++; }
                }
                if (group.AuthLevel != null)
				{
                    if (group.AuthLevel != 0)
					{
                        if (group.AuthLevel != 1 && group.AuthLevel != 2) { Puts("Group '" + group.GroupName.ToString() + "' does not have a correct auth level setting. Must be '0' '1' or '2'" ); possibletotalerrors++; possiblemajorerrors++; }
                    }
				}
				if (group.PermissionNode == null)
				{
					Puts("Group '" + group.GroupName + "' permission node is null. Anyone will be able to toggle into this group.");
					possibletotalerrors++;
				}
			}
			Puts("Group check complete. Checked '" + groupcount + "' groups. Detected '" + possibletotalerrors + "' possible error(s), '" + possiblemajorerrors + "' which are critical based on your settings.");
		}

        object OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if (configData.GameplaySettings.CanAttack) { return null; }
            if (!data.StaffData.ContainsKey(attacker.UserIDString) || data.StaffData[attacker.UserIDString].EnabledOffDutyMode) { return null; }
            if (configData.GameplaySettings.ShowMessages) { SendReply(attacker, configData.Settings.PluginPrefix + " " + Lang("OnAttack", attacker.UserIDString)); }
            return false;
        }

        object CanBeTargeted(BaseCombatEntity player, MonoBehaviour turret)
        {
            if (configData.GameplaySettings.CanBeTargetedByHeliAndTurrets) { return null; }
            var target = player as BasePlayer;
			if (target == null) { return null; }
            if (!(data.StaffData.ContainsKey(target.UserIDString)) || data.StaffData[target.UserIDString].EnabledOffDutyMode) { return null; }
            return false;
        }

        object CanLootPlayer(BasePlayer target, BasePlayer looter)
        {
            if (configData.GameplaySettings.CanLootPlayer) { return null; }
            if (!data.StaffData.ContainsKey(looter.UserIDString) || data.StaffData[looter.UserIDString].EnabledOffDutyMode) { return null; }
            if (configData.GameplaySettings.ShowMessages) { SendReply(looter, configData.Settings.PluginPrefix + " " + Lang("OnLootPlayer", looter.UserIDString)); }
            return false;
        }

        #endregion
        #region Commands

        [ConsoleCommand("checkgroups")]
        void CheckGroupCommand(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin != true) { return; }
            CheckData(2);
        }

		void StaffToggleCommand(BasePlayer player, string cmd, string[] args)
		{	
			if (args.Length == 0)
			{
				if (groupcount == 0)
				{
					SendReply(player, configData.Settings.PluginPrefix + " " + Lang("NoGroups", player.UserIDString));
                    Puts("Error: No groups detected. Please check your data file.");
					return;
				}
				foreach (var group in groupData.Groups.Values)
				{					
					if(!(CheckPermission(player, group.PermissionNode)) && group.PermissionNode != null)
					{
						continue;
					}
					
					PermissionDenied = false;
					if (configData.Settings.EnableGroupToggle)
					{
						if (group.OffDutyGroup == null) {  Puts("Off Duty Group not configured properly. Skipping group '" + group.GroupName + "'"); SendReply(player, configData.Settings.PluginPrefix + " " + Lang("Corrupt", player.UserIDString)); continue; }
						if (group.OnDutyGroup == null) {  Puts("On Duty Group not configured properly. Skipping group '" + group.GroupName + "'"); SendReply(player, configData.Settings.PluginPrefix + " " + Lang("Corrupt", player.UserIDString)); continue; }
					}
					
					if(!data.StaffData.ContainsKey(player.UserIDString)) { data.StaffData.Add(player.UserIDString, new StaffData(player)); }

					//Toggle on
					if(data.StaffData[player.UserIDString].EnabledOffDutyMode)
					{
						if (group.AuthLevel != 0 && !(AlreadyPowered))
						{
							if (configData.Settings.DisconnectOnToggle)
							{
								if (group.AuthLevel == 1) { ConsoleSystem.Run(ConsoleSystem.Option.Server, "moderatorid", player.UserIDString); ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.writecfg"); AlreadyPowered = true; }
								else if (group.AuthLevel == 2) { ConsoleSystem.Run(ConsoleSystem.Option.Server, "ownerid", player.UserIDString); ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.writecfg"); AlreadyPowered = true; } 
							}
							else if (group.AuthLevel == 1 || group.AuthLevel == 2) { player.SetPlayerFlag( BasePlayer.PlayerFlags.IsAdmin, true); AlreadyPowered = true; }
							else { Puts("Error: AuthLevel invalid for group '" + group.GroupName + ".' No AuthLevel given."); }
						}
						if (configData.Settings.EnableGroupToggle)
						{
							permission.AddUserGroup(player.UserIDString, group.OnDutyGroup.ToString());
							permission.RemoveUserGroup(player.UserIDString, group.OffDutyGroup.ToString());	
						}

						if (!(AlreadyAnnounced))
						{
							SendReply(player, configData.Settings.PluginPrefix + " " + Lang("ToggleOn", player.UserIDString));
							if (configData.Settings.LogOnToggle) { Puts(Lang("ToggleOnLog", player.UserIDString).Replace("{player.name}", player.displayName)); }
							if (configData.Settings.AnnounceOnToggle) { PrintToChat(configData.Settings.PluginPrefix + " " + Lang("ToggleOnAnnounce", player.UserIDString).Replace("{player.name}", player.displayName)); }
							if (configData.Settings.DisconnectOnToggle)
							{
								SendReply(player, configData.Settings.PluginPrefix + " " + Lang("Reconnect", player.UserIDString));
								if (!(configData.Debug.Dev)) { timer.Once(5, () => player.Kick("Disconnected")); }
							}
							AlreadyAnnounced = true;
						}		
						AlreadyToggled = true;
					}
					//Toggle off
					else if(!(data.StaffData[player.UserIDString].EnabledOffDutyMode))
					{
						if (configData.Settings.EnableGroupToggle)
						{
							permission.AddUserGroup(player.UserIDString, group.OffDutyGroup.ToString());
							permission.RemoveUserGroup(player.UserIDString, group.OnDutyGroup.ToString());	
						}
						if (group.AuthLevel != 0 && !AlreadyPowered)
						{
							if (configData.Settings.DisconnectOnToggle)
							{
								if (group.AuthLevel == 1) { ConsoleSystem.Run(ConsoleSystem.Option.Server, "removemoderator", player.UserIDString); ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.writecfg"); }
								else if (group.AuthLevel == 2) { ConsoleSystem.Run(ConsoleSystem.Option.Server, "removeowner", player.UserIDString); ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.writecfg"); }
							}
							else if (group.AuthLevel == 1 || group.AuthLevel == 2) { player.SetPlayerFlag( BasePlayer.PlayerFlags.IsAdmin, false); }
							else { Puts("Error: AuthLevel invalid for group '" + group.GroupName + ".' No AuthLevel revoked."); }
							AlreadyPowered = true;
						}
						if (!(AlreadyAnnounced))
						{
							SendReply(player, configData.Settings.PluginPrefix + " " + Lang("ToggleOff", player.UserIDString));
							if (configData.Settings.LogOnToggle) { Puts(Lang("ToggleOffLog", player.UserIDString).Replace("{player.name}", player.displayName)); }
							if (configData.Settings.AnnounceOnToggle) { PrintToChat(configData.Settings.PluginPrefix + " " + Lang("ToggleOffAnnounce", player.UserIDString).Replace("{player.name}", player.displayName)); }
							if (configData.Settings.DisconnectOnToggle)
							{
								SendReply(player, configData.Settings.PluginPrefix + " " + Lang("Reconnect", player.UserIDString)); 
								if (!configData.Debug.Dev) { timer.Once(5, () => player.Kick("Disconnected")); }
							}
							AlreadyAnnounced = true;
						}
						AlreadyToggled = true;
					}
				}
				if(data.StaffData.ContainsKey(player.UserIDString))
				{
					data.StaffData[player.UserIDString].EnabledOffDutyMode = !data.StaffData[player.UserIDString].EnabledOffDutyMode;
					SaveData();
				}
				AlreadyAnnounced = false;
				AlreadyPowered = false;
				if (PermissionDenied && !(AlreadyToggled)) { SendReply(player, configData.Settings.PluginPrefix + " " + Lang("NoPermission", player.UserIDString)); return; }
				PermissionDenied = true;
				AlreadyToggled = false;
				return;
			}
			else
			{
                if(!(CheckPermission(player, configData.Settings.EditPermission))) { SendReply(player, configData.Settings.PluginPrefix + " " + Lang("NoPermission", player.UserIDString)); return; }
				
                switch (args[0].ToLower())
				{
					case "group":
					{
						if (args.Length < 2)
						{
							SendReply(player, configData.Settings.PluginPrefix + " " + string.Format(Lang("Usage", player.UserIDString), configData.Settings.Command, "group", "create/remove/edit", "[groupname]"));
							return;
						}
						switch (args[1].ToLower())
						{
							case "create":
							{	
								if (args.Length != 3)
								{
									SendReply(player, configData.Settings.PluginPrefix + " " + string.Format(Lang("Usage", player.UserIDString), configData.Settings.Command, "group", "create", "[groupname]"));
                                    return;
								}

                                groupname = UppercaseFirst(args[2]);
								
								if(groupData.Groups.ContainsKey(groupname.ToString())) 
								{ 
									SendReply(player, configData.Settings.PluginPrefix + " " + Lang("AlreadyExists", player.UserIDString));
									return; 
								}
								
								groupData.Groups[groupname] = new Group { GroupName = groupname };
								SaveGroups();
								SendReply(player, configData.Settings.PluginPrefix + " " + Lang("CreatedGroup", player.UserIDString).Replace("{group}", groupname.ToString()));
								break;
							}
							case "remove":
							{	
								if (args.Length != 3)
								{
									SendReply(player, configData.Settings.PluginPrefix + " " + string.Format(Lang("Usage", player.UserIDString), configData.Settings.Command, "group", "remove", "[groupname]"));
                                    return;
								}
								
								groupname = UppercaseFirst(args[2]);
								
								if(!(groupData.Groups.ContainsKey(groupname.ToString()))) 
								{ 
									SendReply(player, configData.Settings.PluginPrefix + " " + Lang("DoesNotExist", player.UserIDString));
									return; 
								}
								
								groupData.Groups.Remove(groupname.ToString());
								SaveGroups();
								SendReply(player, configData.Settings.PluginPrefix + " " + Lang("RemovedGroup", player.UserIDString).Replace("{group}", groupname.ToString()));
								break;
							}
                            case "edit":
                            {
                                if (args.Length != 3)
                                {
                                    SendReply(player, configData.Settings.PluginPrefix + " " + string.Format(Lang("Usage", player.UserIDString), configData.Settings.Command, "group", "edit", "[groupname]"));
                                    return;
                                }

                                groupname = UppercaseFirst(args[2]);

                                if (!(groupData.Groups.ContainsKey(groupname.ToString())))
                                {
                                    SendReply(player, configData.Settings.PluginPrefix + " " + Lang("DoesNotExist", player.UserIDString));
                                    return;
                                }
                                groupEditor[player.userID] = groupname;
                                SendReply(player, configData.Settings.PluginPrefix + " " + Lang("EditingGroup", player.UserIDString).Replace("{group}", groupname));

                                foreach (var editValue in editValues)
                                {
                                    SendReply(player, configData.Settings.PluginPrefix + " " + string.Format(Lang("Usage", player.UserIDString), configData.Settings.Command, "edit", editValue.ToString(), "[value]"));
                                }
                                break;
                            }
							default:
							{	
								SendReply(player, configData.Settings.PluginPrefix + " " + string.Format(Lang("Usage", player.UserIDString), configData.Settings.Command, "group", "create/remove/edit", "[groupname]"));
                                break;
							}
						}
						break;
					}
                    case "edit":
                    {
                        if (!(groupEditor.TryGetValue(player.userID, out groupname)))
                        {
                            SendReply(player, configData.Settings.PluginPrefix + " " + Lang("NotEditingGroup", player.UserIDString));
                            return;
                        }

                        if (args.Length != 3)
                        {
                            foreach (var editValue in editValues)
                            {
                                SendReply(player, configData.Settings.PluginPrefix + " " + string.Format(Lang("Usage", player.UserIDString), configData.Settings.Command, "edit", editValue.ToString(), "[value]"));
                            }
                            return;
                        }

                        Group group;

                        if (!(groupData.Groups.TryGetValue(groupname, out group))) { SendReply(player, configData.Settings.PluginPrefix + " " + "An error has occured, try reselecting this group in the editor."); }

                        switch (args[1].ToLower())
                        {
                            case "authlevel":
                            {
                                AuthLevel = int.Parse(args[2]);
                                if (!(AuthLevel == 1 || AuthLevel == 2 || AuthLevel == 0))  
                                {
                                    SendReply(player, configData.Settings.PluginPrefix + " Error: Invalid auth level, must be 0, 1 or 2.");
                                    return;
                                }
                                group.AuthLevel = AuthLevel;
                                SaveGroups();
                                SendReply(player, configData.Settings.PluginPrefix + " " + string.Format(Lang("UpdatedValue", player.UserIDString), "AuthLevel", AuthLevel, groupname));
                                break;
                            }
                            case "offdutygroup":
                            {
                                OffDutygroup = args[2].ToLower();
                                if (!(permission.GroupExists(OffDutygroup)))
                                {
                                    SendReply(player, configData.Settings.PluginPrefix + " Error: This permission group does not exist.");
                                    return;
                                }
                                group.OffDutyGroup = OffDutygroup;
                                SaveGroups();
                                SendReply(player, configData.Settings.PluginPrefix + " " + string.Format(Lang("UpdatedValue", player.UserIDString), "OffDutyGroup", OffDutygroup, groupname));
                                break;
                            }
                            case "ondutygroup":
                            {
                                OnDutygroup = args[2].ToLower();
                                if (!(permission.GroupExists(OnDutygroup)))
                                {
                                    SendReply(player, configData.Settings.PluginPrefix + " Error: This permission group does not exist.");
                                    return;
                                }
                                group.OnDutyGroup = OnDutygroup;
                                SaveGroups();
                                SendReply(player, configData.Settings.PluginPrefix + " " + string.Format(Lang("UpdatedValue", player.UserIDString), "OnDutyGroup", OnDutygroup, groupname));
                                break;
                            }
                            case "permission":
                            {
                                Permissionnode = args[2].ToLower();
                                if (permission.PermissionExists(Permissionnode))
                                {
                                    SendReply(player, configData.Settings.PluginPrefix + " Warning: This permission already exists.");
                                }
                                else
                                {
                                    permission.RegisterPermission(Permissionnode, this);
                                }
                                group.PermissionNode = Permissionnode;
                                SaveGroups();
                                SendReply(player, configData.Settings.PluginPrefix + " " + string.Format(Lang("UpdatedValue", player.UserIDString), "Permission", Permissionnode, groupname));
                                break;
                            }
                            default:
                            {
                                foreach (var editValue in editValues)
                                {
                                    SendReply(player, configData.Settings.PluginPrefix + " " + string.Format(Lang("Usage", player.UserIDString), configData.Settings.Command, "edit", editValue.ToString(), "[value]"));
                                }
                                break;
                            }
                        }
                        break;
                    }
					default:
					{
                        SendReply(player, configData.Settings.PluginPrefix + " " + string.Format(Lang("Usage", player.UserIDString), configData.Settings.Command, "group", "create/remove/edit", "[groupname]"));
						break;
					}
				}
			}
		}
        #endregion
    }
}

// --- End of file: Staffmode.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/submarine-storage ---
// --- Original File Path: S/SubmarineStorage/SubmarineStorage.cs ---

using UnityEngine;
using System.Linq;

namespace Oxide.Plugins {

	[Info("Submarine Storage", "yetzt", "0.0.4")]
	[Description("Adds Storage Boxes to Submarines")]

	public class SubmarineStorage : RustPlugin {

		private string prefab = "assets/content/vehicles/boats/rhib/subents/rhib_storage.prefab";

		#region Oxide

		private void OnEntitySpawned(BaseSubmarine entity) {
			if (entity == null) return;

			// defer checking to ensure storage box is loaded (loads after parent, race condition there)
			timer.Once(0.1f, () => {
				if (entity == null) return;

				// check if there is already a box
				foreach (var child in entity.GetComponentsInChildren<StorageContainer>(true)) {
					if (child.name == prefab) return;
				}
						
				// adding box
				var box = GameManager.server?.CreateEntity(prefab, entity.transform.position) as StorageContainer;
				if (box == null) return;
				box.Spawn();
				box.SetParent(entity);
				if (entity.ShortPrefabName == "submarineduo.entity") {
					box.transform.localPosition = new Vector3(0f, 0.2f, -0.3f);
					box.transform.Rotate(new Vector3(0f, 90f, 0.0f));
				} else {
					box.transform.localPosition = new Vector3(0f, 0.4f, -0.6f);
					box.transform.Rotate(new Vector3(0.0f, 0.0f, 0.0f));
				}
				box.SendNetworkUpdateImmediate(true);

			});

		}

		// drop items when entity dies
		private void OnEntityDeath(BaseSubmarine entity, HitInfo info) {
			if (entity == null) return;
			foreach (var child in entity.GetComponentsInChildren<StorageContainer>(true)) {
				if (child.name == prefab) {
					child.DropItems();
				}
			}
		}
		
		// drop items when entity is killed (don't want salty tears)
		private void OnEntityKill(BaseSubmarine entity) {
			if (entity == null) return;
			foreach (var child in entity.GetComponentsInChildren<StorageContainer>(true)) {
				if (child.name == prefab) {
					child.DropItems();
				}
			}
		}
		
		#endregion
	}
}



// --- End of file: SubmarineStorage.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/save-my-map ---
// --- Original File Path: S/SaveMyMap/SaveMyMap.cs ---

using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using Diag = System.Diagnostics;
using Oxide.Core.Configuration;

namespace Oxide.Plugins
{
	[Info("SaveMyMap", "un boxing man", "1.3.9")] 
	class SaveMyMap : RustPlugin
	{
		bool Changed;
		SaveRestore saveRestore = null;
		bool wasShutDown;
		int Rounds;
		bool Initialized;
		string saveFolder;
		bool loadReload;
		string [] saveFolders;

		int saveInterval;
		int saveCustomAfter;
		bool callOnServerSave;
		float delayCallOnServerSave;
		bool saveAfterLoadFile;
		bool allowOutOfDateSaves;
		bool enableLoadOverride;
		bool onServerSaveUseCoroutine;
		bool saveInData;
		int numberOfSaves;

		object GetConfig(string menu, string datavalue, object defaultValue)
		{
			var data = Config[menu] as Dictionary<string, object>;
			if (data == null)
			{
				data = new Dictionary<string, object>();
				Config[menu] = data;
				Changed = true;
			}
			object value;
			if (!data.TryGetValue(datavalue, out value))
			{
				value = defaultValue;
				data[datavalue] = value;
				Changed = true;
			}
			return value;
		}

		void LoadVariables()
		{
			saveInterval = Convert.ToInt32(GetConfig("Settings", "saveInterval", 1200));
			saveCustomAfter = Convert.ToInt32(GetConfig("Settings", "saveCustomAfter", 1));
			numberOfSaves = Convert.ToInt32(GetConfig("Settings", "numberOfSaves", 5));
			callOnServerSave = Convert.ToBoolean(GetConfig("Settings", "callOnServerSave", true));
			delayCallOnServerSave = Convert.ToInt32(GetConfig("Settings", "delayCallOnServerSave", 3));
			saveAfterLoadFile = Convert.ToBoolean(GetConfig("Settings", "saveAfterLoadFile", true));
			enableLoadOverride = Convert.ToBoolean(GetConfig("Settings", "enableLoadOverride", true));
			allowOutOfDateSaves = Convert.ToBoolean(GetConfig("Settings", "allowOutOfDateSaves", false));
			onServerSaveUseCoroutine = Convert.ToBoolean(GetConfig("Settings", "onServerSaveUseCoroutine", true));
			saveInData = Convert.ToBoolean(GetConfig("Settings", "SaveToOxideData", false));

			if (!Changed) return;
			SaveConfig();
			Changed = false;
		}
		
		void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			                      {
									{"kickreason", "Map restore was initiated. Please wait a momemt"},
									{"loadedinfo", "Saveinverval set to: {0} sec. | Custom save after every '{1}' saves"},
									{"alreadysaving", "Server already saving"},
									{"customsavecomplete", "Custom saving complete"},
									{"needconfirm", "You need to confirm with 'force'"},
									{"definefilename", "You need to define a filename to load"},
									{"lastfilename", "You can load the last file by typing 'load' as name"},
									{"filenotfound", "The given filename was not found."},
									{"dirnotfound", "Save Directory not found. Will be recreated for next save."},									
									{"loadoverride", "Loadfile override succesful."},										
									{"loadoverridecancel", "Loadfile override aborted, map change detected."},		
			                      },this);
		}

		protected override void LoadDefaultConfig()
		{
			Config.Clear();
			LoadVariables();
		}

		void Loaded()
		{
			LoadVariables();
			LoadDefaultMessages();
			Rounds = 0;
			wasShutDown = false;
		}

		void Unload()
		{
		}

		void OnServerInitialized()
		{
			saveFolders = SaveFolders();
			
			if (saveInData == true)
			{
				saveFolder = $"{ Interface.Oxide.DataFileSystem.Directory}/SaveMyMap/{0}/";
			} else { 
				saveFolder = $"{ConVar.Server.rootFolder}/saves/{0}/"; 
			}
			//Puts(saveFolder);
			timer.Every(saveInterval, () =>ServerMgr.Instance.StartCoroutine(SaveLoop()));
			Initialized = true;
			Puts(lang.GetMessage("loadedinfo", this), saveInterval, saveCustomAfter);
		}		
		
		IEnumerator SaveLoop()
		{
			if (!Initialized)
				yield return null;
			WaitForFixedUpdate waitU = new WaitForFixedUpdate();
			BaseEntity.saveList.RemoveWhere(p => !p);
            BaseEntity.saveList.RemoveWhere(p => p == null);
			Diag.Stopwatch stopwatch = Diag.Stopwatch.StartNew();
			foreach (BaseEntity current in BaseEntity.saveList)
				current.InvalidateNetworkCache();
			Debug.Log("Invalidate Network Cache took " + stopwatch.Elapsed.TotalSeconds.ToString("0.00") + " seconds");
			if (Rounds < saveCustomAfter && saveCustomAfter > 0)
			{
				IEnumerator original = SaveRestore.Save(ConVar.Server.rootFolder+"/"+World.SaveFileName, true);					
				while (original.MoveNext()) {} 
				Debug.Log("Saving complete");
				if (!callOnServerSave) Interface.Oxide.DataFileSystem.WriteObject(this.Title, new List<object>(new object[] { ConVar.Server.rootFolder+"/"+World.SaveFileName, "default" }) );
				Rounds++;
				CallOnServerSave();
			}
			else
			{
				string file = saveFolder + World.SaveFileName;
				DirectoryEx.Backup(SaveFolders());
				yield return waitU;
				if (saveInData == true)
				{
					ConVar.Server.GetServerFolder("../../oxide/data/SaveMyMap/0/");
				}
				else
				{
					ConVar.Server.GetServerFolder("saves/0/");

				}
				yield return waitU;
				try {
					IEnumerator custom = SaveRestore.Save(file, true);					
					while (custom.MoveNext()) {}
					Debug.Log("Custom Saving complete");
					if (!callOnServerSave) Interface.Oxide.DataFileSystem.WriteObject(this.Title, new List<object>(new object[] { file, "custom" }) );}
				catch { PrintWarning(lang.GetMessage("dirnotfound", this)); }
				CallOnServerSave();
				Rounds = 0;
			}
			yield return null;
		}

		void OnPluginUnloaded(Plugin name)
		{
			if (Interface.Oxide.IsShuttingDown && !wasShutDown)
			{
				wasShutDown = true;
				
			}
		}

		void OnServerSave(object file = null)
		{
			string type;
			if (file == null)
			{
				file = ConVar.Server.rootFolder+"/"+World.SaveFileName;
				type = "default";
			}
			else
				type = "custom";
			Interface.Oxide.DataFileSystem.WriteObject(this.Title, new List<object>(new object[] { file, type }) );
		}
		
		object OnSaveLoad(Dictionary<BaseEntity, ProtoBuf.Entity> dictionary)
		{
			if (Initialized || loadReload || !enableLoadOverride) return null;
			if (!loadReload)
			{
			List<string> filename = Interface.Oxide.DataFileSystem.ReadObject<List<string>>(this.Title);
			if (filename != null && filename.Count == 2)
				if (filename[1] == "custom")
				{
					loadReload = true;
					if (SaveRestore.Load(filename[0], allowOutOfDateSaves))
					{
						if (dictionary != null)
							dictionary.Clear();
						Puts(lang.GetMessage("loadoverride", this));
						return true;
					}
				}
			}
			return null;
		}
		
		void OnNewSave(string strFilename)
		{
			if (Initialized || loadReload || !enableLoadOverride) return;
			List<string> filename = Interface.Oxide.DataFileSystem.ReadObject<List<string>>(this.Title);
			if (filename != null && filename.Count == 2 && !filename[0].Contains(World.SaveFileName))
			{
				Puts(lang.GetMessage("loadoverridecancel", this));
				return;
			}
			if (filename != null && filename.Count == 2)
				if (filename[1] == "custom")
				{
					loadReload = true;
					if (SaveRestore.Load(filename[0], allowOutOfDateSaves))
						Puts(lang.GetMessage("loadoverride", this));
				}
		}
		
		void CallOnServerSave()
		{
			if (Interface.Oxide.IsShuttingDown)
				return;
			if (callOnServerSave)
				NextTick( () => timer.Once(delayCallOnServerSave, () =>
				{
					if (onServerSaveUseCoroutine)
						ServerMgr.Instance.StartCoroutine(SaveCoroutine());
					else
						Interface.CallHook("OnServerSave", null);
				}));
		}

		IEnumerator SaveCoroutine()
		{
			WaitForFixedUpdate waitU = new WaitForFixedUpdate();
			var allPlugins = plugins.GetAll();
			foreach (var plugin in allPlugins.ToList())
			{
				plugin.CallHook("OnServerSave", null);
				yield return waitU;
			}
			yield return null;
		}		
		
		[ConsoleCommand("smm.save")]
		void cMapSave(ConsoleSystem.Arg arg)
		{
			if(arg.Connection != null && arg.Connection.authLevel < 2) return;
			if (SaveRestore.IsSaving) {
				SendReply(arg, lang.GetMessage("alreadysaving", this, arg.Connection != null ? arg.Connection.userid.ToString() : null ));
				return;
			}
			SaveBackupCreate();
			string saveName;
			saveName = saveFolder + World.SaveFileName;
			foreach (BaseEntity current in BaseEntity.saveList)
				current.InvalidateNetworkCache();
			Diag.Stopwatch stopwatch = Diag.Stopwatch.StartNew();
			UnityEngine.Debug.Log("Invalidate Network Cache took " + stopwatch.Elapsed.TotalSeconds.ToString("0.00") + " seconds");
			try {
				//Puts(saveName);
				BaseEntity.saveList.RemoveWhere(p => !p);
				BaseEntity.saveList.RemoveWhere(p => p == null);
				IEnumerator enumerator = SaveRestore.Save(saveName, true);
				while (enumerator.MoveNext()) {}
				Interface.Oxide.DataFileSystem.WriteObject(this.Title, new List<object>(new object[] { saveName, "custom" }) );
				arg.ReplyWith(lang.GetMessage("customsavecomplete", this, arg.Connection != null ? arg.Connection.userid.ToString() : null )); }
			catch { PrintWarning(lang.GetMessage("dirnotfound", this)); }
			CallOnServerSave();
		}
		
		[ConsoleCommand("server.savemymap")]
		void cMapServerSave(ConsoleSystem.Arg arg)
		{		
			cMapSave(arg);
		}
		
		[ConsoleCommand("smm.loadmap")]
		void cLoadMap(ConsoleSystem.Arg arg)
		{
			if(arg.Connection != null && arg.Connection.authLevel < 2) return;
			if (arg.Args == null || arg.Args.Length != 1 || arg.Args[0] != "force")
			{
				SendReply(arg, lang.GetMessage("needconfirm", this, arg.Connection != null ? arg.Connection.userid.ToString() : null ));
				return;
			}
			foreach (var player in BasePlayer.activePlayerList.ToList())
				player.Kick(lang.GetMessage("kickreason", this, player.UserIDString));
			SaveRestore.Load(ConVar.Server.rootFolder+"/"+World.SaveFileName, allowOutOfDateSaves);
		}

		[ConsoleCommand("smm.loadfile")]
		void cLoadFile(ConsoleSystem.Arg arg)
		{
			if(arg.Connection != null && arg.Connection.authLevel < 2) return;
			if (arg.Args == null || arg.Args.Length < 1 )
			{
					SendReply(arg, lang.GetMessage("definefilename", this, arg.Connection != null ? arg.Connection.userid.ToString() : null ));
					return;
			}
			int folderNumber = -1;
			if (arg.Args[0].Length <= 4 && arg.Args[0] != "last" && !int.TryParse(arg.Args[0], out folderNumber))
			{
					SendReply(arg, lang.GetMessage("lastfilename", this, arg.Connection != null ? arg.Connection.userid.ToString() : null ));
					return;
			}			
			string file = "";
			if (arg.Args[0] == "last")
			{
				List<string> filename = Interface.Oxide.DataFileSystem.ReadObject<List<string>>(this.Title);
				if (filename != null)
					file = filename.First();
			}
			else if (int.TryParse(arg.Args[0], out folderNumber))
			{
				if(saveInData == true)
                {
                    string[] files = Interface.Oxide.DataFileSystem.GetFiles($"{Interface.Oxide.DataFileSystem.Directory}/SaveMyMap/{folderNumber}/", "*.sav");
                   //Puts(files.First());
                    file = files.First();
                }
                else
                {
                    string[] files = Interface.Oxide.DataFileSystem.GetFiles($"{ConVar.Server.rootFolder}/saves/{folderNumber}/", "*.sav");
                    //Puts(files.First());
                    file = files.First();
                }
				
			}
			if (file == "")
				file = saveFolder + arg.Args[0];

			foreach (var player in BasePlayer.activePlayerList.ToList())
				player.Kick(lang.GetMessage("kickreason", this));
			foreach (BaseEntity current in BaseEntity.saveList.ToList())
				if (current != null)
					current.Kill();
			BaseEntity.saveList.Clear();
			ItemManager.DoRemoves();
			if (SaveRestore.Load(file, allowOutOfDateSaves))
			{
				if (saveAfterLoadFile)
				{
					foreach (BaseEntity current in BaseEntity.saveList)
						current.InvalidateNetworkCache();
					SaveRestore.Save(true);
				}
			}
			else
			{
				SendReply(arg, lang.GetMessage("filenotfound", this, arg.Connection != null ? arg.Connection.userid.ToString() : null ));
				return;
			}
		}
		
		[ConsoleCommand("smm.loadnamed")]
		void cLoadNamed(ConsoleSystem.Arg arg)
		{
			if(arg.Connection != null && arg.Connection.authLevel < 2) return;
			if (arg.Args == null || arg.Args.Length < 1 )
			{
					SendReply(arg, lang.GetMessage("definefilename", this, arg.Connection != null ? arg.Connection.userid.ToString() : null ));
					return;
			}
			foreach (var player in BasePlayer.activePlayerList.ToList())
				player.Kick(lang.GetMessage("kickreason", this));
			foreach (BaseEntity current in BaseEntity.saveList.ToList())
				if (current != null)
					current.Kill();
			BaseEntity.saveList.Clear();
			ItemManager.DoRemoves();
			if (SaveRestore.Load(ConVar.Server.rootFolder+"/"+arg.Args[0], true))
			{
				if (saveAfterLoadFile)
				{
					foreach (BaseEntity current in BaseEntity.saveList)
						current.InvalidateNetworkCache();
					SaveRestore.Save(true);
				}
			}
			else
			{
				SendReply(arg, lang.GetMessage("filenotfound", this, arg.Connection != null ? arg.Connection.userid.ToString() : null ));
				return;
			}
		}

		[ConsoleCommand("smm.savefix")]
		void cLoadFix(ConsoleSystem.Arg arg)
		{
			if(arg.Connection != null && arg.Connection.authLevel < 2) return;
			BaseEntity.saveList.RemoveWhere(p => !p);
            BaseEntity.saveList.RemoveWhere(p => p == null);
			foreach (BaseEntity current in BaseEntity.saveList)
				current.InvalidateNetworkCache();
		}

		Int32 UnixTimeStampUTC()
		{
			Int32 unixTimeStamp;
			DateTime currentTime = DateTime.Now;
			DateTime zuluTime = currentTime.ToUniversalTime();
			DateTime unixEpoch = new DateTime(1970, 1, 1);
			unixTimeStamp = (Int32)(zuluTime.Subtract(unixEpoch)).TotalSeconds;
			return unixTimeStamp;
		}
		
		string [] SaveFolders()
		{
			
			
			string [] dp = new string[numberOfSaves];
			for (int i = 0; i < numberOfSaves; i++)
				if (saveInData == true)
				{
					dp[i] = $"{Interface.Oxide.DataFileSystem.Directory}/SaveMyMap/{i}/";

                }
                else
                {
					dp[i] = $"{ConVar.Server.rootFolder}/saves/{i}/";

				}
			
			return dp;
		}
		
		void SaveBackupCreate()
		{
			DirectoryEx.Backup(SaveFolders());
			if (saveInData == true)
            {
				ConVar.Server.GetServerFolder("../../oxide/data/SaveMyMap/0/");
			}
			else
            {
				ConVar.Server.GetServerFolder("saves/0/");

			}
			
            
		}
	}
}

// --- End of file: SaveMyMap.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/server-ban-check ---
// --- Original File Path: S/ServerBanCheck/ServerBanCheck.cs ---

﻿/***********************************************************************************************************************/
/*** DO NOT edit this file! Edit the files under `oxide/config` and/or `oxide/lang`, created once plugin has loaded. ***/
/*** Please note, support cannot be provided if the plugin has been modified. Please use a fresh copy if modified.   ***/
/***********************************************************************************************************************/

using System.Collections.Generic;
using Facepunch;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Server Ban Check", "Wulf", "0.0.2")]
    [Description("Checks if the server IP address has been banned with Facepunch")]
    public class ServerBanCheck : CovalencePlugin
    {
        // https://api.facepunch.com/api/public/manifest/?public_key=j0VF6sNnzn9rwt9qTZtI02zTYK8PRdN1

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandBanCheck"] = "bancheck",
                ["IPAddressesListed"] = "{0} IP addresses for banned servers listed in Facepunch manifest",
                ["ServerIsBanned"] = "Your server IP address {0} is BANNED with Facepunch, and will not appear in the Rust server list",
                ["ServerNotBanned"] = "Your server IP address {0} is NOT BANNED with Facepunch"
            }, this);
        }

        #endregion Localization

        #region Initialization

        private void OnServerInitialized()
        {
            AddLocalizedCommand(nameof(CommandBanCheck));

            Log(GetLang("IPAddressesListed", null, Application.Manifest.Servers.Banned.Length));

            if (!IsServerBanned())
            {
                Log(GetLang("ServerNotBanned", null, server.Address));
            }

            timer.Every(10f, () =>
            {
                if (IsServerBanned())
                {
                    LogWarning(GetLang("ServerIsBanned", null, server.Address));
                }
            });
        }

        private void CommandBanCheck(IPlayer player, string command, string[] args)
        {
            if (player.IsAdmin)
            {
                player.Reply(GetLang(IsServerBanned() ? "ServerIsBanned" : "ServerNotBanned", player.Id, server.Address));
            }
        }

        #endregion Ban Checking

        #region Helpers

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                foreach (KeyValuePair<string, string> message in lang.GetMessages(language, this))
                {
                    if (message.Key.Equals(command) && !string.IsNullOrEmpty(message.Value))
                    {
                        AddCovalenceCommand(message.Value, command);
                    }
                }
            }
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private bool IsServerBanned()
        {
            return Application.Manifest.Servers.IsBannedServer(server.Address.ToString());
        }

        #endregion Helpers
    }
}


// --- End of file: ServerBanCheck.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/storage-blocker ---
// --- Original File Path: S/StorageBlocker/StorageBlocker.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Storage Blocker", "Orange", "1.1.0")]
    [Description("Allows to setup items that can't be moved to certain containers")]
    public class StorageBlocker : RustPlugin
    {
        #region Oxide Hooks
        
        ItemContainer.CanAcceptResult CanAcceptItem(ItemContainer container, Item item, int targetPos)
        {
            return CheckConiner(container?.entityOwner?.ShortPrefabName ?? "null", item?.info?.shortname ?? "null");
        }

        #endregion

        #region Configuration
        
        private ConfigData config;
        
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Container (shortname) - list of items (shortname)")]
            public Dictionary<string, List<string>> containers;
        }
        
        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                containers = new Dictionary<string, List<string>>
                {
                    ["box.example"] = new List<string>
                    {
                        "item.example",
                        "item.example",
                        "item.example"
                    },
                    ["box.wooden.large"] = new List<string>
                    {
                        "battery.small",
                        "blood"
                    }
                }
            };
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
   
            try
            {
                config = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Helpers

        private ItemContainer.CanAcceptResult CheckConiner(string container, string item)
        {
            if (!config.containers.ContainsKey(container))
            {
                return ItemContainer.CanAcceptResult.CanAccept;
            }
            
            return config.containers[container].Contains(item) ? ItemContainer.CanAcceptResult.CannotAccept : ItemContainer.CanAcceptResult.CanAccept;
        }

        #endregion
    }
}

// --- End of file: StorageBlocker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/slap ---
// --- Original File Path: S/Slap/Slap.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;
using Random = System.Random;

// TODO: Add distance/radius restriction for slapping

namespace Oxide.Plugins
{
    [Info("Slap", "Wulf", "2.0.2")]
    [Description("Sometimes players just need to be slapped around a bit")]
    class Slap : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        class Configuration
        {
            [JsonProperty("Command cooldown in seconds (0 to disable)")]
            public int CommandCooldown = 30;

            [JsonProperty("Default damage per slap")]
            public int DefaultDamage = 10;

            [JsonProperty("Default intensity per slap")]
            public int DefaultIntensity = 5;

            [JsonProperty("Default amount of slaps")]
            public int DefaultAmount = 1;

            [JsonProperty("Show players who slapped them")]
            public bool ShowWhoSlapped = true;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandCooldown"] = "Wait a bit before attempting to slap again",
                ["CommandSlap"] = "slap",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["NoPlayersFound"] = "No players found with name or ID '{0}'",
                ["PlayerNotFound"] = "Player '{0}' was not found",
                ["PlayersFound"] = "Multiple players were found, please specify: {0}",
                ["PlayerSlapped"] = "{0} got slapped!",
                ["UsageSlap"] = "Usage: {0} <name or id> [damage] [intensity] [amount]",
                ["YouGotSlapped"] = "You got slapped!",
                ["YouGotSlappedBy"] = "You got slapped by {0}!"
            }, this);
        }

        #endregion Localization

        #region Initialization

        private readonly Hash<string, float> cooldowns = new Hash<string, float>();
        private static readonly Random random = new Random();

        private const string permUse = "slap.use";

        private void Init()
        {
            AddLocalizedCommand(nameof(CommandSlap));

            permission.RegisterPermission(permUse, this);
        }

        #endregion Initialization

        #region Commands

        private void CommandSlap(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permUse))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args.Length == 0)
            {
                Message(player, "UsageSlap", command);
                return;
            }

            if (!player.IsServer)
            {
                if (!cooldowns.ContainsKey(player.Id))
                {
                    cooldowns.Add(player.Id, 0f);
                }

                if (config.CommandCooldown > 0 && cooldowns[player.Id] + config.CommandCooldown > Interface.Oxide.Now)
                {
                    Message(player, "CommandCooldown");
                    return;
                }
            }

            IPlayer target = FindPlayer(args[0], player);
            if (target == null)
            {
                return;
            }

            int damage = args.Length >= 2 ? int.Parse(args[1]) : config.DefaultDamage;
            int intensity = args.Length >= 3 ? int.Parse(args[2]) : config.DefaultIntensity;
            int amount = args.Length >= 4 ? int.Parse(args[3]) : config.DefaultAmount;
            SlapPlayer(target, damage, intensity, amount);

            if (!target.Equals(player))
            {
                Message(player, "PlayerSlapped", target.Name);
            }

            if (config.ShowWhoSlapped)
            {
                Message(target, "YouGotSlappedBy", player.Name);
            }
            else
            {
                Message(target, "YouGotSlapped");
            }
            cooldowns[player.Id] = Interface.Oxide.Now;
        }

        #endregion Commands

        #region Slapping

        private void SlapPlayer(IPlayer player, float damage = 0f, int intensity = 0, int amount = 0)
        {
            damage = damage > 0f ? damage : config.DefaultDamage;
            intensity = intensity > 0 ? intensity : config.DefaultIntensity;
            amount = amount > 0 ? amount : config.DefaultAmount;

            timer.Repeat(0.6f, amount, () => {
                if (player != null && player.IsConnected)
                {
                    player.Hurt(damage * intensity);                    
                }});

#if RUST

            BasePlayer basePlayer = player.Object as BasePlayer;
            BaseEntity.Signal[] flinches = new[]
            {
                BaseEntity.Signal.Flinch_Chest,
                BaseEntity.Signal.Flinch_Head,
                BaseEntity.Signal.Flinch_Stomach
            };
            BaseEntity.Signal flinch = flinches[random.Next(flinches.Length)];
            basePlayer.SignalBroadcast(flinch, string.Empty, null);
            string[] effects = new[] // TODO: Move to configuration
            {
                "headshot",
                "headshot_2d",
                "impacts/slash/clothflesh/clothflesh1",
                "impacts/stab/clothflesh/clothflesh1"
            };
            string effect = effects[random.Next(effects.Length)];
            Effect.server.Run($"assets/bundled/prefabs/fx/{effect}.prefab", basePlayer.transform.position, UnityEngine.Vector3.zero);

#endif

            GenericPosition pos = player.Position();
            player.Teleport(pos.X + random.Next(1, intensity), pos.Y + random.Next(1, intensity), pos.Z + random.Next(1, intensity));
        }

        #endregion Slapping

        #region Helpers

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (message.Key.Equals(command))
                    {
                        if (!string.IsNullOrEmpty(message.Value))
                        {
                            AddCovalenceCommand(message.Value, command);
                        }
                    }
                }
            }
        }

        private IPlayer FindPlayer(string playerNameOrId, IPlayer player)
        {
            IPlayer[] foundPlayers = players.FindPlayers(playerNameOrId).ToArray();
            if (foundPlayers.Length > 1)
            {
                Message(player, "PlayersFound", string.Join(", ", foundPlayers.Select(p => p.Name).Take(10).ToArray()).Truncate(60));
                return null;
            }

            IPlayer target = foundPlayers.Length == 1 ? foundPlayers[0] : null;
            if (target == null)
            {
                Message(player, "NoPlayersFound", playerNameOrId);
                return null;
            }

            return target;
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string textOrLang, params object[] args)
        {
            if (player.IsConnected)
            {
                string message = GetLang(textOrLang, player.Id, args);
                player.Reply(message != textOrLang ? message : textOrLang);
            }
        }

        #endregion Helpers
    }
}

// --- End of file: Slap.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sleeper-animal-protection ---
// --- Original File Path: S/SleeperAnimalProtection/SleeperAnimalProtection.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;
using Facepunch;
using Rust.Ai.Gen2;

namespace Oxide.Plugins
{
    [Info("Sleeper Animal Protection", "Fujikura/Krungh Crow/Lorenzo", "1.0.10")]
	[Description("Protects sleeping players from being killed by animals")]
    class SleeperAnimalProtection : CovalencePlugin
    {

        private readonly int buildingLayer = LayerMask.GetMask("Terrain", "World", "Construction", "Deployed");

        private static Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Settings")]
            public Settings setting = new Settings();
        };

        private class Settings
        {
            [JsonProperty(PropertyName = "OnNpcTarget return code (debug warning issue with TruePVE)")]
            public bool OnNpcReturnCode = true;

            [JsonProperty(PropertyName = "Permission name")]
            public string permissionName = "sleeperanimalprotection.active";   // name of permission

            [JsonProperty(PropertyName = "Required to sleep ON foundation")]
            public bool checkForFoundation = false;

            [JsonProperty(PropertyName = "Use permissions")]
            public bool usePermission = false;      // use permission or grant access to every players

            [JsonProperty(PropertyName = "Animal ignore sleepers")]
            public bool AnimalIgnoreSleepers = true;

            [JsonProperty(PropertyName = "HumanNPC ignore sleepers")]
            public bool HumanNPCIgnoreSleepers = false;
        };

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (Config == null) throw new Exception();
            }
            catch (Exception ex)
            {
                PrintError(ex.Message);
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

		void Init()
		{
			permission.RegisterPermission(_config.setting.permissionName, this);
            if (_config.setting.AnimalIgnoreSleepers == false && _config.setting.AnimalIgnoreSleepers == false) Unsubscribe(nameof(OnNpcTargetSense));
        }

        private List<BuildingBlock> GetFoundation(Vector3 positionCoordinates)
        {
            var position = positionCoordinates;
            var entities = new List<BuildingBlock>();
            var hits = Pool.Get<List<BuildingBlock>>();
            Vis.Entities(position, 2.5f, hits, buildingLayer);
            for (var i = 0; i < hits.Count; i++)
            {
                var entity = hits[i];
                if (!entity.ShortPrefabName.Contains("foundation") || positionCoordinates.y < entity.WorldSpaceBounds().ToBounds().max.y) continue;
                entities.Add(entity);
            }
            Pool.FreeUnmanaged(ref hits);
            return entities;
        }	
	
   
        private object OnNpcTargetSense(BaseEntity attacker, BaseEntity target, AIBrainSenses brainSenses)
        {
            //BasePlayer attackerPlayer = attacker as BasePlayer;
            //BaseAnimalNPC attackerAnimal = attacker as BaseAnimalNPC;
            //BasePlayer targetPlayer = target as BasePlayer;
            if (target is BasePlayer targetPlayer)
            {
                if (attacker is BaseAnimalNPC attackerAnimal && !targetPlayer.IsNpc)
                {
                    if (_config.setting.AnimalIgnoreSleepers == true && targetPlayer.IsSleeping())
                    {
                        if (_config.setting.usePermission && !permission.UserHasPermission(targetPlayer.UserIDString, _config.setting.permissionName))
                            return null;

                        if (_config.setting.checkForFoundation && GetFoundation(target.transform.position).Count == 0)
                            return null;

                        try
                        {                            
                            if (brainSenses != null && brainSenses.brain != null)
                            {
                                if ((brainSenses.brain.CurrentState?.StateType == AIState.Attack) ||
                                    (brainSenses.brain.CurrentState?.StateType == AIState.Chase) ||
                                    (brainSenses.brain.CurrentState?.StateType == AIState.Combat)) brainSenses.brain.SwitchToState(AIState.Idle, 0);
                            }
                        }
                        catch (Exception ex)
                        {
                            PrintError(ex.Message);
                            PrintError($"Animal NRE {target.transform.position}");
                        }

                        return _config.setting.OnNpcReturnCode;
                    }
                }

                if (attacker is BasePlayer attackerPlayer && attackerPlayer.IsNpc && !targetPlayer.IsNpc)
                {
                    if (_config.setting.HumanNPCIgnoreSleepers == true && targetPlayer.IsSleeping())
                    {
                        if (_config.setting.usePermission && !permission.UserHasPermission(targetPlayer.UserIDString, _config.setting.permissionName))
                            return null;

                        if (_config.setting.checkForFoundation && GetFoundation(target.transform.position).Count == 0)
                            return null;

                        try
                        {
                            if (brainSenses != null && brainSenses.brain != null)
                            {
                                if ((brainSenses.brain.CurrentState?.StateType == AIState.Attack) ||
                                    (brainSenses.brain.CurrentState?.StateType == AIState.Chase) ||
                                    (brainSenses.brain.CurrentState?.StateType == AIState.Combat)) brainSenses.brain.SwitchToState(AIState.Idle, 0);
                            }
                        }
                        catch (Exception ex)
                        {
                            PrintError(ex.Message);
                            PrintError($"NPC NRE  {target.transform.position}");
                        }

                        return _config.setting.OnNpcReturnCode;
                    }
                }
            }

            return null;
        }
		
		object OnEntityTakeDamage(BasePlayer player, HitInfo info)
        {
            if (player == null || info == null) return null;
            var npc = info.Initiator as BaseNpc;
			
            if (player.IsSleeping() && npc != null) 
			{
				
				if(_config.setting.usePermission && !permission.UserHasPermission(player.userID.ToString(), _config.setting.permissionName))
					return null;
				if(_config.setting.checkForFoundation && GetFoundation(player.transform.position).Count == 0)
					return null;

                // To stop the attack, hurt animal until it flee. 
                // this method should still work if animal AI change again
                HitInfo newinfo = new HitInfo(player, npc, Rust.DamageType.Generic, npc.Health()*0.6f, player.transform.position);
                npc.Hurt(newinfo);
                return true;
			}

            var wolf2 = info.Initiator as BaseNPC2;
			
            if (player.IsSleeping() && wolf2 != null) 
			{
				
				if(_config.setting.usePermission && !permission.UserHasPermission(player.userID.ToString(), _config.setting.permissionName))
					return null;
				if(_config.setting.checkForFoundation && GetFoundation(player.transform.position).Count == 0)
					return null;

                // To stop the attack, hurt animal until it flee. 
                // this method should still work if animal AI change again
                HitInfo newinfo = new HitInfo(player, wolf2, Rust.DamageType.Generic, wolf2.Health()*0.6f, player.transform.position);
                wolf2.Hurt(newinfo);
                return true;
			}
			
			
			
            return null;
        }		

    }
}

// --- End of file: SleeperAnimalProtection.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/server-armour ---
// --- Original File Path: S/ServerArmour/ServerArmour.cs ---

using ConVar;
using Facepunch;
using Facepunch.Extend;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Libraries;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;
using WebSocketSharp;
using Application = UnityEngine.Application;
using Time = Oxide.Core.Libraries.Time;

#pragma warning disable 8600
#pragma warning disable 8601

namespace Oxide.Plugins
{
    [Info("Server Armour", "Pho3niX90", "2.83.7")]
    [Description("Protect your server! Auto ban known hackers, scripters and griefer accounts, and notify server owners of threats.")]
    class ServerArmour : CovalencePlugin
    {
#if CARBON
        bool isCarbon = true;
#else
        bool isCarbon = false;
#endif
        #region Variables
        string api_hostname = "https://serverarmour.com"; // 
        Dictionary<string, ISAPlayer> _playerData = new Dictionary<string, ISAPlayer>();
        private Time _time = GetLibrary<Time>();
        private double cacheLifetime = 1; // minutes
        private SAConfig config;
        string specifier = "G";
        CultureInfo culture = CultureInfo.CreateSpecificCulture("en-US");
        //StringComparison defaultCompare = StringComparison.InvariantCultureIgnoreCase;
        const string DATE_FORMAT = "yyyy/MM/dd HH:mm";
        const string DATE_FORMAT2 = "yyyy-MM-dd HH:mm:ss";
        const string DATE_FORMAT_BAN = "yyyy-MM-ddTHH:mm:ss.fffZ";
        Regex logRegex = new Regex(@"(^assets.*prefab).*?position (.*) on");
        Regex logRegexNull = new Regex(@"(.*) changed its network group to null");

        bool debug = false;
        bool apiConnected = false;
        bool serverStarted = false;
        int serverId;

        private Dictionary<string, string> headers;
        string adminIds = "";
        Timer updateTimer;

        // related to auto updating
        Dictionary<string, byte[]> fileBackups = new Dictionary<string, byte[]>();
        List<string> ignoredPlugins = new List<string>();

        #endregion

        #region Libraries
        private readonly Game.Rust.Libraries.Player Player = Interface.Oxide.GetLibrary<Game.Rust.Libraries.Player>();
        #endregion

        #region Permissions
        const string PermissionToBan = "serverarmour.ban";
        const string PermissionToUnBan = "serverarmour.unban";

        const string PermissionAdminWebsite = "serverarmour.website.admin";

        const string PermissionWhitelistRecentVacKick = "serverarmour.whitelist.recentvac";
        const string PermissionWhitelistBadIPKick = "serverarmour.whitelist.badip";
        const string PermissionWhitelistVacCeilingKick = "serverarmour.whitelist.vacceiling";
        const string PermissionWhitelistServerCeilingKick = "serverarmour.whitelist.banceiling";
        const string PermissionWhitelistGameBanCeilingKick = "serverarmour.whitelist.gamebanceiling";
        const string PermissionWhitelistTotalBanCeiling = "serverarmour.whitelist.totalbanceiling";
        const string PermissionWhitelistSteamProfile = "serverarmour.whitelist.steamprofile";
        const string PermissionWhitelistFamilyShare = "serverarmour.whitelist.familyshare";
        const string PermissionWhitelistTwitterBan = "serverarmour.whitelist.twitterban";
        const string PermissionWhitelistAllowCountry = "serverarmour.whitelist.allowcountry";
        const string PermissionWhitelistAllowHighPing = "serverarmour.whitelist.allowhighping";

        const string DISCORD_INTRO_URL = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";
        /**
         * Plugin Name, Download Url
         */
        Dictionary<string, string> requiredPlugins = new Dictionary<string, string>
        {
            {"DiscordApi","https://serverarmour.com/api/v1/shop/product/379a27d9-d245-43c9-ad8f-332efa8a25e6/download" },
            {"CombatLogInfo","https://serverarmour.com/api/v1/shop/product/4195c37c-8eb5-47f6-8908-45aaa06df59c/download" }
        };

        // int serverId = 0;
        #endregion

        #region Plugins

#pragma warning disable 0649
        [PluginReference] Plugin DiscordApi, DiscordMessages, BetterChat, Ember, Clans, AdminToggle, CombatLogInfo, ServerArmourUpdater;
#pragma warning restore 0649
        void DiscordSend(string steamId, string name, EmbedFieldList report, int color = 39423, bool isBan = false)
        {
            string webHook;
            if (isBan)
            {
                if (config.DiscordBanWebhookURL.IsNullOrEmpty() || config.DiscordBanWebhookURL.Equals(DISCORD_INTRO_URL)) { Puts("Discord webhook not setup."); return; }
                webHook = config.DiscordBanWebhookURL;
            }
            else
            {
                if (config.DiscordWebhookURL.IsNullOrEmpty() || config.DiscordWebhookURL.Equals(DISCORD_INTRO_URL)) { Puts("Discord webhook not setup."); return; }
                webHook = config.DiscordWebhookURL;
            }

            List<EmbedFieldList> fields = new List<EmbedFieldList>();
            if (config.DiscordQuickConnect)
            {
                fields.Add(new EmbedFieldList()
                {
                    name = server.Name,
                    value = $"[steam://connect/{config.ServerIp}:{server.Port}](steam://connect/{config.ServerIp}:{server.Port})",
                    inline = true
                });
            }

            fields.Add(new EmbedFieldList()
            {
                name = "Steam Profile",
                value = $"[{name}\n{steamId}](https://steamcommunity.com/profiles/{steamId})",
                inline = !config.DiscordQuickConnect
            });

            fields.Add(new EmbedFieldList()
            {
                name = "Server Armour Profile ",
                value = $"[{name}\n{steamId}](https://serverarmour.com/profile/{steamId})",
                inline = !config.DiscordQuickConnect
            });

            fields.Add(report);
            var fieldsObject = fields.Cast<object>().ToArray();
            string json = JsonConvert.SerializeObject(fieldsObject);

            if (DiscordApi != null && DiscordApi.IsLoaded)
            {
                DiscordApi?.Call("API_SendEmbeddedMessage", webHook, "Server Armour Report: ", color, json);
            }
            else if (DiscordMessages != null && DiscordMessages.IsLoaded)
            {
                DiscordMessages?.Call("API_SendFancyMessage", webHook, "Server Armour Report: ", color, json);
            }
            else
            {
                LogWarning("No discord API plugin loaded, will not publish to hook!");
            }
        }

        void CheckPing(IPlayer player)
        {
            // fix: https://discord.com/channels/751155344532570223/751155561776808158/1160293816104914974
            if (player == null || !player.IsConnected)
                return;

            try
            {
                if (!HasPerm(player.Id, PermissionWhitelistAllowHighPing) && (config.AutoKickMaxPing > 0 && config.AutoKickMaxPing < player.Ping))
                {
                    KickPlayer(player.Id, GetMsg("Your Ping is too High", new Dictionary<string, string> { ["ping"] = player.Ping.ToString(), ["maxPing"] = config.AutoKickMaxPing.ToString() }), "C");
                }
            }
            catch (Exception ex) { }
        }

        #endregion

        #region Hooks
        void OnServerSave()
        {
            if (config.AutoKickMaxPing > 0)
                foreach (var player in players.Connected)
                    timer.Once(5f, () => CheckPing(player));
        }

        void OnServerInitialized(bool first)
        {
            LoadData();

            if (first)
            {
                //quick fix to ignore bans on server restart. (rust rebanning.)
                Unsubscribe(nameof(OnUserBanned));
                timer.Once(60, () =>
                {
                    Subscribe(nameof(OnUserBanned));
                    serverStarted = true;
                });
            }
            else
            {
                serverStarted = true;
            }

            // CheckOnlineUsers();
            // CheckLocalBans();

            string ServerGPort = ConVar.Server.port.ToString();
            string ServerQPort = ConVar.Server.queryport > 0 ? ConVar.Server.queryport.ToString() : ServerGPort;
            string ServerRPort = RCon.Port.ToString();

            Puts($"Server Ports are, Game Port: {ServerGPort} | Query Port:{ServerQPort} | RCON Port: {ServerRPort}");

            RegPerm(PermissionToBan);
            RegPerm(PermissionToUnBan);

            RegPerm(PermissionAdminWebsite);

            RegPerm(PermissionWhitelistBadIPKick);
            RegPerm(PermissionWhitelistRecentVacKick);
            RegPerm(PermissionWhitelistServerCeilingKick);
            RegPerm(PermissionWhitelistVacCeilingKick);
            RegPerm(PermissionWhitelistGameBanCeilingKick);
            RegPerm(PermissionWhitelistTotalBanCeiling);
            RegPerm(PermissionWhitelistSteamProfile);
            RegPerm(PermissionWhitelistFamilyShare);
            RegPerm(PermissionWhitelistTwitterBan);
            RegPerm(PermissionWhitelistAllowCountry);
            RegPerm(PermissionWhitelistAllowHighPing);
            RegisterTag();

            string framework = this.isCarbon ? "Carbon" : "Oxide";
            headers = new Dictionary<string, string> {
                { "server-key", config.ServerApiKey },
                { "Accept", "application/json" },
                { "Content-Type", "application/x-www-form-urlencoded" },
                { "User-Agent", $"Server Armour/{this.Version} <{framework}>"}
            };

            string[] _admins = permission.GetUsersInGroup("admin");
            if (config.OwnerSteamId != null && config.OwnerSteamId.Length > 0 && !_admins.Contains(config.OwnerSteamId))
            {
                var adminsList = new List<string>();
                adminsList.AddRange(_admins);
                adminsList.AddRange(config.OwnerSteamId.Split(','));

                var extraAdmins = permission.GetPermissionUsers(PermissionAdminWebsite);
                if (extraAdmins != null && extraAdmins.Length > 0)
                {
                    adminsList.AddRange(extraAdmins);
                }

                int e = 0;
                foreach (string extraAdminsGroups in permission.GetPermissionGroups(PermissionAdminWebsite))
                {
                    foreach (string extraAdmin in permission.GetUsersInGroup(extraAdminsGroups))
                    {
                        if (!adminsList.Contains(extraAdmin))
                        {
                            adminsList.Add(extraAdmin);
                            e++;
                        }
                    }
                }

                _admins = adminsList.Distinct().ToArray();
            }

            for (int i = 0, n = _admins.Length; i < n; i++)
            {
                adminIds += $"{_admins[i].Substring(0, 17)}" + (i < _admins.Length - 1 ? "," : string.Empty);
            }

            CheckServerConnection();
            Application.logMessageReceived += HandleLog;

            if (ServerArmourUpdater != null && ServerArmourUpdater.IsLoaded)
            {
                foreach (var item in plugins.GetAll())
                {
                    if (item.Filename == null || item.Filename.Length == 0)
                        continue;
                    if (requiredPlugins.ContainsKey(item.Name))
                        requiredPlugins.Remove(item.Name);
                }

                Puts($"Needed plugins = {requiredPlugins.Count}");
                foreach (var plugin in requiredPlugins)
                {
                    ServerArmourUpdater?.Call("QueueDownload", plugin.Key, plugin.Value, "Server Armour");
                }
            }
        }

        void CheckServerConnection()
        {
            string body = ServerGetString();
            DoRequest("check_server", body, (code, response) =>
            {
                JObject obj = null;

                try
                {
                    obj = JObject.Parse(response);
                }
                catch (Exception)
                {
                    LogWarning($"Response issue: ({code}) {response}");
                    timer.Once(15, CheckServerConnection);
                    return;
                }

                if (obj != null)
                {
                    var msg = obj["message"].ToString();
                    try
                    {
                        this.serverId = int.Parse(obj["serverId"].ToString());
                    }
                    catch (Exception) { }
                    Puts(msg);
                    if (msg.Equals("connected"))
                    {
                        apiConnected = true;
                        Puts($"Connected to SA API | Server ID = {this.serverId}");
                        ServerStatusUpdate();
                        updateTimer = timer.Every(60, ServerStatusUpdate);
                    }
                    else
                    {
                        Puts($"ServerApiKey = {config.ServerApiKey}");
                        var errMsg = "Server Armour has not initialized. Is your apikey correct? Get it from https://serverarmour.com/my-servers or join discord for support https://discord.gg/jxvRaPR";
                        LogError(errMsg);
                        timer.Once(500, () => LogError(errMsg));
                        return;
                    }
                    Puts("Server Armour has initialized.");
                }
                else
                {
                    timer.Once(5, CheckServerConnection);
                    return;
                }
            });
        }

        void Unload()
        {
            _playerData?.Clear();
            _playerData = null;
            Application.logMessageReceived -= HandleLog;
            if (updateTimer != null && !updateTimer.Destroyed)
                updateTimer.Destroy();
        }

        void OnUserConnected(IPlayer iPlayer)
        {
            this.DoConnectionChecks(iPlayer);
        }

        void DoConnectionChecks(IPlayer player, string type = "C")
        {
            if (!apiConnected)
            {
                LogError("User not checked. Server armour is not loaded.");
            }
            else
            {
                //lets check the userid first.
                if (config.AutoKick_KickWeirdSteam64 && !player.Id.IsSteamId())
                {
                    KickPlayer(player.Id, GetMsg("Strange Steam64ID"), type);
                    return;
                }

                GetPlayerBans(player);

                try
                {
                    var connectedSeconds = GetConnectedSeconds(player);
                    if (connectedSeconds < 600)
                        timer.Once(120, () =>
                        {
                            DoConnectionChecks(player);
                        });

                    if (config.ShowProtectedMsg && connectedSeconds < 60) SendReplyWithIcon(player, GetMsg("Protected MSG"));
                }
                catch (Exception) { }
            }
        }

        int GetConnectedSeconds(IPlayer player)
        {
            return BasePlayer.FindByID(ulong.Parse(player.Id))?.secondsConnected ?? int.MaxValue;
        }

        int GetConnectedSeconds(ISAPlayer player)
        {
            return BasePlayer.FindByID(ulong.Parse(player.steamid))?.secondsConnected ?? int.MaxValue;
        }

        void OnUserDisconnected(IPlayer player)
        {
            if (apiConnected)
            {
                try
                {
                    _playerData = _playerData?.Where(pair => MinutesAgo((uint)pair.Value.cacheTimestamp) < cacheLifetime)
                                     ?.ToDictionary(pair => pair.Key, pair => pair.Value);
                }
                catch (Exception) { }
            }
        }

        void OnPluginLoaded(Plugin plugin)
        {
            if (plugin.Title == "BetterChat") RegisterTag();
        }
        /**
         * To detect publisher bans
         */
        void OnPlayerKicked(BasePlayer player, string reason)
        {
            if (reason.Contains("PublisherBanned"))
            {
                DoRequest($"player/eacban", $"reason={reason}&steamId={player.UserIDString}&username={player.displayName}&serverId={this.serverId}",
                    (code, response) => { }, RequestMethod.POST);
            }
        }


        void OnUserUnbanned(string name, string id, string ipAddress)
        {
            DoPardon(id);
        }

        void OnUserBanned(string name, string id, string ipAddress, string reason)
        {
            //this is to make sure that if an app like battlemetrics for example, bans a player, we catch it.
            if (config.IgnoreCheatDetected && reason.StartsWith("Cheat Detected"))
            {
                return;
            }
            try
            {
                if (AdminToggle != null && AdminToggle.Call<bool>("IsAdmin", id))
                {
                    return;
                }
            }
            catch (Exception) { }
            timer.Once(10f, () =>
            {
                //lets make sure first it wasn't us. 
                if (!IsPlayerCached(id) && (IsPlayerCached(id) && !ContainsMyBan(id)))
                {
                    // LogDebug($"Player wasn't banned via Server Armour, now adding to DB with a default lengh ban of 100yrs {name} ({id}) at {ipAddress} was banned: {reason}");
                    IPlayer bPlayer = players.FindPlayerById(id);
                    if (bPlayer != null)
                    {
                        if ((bPlayer.IsAdmin && config.IgnoreAdmins)) return;
                        // LogDebug("Before AddBan");
                        AddBan(new ISABan
                        {
                            steamid = ulong.Parse(bPlayer.Id),
                            serverName = server.Name,
                            serverIp = config.ServerIp,
                            reason = reason,
                            created = DateTime.Now.ToString(DATE_FORMAT),
                            banUntil = DateTime.Now.AddYears(100).ToString(DATE_FORMAT)
                        }, false);
                    }
                }
            });
        }

        void OnPlayerReported(BasePlayer reporter, string targetName, string targetId, string subject, string message, string type)
        {
            if (!serverStarted)
                return;
            string messageClean = Uri.EscapeDataString(message);
            string subjectClean = Uri.EscapeDataString(subject);
            DoRequest(
                $"player/{reporter.UserIDString}/addf7",
                $"target={targetId}&subject={subjectClean}&message={messageClean}", (c, s) => { });
        }
        #endregion


        #region Checks
        void GetPlayerRiskScore(ulong steamId)
        {
            GetJson($"player/{steamId}/risk", (c, s) =>
            {
                if (c < 300)
                {
                    double riskscore = 0;
                    double.TryParse(s.GetValue("score").ToString(), out riskscore);
                    // TODO check the risk
                }
            });
        }
        #endregion

        #region API_Hooks

        #endregion

        #region WebRequests

        void GetPlayerBans(IPlayer player)
        {
            if (player == null || player.Id == null) return;
            KickIfBanned(GetPlayerCache(player?.Id));
            WebCheckPlayer(player.Id, player.Address, player.IsConnected);
            timer.Once(10f, () => CheckPing(player));
        }

        void GetPlayerBans(string playerId, string playerName)
        {
            KickIfBanned(GetPlayerCache(playerId));
            WebCheckPlayer(playerId, "0.0.0.0", true);
        }

        void WebCheckPlayer(string id, string address, bool connected)
        {
            if (!serverStarted)
                return;

            DoRequest($"player/{id}?bans=true&linked={config.AutoKick_ActiveBans.ToString().ToLowerInvariant()}", $"ipAddress={address}",
                (code, response) =>
                {
                    // LogDebug("Getting player from API");
                    ISAPlayer isaPlayer = null;

                    try
                    {
                        isaPlayer = JsonConvert.DeserializeObject<ISAPlayer>(response);
                    }
                    catch (Exception)
                    {
                        timer.Once(30, () => WebCheckPlayer(id, address, connected));
                        return;
                    }

                    if (isaPlayer == null)
                    {
                        return;
                    }

                    isaPlayer.cacheTimestamp = _time.GetUnixTimestamp();
                    isaPlayer.lastConnected = _time.GetUnixTimestamp();


                    // add cache for player
                    // LogDebug("Checking cache");
                    if (!IsPlayerCached(isaPlayer.steamid))
                    {
                        AddPlayerCached(isaPlayer);
                    }
                    else
                    {
                        UpdatePlayerData(isaPlayer);
                    }

                    // lets check bans first
                    try
                    {
                        KickIfBanned(isaPlayer);
                    }
                    catch (Exception ane)
                    {
                        Puts("An ArgumentNullException occured. Please notify the developer along with the below information: ");
                        Puts(response);
                        Puts(ane.StackTrace);
                    }

                    //script vars
                    string pSteamId = isaPlayer.steamid ?? id;
                    //string lSteamId = GetFamilyShare(isaPlayer.steamid);
                    //

                    LogDebug("Check for a twitter/eac game ban");
                    if (config.AutoKick_KickTwitterGameBanned && !HasPerm(pSteamId, PermissionWhitelistTwitterBan) && isaPlayer.eacBans.Count > 0)
                    {
                        KickPlayer(isaPlayer?.steamid, $"https://twitter.com/rusthackreport/status/{isaPlayer.eacBans[isaPlayer.eacBans.Count - 1].id}", "C");
                    }

                    LogDebug($"Check for a recent vac: DissallowVacBanDays = {config?.DissallowVacBanDays}, steamDaysSinceLastBan = {isaPlayer?.steamDaysSinceLastBan}, steamNumberOfVACBans = {isaPlayer?.steamNumberOfVACBans}, steamDaysSinceLastBan = {isaPlayer?.steamDaysSinceLastBan}, whitelisted = {HasPerm(pSteamId, PermissionWhitelistRecentVacKick)}");
                    bool pRecentVac = (isaPlayer.steamNumberOfVACBans > 0 || isaPlayer.steamDaysSinceLastBan > 0)
                    && isaPlayer.steamDaysSinceLastBan < config.DissallowVacBanDays; //check main player

                    //bool lRecentVac = (isaPlayer.lender?.steamNumberOfVACBans > 0 || isaPlayer.lender?.steamDaysSinceLastBan > 0)
                    //&& isaPlayer.lender?.steamDaysSinceLastBan < config.DissallowVacBanDays; //check the lender player

                    if (config.AutoKickOn && !HasPerm(pSteamId, PermissionWhitelistRecentVacKick) && pRecentVac)
                    {
                        int vacLast = isaPlayer.steamDaysSinceLastBan;
                        int until = config.DissallowVacBanDays - vacLast;

                        Interface.CallHook("OnSARecentVacKick", vacLast, until);

                        string msg = GetMsg(pRecentVac ? "Reason: VAC Ban Too Fresh" : "Reason: VAC Ban Too Fresh - Lender", new Dictionary<string, string> { ["daysago"] = vacLast.ToString(), ["daysto"] = until.ToString() });

                        KickPlayer(isaPlayer?.steamid, msg, "C");
                    }

                    LogDebug("Check for too many vac bans");
                    if (!HasPerm(pSteamId, PermissionWhitelistVacCeilingKick) && HasReachedVacCeiling(isaPlayer))
                    {
                        Interface.CallHook("OnSATooManyVacKick", pSteamId, isaPlayer?.steamNumberOfVACBans);
                        KickPlayer(isaPlayer?.steamid, GetMsg("VAC Ceiling Kick"), "C");
                    }

                    LogDebug("Check for too many game bans");
                    if (!HasPerm(pSteamId, PermissionWhitelistGameBanCeilingKick) && HasReachedGameBanCeiling(isaPlayer))
                    {
                        Interface.CallHook("OnSATooManyGameBansKick", pSteamId, isaPlayer.steamNumberOfGameBans);
                        KickPlayer(isaPlayer?.steamid, GetMsg("Too Many Previous Game Bans"), "C");
                    }

                    // LogDebug("Check for players with too many server bans");
                    //if (!HasPerm(pSteamId, PermissionWhitelistServerCeilingKick) && HasReachedServerCeiling(isaPlayer))
                    //{
                    //    Interface.CallHook("OnSATooManyServerBans", pSteamId, config.AutoKickCeiling, ServerBanCount(isaPlayer) + ServerBanCount(isaPlayer.lender));
                    //    KickPlayer(isaPlayer?.steamid, GetMsg("Too Many Previous Bans"), "C");
                    //}

                    //if (!HasPerm(PermissionWhitelistTotalBanCeiling, pSteamId) && HasReachedTotalBanCeiling(isaPlayer))
                    //{
                    //    Interface.CallHook("OnSATooManyBans", pSteamId, config.AutoKickCeiling, TotalBans(isaPlayer.lender));
                    //    KickPlayer(isaPlayer?.steamid, GetMsg("Too Many Previous Bans"), "C");
                    //}

                    LogDebug("Check for players with a private profile");
                    if (!HasPerm(pSteamId, PermissionWhitelistSteamProfile) && config.AutoKick_KickPrivateProfile && isaPlayer.communityvisibilitystate != 3)
                    {
                        Interface.CallHook("OnSAProfilePrivate", pSteamId, isaPlayer.communityvisibilitystate);
                        KickPlayer(isaPlayer?.steamid, GetMsg("Profile Private"), "C");
                    }

                    LogDebug("Check for a hidden steam level");
                    if (!HasPerm(pSteamId, PermissionWhitelistSteamProfile) && isaPlayer.steamlevel == -1 && config.AutoKick_KickHiddenLevel)
                    {
                        Interface.CallHook("OnSASteamLevelHidden", pSteamId);
                        KickPlayer(isaPlayer?.steamid, GetMsg("Steam Level Hidden"), "C");
                    }

                    LogDebug($"Player {isaPlayer.steamid} is at steam level {isaPlayer.steamlevel}");
                    if (!HasPerm(pSteamId, PermissionWhitelistSteamProfile) && isaPlayer.steamlevel < config.AutoKick_MinSteamProfileLevel && isaPlayer.steamlevel >= 0)
                    {
                        Interface.CallHook("OnSAProfileLevelLow", pSteamId, config.AutoKick_MinSteamProfileLevel, isaPlayer.steamlevel);
                        KickPlayer(isaPlayer?.steamid, GetMsg("Profile Low Level", new Dictionary<string, string> { ["level"] = config.AutoKick_MinSteamProfileLevel.ToString() }), "C");
                    }

                    LogDebug($"IP/CACHE| ID:{id} ADD:{address} COUNTRY: {isaPlayer.ipInfo.isocode} RATING:{isaPlayer?.ipInfo?.rating} AGE: {isaPlayer.ipInfo?.lastcheck}");
                    if (config.AutoKickOn && config.AutoKick_BadIp && !HasPerm(id, PermissionWhitelistBadIPKick) && config.AutoKick_BadIp)
                    {
                        if (IsBadIp(isaPlayer))
                        {
                            if (isaPlayer.ipInfo?.proxy == "yes")
                                KickPlayer(id, GetMsg("Reason: Proxy IP"), "C");
                            else
                                KickPlayer(id, GetMsg("Reason: Bad IP"), "C");

                            Interface.CallHook("OnSAVPNKick", id, isaPlayer?.ipInfo?.rating);
                        }
                    }

                    if (!HasPerm(id, PermissionWhitelistAllowCountry) && !config.AutoKickLimitCountry.IsNullOrEmpty())
                    {
                        var playerIso = isaPlayer.ipInfo?.isocode?.Trim();
                        var countriesAllowed = config.AutoKickLimitCountry.Split(',');
                        if (playerIso != null && playerIso != "" && !countriesAllowed.Contains(playerIso))
                            KickPlayer(id, GetMsg("Country Not Allowed", new Dictionary<string, string> { ["country"] = playerIso, ["country2"] = config.AutoKickLimitCountry.ToString() }), "C");
                    }

                    GetPlayerReport(isaPlayer, connected);

                }, RequestMethod.POST, 5);
        }

        void KickIfBanned(ISAPlayer isaPlayer)
        {
            if (isaPlayer == null) return;
            IPlayer iPlayer = covalence.Players.FindPlayer(isaPlayer.steamid);
            if (iPlayer != null && iPlayer.IsAdmin && config.IgnoreAdmins) return;
            try
            {
                if (AdminToggle != null && AdminToggle.Call<bool>("IsAdmin", iPlayer.Id) && config.IgnoreAdmins) return;
            }
            catch (Exception) { }

            ISABan ban = IsBanned(isaPlayer?.steamid);
            if (ban != null)
            {
                if (!ban.steamid.ToString().Equals(isaPlayer.steamid))
                {
                    KickPlayer(isaPlayer?.steamid, $"Linked: {ban.steamid}, {ban.reason}", "U");
                }
                else
                {
                    KickPlayer(isaPlayer?.steamid, ban.reason, "U");
                }
            }
        }

        void AddBan(ISABan thisBan, bool doNative = true)
        {
            if (!serverStarted)
                return;
            if (thisBan == null)
            {
                // LogDebug($"This ban is null");
                return;
            }

            string reason = Uri.EscapeDataString(thisBan.reason);

            try
            {
                DoRequest($"player/{thisBan.steamid}/addban", $"reason={reason}&dateTime={thisBan.created}&banUntil={thisBan.banUntil}&createdBySteamId={thisBan.bannedBy}", (code, response) =>
                {
                    // ISABan thisBan = new ISABan { serverName = server.Name, date = dateTime, reason = banreason, serverIp = thisServerIp, banUntil = dateBanUntil };
                    // LogDebug("Check cache");
                    if (IsPlayerCached(thisBan.steamid.ToString()))
                    {
                        // LogDebug($"{thisBan.steamid} has ban cached, now updating.");
                        AddPlayerData(thisBan.steamid.ToString(), thisBan);
                    }
                    else
                    {
                        // LogDebug($"{thisBan.steamid} had no ban data cached, now creating.");
                        ISAPlayer newPlayer = new ISAPlayer((ulong)thisBan.steamid);
                        // LogDebug("Player cache object created");
                        newPlayer.bans.Add(thisBan);
                        // LogDebug("After adding");
                        AddPlayerCached(newPlayer);
                    }
                }, RequestMethod.POST, 60);
            }
            catch (Exception)
            {
                return;
            }
        }

        #endregion

        #region Commands
        [Command("sa.apply_key")]
        void ApplyKey(IPlayer player, string command, string[] args)
        {
            var key = args[0].ToString();

            if (!player.IsServer)
            {
                return;
            }

            this.config.ServerApiKey = key;
            SaveConfig();
        }

        [Command("sa.clb", "getreport")]
        void SCmdCheckLocalBans(IPlayer player, string command, string[] args)
        {
            CheckLocalBans();
        }

        [Command("unban", "playerunban", "sa.unban"), Permission(PermissionToUnBan)]
        void SCmdUnban(IPlayer player, string command, string[] args)
        {
            if (args == null || (args.Length > 2 || args.Length < 1))
            {
                SendReplyWithIcon(player, GetMsg("UnBan Syntax"));
                return;
            }

            var reason = args.Length > 1 ? args[1] : "";
            SaUnban(args[0], player, reason);
        }

        void SilentBan(ulong steamId, TimeSpan timeSpan, string reason, IPlayer enforcer = null)
        {
            Unsubscribe(nameof(OnUserBanned));
            var username = covalence.Players.FindPlayerById(steamId.ToString())?.Name ?? "";
            NativeBan(steamId, reason, Convert.ToInt64(timeSpan.TotalSeconds), username, enforcer);
            Subscribe(nameof(OnUserBanned));
        }
        void SilentBan(ulong steamId, int timeSpan, string reason, IPlayer enforcer = null)
        {
            Unsubscribe(nameof(OnUserBanned));
            var username = covalence.Players.FindPlayerById(steamId.ToString())?.Name ?? "";
            NativeBan(steamId, reason, -1, username, enforcer);
            Subscribe(nameof(OnUserBanned));
        }

        void SilentUnban(string playerId, IPlayer admin)
        {
            Unsubscribe(nameof(OnUserUnbanned));
            NativeUnban(playerId, admin);
            Subscribe(nameof(OnUserUnbanned));
        }

        void NativeBan(ulong playerId, string reason, long duration = -1, string playerUsername = "unnamed", IPlayer player = null)
        {

            if (!playerId.IsSteamId())
            {
                if (serverStarted)
                    player?.Reply(string.Concat("This doesn't appear to be a 64bit steamid: ", playerId));
                return;
            }

            ServerUsers.User user = ServerUsers.Get(playerId);

            if (user != null && user.@group == ServerUsers.UserGroup.Banned)
            {
                if (serverStarted)
                    player?.Reply(string.Concat("User ", playerId, " is already banned"));
                return;
            }

            string str3 = "";
            BasePlayer basePlayer = BasePlayer.FindByID(playerId);
            string durationSuffix = (duration > (long)0 ? string.Concat(" for ", duration.FormatSecondsLong()) : "");
            if (basePlayer != null && basePlayer.IsConnected)
            {
                playerUsername = basePlayer.displayName;
                if (basePlayer.IsConnected && basePlayer.net.connection.ownerid != 0 && basePlayer.net.connection.ownerid != basePlayer.net.connection.userid)
                {
                    str3 = string.Concat(str3, string.Format(" and also banned ownerid {0}", basePlayer.net.connection.ownerid));
                    ServerUsers.Set(basePlayer.net.connection.ownerid, ServerUsers.UserGroup.Banned, basePlayer.displayName, reason, duration);
                }
                Chat.Broadcast(string.Concat(new string[] { "Kickbanning ", basePlayer.displayName, durationSuffix, " (", reason, ")" }), "SERVER", "#eee", (ulong)0);
                //Net.sv.Kick(basePlayer.net.connection, string.Concat("Banned", str, ": ", str2), false);
            }

            ServerUsers.Set(playerId, ServerUsers.UserGroup.Banned, playerUsername, reason, duration == -1 ? -1 : (long)(DateTime.Now.AddSeconds(duration) - Epoch).TotalSeconds);
            if (serverStarted)
                player?.Reply(string.Format("Banned User{0}: {1} - \"{2}\" for \"{3}\"{4}", new object[] { durationSuffix, playerId, playerUsername, reason, str3 }));
        }

        bool NativeUnban(string playerId, IPlayer admin = null)
        {
            ulong playerIdLong = 0;

            if (!ulong.TryParse(playerId, out playerIdLong))
            {
                var msg = string.Format("This doesn't appear to be a 64bit steamid: {0}", playerId);

                if (admin == null)
                {
                    Puts(msg);
                }
                else
                {
                    admin.Reply(msg);
                }
                return false;
            }

            ServerUsers.User user = ServerUsers.Get(playerIdLong);
            if (user == null || user.@group != ServerUsers.UserGroup.Banned)
            {
                admin?.Reply(string.Format("User {0} isn't banned", playerId));
                return false;
            }
            ServerUsers.Remove(playerIdLong);
            admin?.Reply($"Unbanned User: {playerId}");
            return true;
        }

        void SaUnban(string playerId, IPlayer admin = null, string reason = "")
        {
            IPlayer iPlayer = players.FindPlayer(playerId);
            SilentUnban(playerId, admin);

            ulong playerIdLong = 0;
            ulong.TryParse(playerId, out playerIdLong);

            if (playerIdLong == 0 && iPlayer == null)
            {
                GetMsg("Player Not Found", new Dictionary<string, string> { ["player"] = playerId }); return;
            }

            Puts($"Player {iPlayer?.Name} ({playerId}) was unbanned by {admin?.Name} ({admin?.Id})");

            // Add ember support.
            if (Ember != null)
            {
                Ember?.Call("Unban", playerId, Player.FindById(admin?.Id));
            }
            //

            if (serverStarted)
            {
                DoPardon(playerId, iPlayer, admin);
            }

            string msgClean;
            if (reason.IsNullOrEmpty())
            {
                msgClean = GetMsg("Player Now Unbanned Clean - NoReason", new Dictionary<string, string> { ["player"] = iPlayer?.Name ?? playerId });
            }
            else
            {
                msgClean = GetMsg("Player Now Unbanned Clean - Reason", new Dictionary<string, string> { ["player"] = iPlayer?.Name ?? playerId, ["reason"] = reason });
            }

            if (config.DiscordBanReport)
            {
                DiscordSend(playerId, iPlayer?.Name ?? playerId, new EmbedFieldList()
                {
                    name = "Player Unbanned",
                    value = msgClean,
                    inline = true
                }, 3066993, true);
            }
        }

        void DoPardon(string playerId, IPlayer iPlayer = null, IPlayer admin = null)
        {
            RemoveBans(playerId);
            DoRequest($"player/ban/pardon/{playerId}", $"pardonedBy={admin?.Id ?? admin.Name}", (code, response) =>
            {
                if (config.RconBroadcast)
                    RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
                    {
                        Message = $"Player was unbanned by {admin.Name} ({admin?.Id})",
                        UserId = playerId,
                        Username = iPlayer?.Name ?? "",
                        Time = Facepunch.Math.Epoch.Current
                    });


                if (admin != null && config.RconBroadcast)
                {
                    RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
                    {
                        Message = $"Player {iPlayer?.Name} ({playerId}) was unbanned",
                        UserId = admin?.Id,
                        Username = admin?.Name ?? "",
                        Time = Facepunch.Math.Epoch.Current
                    });
                }
                if (admin != null && !admin.IsServer)
                {
                    SendReplyWithIcon(admin, $"Player {iPlayer?.Name} ({playerId}) was unbanned");
                }
            }, RequestMethod.POST, 30, 5);
        }

        //banid 76561198007433923 "Pho3niX90" "Some reason" 1953394942
        [Command("banid"), Permission(PermissionToBan)]
        void SCmdBanId(IPlayer player, string command, string[] args)
        {
            var argString = string.Join(" ", args);
            var matches = new Regex(@"([7]\d{16}).*?(\d{9,12}|-1)$").Match(argString);
            var mG = matches.Groups;

            // [0] steam64id [1] username [2] reason [3] length
            if (args.Length > 0)
            {
                var playerId = args[0];
                var reason = "No reason provided.";
                var lengthInt = 0;
                var length = "-1";
                if (mG.Count == 3)
                {
                    if (int.TryParse(mG[2].Value, out lengthInt))
                        length = lengthInt == -1 || lengthInt > 1848030000 ? length : lengthInt.ToString();
                }

                if (args.Length >= 3)
                {
                    reason = args[2].ToString() == length ? args[1] : args[2];
                }


                API_BanPlayer(player, playerId, reason, length, true);
            }
        }


        [Command("ban", "playerban", "sa.ban"), Permission(PermissionToBan)]
        void SCmdBan(IPlayer player, string command, string[] args)
        {

            int argsLength = args == null ? 0 : args.Length;
            if (argsLength >= 0 && argsLength < 2)
            {
                SendReplyWithIcon(player, GetMsg("Ban Syntax"));
                return;
            }
            var playerId = args[0]?.ToString()?.Trim();
            var fPlayer = players.FindPlayer(playerId);
            if (playerId.Length != 17 && !playerId.StartsWith("7656"))
            {
                // LogDebug("Length = " + playerId.Length + ", StartsWith = " + playerId.StartsWith("7656"));
                if (fPlayer == null)
                {
                    //Puts("Player not found, or not in servers cache.");
                    SendReplyWithIcon(player, "Player not found, or not in servers cache.");
                    return;
                }
                playerId = fPlayer.Id;
            }

            /***
             * Length 2: player, reason
             * Length 3: player, reason, time
             * Length 4: playerSteamId, reason, time, ignoreSearch
             ***/

            if (args == null || (argsLength > 4))
            {
                SendReplyWithIcon(player, GetMsg("Ban Syntax"));
                return;
            }

            var reason = argsLength < 2 ? "No reason provided." : args[1];
            var length = args.Length > 2 ? args[2].ToUpper() : "100Y";
            var ignoreSearch = false;

            if (args.Length > 3)
                bool.TryParse(args[3], out ignoreSearch);

            try
            {
                API_BanPlayer(player, playerId, reason, length, ignoreSearch);
            }
            catch (Exception e)
            {
                Puts(e.Message);
                SendReplyWithIcon(player, GetMsg("Ban Syntax"));
            }
        }

        [Command("clanban"), Permission(PermissionToBan)]
        void SCmdClanBan(IPlayer player, string command, string[] args)
        {
            int argsLength = args == null ? 0 : args.Length;

            /***
             * Length 2: player, reason
             * Length 3: player, reason, time
             * Length 4: playerSteamId, reason, time, ignoreSearch
             ***/
            if (args == null || (argsLength < 2 || argsLength > 4))
            {
                SendReplyWithIcon(player, GetMsg("Ban Syntax"));
                return;
            }

            var playerId = args[0];
            var reason = args[1];
            var length = args.Length > 2 ? args[2] : "100y";
            var ignoreSearch = false;


            var errMsg = "";
            IPlayer iPlayer = null;
            IEnumerable<IPlayer> playersFound = players.FindPlayers(playerId);
            int playersFoundCount = playersFound.Count();
            switch (playersFoundCount)
            {
                case 0:
                    errMsg = GetMsg("Player Not Found", new Dictionary<string, string> { ["player"] = playerId });
                    break;
                case 1:
                    iPlayer = players.FindPlayer(playerId);
                    break;
                default:
                    List<string> playersFoundNames = new List<string>();
                    for (int i = 0; i < playersFoundCount; i++) playersFoundNames.Add(playersFound.ElementAt(i).Name);
                    string playersFoundNamesString = String.Join(", ", playersFoundNames.ToArray());
                    errMsg = GetMsg("Multiple Players Found", new Dictionary<string, string> { ["players"] = playersFoundNamesString });
                    break;
            }
            if ((!ignoreSearch && iPlayer == null) || !errMsg.Equals("")) { SendReplyWithIcon(player, errMsg); return; }

            ulong playerIdU = ulong.Parse(iPlayer.Id);

            List<ulong> teamMembers = new List<ulong>();

            if (config.ClanBanTeams)
            {
                teamMembers = GetTeamMembers(playerIdU);
            }

            if (Clans != null && Clans.IsLoaded)
            {
                var clanMembers = GetClan(playerId);
                if (clanMembers != null && clanMembers.Count() > 0)
                {
                    teamMembers.AddRange(clanMembers);
                }
            }

            teamMembers = teamMembers.Distinct().ToList();
            teamMembers?.Remove(ulong.Parse(playerId));

            bool.TryParse(args[3], out ignoreSearch);

            API_BanPlayer(player, playerId, reason, length, ignoreSearch);

            if (teamMembers.Count() > 0)
            {
                var clanBanReason = config.ClanBanPrefix.Replace("{reason}", reason).Replace("{playerId}", playerId);

                foreach (var member in teamMembers)
                {
                    API_BanPlayer(player, member.ToString(), clanBanReason, length, ignoreSearch);
                }
            }
        }

        [Command("sa.cp")]
        void SCmdCheckPlayer(IPlayer player, string command, string[] args)
        {
            string playerArg = (args.Length == 0) ? player.Id : args[0];

            IPlayer playerToCheck = players.FindPlayer(playerArg.Trim());
            if (playerToCheck == null)
            {
                SendReplyWithIcon(player, GetMsg("Player Not Found", new Dictionary<string, string> { ["player"] = playerArg }));
                return;
            }

            GetPlayerReport(playerToCheck, player);
        }
        #endregion

        #region VPN/Proxy
        #endregion

        #region Ban System

        string BanMinutes(DateTime ban)
        {
            return ((int)Math.Round((ban - DateTime.UtcNow).TotalMinutes)).ToString();
        }
        DateTime BanUntil(string banLength)
        {
            int digit = 10;
            string del = "y";

            if (!banLength.ToLower().Equals("permanent"))
            {
                int.TryParse(new string(banLength.Where(char.IsDigit).ToArray()), out digit);
                del = new string(banLength.Where(char.IsLetter).ToArray());
            }

            if (digit <= 0)
            {
                digit = 100;
            }

            DateTime now = DateTime.UtcNow;

            /*
             * Fix for bans.cfg going blank.
             * Issue: When server restarts, the bans.cfg is empty. The reason is that facepunch stores the bans in this file, verbatim, and rebans everyone when the server is restart (bans are kept in memory). Once the server restarted, SA couldn't convert the unix timestamp to a length, and errored out, causing the file to go blank on next save (since there are no bans in memory).
             */
            DateTime dateBanUntil;
            if (banLength.Length >= 10)
            {
                //already epoch?
                long lBanLength;
                if (long.TryParse(banLength, out lBanLength))
                {
                    return ConvertUnixToDateTime(lBanLength);
                }
            }

            switch (del.ToUpper())
            {
                case "S":
                    dateBanUntil = now.AddSeconds(digit);
                    break;
                case "MI":
                    dateBanUntil = now.AddMinutes(digit);
                    break;
                case "H":
                    dateBanUntil = now.AddHours(digit);
                    break;
                case "D":
                    dateBanUntil = now.AddDays(digit);
                    break;
                case "W":
                    dateBanUntil = now.AddDays(digit * 7);
                    break;
                case "M":
                    dateBanUntil = now.AddMonths(digit);
                    break;
                case "Y":
                    dateBanUntil = now.AddYears(Math.Min(2030 - DateTime.Now.Year, digit));
                    break;
                default:
                    dateBanUntil = now.AddDays(digit);
                    break;
            }
            return dateBanUntil;
        }

        string BanFor(string banLength)
        {
            int digit = int.Parse(new string(banLength.Where(char.IsDigit).ToArray()));
            string del = new string(banLength.Where(char.IsLetter).ToArray());


            // DateTime now = DateTime.Now;
            //string dateTime = now.ToString(DATE_FORMAT);
            string dateBanUntil;

            switch (del.ToUpper())
            {
                case "MI":
                    dateBanUntil = digit + " Minutes";
                    break;
                case "H":
                    dateBanUntil = digit + " Hours";
                    break;
                case "D":
                    dateBanUntil = digit + " Days";
                    break;
                case "M":
                    dateBanUntil = digit + " Months";
                    break;
                case "Y":
                    dateBanUntil = digit + " Years";
                    break;
                default:
                    dateBanUntil = digit + " Days";
                    break;
            }
            return dateBanUntil;
        }

        void RemoveBans(string id)
        {
            if (_playerData.ContainsKey(id) && ServerBanCount(_playerData[id]) > 0)
            {
                _playerData[id].bans.RemoveAll(x => x.serverIp == config.ServerIp || x.adminSteamId.Equals(config.OwnerSteamId));
            }
        }

        bool BanPlayer(ISABan ban)
        {
            AddBan(ban);
            KickPlayer(ban.steamid.ToString(), ban.reason, "U");
            return true;
        }
        #endregion

        #region IEnumerators

        void CheckOnlineUsers()
        {
            // todo, improve by changing to single call.
            IEnumerable<IPlayer> allPlayers = players.Connected;

            int allPlayersCount = allPlayers.Count();

            List<string> playerCalls = new List<string>();

            int page = 0;
            for (int i = 0; i < allPlayersCount; i++)
            {
                if (i % 50 == 0)
                {
                    page++;
                }
                playerCalls[page] += allPlayers.ElementAt(i);
            }

            int allPlayersCounter = 0;
            float waitTime = 5f;
            if (allPlayersCount > 0)
            {
                // LogDebug("Will now inspect all online users, time etimation: " + (allPlayersCount * waitTime) + " seconds");
                timer.Repeat(waitTime, allPlayersCount, () =>
                {
                    // LogDebug($"Inpecting online user {allPlayersCounter + 1} of {allPlayersCount} for infractions");
                    try
                    {
                        IPlayer player = allPlayers.ElementAt(allPlayersCounter);
                        if (player != null) GetPlayerBans(player);
                        if (allPlayersCounter >= allPlayersCount) LogDebug("Inspection completed.");
                        allPlayersCounter++;
                    }
                    catch (Exception)
                    {
                        allPlayersCounter++;
                    }
                });
            }
        }

        void CheckLocalBans()
        {
            IEnumerable<ServerUsers.User> bannedUsers = ServerUsers.GetAll(ServerUsers.UserGroup.Banned);
            int BannedUsersCount = bannedUsers.Count();
            int BannedUsersCounter = 0;
            float waitTime = 1f;

            if (BannedUsersCount > 0)
                timer.Repeat(waitTime, BannedUsersCount, () =>
                {
                    ServerUsers.User usr = bannedUsers.ElementAt(BannedUsersCounter);
                    LogDebug($"Checking local user ban {BannedUsersCounter + 1} of {BannedUsersCount}");
                    if (IsBanned(usr.steamid.ToString(specifier, culture)) == null && !usr.IsExpired)
                    {
                        try
                        {
                            IPlayer player = covalence.Players.FindPlayer(usr.steamid.ToString(specifier, culture));
                            DateTime expireDate = ConvertUnixToDateTime(usr.expiry);
                            if (expireDate.Year <= 1970)
                            {
                                expireDate = expireDate.AddYears(100);
                            }
                            // LogDebug($"Adding ban for {((player == null) ? usr.steamid.ToString() : player.Name)} with reason `{usr.notes}`, and expiry {expireDate.ToString(DATE_FORMAT)} to server armour.");

                            AddBan(new ISABan
                            {
                                steamid = (ulong)usr.steamid,
                                serverName = server.Name,
                                serverIp = config.ServerIp,
                                reason = usr.notes,
                                created = DateTime.Now.ToString(DATE_FORMAT),
                                banUntil = expireDate.ToString(DATE_FORMAT)
                            });
                        }
                        catch (ArgumentOutOfRangeException)
                        {
                            BannedUsersCounter++;
                        }
                    }

                    BannedUsersCounter++;
                });

        }
        #endregion

        #region Data Handling
        bool IsPlayerDirty(string steamid)
        {
            try
            {
                if (steamid.IsNullOrEmpty()) return false;
                ISAPlayer isaPlayer = GetPlayerCache(steamid);
                return isaPlayer != null && IsPlayerCached(steamid) && (ServerBanCount(isaPlayer) > 0 || isaPlayer?.steamCommunityBanned > 0 || isaPlayer?.steamNumberOfGameBans > 0 || isaPlayer?.steamVACBanned > 0);
            }
            catch (NullReferenceException)
            {
                return false;
            }
        }

        bool IsPlayerCached(string steamid) { return _playerData != null && _playerData.Count() > 0 && _playerData.ContainsKey(steamid); }
        void AddPlayerCached(ISAPlayer isaplayer) => _playerData.Add(isaplayer.steamid, isaplayer);
        ISAPlayer GetPlayerCache(string steamid)
        {
            return !steamid.IsNullOrEmpty() && IsPlayerCached(steamid) ? _playerData[steamid] : null;
        }

        int GetPlayerBanDataCount(string steamid) => ServerBanCount(_playerData[steamid]);
        void UpdatePlayerData(ISAPlayer isaplayer) => _playerData[isaplayer.steamid] = isaplayer;
        void AddPlayerData(string id, ISABan isaban) => _playerData[id].bans.Add(isaban);

        static bool DateIsPast(DateTime to)
        {
            return DateTime.UtcNow > to && to.Year > 2010;
        }

        double MinutesAgo(uint to)
        {
            return Math.Round((_time.GetUnixTimestamp() - to) / 60.0);
        }

        void GetPlayerReport(IPlayer player, IPlayer cmdplayer)
        {
            ISAPlayer isaPlayer = GetPlayerCache(player.Id);
            if (isaPlayer != null) GetPlayerReport(isaPlayer, player.IsConnected, true, cmdplayer);
        }

        void GetPlayerReport(ISAPlayer isaPlayer, bool isConnected = true, bool isCommand = false, IPlayer cmdPlayer = null)
        {
            try
            {
                if (isaPlayer == null || isaPlayer.steamid == null) return;
                Dictionary<string, string> data =
                           new Dictionary<string, string>
                           {
                               ["status"] = IsPlayerDirty(isaPlayer.steamid) ? "dirty" : "clean",
                               ["steamid"] = isaPlayer.steamid,
                               ["username"] = isaPlayer.personaname ?? "N/A",
                               ["serverBanCount"] = ServerBanCount(isaPlayer).ToString(),
                               ["NumberOfGameBans"] = isaPlayer.steamNumberOfGameBans.ToString(),
                               ["NumberOfVACBans"] = isaPlayer.steamNumberOfVACBans.ToString() + (isaPlayer.steamNumberOfVACBans > 0 ? $" Last({isaPlayer.steamDaysSinceLastBan}) days ago" : ""),
                               ["EconomyBan"] = (!isaPlayer.steamEconomyBan?.Equals("none")).ToString()
                           };

                LogDebug("Checking player status");
                if (IsPlayerDirty(isaPlayer.steamid) || isCommand)
                {
                    LogDebug("Getting report");
                    string report = GetMsg("User Dirty MSG", data);
                    LogDebug("Checking if should broadcast");
                    if (config.BroadcastPlayerBanReport && isConnected && isCommand && !(config.BroadcastPlayerBanReportVacDays > isaPlayer.steamDaysSinceLastBan))
                    {
                        LogDebug("Broadcasting");
                        BroadcastWithIcon(report.Replace(isaPlayer.steamid + ":", string.Empty).Replace(isaPlayer.steamid, string.Empty));
                    }
                    if (isCommand)
                    {
                        LogDebug("Replying to command");
                        SendReplyWithIcon(cmdPlayer, report.Replace(isaPlayer.steamid + ":", string.Empty).Replace(isaPlayer.steamid, string.Empty));
                    }
                }

                if (config.DiscordJoinReports && ((config.DiscordOnlySendDirtyReports && IsPlayerDirty(isaPlayer.steamid)) || !config.DiscordOnlySendDirtyReports))
                {
                    if (GetConnectedSeconds(isaPlayer) > 30)
                        return;

                    IPlayer iPlayer = players.FindPlayer(isaPlayer.steamid);

                    LogDebug($"Sending to discord.");
                    DiscordSend(iPlayer.Id, iPlayer.Name, new EmbedFieldList()
                    {
                        name = "Report",
                        value = GetMsg("User Dirty DISCORD MSG", data),
                        inline = true
                    });

                    LogDebug($"Broadcasting via RCON {config.RconBroadcast}");
                    if (config.RconBroadcast)
                        RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
                        {
                            Message = GetMsg("User Dirty DISCORD MSG", data),
                            UserId = isaPlayer.steamid,
                            Username = isaPlayer.personaname,
                            Time = Facepunch.Math.Epoch.Current
                        });

                }
            }
            catch (Exception) { }

        }

        private void LogDebug(string txt)
        {
            if (config.Debug || debug) Puts($"DEBUG: {txt}");
        }

        void LoadData()
        {
            Dictionary<string, ISAPlayer> playerData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, ISAPlayer>>($"ServerArmour/playerData");
            if (playerData != null)
            {
                _playerData = playerData;
            }
        }

        /***
         * WARNING: Modifying any data below to falsify information (online players, fps) will get your push rights revoked permanently, without notice. And possibly blacklisted from the servers directory.  
         */
        string ServerGetString()
        {
            // Define an array of parameter names
            string[] parameterNames = {
                "sip", "an", "ae", "ownerid", "gport", "qport", "rport", "sname", "sipcov",
                "sk", "fps", "fpsa", "mp", "cp", "qp", "v"
            };

            // Define an array of parameter values
            string[] parameterValues = {
                !config.ServerIp.IsNullOrEmpty() && !config.ServerIp.Equals("0.0.0.0") ? config.ServerIp : covalence.Server.Address.ToString(),
                Uri.EscapeDataString(config.ServerAdminName),
                Uri.EscapeDataString(config.ServerAdminEmail),
                Uri.EscapeDataString(config.OwnerSteamId),
                ConVar.Server.port.ToString(),
                ConVar.Server.queryport.ToString(),
                RCon.Port.ToString(),
                Uri.EscapeDataString(server.Name),
                covalence.Server.Address.ToString(),
                Uri.EscapeDataString(config.SteamApiKey),
                Uri.EscapeDataString(Performance.report.frameRate.ToString()),
                Uri.EscapeDataString(Performance.report.frameRateAverage.ToString()),
                Uri.EscapeDataString(Admin.ServerInfo().MaxPlayers.ToString()),
                Uri.EscapeDataString(Admin.ServerInfo().Players.ToString()),
                Uri.EscapeDataString(Admin.ServerInfo().Queued.ToString()),
                Version.ToString(),
            };

            // Use StringBuilder to efficiently build the serverString
            StringBuilder serverString = new StringBuilder();

            // Loop through the parameters and add non-empty ones to the serverString
            for (int i = 0; i < parameterNames.Length; i++)
            {
                if (!string.IsNullOrEmpty(parameterValues[i]))
                {
                    if (serverString.Length > 0)
                    {
                        serverString.Append("&");
                    }
                    serverString.Append($"{parameterNames[i]}={parameterValues[i]}");
                }
            }
            return serverString.ToString();
        }
        #endregion

        #region Server Directory Methods
        private void ServerStatusUpdate()
        {
            DoRequest("status", ServerGetString(), (c, r) => { });
        }
        #endregion

        #region Kicking 

        void KickPlayer(string steamid, string reason, string type)
        {
            if (steamid == null)
                return;
            IPlayer player = players.FindPlayerById(steamid);
            if (player == null || (player.IsAdmin && config.IgnoreAdmins)) return;

            if (player.IsConnected)
            {
                player?.Kick(reason);
                Puts($"Player {player?.Name} was kicked for `{reason}`");

                if (config.DiscordKickReport)
                {
                    DiscordSend(player.Id, player.Name, new EmbedFieldList()
                    {
                        name = "Player Kicked",
                        value = reason,
                        inline = true
                    }, 13459797);
                }

                if (type.Equals("C") && config.BroadcastKicks)
                {
                    BroadcastWithIcon(GetMsg("Player Kicked", new Dictionary<string, string> { ["player"] = player.Name, ["reason"] = reason }));
                }
            }
        }

        bool IsBadIp(ISAPlayer isaPlayer)
        {
            if (isaPlayer?.ipInfo == null) return false;
            try
            {
                return (config.AutoKick_BadIp
                    && isaPlayer.ipInfo.type?.ToLower() == "vpn" || isaPlayer.ipInfo.type?.ToLower() == "proxy" || isaPlayer.ipInfo?.proxy == "yes")
                    && !(config.AutoKick_IgnoreNvidia && isaPlayer.ipInfo.isCloudComputing);
            }
            catch (Exception)
            {
                Puts($"An error occured with the proxy check. Please report this to the developer. with the previous trailing logs", isaPlayer.ipInfo.ToString());
                return false;
            }
        }

        bool ContainsMyBan(string steamid)
        {
            return IsBanned(steamid) != null;
        }

        ISABan IsBanned(string steamid)
        {
            if (steamid == null || steamid.Equals("0")) return null;

            if (!IsPlayerCached(steamid)) return null;

            try
            {
                ISAPlayer isaPlayer = GetPlayerCache(steamid);

                if (isaPlayer?.bans?.Count() == 0)
                {
                    return null;
                }

                LogDebug("Check ban!");
                foreach (ISABan ban in isaPlayer?.bans)
                {
                    var isServerIP = (config.AutoKick_SameServerIp && ban.serverIp.Equals(config.ServerIp))
                        || (config.AutoKick_SameServerIp && ban.serverIp.Equals(covalence.Server.Address.ToString()));
                    var shouldNetworkCheck = (config.AutoKick_NetworkBan && !config.OwnerSteamId.IsNullOrEmpty() && ban.adminSteamId != null && ban.adminSteamId.Contains(config.OwnerSteamId));
                    var isServerId = this.serverId == ban.serverId;
                    if (isServerId || isServerIP || shouldNetworkCheck)
                    {
                        try
                        {
                            if (ban.IsBanned())
                                return ban;
                        }
                        catch (FormatException ex) { }
                    }
                }

                return null;
            }
            catch (InvalidOperationException ioe)
            {
                if (_playerData.ContainsKey(steamid))
                {
                    _playerData.Remove(steamid);
                }
                Puts(ioe.Message);
                return null;
            }
        }

        int ServerBanCount(ISAPlayer player)
        {
            try
            {
                if (player == null || player.bans == null) return 0;
                return player.bans.Count();
            }
            catch (NullReferenceException)
            {
                return 0;
            }
        }

        int TotalBans(ISAPlayer isaPlayer)
        {
            int banCounts = 0;
            banCounts += isaPlayer.steamNumberOfVACBans;
            banCounts += isaPlayer.steamNumberOfGameBans;
            banCounts += ServerBanCount(isaPlayer);
            return banCounts;
        }

        bool HasReachedVacCeiling(ISAPlayer isaPlayer)
        {
            if (isaPlayer == null) return false;
            return config.AutoKickOn && config.AutoVacBanCeiling >= 0 && config.AutoVacBanCeiling < (isaPlayer.steamNumberOfVACBans);
        }

        bool HasReachedGameBanCeiling(ISAPlayer isaPlayer)
        {
            if (isaPlayer == null) return false;
            return config.AutoKickOn && config.AutoGameBanCeiling >= 0 && config.AutoGameBanCeiling < isaPlayer.steamNumberOfGameBans;
        }

        bool HasReachedTotalBanCeiling(ISAPlayer isaPlayer)
        {
            if (isaPlayer == null) return false;
            int banCounts = TotalBans(isaPlayer);

            bool kick = config.AutoKickOn && config.EnableTotalBanKick && config.AutoTotalBanCeiling >= 0 && banCounts > config.AutoTotalBanCeiling;
            if (kick)
            {
                Puts($"Player ${isaPlayer.steamid} had {banCounts} total bans, it's more than the limit set of {config.AutoTotalBanCeiling}. Kicking player");
            }
            return kick;
        }

        bool HasReachedServerCeiling(ISAPlayer isaPlayer)
        {
            if (isaPlayer == null) return false;
            return config.AutoKickOn && config.AutoKickCeiling < (ServerBanCount(isaPlayer));
        }

        bool IsProfilePrivate(string steamid)
        {
            ISAPlayer player = GetPlayerCache(steamid);
            return player.communityvisibilitystate == 1;
        }

        int GetProfileLevel(string steamid)
        {
            ISAPlayer player = GetPlayerCache(steamid);
            return (int)player.steamlevel;
        }

        #endregion

        #region API Hooks
        private int API_GetServerBanCount(string steamid) => IsPlayerCached(steamid) ? GetPlayerBanDataCount(steamid) : 0;
        private bool API_GetIsVacBanned(string steamid) => IsPlayerCached(steamid) ? GetPlayerCache(steamid).steamVACBanned == 1 : false;
        private bool API_GetIsCommunityBanned(string steamid) => IsPlayerCached(steamid) ? GetPlayerCache(steamid).steamCommunityBanned == 1 : false;
        private int API_GetVacBanCount(string steamid) => IsPlayerCached(steamid) ? GetPlayerCache(steamid).steamNumberOfVACBans : 0;
        private int API_GetDaysSinceLastVacBan(string steamid) => IsPlayerCached(steamid) ? GetPlayerCache(steamid).steamDaysSinceLastBan : 0;
        private int API_GetGameBanCount(string steamid) => IsPlayerCached(steamid) ? GetPlayerCache(steamid).steamNumberOfGameBans : 0;
        private string API_GetEconomyBanStatus(string steamid) => IsPlayerCached(steamid) ? GetPlayerCache(steamid).steamEconomyBan : "none";
        private bool API_GetIsPlayerDirty(string steamid) => IsPlayerDirty(steamid);
        private bool API_GetIsProfilePrivate(string steamid) => IsProfilePrivate(steamid);
        private int API_GetProfileLevel(string steamid) => GetProfileLevel(steamid);

        private void API_BanPlayer(IPlayer player, string playerNameId, string reason, string length = "-1", bool ignoreSearch = false)
        {
            /***
             * Length 2: player, reason
             * Length 3: player, reason, time
             * Length 4: playerSteamId, reason, time, ignoreSearch
             ***/
            string banPlayer = playerNameId; //0
            string banReason = reason; // 1
            ulong banSteamId = 0;
            if (config.IgnoreCheatDetected && reason.StartsWith("Cheat Detected"))
            {
                return;
            }

            DateTime now = DateTime.Now;
            string dateTime = now.ToString(DATE_FORMAT);
            /***
             * If time not specified, default to 100 years
             ***/
            string lengthOfBan = !length.IsNullOrEmpty() && !length.Equals("-1") && !length.Equals("100Y") ? length : "-1";

            string dateBanUntil = lengthOfBan != "-1" ? BanUntil(lengthOfBan).ToString(DATE_FORMAT) : "-1";

            ulong.TryParse(banPlayer, out banSteamId);

            string errMsg = "";


            string playerName = banSteamId.ToString();

            IPlayer iPlayer = null;

            IEnumerable<IPlayer> playersFound = players.FindPlayers(banPlayer);
            int playersFoundCount = playersFound.Count();

            switch (playersFoundCount)
            {
                case 0:
                    if (banSteamId == 0)
                    {
                        errMsg = GetMsg("Player Not Found", new Dictionary<string, string> { ["player"] = banPlayer });
                    }
                    break;
                case 1:
                    iPlayer = players.FindPlayer(banPlayer);
                    break;
                default:
                    List<string> playersFoundNames = new List<string>();
                    for (int i = 0; i < playersFoundCount; i++) playersFoundNames.Add(playersFound.ElementAt(i).Name);
                    string playersFoundNamesString = String.Join(", ", playersFoundNames.ToArray());
                    errMsg = GetMsg("Multiple Players Found", new Dictionary<string, string> { ["players"] = playersFoundNamesString });
                    break;
            }

            if (iPlayer != null && iPlayer.IsAdmin)
            {
                Puts($"You cannot ban a admin! Issued by {player?.Id ?? player?.Name}");
                return;
            }
            try
            {
                if (AdminToggle != null && AdminToggle.Call<bool>("IsAdmin", iPlayer.Id))
                {
                    return;
                }
            }
            catch (Exception) { }

            playerName = iPlayer?.Name;

            if (!ignoreSearch && !errMsg.Equals("")) { SendReplyWithIcon(player, errMsg); return; }

            ISAPlayer isaPlayer;

            ulong adminId = 0;
            ulong.TryParse(player?.Id, out adminId);
            if (BanPlayer(new ISABan
            {
                steamid = banSteamId,
                bannedBy = adminId,
                serverName = server.Name,
                serverIp = config.ServerIp,
                reason = banReason,
                created = dateTime,
                banUntil = dateBanUntil
            }))
            {
                string msg;
                string banLengthText = lengthOfBan.Equals("-1") ? GetMsg("Permanent") : BanFor(lengthOfBan);
                // LogDebug($"banLengthText {banLengthText}");

                msg = GetMsg("Player Now Banned Perma", new Dictionary<string, string> { ["player"] = playerName, ["reason"] = reason, ["length"] = banLengthText });
                string msgClean = GetMsg("Player Now Banned Clean", new Dictionary<string, string> { ["player"] = playerName, ["reason"] = reason, ["length"] = banLengthText });


                // fix to ignore init rebans from rust
                if (serverStarted && apiConnected)
                {
                    // Add ember support.
                    if (Ember != null)
                        Ember?.Call("Ban", banSteamId, BanMinutes(BanUntil(lengthOfBan)), banReason, true, config.OwnerSteamId, Player.FindById(banSteamId));

                    if (config.RconBroadcast)
                        RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
                        {
                            Message = msgClean,
                            UserId = banSteamId.ToString(),
                            Username = playerName,
                            Time = Facepunch.Math.Epoch.Current
                        });

                    if (config.BroadcastNewBans)
                    {
                        BroadcastWithIcon(msg);
                    }
                    else
                    {
                        SendReplyWithIcon(player, msg);
                    }

                    if (config.DiscordBanReport)
                    {
                        DiscordSend(banSteamId.ToString(), playerName, new EmbedFieldList()
                        {
                            name = "Player Banned",
                            value = msgClean,
                            inline = true
                        }, 13459797, true);
                    }
                }

                try
                {
                    if (lengthOfBan == "-1")
                        SilentBan(banSteamId, -1, banReason, player);
                    else
                        SilentBan(banSteamId, TimeSpan.FromMinutes((BanUntil(lengthOfBan) - DateTime.Now).TotalMinutes), banReason, player);
                }
                catch (Exception e)
                {
                    Puts("Silent Ban Failed.");
                    Puts(e.Message);
                }
                finally
                {
                    Subscribe(nameof(OnUserBanned));
                }
            }
        }
        #endregion

        #region Localization
        string GetMsg(string msg, Dictionary<string, string> rpls = null)
        {
            string message = lang.GetMessage(msg, this);
            if (rpls != null) foreach (var rpl in rpls) message = message.Replace($"{{{rpl.Key}}}", rpl.Value);
            return message;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Protected MSG"] = "Server protected by [#008080ff]ServerArmour[/#]",
                ["User Dirty MSG"] = "[#008080ff]Server Armour Report:\n {steamid}:{username}[/#] is {status}.\n [#ff0000ff]Server Bans:[/#] {serverBanCount}\n [#ff0000ff]Game Bans:[/#] {NumberOfGameBans}\n [#ff0000ff]Vac Bans:[/#] {NumberOfVACBans}\n [#ff0000ff]Economy Banned:[/#] {EconomyBan}\n [#ff0000ff]Family Share:[/#] {FamShare}",
                ["User Dirty DISCORD MSG"] = "**Server Bans:** {serverBanCount}\n **Game Bans:** {NumberOfGameBans}\n **Vac Bans:** {NumberOfVACBans}\n **Economy Banned:** {EconomyBan}\n **Family Share:** {FamShare}",
                ["Command sa.cp Error"] = "Wrong format, example: /sa.cp usernameORsteamid trueORfalse",
                ["Arkan No Recoil Violation"] = "[#ff0000]{player}[/#] received an Arkan no recoil violation.\n[#ff0000]Violation[/#] #{violationNr}, [#ff0000]Weapon:[/#] {weapon}, [#ff0000]Ammo:[/#] {ammo}, [#ff0000]Shots count:[/#] {shots}\n Admins will investigate ASAP, please have handcams ready.\n This might be a false-positive, but all violations need to be investigated.",
                ["Arkan Aimbot Violation"] = "[#ff0000]{player}[/#] received an Arkan aimbot violation.\n[#ff0000]Violation[/#]  #{violationNr}, [#ff0000]Weapon:[/#] {weapon}, [#ff0000]Ammo:[/#] {ammo}\n Admins will investigate ASAP, please have handcams ready.\n This might be a false-positive, but all violations need to be investigated.",
                ["Arkan In Rock Violation"] = "[#ff0000]{player}[/#] received an Arkan in rock violation.\n[#ff0000]Violation[/#]  #{violationNr}, [#ff0000]Weapon:[/#] {weapon}, [#ff0000]Ammo:[/#] {ammo}\n Admins will investigate ASAP, please have handcams ready.\n This might be a false-positive, but all violations need to be investigated.",
                ["Player Now Banned Perma"] = "[#ff0000]{player}[/#] has been banned\n[#ff0000]Reason:[/#] {reason}\n[#ff0000]Length:[/#] {length}",
                ["Player Now Banned Clean"] = "{player} has been banned\nReason: {reason}\nLength: {length}",
                ["Player Now Unbanned Clean - Reason"] = "{player} has been unbanned\nReason: {reason}",
                ["Player Now Unbanned Clean - NoReason"] = "{player} has been unbanned",
                ["Reason: Bad IP"] = "Bad IP Detected, either due to a VPN/Proxy",
                ["Reason: Proxy IP"] = "VPN & Proxy's not allowed.",
                ["Player Not Found"