RIcon = false;
			[JsonProperty("Show XPerience Icon (Requires XPerience Plugin)")]
			public bool ShowXPIcon = false;
			[JsonProperty("Show XPerience Rank Sig (Requires XPerience Plugin)")]
			public bool ShowRankSig = false;
			[JsonProperty("Show XPerience Level (Requires XPerience Plugin)")]
			public bool ShowLevel = false;
			[JsonProperty("Show TPR Icon (Requires NTeleportation Plugin and tpr permission)")]
			public bool ShowTPIcon = false;
			[JsonProperty("Show Discord Report Icon (Requires DiscordReport Plugin)")]
			public bool ShowDRIcon = false;
			[JsonProperty("UI Location (distance from left 0 - 0.80)")]
			public double UILeft = 0.05;
			[JsonProperty("UI Location (distance from bottom 0.45 - 1.0)")]
			public double UITop = 0.75;
			[JsonProperty("Chat Command (Online Players)")]
			public string chatplayers = "players";
			[JsonProperty("Chat Command (Sleepers)")]
			public string chatsleepers = "sleepers";
            [JsonProperty("Show Online HUD")]
            public bool OnlineHUD = false;
            [JsonProperty("Online HUD Chat Command")]
            public string chathud = "onlinehud";
            [JsonProperty("HUD Location From Left")]
            public double HUDLeft = 0.01;
            [JsonProperty("HUD Location From Top")]
            public double HUDTop = 0.98;
            [JsonProperty("HUD Width")]
            public double HUDWidth = 0.15;
            [JsonProperty("HUD Height")]
            public double HUDHeight = 0.30;
            [JsonProperty("Max Players On HUD")]
            public int HUDplayercount = 10;
            [JsonProperty("HUD Transparency 0.0 - 1.0")]
            public double HUDTransparency = 0.25;
            [JsonProperty("HUD Refresh Rate (seconds)")]
            public float HUDrefreshrate = 60;
            [JsonProperty("HUD Font Size")]
            public int HUDfontsize = 10;

            public string ToJson() => JsonConvert.SerializeObject(this);
			public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
		}
		protected override void LoadDefaultConfig() => config = new Configuration();
		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				config = Config.ReadObject<Configuration>();
				if (config == null)
				{
					throw new JsonException();
				}
				if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
				{
					PrintWarning("Configuration appears to be outdated; updating and saving");
					SaveConfig();
				}
			}
			catch
			{
				PrintWarning($"Configuration file {Name}.json is invalid; using defaults");
				LoadDefaultConfig();
			}
		}
		protected override void SaveConfig()
		{
			PrintWarning($"Configuration changes saved to {Name}.json");
			Config.WriteObject(config, true);
		}
		#endregion

		#region Oxide Hooks
        private void OnServerInitialized()
		{
			cmd.AddChatCommand(config.chatplayers, this, Chatplayers);
			cmd.AddChatCommand(config.chatsleepers, this, Chatsleepers);
			cmd.AddChatCommand(config.chathud, this, ChatHUD);
			//foreach (var player in BasePlayer.activePlayerList)
			//{
			//	if (player.userID.IsSteamId())
			//	{
			//		if (config.HideAdmins && player.IsAdmin) continue;
			//		onlinePlayers.Add(player.userID, player.displayName);
			//	}
			//	if (config.OnlineHUD)
			//	{
			//		OnlineHUD(player);
			//		HUDTimer(player, true);
   //             }
   //         }
   //         foreach (var player in BasePlayer.sleepingPlayerList)
			//{
			//	if (player.userID.IsSteamId())
			//	{
			//		if (config.HideAdmins && player.IsAdmin) continue;
   //                 onlinePlayers.Add(player.userID, player.displayName);
   //                 //sleeperPlayers.Add(player.userID, player.displayName);
			//	}
			//}
        }
        private void Loaded()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player.userID.Get().IsSteamId())
                {
                    if (config.HideAdmins && player.IsAdmin) continue;
                    onlinePlayers.Add(player.userID, player.displayName);
                }
                if (config.OnlineHUD)
                {
                    OnlineHUD(player);
                    HUDTimer(player, true);
                }
            }
            foreach (var player in BasePlayer.sleepingPlayerList)
            {
                if (player.userID.Get().IsSteamId())
                {
                    if (config.HideAdmins && player.IsAdmin) continue;
                    sleeperPlayers.Add(player.userID, player.displayName);
                }
            }
        }
		private void Unload()
		{
			foreach (var player in BasePlayer.activePlayerList)
			{
                ClearPlayerUIs(player);
				HUDTimer(player, false);
            }
            onlinePlayers.Clear();
			_onlineUIPage.Clear();
			sleeperPlayers.Clear();
			_sleeperPlayersUIPage.Clear();
        }
        private void OnPlayerConnected(BasePlayer player)
		{
			if (!onlinePlayers.ContainsKey(player.userID))
			{
				if (!config.HideAdmins && player.IsAdmin)
				{
					onlinePlayers.Add(player.userID, player.displayName);
				}
				else if (!player.IsAdmin)
				{
					onlinePlayers.Add(player.userID, player.displayName);
				}
			}
			if (sleeperPlayers.ContainsKey(player.userID))
			{
				if (!config.HideAdmins && player.IsAdmin)
				{
					sleeperPlayers.Remove(player.userID);
				}
				else if (!player.IsAdmin)
				{
					sleeperPlayers.Remove(player.userID);
				}
			}
			if(config.OnlineHUD)
			{
				OnlineHUD(player);
                HUDTimer(player, true);
            }
        }
		private void OnPlayerDisconnected(BasePlayer player)
		{
			ClearPlayerUIs(player);
			if (onlinePlayers.ContainsKey(player.userID))
			{
				if (!config.HideAdmins && player.IsAdmin)
				{
					onlinePlayers.Remove(player.userID);
				}
				else if (!player.IsAdmin)
				{
					onlinePlayers.Remove(player.userID);
				}
			}
			if (!sleeperPlayers.ContainsKey(player.userID))
			{
				if (!config.HideAdmins && player.IsAdmin)
				{
					sleeperPlayers.Add(player.userID, player.displayName);
				}
				else if (!player.IsAdmin)
				{
					sleeperPlayers.Add(player.userID, player.displayName);
				}
			}
		}
		private static BasePlayer FindPlayer(string playerid)
		{
			foreach (var activePlayer in BasePlayer.activePlayerList)
			{
				if (activePlayer.UserIDString == playerid)
					return activePlayer;
			}
			foreach (var sleepingPlayer in BasePlayer.sleepingPlayerList)
			{
				if (sleepingPlayer.UserIDString == playerid)
					return sleepingPlayer;
			}
			return null;
		}
		#endregion

		#region Commands
		// Chat Commands
		private void Chatplayers(BasePlayer player, string command, string[] args)
		{
            ClearPlayerUIs(player);
            PlayerOnlineUI(player);
            PlayerOnlineUIList(player, _onlineUIPage[player.userID]);
        }	
		private void Chatsleepers(BasePlayer player, string command, string[] args)
		{
            ClearPlayerUIs(player);
            SleeperPlayerUI(player);
            SleeperPlayerUIList(player, _sleeperPlayersUIPage[player.userID]);
        }
		private void ChatHUD(BasePlayer player, string command, string[] args)
		{
			switch (args[0])
			{
				case "on":
					OnlineHUD(player);
                    HUDTimer(player, true);
                    break;
				case "off":
                    DestroyUi(player, OnlinePlayersHUD);
                    HUDTimer(player, false);
                    break;
			}
        }
		// Command Handlers
        [ConsoleCommand("op.playerprofiles")]
		private void Cmdopplayerprofiles(ConsoleSystem.Arg arg)
		{
			var player = arg.Player();
			if (player == null) return;
			string page = arg.GetString(0);
			ClearPlayerUIs(player);
            switch (page)
            {
				case "xperience":
					if (XPerience != null)
					{
                        //XPerience.Call("PlayerProfile", player, FindPlayer(arg.GetString(1)));
                        //XPerience.Call("PlayerProfileMain", player, FindPlayer(arg.GetString(1)));
                        player.SendConsoleCommand($"chat.say \"/xpstats {FindPlayer(arg.GetString(1))}\"");
                    }
                    break;
				case "killrecords":
					if (KillRecords != null)
					{
						KillRecords.Call("KRUIplayers", player, arg.GetString(1).ToLower());
					}
					break;
				case "discordreport":
					if (DiscordReport != null)
					{
						string message = "[Received player report from Online Players]";
						player.SendConsoleCommand($"chat.say \"/report {FindPlayer(arg.GetString(1))} {message}\"");
						//DiscordReport.Call("CommandReport", player, "report", info);
					}
					break;
			}
		}
        [ConsoleCommand("op.sleeperprofiles")]
		private void Cmdopsleeperprofiles(ConsoleSystem.Arg arg)
		{
			var player = arg.Player();
			if (player == null) return;
			string page = arg.GetString(0);
			var info = arg.GetString(1).ToLower();
            var otherplayer = FindPlayer(arg.GetString(1));
            ClearPlayerUIs(player);
            switch (page)
            {
				case "xperience":
                    if (XPerience != null)
                    {
                        //XPerience.Call("PlayerProfile", player, otherplayer);
                        //XPerience.Call("PlayerProfileMain", player, otherplayer);
                        player.SendConsoleCommand($"chat.say \"/xpstats {FindPlayer(arg.GetString(1))}\"");
                    }
                    break;
				case "killrecords":
					if (KillRecords != null)
					{
						KillRecords.Call("KRUIplayers", player, info);
					}
				break;
			}		
		}	
		[ConsoleCommand("op.refreshplayers")]
		private void Cmdrefreshplayers(ConsoleSystem.Arg arg)
		{
			var player = arg.Player();
			if (player == null) return;
            ClearPlayerUIs(player);
            PlayerOnlineUI(player);
			PlayerOnlineUIList(player, _onlineUIPage[player.userID]);
		}
		[ConsoleCommand("op.refreshsleepers")]
		private void Cmdrefreshsleepers(ConsoleSystem.Arg arg)
		{
			var player = arg.Player();
			if (player == null) return;
            ClearPlayerUIs(player);
            SleeperPlayerUI(player);
			SleeperPlayerUIList(player, _sleeperPlayersUIPage[player.userID]);
		}
		[ConsoleCommand("op.playerpages")]
		private void Cmdopplayerpages(ConsoleSystem.Arg arg)
		{
            BasePlayer player = arg.Player();
			if (player == null) return;
            DestroyUi(player, OnlinePlayersUIInner);
			DestroyUi(player, OnlinePlayersUIPages);
            PlayerOnlineUIList(player, arg.GetInt(0));
		}
		[ConsoleCommand("op.sleeperpages")]
		private void Cmdopsleeperpages(ConsoleSystem.Arg arg)
		{
            BasePlayer player = arg.Player();
			if (player == null) return;
            DestroyUi(player, SleeperPlayersUIInner);
			DestroyUi(player, SleeperPlayersUIPages);
            SleeperPlayerUIList(player, arg.GetInt(0));
		}
        [ConsoleCommand("op.nteleportation")]
		private void Cmdnteleportation(ConsoleSystem.Arg arg)
		{
			var player = arg.Player();
			if (arg.Player() == null) return;
			var target = arg.GetString(0).ToLower();
            ClearPlayerUIs(player);
            if (NTeleportation != null)
			{
				player.SendConsoleCommand($"chat.say \"/tpr {target}\"");
			}	
		}
		#endregion

		#region UIs
		// UI Defaults
		private CuiPanel DefaultUIPanel(string anchorMin, string anchorMax, string color = "0 0 0 0")
		{
			return new CuiPanel
			{
				Image =
				{
					Color = color
				},
				RectTransform =
				{
					AnchorMin = anchorMin,
					AnchorMax = anchorMax
				}
			};
		}
		private CuiLabel DefaultUILabel(string text, double i, float height, TextAnchor align = TextAnchor.MiddleLeft, int fontSize = 13, string xMin = "0", string xMax = "1", string color = "1.0 1.0 1.0 1.0")
		{
			return new CuiLabel
			{
				Text =
				{
					Text = text,
					FontSize = fontSize,
					Align = align,
					Color = color
				},
				RectTransform =
				{
					AnchorMin = $"{xMin} {1 - height*i + i * .002f}",
					AnchorMax = $"{xMax} {1 - height*(i-1) + i * .002f}"
				}
			};
		}
		private CuiButton DefaultUIButton(string command, double i, float rowHeight, int fontSize = 11, string color = "1.0 0.0 0.0 0.7", string content = "+", string xMin = "0", string xMax = "1", TextAnchor align = TextAnchor.MiddleLeft, string fcolor = "1.0 1.0 1.0 1.0")
		{
			return new CuiButton
			{
				Button =
				{
					Command = command,
					Color = $"{color}"
				},
				RectTransform =
				{
					AnchorMin = $"{xMin} {1 - rowHeight*i + i * .002f}",
					AnchorMax = $"{xMax} {1 - rowHeight*(i-1) + i * .002f}"
				},
				Text =
				{
					Text = content,
					FontSize = fontSize,
					Align = align,
					Color = fcolor,
				}
			};
		}
        private CuiElement DefaultUIImage(string parent, string image, double i, float imgheight, string xMin = "0", string xMax = "1")
        {
            return new CuiElement
            {
                Parent = parent,
                Components =
                {
                    new CuiRawImageComponent
                    {
                        Png = ImageLibrary?.Call<string>("GetImage", image)
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = $"{xMin} {1 - imgheight*i + i * .002f}",
                        AnchorMax = $"{xMax} {1 - imgheight*(i-1) + i * .002f}",
                    }
                }
            };
        }
        private CuiElement DefaultHUDUIImage(string parent, string image, double i, float imgheight, string xMin = "0", string xMax = "1")
        {
            return new CuiElement
            {
                Parent = parent,
                Components =
                {
                    new CuiRawImageComponent
                    {
                        Png = ImageLibrary?.Call<string>("GetImage", image)
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = $"{xMin} {1 - imgheight*i + i * .002f}",
                        AnchorMax = $"{xMax} {1 - imgheight*(i-1) + i * .002f - .03}",
                    }
                }
            };
        }
        private CuiLabel DefaultHUDUILabel(string text, double i, float height, TextAnchor align = TextAnchor.MiddleLeft, int fontSize = 13, string xMin = "0", string xMax = "1", string color = "1.0 1.0 1.0 1.0")
        {
            return new CuiLabel
            {
                Text =
                {
                    Text = text,
                    FontSize = fontSize,
                    Align = align,
                    Color = color
                },
                RectTransform =
                {
                    AnchorMin = $"{xMin} {1 - height*i + i * .002f}",
                    AnchorMax = $"{xMax} {1 - height*(i-1) + i * .002f - .03}"
                }
            };
        }
        // Online Players
        private void OnlineHUD(BasePlayer player)
		{
            if (player == null || !player.userID.Get().IsSteamId()) return;
            DestroyUi(player, OnlinePlayersHUD);
            var HUDelements = new CuiElementContainer();
            // Main UI
            double HUDLeft = config.HUDLeft;
            double HUDTop = config.HUDTop;
            if (HUDLeft > 0.80) { HUDLeft = 0.80; }
            if (HUDLeft < 0) { HUDLeft = 0; }
            if (HUDTop > 1) { HUDTop = 1; }
            if (HUDTop < config.HUDHeight) { HUDTop = config.HUDHeight; }
			double HUDWidth = config.HUDWidth;
			double HUDHeight = config.HUDHeight;
            int n = 1;
            float height = 0.1f;
            var rank = "";
            var level = "";
			string avatarloc = "0.1";
			string nameloc = "0.01";
            HUDelements.Add(DefaultUIPanel($"{HUDLeft} {HUDTop - HUDHeight}", $"{HUDLeft + HUDWidth} {HUDTop}", $"0 0 0 {config.HUDTransparency}"), "Hud", OnlinePlayersHUD);
            foreach (var onlineplayer in onlinePlayers)
            {
                if ((n - config.HUDplayercount) < config.HUDplayercount)
                {
                    if (ImageLibrary != null && config.playeravatars)
                    {
                        HUDelements.Add(DefaultHUDUIImage(OnlinePlayersHUD, onlineplayer.Key.ToString(), n, height, "0", avatarloc));
						nameloc = "0.12";
                    }
                    if (XPerience != null)
                    {
						if(config.ShowRankSig && XPerience?.Call<string>("GetXPCache", FindPlayer(onlineplayer.Key.ToString()), "ranksig") != null)
						{
                            rank = $" {XPerience?.Call<string>("GetXPCache", FindPlayer(onlineplayer.Key.ToString()), "ranksig")}";
                        }
						if(config.ShowLevel && XPerience?.Call<string>("GetXPCache", FindPlayer(onlineplayer.Key.ToString()), "level") != null)
						{
                            level = $" [{XPerience?.Call<string>("GetXPCache", FindPlayer(onlineplayer.Key.ToString()), "level")}]";
                        }
                    }
                    HUDelements.Add(DefaultHUDUILabel($"{onlineplayer.Value}{rank}{level}", n, height, TextAnchor.MiddleLeft, config.HUDfontsize, nameloc, "1", "1 1 1 1"), OnlinePlayersHUD, "HUDList");
                }
                n++;
            }
            // UI End
            CuiHelper.AddUi(player, HUDelements);
			return;
        }        
		private void PlayerOnlineUI(BasePlayer player)
		{
			if (player == null) return;
			DestroyUi(player, OnlinePlayersUI);
			DestroyUi(player, SleeperPlayersUI);
			int count = onlinePlayers.Count;
			var OnlinePlayersUIelements = new CuiElementContainer();
			// Main UI
			double UILeft = config.UILeft;
			double UITop = config.UITop;
			if(UILeft > 0.80){UILeft = 0.80;}			
			if(UILeft < 0){UILeft = 0;}			
			if(UITop > 1) {UITop = 1;}
			if(UITop < 0.45) {UITop = 0.45;}
			OnlinePlayersUIelements.Add(new CuiPanel
			{
				Image =
				{
					Color = "0.1 0.1 0.1 0.95"
				},
				RectTransform =
				{
					AnchorMin = $"{UILeft} {UITop - 0.45}",
					AnchorMax = $"{UILeft + 0.20} {UITop}"
				},
				CursorEnabled = true
			}, "Hud", OnlinePlayersUI);
			// Close Button
			OnlinePlayersUIelements.Add(new CuiButton
			{
				Button =
				{
					Close = OnlinePlayersUI,
					Color = "0.0 0.0 0.0 0.0"
				},
				RectTransform =
				{
					AnchorMin = "0.88 0.94",
					AnchorMax = "1.0 1.0"
				},
				Text =
				{
					Text = "ⓧ",
					FontSize = 15,
					Color = "1.0 0.0 0.0 1.0",
					Align = TextAnchor.MiddleCenter
				}
			}, OnlinePlayersUI);
			// Online Player Box
			if (config.ShowOnlineCount)
			{
				OnlinePlayersUIelements.Add(DefaultUILabel($"{OPLang("OP_01", player.UserIDString, count)}", 1, 0.095f, TextAnchor.MiddleLeft, 15, "0.01", "0.75", "1.0 1.0 1.0 1.0"), OnlinePlayersUI);
			}
			else
			{
				OnlinePlayersUIelements.Add(DefaultUILabel($"{OPLang("OP_03", player.UserIDString)}", 1, 0.095f, TextAnchor.MiddleLeft, 15, "0.01", "0.75", "1.0 1.0 1.0 1.0"), OnlinePlayersUI);
			}
			// UI End
			CuiHelper.AddUi(player, OnlinePlayersUIelements);
			return;
		}
        private void PlayerOnlineUIList(BasePlayer player, int from = 0)
		{
			if (player == null) return;
            _onlineUIPage[player.userID] = from;
            int current = 0;
            float height = 0.05f;
            var OnlinePlayersUIelements = new CuiElementContainer();
			var rank = "";
			var level = "";
			// Online Player Box
			OnlinePlayersUIelements.Add(DefaultUIPanel("0.0 0.10", "0.995 0.90", "0.0 0.0 0.0 0.50"), OnlinePlayersUI, OnlinePlayersUIInner);
            foreach (var p in onlinePlayers)
            {
                if (current >= from && current < from + 20)
                {
                    int pos = (current - from);
                    if (ImageLibrary != null && config.playeravatars)
                    {
                        OnlinePlayersUIelements.Add(DefaultUIImage(OnlinePlayersUIInner, p.Key.ToString(), pos + 1, height, "0", "0.05"));
                    }
					if (XPerience != null)
					{
						if (config.ShowRankSig)
						{
							rank = $" {XPerience.Call<string>("GetXPCache", FindPlayer(p.Key.ToString()), "ranksig")}";
						}
						if (config.ShowLevel)
						{
							level = $" [{XPerience.Call<string>("GetXPCache", FindPlayer(p.Key.ToString()), "level")}]";
						}
					}
					OnlinePlayersUIelements.Add(DefaultUILabel($"{p.Value}{rank}{level}", pos + 1, height, TextAnchor.UpperLeft, 12, "0.06", "0.75", "1 1 1 1"), OnlinePlayersUIInner);
					if (NTeleportation != null && config.ShowTPIcon)
                    {
						OnlinePlayersUIelements.Add(DefaultUIButton($"op.nteleportation {p.Value}", pos + 1, height, 12, "0 0 0 0", "⇆", "0.80", "0.85", TextAnchor.UpperLeft, "0 1 0 1"), OnlinePlayersUIInner);
                    }
					if (XPerience != null && config.ShowXPIcon)
                    {
						OnlinePlayersUIelements.Add(DefaultUIButton($"op.playerprofiles xperience {p.Key}", pos + 1, height, 12, "0 0 0 0", "⇪", "0.85", "0.90", TextAnchor.UpperLeft, "0 0 1 1"), OnlinePlayersUIInner);
                    }
                    if (KillRecords != null && config.ShowKRIcon)
                    {
                        OnlinePlayersUIelements.Add(DefaultUIButton($"op.playerprofiles killrecords {p.Key}", pos + 1, height, 10, "0 0 0 0", "☠", "0.90", "0.95", TextAnchor.UpperLeft, "1 0 0 1"), OnlinePlayersUIInner);
                    }
                    if (DiscordReport != null && config.ShowDRIcon)
                    {
						var iplayer = FindPlayer(p.Key.ToString());
                        OnlinePlayersUIelements.Add(DefaultUIButton($"op.playerprofiles discordreport {iplayer}", pos + 1, height, 10, "0 0 0 0", "☄", "0.95", "1", TextAnchor.UpperLeft, "1 0 0 1"), OnlinePlayersUIInner);
                    }
					current++;
                }
                current++;
			}
            int minfrom = from <= 10 ? 0 : from - 10;
            int maxfrom = from + 10 >= current ? from : from + 10;
            PlayerOnlineUIPages(player, minfrom, maxfrom, from);
            // UI End
			CuiHelper.AddUi(player, OnlinePlayersUIelements);
        }
        private void PlayerOnlineUIPages(BasePlayer player, int next, int back, int from)
		{
            float height = 1f;
            var OnlinePlayersUIelements = new CuiElementContainer();
			OnlinePlayersUIelements.Add(DefaultUIPanel("0.0 0.0", "0.995 0.10", "0.0 0.0 0.0 0.0"), OnlinePlayersUI, OnlinePlayersUIPages);
			// Next Page
            if (from >= 1)
			{
				OnlinePlayersUIelements.Add(DefaultUIButton($"op.playerpages {next}", 1, height, 25, "0 0 0 0", "⇧", "0.0", "0.25", TextAnchor.MiddleCenter, "1.0 1.0 0.0 1.0"), OnlinePlayersUIPages);		
			}
			// Prev Page
			if (from + 10 < onlinePlayers.Count)
			{
				OnlinePlayersUIelements.Add(DefaultUIButton($"op.playerpages {back}", 1, height, 25, "0 0 0 0", "⇩", "0.25", "0.50", TextAnchor.MiddleCenter, "1.0 1.0 0.0 1.0"), OnlinePlayersUIPages);
			}
			// Refresh Page
			OnlinePlayersUIelements.Add(DefaultUIButton($"op.refreshplayers", 1, height, 25, "0 0 0 0", "↺", "0.50", "0.75", TextAnchor.MiddleCenter, "0.0 1.0 0.0 1.0"), OnlinePlayersUIPages);
			// Switch To Sleeper Page
			OnlinePlayersUIelements.Add(DefaultUIButton($"op.refreshsleepers", 1, height, 25, "0 0 0 0", "⊷", "0.75", "1.0", TextAnchor.UpperCenter, "0.0 1.0 1.0 1.0"), OnlinePlayersUIPages);
			// UI End
			CuiHelper.AddUi(player, OnlinePlayersUIelements);
			return;
		}
		private void HUDTimer(BasePlayer player, bool active = true) 
		{
			if (active)
			{
                _playerdata = timer.Every(config.HUDrefreshrate, () =>
				{
					OnlineHUD(player);
				});
			} 
            if (!active)
			{
                _playerdata?.Destroy();
            }
        }
		// Sleepers
		private void SleeperPlayerUI(BasePlayer player)
			{
				if (player == null) return;
				DestroyUi(player, OnlinePlayersUI);
				DestroyUi(player, SleeperPlayersUI);
				int count = sleeperPlayers.Count;
				var SleeperPlayersUIelements = new CuiElementContainer();
				// Main UI
				double UILeft = config.UILeft;
				double UITop = config.UITop;
				if (UILeft > 0.80) { UILeft = 0.80; }
				if (UILeft < 0) { UILeft = 0; }
				if (UITop > 1) { UITop = 1; }
				if (UITop < 0.45) { UITop = 0.45; }
				SleeperPlayersUIelements.Add(new CuiPanel
				{
					Image =
					{
						Color = "0.1 0.1 0.1 0.95"
					},
					RectTransform =
					{
						AnchorMin = $"{UILeft} {UITop - 0.45}",
						AnchorMax = $"{UILeft + 0.20} {UITop}"
					},
					CursorEnabled = true
				}, "Hud", SleeperPlayersUI);
				// Close Button
				SleeperPlayersUIelements.Add(new CuiButton
				{
					Button =
					{
						Close = SleeperPlayersUI,
						Color = "0.0 0.0 0.0 0.0"
					},
					RectTransform =
					{
						AnchorMin = "0.88 0.94",
						AnchorMax = "1.0 1.0"
					},
					Text =
					{
						Text = "ⓧ",
						FontSize = 15,
						Color = "1.0 0.0 0.0 1.0",
						Align = TextAnchor.MiddleCenter
					}
				}, SleeperPlayersUI);
				// Online Player Box
				if (config.ShowSleeperCount)
				{
					SleeperPlayersUIelements.Add(DefaultUILabel($"{OPLang("OP_02", player.UserIDString, count)}", 1, 0.095f, TextAnchor.MiddleLeft, 15, "0.01", "0.75", "1.0 1.0 1.0 1.0"), SleeperPlayersUI);
				}
				else
				{
					SleeperPlayersUIelements.Add(DefaultUILabel($"{OPLang("OP_04", player.UserIDString)}", 1, 0.095f, TextAnchor.MiddleLeft, 15, "0.01", "0.75", "1.0 1.0 1.0 1.0"), SleeperPlayersUI);
				}
				// UI End
				CuiHelper.AddUi(player, SleeperPlayersUIelements);
				return;
			}
        private void SleeperPlayerUIList(BasePlayer player, int from = 0)
		{
			if (player == null) return;
            _sleeperPlayersUIPage[player.userID] = from;
            int current = 0;
            float height = 0.05f;
            //float avatarheight = 0.05f;
            var SleeperPlayersUIelements = new CuiElementContainer();
			var rank = "";
			var level = "";
			// Online Player Box
			SleeperPlayersUIelements.Add(DefaultUIPanel("0 .10", ".995 .90", "0 0 0 .50"), SleeperPlayersUI, SleeperPlayersUIInner);
			foreach (var p in sleeperPlayers)
			{
				if (current >= from && current < from + 20)
				{
					int pos = (current - from);
                    if (ImageLibrary != null && config.playeravatars)
                    {
                        SleeperPlayersUIelements.Add(DefaultUIImage(SleeperPlayersUIInner, p.Key.ToString(), pos + 1, height, "0", "0.05"));
                    }
                    if (XPerience != null)
					{
                        if (config.ShowRankSig)
                        {
                            rank = $" {XPerience.Call<string>("GetXPCache", FindPlayer(p.Key.ToString()), "ranksig")}";
                        }
                        if (config.ShowLevel)
                        {
                            level = $" [{XPerience.Call<string>("GetXPCache", FindPlayer(p.Key.ToString()), "level")}]";
                        }
                    }
                    SleeperPlayersUIelements.Add(DefaultUILabel($"{p.Value}{rank}{level}", pos + 1, height, TextAnchor.UpperLeft, 12, "0.06", "0.75", "1 1 1 1"), SleeperPlayersUIInner);
					if (XPerience != null && config.ShowXPIcon)
					{
						SleeperPlayersUIelements.Add(DefaultUIButton($"op.sleeperprofiles xperience {p.Key}", pos + 1, height, 12, "0 1 0 0", "⇪", "0.80", "0.85", TextAnchor.UpperLeft, "0 0 1 1"), SleeperPlayersUIInner);
					}
					if (KillRecords != null && config.ShowKRIcon)
					{
						SleeperPlayersUIelements.Add(DefaultUIButton($"op.sleeperprofiles killrecords {p.Value}", pos + 1, height, 10, "0 1 0 0", "☠", "0.90", "0.95", TextAnchor.UpperLeft, "1 0 0 1"), SleeperPlayersUIInner);
					}
                    current++;
                }
                current++;
			}
            int minfrom = from <= 10 ? 0 : from - 10;
            int maxfrom = from + 10 >= current ? from : from + 10;
			SleeperPlayerUIPages(player, minfrom, maxfrom, from);         
            // UI End
			CuiHelper.AddUi(player, SleeperPlayersUIelements);
        }
        private void SleeperPlayerUIPages(BasePlayer player, int next, int back, int from)
		{
            float height = 1f;
            var SleeperPlayersUIelements = new CuiElementContainer();
			// Next Page
			SleeperPlayersUIelements.Add(DefaultUIPanel("0.0 0.0", "0.995 0.10", "0.0 0.0 0.0 0.0"), SleeperPlayersUI, SleeperPlayersUIPages);
            if (from >= 1)
			{
				SleeperPlayersUIelements.Add(DefaultUIButton($"op.sleeperpages {next}", 1, height, 25, "0 0 0 0", "⇧", "0.0", "0.25", TextAnchor.MiddleCenter, "1.0 1.0 0.0 1.0"), SleeperPlayersUIPages);		
			}
			// Prev Page
			if (from + 10 < sleeperPlayers.Count)
			{
				SleeperPlayersUIelements.Add(DefaultUIButton($"op.sleeperpages {back}", 1, height, 25, "0 0 0 0", "⇩", "0.25", "0.50", TextAnchor.MiddleCenter, "1.0 1.0 0.0 1.0"), SleeperPlayersUIPages);
			}
			// Refresh Page
			SleeperPlayersUIelements.Add(DefaultUIButton($"op.refreshsleepers", 1, height, 25, "0 0 0 0", "↺", "0.50", "0.75", TextAnchor.MiddleCenter, "0.0 1.0 0.0 1.0"), SleeperPlayersUIPages);
			// Switch To Online Page 
			SleeperPlayersUIelements.Add(DefaultUIButton($"op.refreshplayers", 1, height, 25, "0 0 0 0", "⊶", "0.75", "1.0", TextAnchor.UpperCenter, "0.0 1.0 1.0 1.0"), SleeperPlayersUIPages);
			// UI End
			CuiHelper.AddUi(player, SleeperPlayersUIelements);
			return;
		}
		// Destroy UI
		private void DestroyUi(BasePlayer player, string name)
		{
			CuiHelper.DestroyUi(player, name);
		}
        private void ClearPlayerUIs(BasePlayer player, bool hud = false)
        {
            DestroyUi(player, OnlinePlayersUI);
            DestroyUi(player, OnlinePlayersUIInner);
            DestroyUi(player, SleeperPlayersUI);
            DestroyUi(player, SleeperPlayersUIInner);
			if(hud)
			{
				DestroyUi(player, OnlinePlayersHUD);
			}
        }
        #endregion

        #region Lang
        protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["OP_01"] = "Online Players: {0}",
				["OP_02"] = "Sleeping Players: {0}",
				["OP_03"] = "Online Players:",
				["OP_04"] = "Sleeping Players:",

			}, this);
		}
		private string OPLang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        #endregion
    }
}

// --- End of file: OnlinePlayers.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/old-school-quarries ---
// --- Original File Path: O/OldSchoolQuarries/OldSchoolQuarries.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("OldSchoolQuarries", "S0N_0F_BISCUIT", "1.0.8")]
    [Description("Makes resource output from quarries better")]
    class OldSchoolQuarries : RustPlugin
    {
        #region Variables
        private enum OreType { None, Sulfur, Metal, HighQuality };

        class CustomItem
        {
            public string shortname;
            public int amount;
            public double chance;
            public bool valid = true;
        }

        class ConfigData
        {
            [JsonProperty(PropertyName = "Display Detailed Analysis")]
            public bool Detailed_Analysis = false;
            [JsonProperty(PropertyName = "Custom Items")]
            public List<CustomItem> Custom_Items = new List<CustomItem>();
        }

        static class StandardOutput
        {
            public static DepositEntry stone = new DepositEntry()
            {
                type = OreType.None,
                amount = 100000,
                workNeeded = .3f
            };
            public static DepositEntry hqm = new DepositEntry()
            {
                type = OreType.HighQuality,
                amount = 100000,
                workNeeded = 35f
            };
            public static DepositEntry metal = new DepositEntry()
            {
                type = OreType.Metal,
                amount = 100000,
                workNeeded = 2f
            };
            public static DepositEntry sulfur = new DepositEntry()
            {
                type = OreType.Sulfur,
                amount = 100000,
                workNeeded = 3.25f
            };
        }

        class DepositEntry
        {
            public OreType type = OreType.None;
            public int amount;
            public float workNeeded;
        }

        class Deposit
        {
            public Origin origin = new Origin();
            public List<DepositEntry> entries = new List<DepositEntry>();
        }

        class Origin
        {
            public float x = 0;
            public float y = 0;
            public float z = 0;

            public Origin()
            {
                x = y = z = 0;
            }
            public Origin(Vector3 vector)
            {
                x = vector.x;
                y = vector.y;
                z = vector.z;
            }
        }

        class StoredData
        {
            public List<Deposit> changedDeposits = new List<Deposit>();
        }

        private static readonly System.Random rng = new System.Random();
        private ConfigData config = new ConfigData();
        private StoredData data = new StoredData();
        #endregion

        #region Localization
        private new void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoCommandPermission"] = "You do not have permission to use this command!",
                ["NoResources"] = "No resources found.",
                ["AnalysisHeader"] = "Mineral Analysis:",
                ["Analysis"] = "Item: {0}, Amount: {1} pM",
                ["AnalysisDetailed"] = "Item: {0}, Amount: {1}, Work Needed: {2}, Return: {3} pM",
                ["AnalysisFooter"] = "----------------------------------",
                ["ClearData"] = "Plugin data cleared."
            }, this);
        }
        #endregion

        #region Permissions
        private static class Permissions
        {
            public static string probe = $"oldschoolquarries.probe";
            public static string customloot = $"oldschoolquarries.customloot";
            public static string standardoutput = $"oldschoolquarries.standardoutput";
        }
        #endregion

        #region Initialization
        //
        // Mod initialization
        //
        private void Init()
        {
            // Permissions
            permission.RegisterPermission(Permissions.probe, this);
            permission.RegisterPermission(Permissions.customloot, this);
            permission.RegisterPermission(Permissions.standardoutput, this);
            // Configuration
            try
            {
                LoadConfigData();
            }
            catch
            {
                LoadDefaultConfig();
                LoadConfigData();
            }
            // Data
            LoadData();
        }
        //
        // Edit the stored resource deposits
        //
        void OnServerInitialized()
        {
            ValidateConfig();

            ItemDefinition stones = ItemManager.itemList.Find(x => x.shortname == "stones");
            ItemDefinition sulfur = ItemManager.itemList.Find(x => x.shortname == "sulfur.ore");
            ItemDefinition metal = ItemManager.itemList.Find(x => x.shortname == "metal.ore");
            ItemDefinition hqm = ItemManager.itemList.Find(x => x.shortname == "hq.metal.ore");

            foreach (Deposit deposit in data.changedDeposits)
            {
                ResourceDepositManager.ResourceDeposit rd = ResourceDepositManager.GetOrCreate(GetVector3(deposit.origin));

                if (deposit.entries.Count == 4)
                {
                    rd._resources.Clear();
                    rd.Add(stones, 1, StandardOutput.stone.amount, StandardOutput.stone.workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
                    rd.Add(sulfur, 1, StandardOutput.sulfur.amount, StandardOutput.sulfur.workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
                    rd.Add(metal, 1, StandardOutput.metal.amount, StandardOutput.metal.workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
                    rd.Add(hqm, 1, StandardOutput.hqm.amount, StandardOutput.hqm.workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
                }
                else
                {
                    foreach (DepositEntry entry in deposit.entries)
                    {
                        switch (entry.type)
                        {
                            case OreType.Metal:
                                if (!rd._resources.Exists(r => r.type.shortname == "metal.ore"))
                                    rd.Add(metal, 1, entry.amount, entry.workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
                                else
                                {
                                    ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource = rd._resources.Find(r => r.type.shortname == "metal.ore");
                                    resource.amount = entry.amount;
                                    resource.workNeeded = entry.workNeeded;
                                }
                                break;
                            case OreType.Sulfur:
                                if (!rd._resources.Exists(r => r.type.shortname == "sulfur.ore"))
                                    rd.Add(sulfur, 1, entry.amount, entry.workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
                                else
                                {
                                    ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource = rd._resources.Find(r => r.type.shortname == "sulfur.ore");
                                    resource.amount = entry.amount;
                                    resource.workNeeded = entry.workNeeded;
                                }
                                break;
                            default:
                                break;
                        }
                    }
                }
            }
        }
        //
        // Clear the data on a new map
        //
        private void OnNewSave(string filename)
        {
            ClearData();
        }
        #endregion

        #region Config Handling
        //
        // Load config file
        //
        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            var config = new ConfigData();
            // Create example item
            config.Custom_Items.Add(new CustomItem() { shortname = "candycane", amount = 1, chance = 0 });
            Config.WriteObject(config, true);
        }
        //
        // Load the config values to the config class
        //
        private void LoadConfigData()
        {
            config = Config.ReadObject<ConfigData>();
        }
        //
        // Validate the config file
        //
        private void ValidateConfig()
        {
            bool issuesFound = false;
            List<ItemDefinition> itemDefinitions = ItemManager.itemList;
            foreach (CustomItem item in config.Custom_Items)
            {
                if (!itemDefinitions.Exists(x => x.shortname == item.shortname))
                {
                    Puts($"The shortname \"{item.shortname}\" is invalid!");
                    item.valid = false;
                    issuesFound = true;
                }
                else
                {
                    item.valid = true;
                }

                if (item.chance > 100)
                {
                    Puts($"Invalid chance for shortname: \"{item.shortname}\"");
                    item.chance = 100;
                    issuesFound = true;
                }
                else if (item.chance < 0)
                {
                    Puts($"Invalid chance for shortname: \"{item.shortname}\"");
                    item.chance = 0;
                    issuesFound = true;
                }

                if (item.amount < 0)
                {
                    Puts($"Invalid amount for shortname: \"{item.shortname}\"");
                    item.amount = 0;
                    issuesFound = true;
                }
            }
            if (issuesFound)
            {
                Puts("Issues found in configuration file!");
            }
            Config.WriteObject(config, true);
        }
        #endregion

        #region Data Handling
        //
        // Load plugin data
        //
        private void LoadData()
        {
            try
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Title);
            }
            catch
            {
                data = new StoredData();
                SaveData();
            }
        }
        //
        // Save PlayerData
        //
        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Title, data);
        }
        //
        // Clear StoredData
        //
        private void ClearData()
        {
            data = new StoredData();
            SaveData();
        }
        #endregion

        #region Functionality
        //
        // Update salt map when resource deposit is tapped for the first time
        //
        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity is SurveyCharge)
            {
                OreType ore = OreType.None;

                ItemDefinition stones = ItemManager.itemList.Find(x => x.shortname == "stones");
                ItemDefinition sulfur = ItemManager.itemList.Find(x => x.shortname == "sulfur.ore");
                ItemDefinition metal = ItemManager.itemList.Find(x => x.shortname == "metal.ore");
                ItemDefinition hqm = ItemManager.itemList.Find(x => x.shortname == "hq.metal.ore");

                ResourceDepositManager.ResourceDeposit rd = ResourceDepositManager.GetOrCreate(entity.transform.position);
                Deposit deposit = new Deposit { origin = GetOrigin(rd.origin) };
                BasePlayer player = (entity as SurveyCharge).creatorEntity as BasePlayer;

                if (permission.UserHasPermission(player.UserIDString, Permissions.standardoutput))
                {
                    bool createDeposit = true;
                    // If deposit has been changed make sure it is correct
                    if (data.changedDeposits.Exists(d => GetVector3(d.origin) == rd.origin))
                    {
                        bool depositValid = true;
                        foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in rd._resources)
                        {
                            switch (resource.type.shortname)
                            {
                                case "stones":
                                    if (!(StandardOutput.stone.amount == resource.amount && StandardOutput.stone.workNeeded == resource.workNeeded))
                                        depositValid = false;
                                    break;
                                case "sulfur.ore":
                                    if (!(StandardOutput.sulfur.amount == resource.amount && StandardOutput.sulfur.workNeeded == resource.workNeeded))
                                        depositValid = false;
                                    break;
                                case "metal.ore":
                                    if (!(StandardOutput.metal.amount == resource.amount && StandardOutput.metal.workNeeded == resource.workNeeded))
                                        depositValid = false;
                                    break;
                                case "hq.metal.ore":
                                    if (!(StandardOutput.hqm.amount == resource.amount && StandardOutput.hqm.workNeeded == resource.workNeeded))
                                        depositValid = false;
                                    break;
                                default:
                                    break;
                            }
                        }

                        if (depositValid)
                            createDeposit = false;
                        else
                            deposit = data.changedDeposits.Find(d => GetVector3(d.origin) == rd.origin);

                    }

                    if (createDeposit)
                    {
                        rd._resources.Clear();
                        deposit.entries.Clear();

                        rd.Add(stones, 1, StandardOutput.stone.amount, StandardOutput.stone.workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
                        deposit.entries.Add(new DepositEntry()
                        {
                            type = StandardOutput.stone.type,
                            amount = StandardOutput.stone.amount,
                            workNeeded = StandardOutput.stone.workNeeded
                        });
                        rd.Add(sulfur, 1, StandardOutput.sulfur.amount, StandardOutput.sulfur.workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
                        deposit.entries.Add(new DepositEntry()
                        {
                            type = StandardOutput.sulfur.type,
                            amount = StandardOutput.sulfur.amount,
                            workNeeded = StandardOutput.sulfur.workNeeded
                        });
                        rd.Add(metal, 1, StandardOutput.metal.amount, StandardOutput.metal.workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
                        deposit.entries.Add(new DepositEntry()
                        {
                            type = StandardOutput.metal.type,
                            amount = StandardOutput.metal.amount,
                            workNeeded = StandardOutput.metal.workNeeded
                        });
                        rd.Add(hqm, 1, StandardOutput.hqm.amount, StandardOutput.hqm.workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
                        deposit.entries.Add(new DepositEntry()
                        {
                            type = StandardOutput.hqm.type,
                            amount = StandardOutput.hqm.amount,
                            workNeeded = StandardOutput.hqm.workNeeded
                        });

                        data.changedDeposits.Add(deposit);
                        SaveData();
                    }
                }

                if (data.changedDeposits.Exists(d => GetVector3(d.origin) == rd.origin))
                    return;

                ResourceDepositManager.ResourceDeposit.ResourceDepositEntry originalResource = null;

                int oreCount = 0;
                foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in rd._resources)
                {
                    switch (resource.type.shortname)
                    {
                        case "sulfur.ore":
                            ore = OreType.Sulfur;
                            originalResource = resource;
                            oreCount++;
                            break;
                        case "metal.ore":
                            ore = OreType.Metal;
                            originalResource = resource;
                            oreCount++;
                            break;
                        case "hq.metal.ore":
                            ore = OreType.HighQuality;
                            originalResource = resource;
                            oreCount++;
                            break;
                        default:
                            break;
                    }
                }

                if (oreCount > 1)
                    return;



                if (originalResource == null && rd._resources.Count != 0)
                    originalResource = rd._resources.ToArray()[0];

                System.Random rng = new System.Random();
                float workNeeded = (float)(rng.Next(0, 2) + rng.NextDouble());
                int choice = rng.Next(1, 100);
                int amount = 0;
                switch (ore)
                {
                    case OreType.Sulfur:  // Give a chance at some amount of metal ore
                        if (workNeeded > 1f)
                        {
                            amount = rng.Next(10000, 100000);
                            rd.Add(metal, 1, amount, workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
                            deposit.entries.Add(new DepositEntry() { type = OreType.Metal, amount = amount, workNeeded = workNeeded });
                        }
                        break;
                    case OreType.Metal: // Give a chance at some amount of sulfur ore
                        if (workNeeded > 1.75f)
                        {
                            amount = rng.Next(10000, 100000);
                            rd.Add(sulfur, 1, amount, workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
                            deposit.entries.Add(new DepositEntry() { type = OreType.Sulfur, amount = amount, workNeeded = workNeeded });
                        }
                        break;
                    case OreType.HighQuality: // Give a chance at some amount of either metal, sulfur, or both ores
                        if (choice < 40) // Just sulfur
                        {
                            amount = rng.Next(10000, 100000);
                            workNeeded = (float)(rng.Next(3, 4) + rng.NextDouble());
                            rd.Add(sulfur, 1, amount, workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
                            deposit.entries.Add(new DepositEntry() { type = OreType.Sulfur, amount = amount, workNeeded = workNeeded });
                        }
                        else if (choice < 80) // Just metal
                        {
                            if (workNeeded < 1.75f)
                                workNeeded += (1.75f - workNeeded);
                            amount = rng.Next(10000, 100000);
                            rd.Add(metal, 1, amount, workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
                            deposit.entries.Add(new DepositEntry() { type = OreType.Metal, amount = amount, workNeeded = workNeeded });
                        }
                        else // Both sulfur and metal
                        {
                            if (workNeeded < 1.75f)
                                workNeeded += (1.75f - workNeeded);
                            amount = rng.Next(10000, 100000);
                            rd.Add(metal, 1, amount, workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
                            deposit.entries.Add(new DepositEntry() { type = OreType.Metal, amount = amount, workNeeded = workNeeded });
                            amount = rng.Next(10000, 100000);
                            workNeeded = (float)(rng.Next(3, 4) + rng.NextDouble());
                            rd.Add(sulfur, 1, amount, workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
                            deposit.entries.Add(new DepositEntry() { type = OreType.Sulfur, amount = amount, workNeeded = workNeeded });
                        }
                        break;
                    default: // Give a chance at some amount of either metal, sulfur, or both ores
                        if (oreCount == 1)
                            return;
                        if (choice < 40) // Just sulfur
                        {
                            if (workNeeded > 1.75f)
                                return;
                            amount = rng.Next(10000, 100000);
                            workNeeded = (float)(rng.Next(3, 4) + rng.NextDouble());
                            rd.Add(sulfur, 1, amount, workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
                            deposit.entries.Add(new DepositEntry() { type = OreType.Sulfur, amount = amount, workNeeded = workNeeded });
                        }
                        else if (choice < 80) // Just metal
                        {
                            if (workNeeded < 1.75f)
                                workNeeded += (1.75f - workNeeded);
                            amount = rng.Next(10000, 100000);
                            rd.Add(metal, 1, amount, workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
                            deposit.entries.Add(new DepositEntry() { type = OreType.Metal, amount = amount, workNeeded = workNeeded });
                        }
                        else // Both sulfur and metal
                        {
                            if (workNeeded < 1.75f)
                                workNeeded += (1.75f - workNeeded);
                            amount = rng.Next(10000, 100000);
                            rd.Add(metal, 1, amount, workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
                            deposit.entries.Add(new DepositEntry() { type = OreType.Metal, amount = amount, workNeeded = workNeeded });
                            amount = rng.Next(10000, 100000);
                            workNeeded = (float)(rng.Next(3, 4) + rng.NextDouble());
                            rd.Add(sulfur, 1, amount, workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
                            deposit.entries.Add(new DepositEntry() { type = OreType.Sulfur, amount = amount, workNeeded = workNeeded });
                        }
                        break;
                }

                data.changedDeposits.Add(deposit);
                SaveData();
            }
        }
        //
        // Add custom item to quarries on fuel consumed
        //
        void OnItemUse(Item item, int amountToUse)
        {
            try
            {
                if (BaseNetworkable.serverEntities.Find(item.parent.entityOwner.parentEntity.uid) is MiningQuarry)
                {
                    MiningQuarry quarry = BaseNetworkable.serverEntities.Find(item.parent.entityOwner.parentEntity.uid) as MiningQuarry;

                    if (quarry.canExtractLiquid)
                        return;

                    if (!permission.UserHasPermission(quarry.OwnerID.ToString(), Permissions.customloot))
                        return;

                    ItemContainer hopper = (quarry.hopperPrefab.instance as StorageContainer).inventory;

                    double value = (rng.Next(0, 100) + rng.NextDouble());
                    if (value > 100d)
                        value = 100d;
                    if (config.Custom_Items == null)
                        return;
                    foreach (CustomItem cItem in config.Custom_Items)
                    {
                        if (!cItem.valid || cItem.chance == 0 || cItem.amount == 0)
                            continue;
                        if (value <= cItem.chance)
                        {
                            try
                            {
                                hopper.AddItem(ItemManager.itemList.Find(x => x.shortname == cItem.shortname), cItem.amount);
                            }
                            catch { }
                        }
                    }
                }
            }
            catch { }
        }
        #endregion

        #region Commands
        //
        // Perform a mineral analysis at players position
        //
        [ChatCommand("getdeposit")]
        void GetDeposit(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, Permissions.probe))
            {
                PrintToChat(player, Lang("NoCommandPermission", player.UserIDString));
                return;
            }

            ResourceDepositManager.ResourceDeposit rd = ResourceDepositManager.GetOrCreate(player.transform.position);
            if (rd == null)
            {
                PrintToChat(player, Lang("NoResources", player.UserIDString));
                return;
            }

            PrintToChat(player, Lang("AnalysisHeader", player.UserIDString));
            float num1 = 10f;
            float num2 = 7.5f;
            List<int> fixIndex = new List<int>();
            int index = 0;
            foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in rd._resources)
            {
                float num3 = (float)(60.0 / num1 * (num2 / (double)resource.workNeeded));
                if (float.IsInfinity(num3))
                    fixIndex.Add(index);
                if (config.Detailed_Analysis)
                    PrintToChat(player, Lang("AnalysisDetailed", player.UserIDString, resource.type.displayName.translated, resource.amount, resource.workNeeded, Math.Round(num3, 1)));
                else
                    PrintToChat(player, Lang("Analysis", player.UserIDString, resource.type.displayName.translated, Math.Round(num3, 1)));
                index++;
            }

            if (fixIndex.Count != 0)
            {
                foreach (int pos in fixIndex)
                    rd._resources.RemoveAt(pos);
            }

            PrintToChat(player, Lang("AnalysisFooter", player.UserIDString));
        }

        [ConsoleCommand("getdeposit")]
        void GetDepositConsole(ConsoleSystem.Arg arg)
        {
            GetDeposit(arg.Player(), "getdeposit", null);
        }
        //
        // Reload plugin config from within the game
        //
        [ChatCommand("osq.reloadconfig")]
        void ReloadConfig(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin)
                return;

            LoadConfigData();
            ValidateConfig();
        }
        //
        // Clear plugin data
        //
        [ConsoleCommand("osq.cleardata")]
        void ClearData(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
                return;
            ClearData();
            Puts(Lang("ClearData"));
        }
        #endregion

        #region Helpers
        //
        // Get formatted string from the lang file
        //
        private string Lang(string key, string userId = null, params object[] args) => string.Format(lang.GetMessage(key, this, userId), args);
        //
        // Get Vector3 from Origin
        //
        private Vector3 GetVector3(Origin origin) => new Vector3(origin.x, origin.y, origin.z);
        //
        // Get Origin from Vector3
        //
        private Origin GetOrigin(Vector3 vector) => new Origin(vector);
        #endregion
    }
}

// --- End of file: OldSchoolQuarries.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/online-quarries ---
// --- Original File Path: O/OnlineQuarries/OnlineQuarries.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Online Quarries", "mvrb/Arainrr", "1.2.8", ResourceId = 2216)]
    [Description("Automatically disable players' quarries when offline")]
    public class OnlineQuarries : RustPlugin
    {
        #region Fields

        [PluginReference]
        private Plugin Friends, Clans;

        private readonly Dictionary<ulong, Timer> _stopEngineTimer = new Dictionary<ulong, Timer>();
        private readonly HashSet<MiningQuarry> _miningQuarries = new HashSet<MiningQuarry>();

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            Unsubscribe(nameof(OnEntityDistanceCheck));
        }

        private void OnServerInitialized()
        {
            if (configData.preventOther)
            {
                Subscribe(nameof(OnEntityDistanceCheck));
            }
            foreach (var miningQuarry in BaseNetworkable.serverEntities.OfType<MiningQuarry>())
            {
                OnEntitySpawned(miningQuarry);
            }
            CheckQuarries();
        }

        private void OnEntitySpawned(MiningQuarry miningQuarry)
        {
            if (miningQuarry == null || miningQuarry.OwnerID == 0)
            {
                return;
            }
            _miningQuarries.Add(miningQuarry);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null)
            {
                return;
            }
            Timer value;
            if (_stopEngineTimer.TryGetValue(player.userID, out value))
            {
                value?.Destroy();
                _stopEngineTimer.Remove(player.userID);
            }

            if (configData.autoStart)
            {
                CheckQuarries(player, true);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (player == null)
            {
                return;
            }
            var playerId = player.userID;
            Timer value;
            if (_stopEngineTimer.TryGetValue(playerId, out value))
            {
                value?.Destroy();
                _stopEngineTimer.Remove(playerId);
            }
            _stopEngineTimer.Add(playerId, timer.Once(configData.offlineTime, () =>
            {
                CheckQuarries();
                _stopEngineTimer.Remove(playerId);
            }));
        }

        private object OnEntityDistanceCheck(EngineSwitch engineSwitch, BasePlayer player, uint id, string debugName, float maximumDistance)
        {
            if (player == null || engineSwitch == null)
            {
                return null;
            }
            if (id == 1739656243u && debugName == "StopEngine" || id == 1249530220u && debugName == "StartEngine")
            {
                var parentEntity = engineSwitch.GetParentEntity();
                if (parentEntity == null || !parentEntity.OwnerID.IsSteamId())
                {
                    return null;
                }
                if (AreFriends(parentEntity.OwnerID, player.userID))
                {
                    return false;
                }
            }
            return null;
        }

        #endregion Oxide Hooks

        #region Methods

        private void CheckQuarries(BasePlayer player = null, bool isOn = false)
        {
            foreach (var miningQuarry in _miningQuarries)
            {
                if (miningQuarry == null)
                {
                    continue;
                }
                if (player != null)
                {
                    if (AreFriends(miningQuarry.OwnerID, player.userID))
                    {
                        miningQuarry.SetOn(isOn);
                    }
                    continue;
                }

                if (!AnyOnlineFriends(miningQuarry.OwnerID))
                {
                    miningQuarry.SetOn(isOn);
                }
            }
        }

        private bool AnyOnlineFriends(ulong playerId)
        {
            foreach (var friend in BasePlayer.activePlayerList)
            {
                if (AreFriends(playerId, friend.userID))
                {
                    return true;
                }
            }

            return false;
        }

        #region AreFriends

        private bool AreFriends(ulong playerID, ulong friendID)
        {
            if (playerID == friendID)
            {
                return true;
            }
            if (configData.useTeam && SameTeam(friendID, playerID))
            {
                return true;
            }
            if (configData.useFriends && HasFriend(friendID, playerID))
            {
                return true;
            }
            if (configData.useClans && SameClan(friendID, playerID))
            {
                return true;
            }
            return false;
        }

        private bool SameTeam(ulong playerID, ulong friendID)
        {
            if (!RelationshipManager.TeamsEnabled())
            {
                return false;
            }
            var playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(playerID);
            if (playerTeam == null)
            {
                return false;
            }
            var friendTeam = RelationshipManager.ServerInstance.FindPlayersTeam(friendID);
            if (friendTeam == null)
            {
                return false;
            }
            return playerTeam == friendTeam;
        }

        private bool HasFriend(ulong playerID, ulong friendID)
        {
            if (Friends == null)
            {
                return false;
            }
            return (bool)Friends.Call("HasFriend", playerID, friendID);
        }

        private bool SameClan(ulong playerID, ulong friendID)
        {
            if (Clans == null)
            {
                return false;
            }
            //Clans
            var isMember = Clans.Call("IsClanMember", playerID.ToString(), friendID.ToString());
            if (isMember != null)
            {
                return (bool)isMember;
            }
            //Rust:IO Clans
            var playerClan = Clans.Call("GetClanOf", playerID);
            if (playerClan == null)
            {
                return false;
            }
            var friendClan = Clans.Call("GetClanOf", friendID);
            if (friendClan == null)
            {
                return false;
            }
            return (string)playerClan == (string)friendClan;
        }

        #endregion AreFriends

        #endregion Methods

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Use team")]
            public readonly bool useTeam = false;

            [JsonProperty(PropertyName = "Use clans")]
            public readonly bool useClans = false;

            [JsonProperty(PropertyName = "Use friends")]
            public readonly bool useFriends = false;

            [JsonProperty(PropertyName = "Prevent other players from turning the quarry on or off")]
            public readonly bool preventOther = false;

            [JsonProperty(PropertyName = "Automatically disable the delay of quarry (seconds)")]
            public readonly float offlineTime = 120f;

            [JsonProperty(PropertyName = "Quarry automatically starts after players are online")]
            public readonly bool autoStart = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(configData);
        }

        #endregion ConfigurationFile
    }
}

// --- End of file: OnlineQuarries.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/oil-rig-doors-fix ---
// --- Original File Path: O/OilRigDoorsFix/OilRigDoorsFix.cs ---

using System;
using System.Collections.Generic;
using Facepunch;

namespace Oxide.Plugins
{
    [Info("OilRigDoorsFix", "MON@H", "1.0.2")]
    [Description("Fix for always open doors on Oil Rigs")]
    public class OilRigDoorsFix : RustPlugin
    {
        private uint _prefabIDCrate;
        private readonly uint[] _prefabIDs = new uint[3];

        #region Initialization

        private void Init()
        {
            Unsubscribe(nameof(OnEntitySpawned));
        }

        private void OnServerInitialized()
        {
            uint id;
            id = StringPool.Get("assets/prefabs/deployable/chinooklockedcrate/codelockedhackablecrate_oilrig.prefab");
            if (id == 0)
            {
                PrintError("codelockedhackablecrate_oilrig.prefab is not found!");
                return;
            }
            _prefabIDCrate = id;

            id = StringPool.Get("assets/bundled/prefabs/static/door.hinged.security.green.prefab");
            if (id == 0)
            {
                PrintError("door.hinged.security.green.prefab is not found!");
                return;
            }
            _prefabIDs[0] = id;

            id = StringPool.Get("assets/bundled/prefabs/static/door.hinged.security.blue.prefab");
            if (id == 0)
            {
                PrintError("door.hinged.security.blue.prefab is not found!");
                return;
            }
            _prefabIDs[1] = id;

            id = StringPool.Get("assets/bundled/prefabs/static/door.hinged.security.red.prefab");
            if (id == 0)
            {
                PrintError("door.hinged.security.red.prefab is not found!");
                return;
            }
            _prefabIDs[2] = id;

            Subscribe(nameof(OnEntitySpawned));
        }

        #endregion Initialization

        #region Oxide Hooks

        private void OnEntitySpawned(HackableLockedCrate crate)
        {
            if (crate.prefabID != _prefabIDCrate)
            {
                return;
            }

            List<PressButton> pressButtons = Pool.GetList<PressButton>();
            List<Door> doors = Pool.GetList<Door>();
            Vis.Entities(crate.transform.position, 5f, doors);

            foreach (Door door in doors)
            {
                if (!door.IsOpen() || !_prefabIDs.Contains(door.prefabID))
                {
                    continue;
                }

                pressButtons.Clear();
                Vis.Entities(door.transform.position, 2f, pressButtons);
                foreach (PressButton pressButton in pressButtons)
                {
                    pressButton.SetFlag(BaseEntity.Flags.On, true, false, true);
                    pressButton.Invoke(new Action(pressButton.UnpowerTime), pressButton.pressPowerTime);
                    pressButton.SetFlag(BaseEntity.Flags.Reserved3, true, false, true);
                    pressButton.SendNetworkUpdateImmediate(false);
                    pressButton.MarkDirty();
                    pressButton.Invoke(new Action(pressButton.Unpress), pressButton.pressDuration);
                }
            }

            Pool.FreeList(ref doors);
            Pool.FreeList(ref pressButtons);
        }

        #endregion Oxide Hooks
    }
}

// --- End of file: OilRigDoorsFix.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/our-servers ---
// --- Original File Path: O/OurServers/OurServers.cs ---

using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Our Servers", "Hougan / rostov114", "0.0.8")] 
    [Description("Show information about other servers (with fetching current online)")]
    public class OurServers : RustPlugin 
    {
        #region Classes

        private class Server
        {
            [JsonProperty("Name of your server in interface")] 
            public string DisplayName;

            [JsonProperty("Description of your server in interface")] 
            public string Description;

            [JsonProperty("IP:Port of server (ex: 127.0.0.1:12000)")]
            public string IPAndPort;

            [JsonProperty("Interface width (increase it, if your description is very length)")]
            public int ServerWidth = 250;

            [JsonIgnore] 
            public int CurrentOnline; 

            [JsonIgnore] 
            public int MaxOnline;

            [JsonIgnore]
            public bool Status = false;

            public string IP()                      => IPAndPort.Split(':')[0];
            public int    Port()                    => int.Parse(IPAndPort.Split(':')[1]);
            public int    GetOnline()               => Mathf.Min(MaxOnline, CurrentOnline);
            public void   UpdateStatus(bool status) => Status = status;
        } 

        private class Configuration
        {
            [JsonProperty("Servers configure")]
            public List<Server> Servers = new List<Server>();

            [JsonProperty("Command to open interface")]
            public string Command = "servers";

            [JsonProperty("Use chat instead of UI")]
            public bool UseChat = false;

            [JsonProperty("Information update interval in seconds (should be > 30)")]
            public int Interval = 60;

            [JsonProperty("Which API to use? (Possible options: steampowered or battlemetrics) (Default: battlemetrics)")]
            public string API = "battlemetrics";

            [JsonProperty("Steampowered API key")]
            public string SteamWebApiKey = "!!! You can get it HERE > https://steamcommunity.com/dev/apikey < and you need to insert HERE !!!";

            public static Configuration Generate()
            {
                return new Configuration
                {
                    Servers = new List<Server>
                    {
                        new Server
                        {
                            DisplayName = "UMOD-SERVER #1 - PROCEDURAL",
                            Description = "Example server, with example description",
                            IPAndPort   = "8.8.8.8:12000",
                            ServerWidth = 250
                        },
                        new Server
                        {
                            DisplayName = "UMOD-SERVER #2 - BARREN",
                            Description = "Example server, with example description",
                            IPAndPort   = "1.1.1.1:13000"
                        }
                    }
                };
            }
        }

        public class BattlemetricsApiResponse
        {
            [JsonProperty("data")]
            public List<ServerData> data;

            public class ServerData
            {
                [JsonProperty("id")]
                public string id;

                [JsonProperty("type")]
                public string type;

                [JsonProperty("attributes")]
                public Attributes attributes;
                
                public class Attributes
                {
                    [JsonProperty("id")]
                    public string id;

                    [JsonProperty("name")]
                    public string name;

                    [JsonProperty("ip")]
                    public string ip;

                    [JsonProperty("port")]
                    public int port;

                    [JsonProperty("portQuery")]
                    public int portQuery;

                    [JsonProperty("players")]
                    public int players;

                    [JsonProperty("maxPlayers")]
                    public int maxPlayers;

                    [JsonProperty("status")]
                    public string status;
                }
            }
        }

        public class SteampoweredApi
        {
            [JsonProperty("response")]
            public Response response;

            public class Response
            {
                [JsonProperty("servers")]
                public List<ServerData> servers;

                public class ServerData
                {
                    [JsonProperty("addr")]
                    public string addr;

                    [JsonProperty("gameport")]
                    public int gameport;

                    [JsonProperty("steamid")]
                    public string steamid;

                    [JsonProperty("name")]
                    public string name;
                    
                    [JsonProperty("appid")]
                    public int appid;

                    [JsonProperty("gamedir")]
                    public string gamedir;

                    [JsonProperty("version")]
                    public string version;

                    [JsonProperty("product")]
                    public string product;

                    [JsonProperty("region")]
                    public int region;

                    [JsonProperty("players")]
                    public int players;

                    [JsonProperty("max_players")]
                    public int max_players;

                    [JsonProperty("bots")]
                    public int bots;

                    [JsonProperty("map")]
                    public string map;

                    [JsonProperty("secure")]
                    public bool secure;

                    [JsonProperty("dedicated")]
                    public bool dedicated;

                    [JsonProperty("os")]
                    public string os;

                    [JsonProperty("gametype")]
                    public string gametype;
                }
            }
        }

        #endregion

        #region Variables

        // Coroutines
        private Coroutine UpdateAction;

        // Configuration
        private Configuration Settings;
        private bool          Initialized;
        private bool          Broken;

        #endregion

        #region Initialization

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                Settings = Config.ReadObject<Configuration>();
                if (Settings?.Servers == null) LoadDefaultConfig();
                SaveConfig();

                if (Settings.API == "steampowered" && (Settings.SteamWebApiKey == null || Settings.SteamWebApiKey == string.Empty || Settings.SteamWebApiKey.Length != 32))
                {
                    PrintError("Steampowered API requires an Steam Web API key to work! Check your configuration!");
                    Broken = true;
                }
            }
            catch
            {
                PrintError("Error reading config, please check!");
                Broken = true;
            }
        }

        protected override void SaveConfig() => Config.WriteObject(Settings);
        protected override void LoadDefaultConfig()
        {
            Settings = Configuration.Generate();
            SaveConfig();
        }

        private void OnServerInitialized()
        {
            if (Broken) return;

            cmd.AddChatCommand(Settings.Command, this, nameof(CmdShowServers));
            if (Settings.Interval < 30)
            {
                PrintError($"Update interval should be bigger then 30 s!");
                Settings.Interval = 30;
            }

            UpdateAction = ServerMgr.Instance.StartCoroutine(UpdateOnline());
        }

        private void Unload()
        {
            if (UpdateAction != null)
                ServerMgr.Instance.StopCoroutine(UpdateAction);
        }

        #endregion

        #region Functions

        private IEnumerator UpdateOnline()
        {
            while (true)
            {
                foreach (var check in Settings.Servers)
                {
                    if (Settings.API == "steampowered")
                    {
                        string url = $"https://api.steampowered.com/IGameServersService/GetServerList/v1/?format=json&key={Settings.SteamWebApiKey}&filter=\\gameaddr\\{check.IP()}:{check.Port()}";
                        webrequest.Enqueue(url, "", (code, response) =>
                        {
                            switch (code)
                            {
                                case 200:
                                    try
                                    {
                                        SteampoweredApi data = JsonConvert.DeserializeObject<SteampoweredApi>(response);
                                        if (data.response.servers != null)
                                        {
                                            switch (data.response.servers.Count)
                                            {
                                                case 1:
                                                    SteampoweredApi.Response.ServerData serverData = data.response.servers.Last();
                                                    if (serverData.addr != $"{check.IP()}:{check.Port()}")
                                                    {
                                                        PrintError($"Steampowered API: The response from Steampowered does not match the IP or port of the expected server! (Request: {check.IP()}:{check.Port()}, Response: {serverData.addr})");
                                                    }
                                                    else
                                                    {
                                                        check.CurrentOnline = serverData.players;
                                                        check.MaxOnline = serverData.max_players;
                                                        check.UpdateStatus(true);

                                                        Initialized = true;
                                                    }
                                                    break;

                                                default:
                                                    PrintError($"Steampowered API: The number of results is different than expected! Contact the plugin developer! (Server: {check.IP()}:{check.Port()}, Count: {data.response.servers.Count})");
                                                    break;
                                            }
                                        }
                                        else
                                        {
                                            check.UpdateStatus(false);
                                        }
                                    }
                                    catch
                                    {
                                        PrintError($"Steampowered API: Error parsing response from server. Perhaps the format has changed. Contact the plugin developer!");
                                    }
                                    break;

                                case 403:
                                    PrintError($"Steampowered API: Invalid Steam Web API key! Check it with your key indicated on the page: https://steamcommunity.com/dev/apikey");
                                    break;

                                default:
                                    PrintError($"Steampowered API HTTP CODE: {code}");
                                    break;
                            }
                        }, this);
                    }
                    else
                    {
                        string url = $"https://api.battlemetrics.com/servers?filter[search]=\"{check.IP()}:{check.Port()}\"";
                        webrequest.Enqueue(url, "", (code, response) =>
                        {
                            if (code == 200)
                            {
                                try
                                {
                                    BattlemetricsApiResponse apiResponse = JsonConvert.DeserializeObject<BattlemetricsApiResponse>(response);
                                    switch (apiResponse.data.Count)
                                    {
                                        case 1:
                                            BattlemetricsApiResponse.ServerData serverData = apiResponse.data.Last();
                                            if (check.IP() != serverData.attributes.ip || check.Port() != serverData.attributes.port)
                                            {
                                                PrintError($"Battlemetrics API: The response from Battlemetrics does not match the IP or port of the expected server! (Request: {check.IP()}:{check.Port()}, Response: {serverData.attributes.ip}:{serverData.attributes.port})");
                                            }
                                            else
                                            {
                                                check.CurrentOnline = serverData.attributes.players;
                                                check.MaxOnline = serverData.attributes.maxPlayers;
                                                check.UpdateStatus((serverData.attributes.status == "online"));

                                                Initialized = true;
                                            }
                                            break;

                                        case 0:
                                            PrintError($"Battlemetrics API: Server '{check.IP()}:{check.Port()}' not found! Perhaps he has not yet been interviewed. Wait a while.");
                                            break;

                                        default:
                                            PrintError($"Battlemetrics API: The number of results is different than expected! Contact the plugin developer! (Server: {check.IP()}:{check.Port()}, Count: {apiResponse.data.Count})");
                                            break;
                                    }
                                }
                                catch
                                {
                                    PrintError($"Battlemetrics API: Error parsing response from server. Perhaps the format has changed. Contact the plugin developer!");
                                }
                            }
                            else
                            {
                                PrintError($"Battlemetrics API HTTP CODE: {code}");
                            }
                        }, this);
                    }

                    yield return new WaitForSeconds(1f);
                }

                yield return new WaitForSeconds(Settings.Interval);
            }
        }

        #endregion 

        #region Commands

        [ConsoleCommand("UI_OurServersHandler")]
        private void CmdConsoleHandler(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null || !args.HasArgs(1)) return;

            switch (args.Args[0].ToLower())
            {
                case "show":
                {
                    if (!args.HasArgs(2)) return;

                    int index = 0;
                    if (!int.TryParse(args.Args[1], out index) || Settings.Servers.ElementAtOrDefault(index) == null) return;
                    UI_DrawInterface(player, index);
                    break;
                }
                case "hide":
                {
                    UI_DrawInterface(player, -2);
                    break;
                }
            }
        }

        private void CmdShowServers(BasePlayer player, string command, string[] args)
        {
            if (!Initialized) return;

            if (Settings.UseChat)
            {
                string resultMessage = "";
                foreach (var server in Settings.Servers)
                    resultMessage += $"{server.DisplayName} (IP: {server.IPAndPort}) - " + ((server.Status) ? $"{server.GetOnline()}/{server.MaxOnline} players online" : "OFFLINE") + "\n\n";
                
                player.ChatMessage(resultMessage); 
            }
            else
            {
                UI_DrawInterface(player);
            }
        }

        #endregion

        #region Interface

        private const string Layer = "UI_OurServersLayer";

        private void UI_DrawInterface(BasePlayer player, int index = -1)
        {
            CuiHelper.DestroyUi(player, Layer);
            CuiElementContainer container = new CuiElementContainer();

            float  fadeSpeed     = 1f;
            Server choosedServer = null;
            if (index >= 0)
            {
                fadeSpeed     = 0f;
                choosedServer = Settings.Servers.ElementAtOrDefault(index);
            }
            else if (index == -2)
            {
                fadeSpeed = 0;
            }

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0"},
                Image         = {FadeIn    = fadeSpeed, Color = "0 0 0 0.7"}
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0"},
                Button        = {Color     = "0 0 0 0", Close = Layer},
                Text          = {Text      = ""}
            }, Layer);

            float panelWidth  = 80;
            var   list        = Settings.Servers.Where(p => p.CurrentOnline > -1).ToList();
            float topPosition = list.Count / 2f * panelWidth + (list.Count - 1) / 2f * 15;

            float startPosition = 0.5f;
            if (list.Count >= 6)
            {
                startPosition = 0.25f;
                topPosition /= 2f;
            }

            foreach (var check in list)
            {
                float leftPosition = check.ServerWidth * -1 - 83f;
                if (list.IndexOf(check) == list.Count - 1 && startPosition == 0.25f)
                    startPosition = 0.5f;

                container.Add(new CuiPanel
                {
                    RectTransform = {AnchorMin = $"{startPosition} 0.5", AnchorMax = $"{startPosition} {0.5f}", OffsetMin = $"{leftPosition} {topPosition - panelWidth}", OffsetMax = $"{check.ServerWidth} {topPosition}"},
                    Image         = {FadeIn    = fadeSpeed, Color     = "1 1 1 0.03008521"}
                }, Layer, check.IPAndPort);

                if (check != choosedServer)
                {
                    container.Add(new CuiPanel
                    {
                        RectTransform = {AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "3 0", OffsetMax = "83 0"},
                        Image         = {FadeIn    = fadeSpeed, Color = "1 1 1 0.03008521"}
                    }, check.IPAndPort, check.IPAndPort + ".Help");

                    container.Add(new CuiButton
                    {
                        RectTransform = {AnchorMin = "0 0", AnchorMax  = "1 1", OffsetMin                                 = "10 10", OffsetMax = "-10 -10"},
                        Button        = {Color     = "1 1 1 0", Sprite = "assets/icons/circle_closed_toedge.png", Command = $"UI_OurServersHandler show {Settings.Servers.IndexOf(check)}"},
                        Text          = {FadeIn    = fadeSpeed, Text   = "i", Align                                       = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 50, Color = "1 1 1 0.7"}
                    }, check.IPAndPort + ".Help");

                    container.Add(new CuiLabel
                    {
                        RectTransform = {AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin        = "15 -45", OffsetMax                  = "-15 -10"},
                        Text          = {FadeIn    = fadeSpeed, Text  = check.DisplayName, Font = "robotocondensed-bold.ttf", FontSize = 20, Align = TextAnchor.LowerLeft}
                    }, check.IPAndPort);

                    container.Add(new CuiLabel
                    {
                        RectTransform = {AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin      = "15 -25", OffsetMax                     = "-15 -5"},
                        Text          = {FadeIn    = fadeSpeed, Text  = check.IPAndPort, Font = "robotocondensed-regular.ttf", FontSize = 16, Color = "1 1 1 0.6", Align = TextAnchor.MiddleLeft}
                    }, check.IPAndPort);

                    container.Add(new CuiLabel
                    {
                        RectTransform = {AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin                                 = "15 -45", OffsetMax                     = "-15 -5"},
                        Text          = {FadeIn    = fadeSpeed, Text  = ((check.Status) ? $"{check.GetOnline()} / {check.MaxOnline}" : "OFFLINE"), Font = "robotocondensed-regular.ttf", FontSize = 32, Color = "1 1 1 0.4", Align = TextAnchor.MiddleRight}
                    }, check.IPAndPort);

                    container.Add(new CuiPanel
                    {
                        RectTransform = {AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "15 10", OffsetMax = "-15 30"},
                        Image         = {FadeIn    = fadeSpeed, Color = ((check.Status) ? "1 1 1 0.4" : "1 0.2 0 0.4")}
                    }, check.IPAndPort, check.IPAndPort + ".Online");

                    container.Add(new CuiPanel
                    {
                        RectTransform = {AnchorMin = "0 0", AnchorMax = $"{(float) check.GetOnline() / check.MaxOnline} 1", OffsetMin = "0 0", OffsetMax = "0 0"},
                        Image         = {FadeIn    = fadeSpeed, Color = "0.6 0.9 0.6 0.8"}
                    }, check.IPAndPort + ".Online");
                }
                else 
                {
                    container.Add(new CuiPanel
                    {
                        RectTransform = {AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "3 0", OffsetMax = "83 0"},
                        Image         = {FadeIn    = fadeSpeed, Color = "1 1 1 0.03008521"}
                    }, check.IPAndPort, check.IPAndPort + ".Help");

                    container.Add(new CuiButton
                    {
                        RectTransform = {AnchorMin = "0 0", AnchorMax  = "1 1", OffsetMin                                 = "10 10", OffsetMax = "-10 -10"},
                        Button        = {Color     = "1 1 1 0", Sprite = "assets/icons/circle_closed_toedge.png", Command = $"UI_OurServersHandler hide"},
                        Text          = {FadeIn    = fadeSpeed, Text   = "X", Align                                       = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 50, Color = "1 1 1 0.7"}
                    }, check.IPAndPort + ".Help");

                    container.Add(new CuiLabel
                    {
                        RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin        = "15 15", OffsetMax                      = "-15 -15"},
                        Text          = {FadeIn    = fadeSpeed, Text  = check.Description, Font = "robotocondensed-regular.ttf", FontSize = 16, Color = "1 1 1 1", Align = TextAnchor.MiddleCenter}
                    }, check.IPAndPort);
                }

                if (startPosition < 0.5f)
                {
                    startPosition = 0.75f;
                }
                else if (startPosition > 0.5f)
                {
                    startPosition = 0.25f;
                    topPosition -= panelWidth + 15;
                }
                else
                {
                    topPosition -= panelWidth + 15;
                }
            }

            CuiHelper.AddUi(player, container);
        }

        #endregion
    }
}

// --- End of file: OurServers.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/orange-lift ---
// --- Original File Path: O/OrangeLift/OrangeLift.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Orange Lift", "Orange", "1.0.2")]
    [Description("Allows you to stop lifts at any level")]
    public class OrangeLift : RustPlugin
    {
        #region Oxide Hooks

        private void Init()
        {
            cmd.AddChatCommand("lift", this, nameof(cmdControlChat));
            cmd.AddChatCommand("lifts", this, nameof(cmdControlChat));
            //cmd.AddConsoleCommand("lifts.control", this, nameof(cmdControlConsole));
        }

        private void OnServerInitialized()
        {
            LoadLifts();
        }

        private void Unload()
        {
            DestroyLifts();
        }

        private object OnLiftUse(ProceduralLift entity, BasePlayer player)
        {
            var obj = entity.GetComponent<LiftExtended>();
            if (obj != null)
            {
                SendMessage(player, MessageType.OnLiftUse);
                obj.SetLastPassenger(player);
                obj.MoveToNextFloor();
                return true;
            }

            return null;
        }

        private void OnEntitySpawned(ProceduralLift entity)
        {
            var def = config.lifts.FirstOrDefault(x => x.Match(entity));
            if (def != null && def.floors?.Count > 0)
            {
                var lift = entity.gameObject.AddComponent<LiftExtended>();
                lift.definition = def;
            }
        }

        #endregion

        #region Commands

        private void cmdControlChat(BasePlayer player, string commands, string[] args)
        {
            if (args == null || args.Length < 1 || player.IsAdmin == false)
            {
                SendMessage(player, MessageType.Usage);
                return;
            }

            var action = args[0].ToLower();
            var lift = GetClosestLift(player);
            var component = lift?.GetComponent<LiftExtended>();
            var definition = component?.definition;
            var y = player.transform.position.y + 3.5f;

            switch (action)
            {
                default:
                    SendMessage(player, MessageType.Usage);
                    return;

                case "add":
                    if (lift == null)
                    {
                        SendMessage(player, MessageType.NoLift);
                        return;
                    }

                    if (definition != null)
                    {
                        SendMessage(player, MessageType.LiftNearby, "{name}", definition.name);
                        return;
                    }

                    definition = new LiftDefinition();
                    var position = lift.transform.position;
                    definition.position = position;
                    config.lifts.Add(definition);
                    component = lift.gameObject.AddComponent<LiftExtended>();
                    component.definition = definition;
                    SendMessage(player, MessageType.AddedLift, "{position}", definition.position);
                    break;

                case "remove":
                    if (definition == null)
                    {
                        SendMessage(player, MessageType.NoLift);
                        return;
                    }

                    config.lifts.Remove(definition);
                    UnityEngine.Object.Destroy(component);
                    SendMessage(player, MessageType.RemovedLift, "{position}", definition.position, "{name}",
                        definition.name);
                    break;

                case "addfloor":
                    if (definition == null)
                    {
                        SendMessage(player, MessageType.NoLift);
                        return;
                    }

                    y -= definition.position.y;
                    definition.floors.Add(y);
                    SendMessage(player, MessageType.AddedFloor, "{position}", $"{y:0.0}", "{name}", definition.name);
                    break;

                case "removefloor":
                    if (definition == null)
                    {
                        SendMessage(player, MessageType.NoLift);
                        return;
                    }

                    y -= definition.position.y;
                    definition.floors.RemoveAll(x => Math.Abs(x - y) < 1f);
                    SendMessage(player, MessageType.RemovedFloor, "{position}", $"{y:0.0}", "{name}", definition.name);
                    break;
            }

            SaveConfig();
        }

        private void cmdControlConsole(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length < 2)
            {
                return;
            }

            var player = arg.Player();
            var levelStr = arg.Args[0];
            var levelInt = 0;
            var idStr = arg.Args[1];
            var id = 0u;

            if (uint.TryParse(idStr, out id) == false || int.TryParse(levelStr, out levelInt))
            {
                return;
            }

            var entity = BaseNetworkable.serverEntities.Find(id);
            if (entity != null && player != null &&  Vector3.Distance(player.transform.position, entity.transform.position) < 3f)
            {
                var obj = entity.GetComponent<LiftExtended>();
                if (obj != null)
                {
                    obj.SelectFloor(levelInt);
                    player.ConsoleMessage($"Selecting floor {levelInt} for {id}");
                }
            }
        }

        #endregion

        #region Core

        private void LoadLifts()
        {
            timer.Once(1f, () =>
            {
                foreach (var entity in UnityEngine.Object.FindObjectsOfType<ProceduralLift>())
                {
                    OnEntitySpawned(entity);
                }
            });
        }

        private void DestroyLifts()
        {
            foreach (var obj in UnityEngine.Object.FindObjectsOfType<LiftExtended>())
            {
                UnityEngine.Object.Destroy(obj);
            }
        }

        private static ProceduralLift GetClosestLift(BasePlayer player)
        {
            var lifts = new List<ProceduralLift>();
            Vis.Entities(player.transform.position, 50f, lifts);
            return lifts.FirstOrDefault();
        }

        #endregion

        #region Configuration | 24.05.2020

        private static ConfigData config = new ConfigData();

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Lifts")] public List<LiftDefinition> lifts = new List<LiftDefinition>();
        }

        private class LiftDefinition
        {
            [JsonProperty(PropertyName = "Name")] public string name = "Lift";

            [JsonProperty(PropertyName = "Position")]
            public Vector3 position;

            [JsonProperty(PropertyName = "Return delay time")]
            public float returnDelay = 10;

            [JsonProperty(PropertyName = "Floors")]
            public List<float> floors = new List<float>();

            public bool Match(BaseEntity entity)
            {
                return Vector3.Distance(entity.transform.position, position) < 10f;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                for (var i = 0; i < 3; i++)
                {
                    PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                }

                LoadDefaultConfig();
                return;
            }

            ValidateConfig();
            SaveConfig();
        }

        private void ValidateConfig()
        {
            if (ConVar.Server.hostname.Contains("[DEBUG]") == true)
            {
                PrintWarning("Using default configuration on debug server");
            }
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Language | 24.05.2020

        private Dictionary<object, string> langMessages = new Dictionary<object, string>
        {
            {MessageType.OnLiftUse, "Thanks for using smart lifts!"},
            {
                MessageType.Usage, "Usage:\n" +
                                   "/lift add - add nearby lift as extended\n" +
                                   "/lift remove - remove nearby lift as extended\n" +
                                   "/lift addfloor - add floor to nearby lift\n" +
                                   "/lift removefloor - remove floor at nearby lift"
            },
            {MessageType.NoLift, "Can't find extended lift nearby!"},
            {MessageType.AddedLift, "Added extended lift on position {position}"},
            {MessageType.RemovedLift, "Removed extended lift on position {position} ({name})"},
            {MessageType.AddedFloor, "Added floor at level {position} for {name}"},
            {MessageType.RemovedFloor, "Removed floor at level {position} for {name}"},
            {MessageType.LiftNearby, "There are already extended lift nearby! ({name})"},
        };

        private enum MessageType
        {
            OnLiftUse,
            Usage,
            NoLift,
            AddedLift,
            RemovedLift,
            AddedFloor,
            RemovedFloor,
            LiftNearby,
        }

        protected override void LoadDefaultMessages()
        {
            var dictionary = new Dictionary<string, string>();
            foreach (var pair in langMessages)
            {
                var key = pair.Key.ToString();
                var value = pair.Value;
                dictionary.TryAdd(key, value);
            }

            lang.RegisterMessages(dictionary, this);
        }

        private string GetMessage(MessageType key, string playerID = null, params object[] args)
        {
            var keyString = key.ToString();
            var message = lang.GetMessage(keyString, this, playerID);
            if (message == keyString)
            {
                return $"{keyString} is not defined in lang!";
            }

            var organized = OrganizeArgs(args);
            message = ReplaceArgs(message, organized);
            return message;
        }

        private static Dictionary<string, object> OrganizeArgs(object[] args)
        {
            var dic = new Dictionary<string, object>();
            for (var i = 0; i < args.Length; i += 2)
            {
                var value = args[i].ToString();
                var nextValue = i + 1 < args.Length ? args[i + 1] : null;
                dic.TryAdd(value, nextValue);
            }

            return dic;
        }

        private static string ReplaceArgs(string message, Dictionary<string, object> args)
        {
            if (args == null || args.Count < 1)
            {
                return message;
            }

            foreach (var pair in args)
            {
                var s0 = "{" + pair.Key + "}";
                var s1 = pair.Key;
                var s2 = pair.Value != null ? pair.Value.ToString() : "null";
                message = message.Replace(s0, s2, StringComparison.InvariantCultureIgnoreCase);
                message = message.Replace(s1, s2, StringComparison.InvariantCultureIgnoreCase);
            }

            return message;
        }

        private void SendMessage(object receiver, MessageType key, params object[] args)
        {
            var userID = (receiver as BasePlayer)?.UserIDString;
            var message = GetMessage(key, userID, args);
            SendMessage(receiver, message);
        }

        private void SendMessage(object receiver, string message)
        {
            if (receiver == null)
            {
                Puts(message);
                return;
            }

            var console = receiver as ConsoleSystem.Arg;
            if (console != null)
            {
                SendReply(console, message);
                return;
            }

            var player = receiver as BasePlayer;
            if (player != null)
            {
                player.ChatMessage(message);
                return;
            }
        }

        #endregion

        #region Scripts

        private class LiftExtended : MonoBehaviour
        {
            public ProceduralLift entity;
            public int lastIndex = -1;
            public Vector3 movePosition;
            public LiftDefinition definition;
            public int maxFloors => definition.floors.Count;
            public BasePlayer lastPassenger;
            public bool paused = true;

            private void Awake()
            {
                entity = GetComponent<ProceduralLift>();
                OnDestroy();
            }

            private void OnDestroy()
            {
                if (definition != null)
                {
                    entity.transform.position = definition.position;
                    entity.SetFlag(BaseEntity.Flags.Busy, false);
                    entity.SendNetworkUpdateImmediate();
                }
            }

            public void SetLastPassenger(BasePlayer player)
            {
                lastPassenger = player;
            }

            public void MoveToNextFloor()
            {
                SelectFloor(++lastIndex);
            }

            public void SelectFloor(int floor)
            {
                if (paused == false)
                {
                    return;
                }

                if (floor >= maxFloors || floor < 0)
                {
                    floor = 0;
                    lastIndex = -1;
                    movePosition = definition.position;
                }
                else
                {
                    movePosition = GetFloor(floor);
                    lastIndex = floor;
                }

                OnStartedMoving();
            }

            public Vector3 GetFloor(int index)
            {
                return definition.position + new Vector3(0, definition.floors[index], 0);
            }

            public void MoveToStart()
            {
                // TODO: Add check for players inside
                SelectFloor(-1);
            }

            public void Update()
            {
                if (paused == true)
                {
                    return;
                }

                if (entity.transform.position == movePosition)
                {
                    OnFinishedMoving();
                    return;
                }

                entity.transform.position =
                    Vector3.MoveTowards(entity.transform.position, movePosition, 1 * Time.deltaTime);
                entity.SendNetworkUpdateImmediate();
            }

            private void OnStartedMoving()
            {
                entity.SetFlag(BaseEntity.Flags.Busy, true);
                entity.SendNetworkUpdate();

                if (lastPassenger != null && lastPassenger.IsAdmin)
                {
                    lastPassenger.ConsoleMessage(
                        $"Moving to index = {lastIndex}, floor = {lastIndex + 1}, y = {movePosition.y}");
                }

                paused = false;
            }

            private void OnFinishedMoving()
            {
                paused = true;
                entity.SetFlag(BaseEntity.Flags.Busy, false);
                entity.SendNetworkUpdate();
                if (movePosition != definition.position && definition.returnDelay > 0)
                {
                    CancelInvoke(nameof(MoveToStart));
                    Invoke(nameof(MoveToStart), definition.returnDelay);
                }
            }
        }

        #endregion
    }
}

// --- End of file: OrangeLift.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/oil-crate ---
// --- Original File Path: O/OilCrate/OilCrate.cs ---

﻿using Facepunch;
using System;
using System.Collections.Generic;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Oil Crate", "Default", "0.7.5")]
    [Description("Brings the pump jack back into the game")]
    class OilCrate : RustPlugin
    {
        private const string oilCrateAllow = "oilcrate.allow";
        private readonly List<Timer> timers = new List<Timer>();
        private readonly List<string> duplicate = new List<string>();
        private bool quarryLiquid;
        private bool pumpjackSolid;
        private bool effectStaticPumpjacks;
        private bool missingPermission;
        private float oilCrateChance;
        private float oilCrateDespawn;
        private bool dryOnly;
        private float oilGatherWorkNeededMin;
        private float oilGatherWorkNeededMax;
        private bool dropFreePumpjack;
        private bool craftViaPickaxe;
        private Dictionary<string, object> pumpJackResources = new Dictionary<string, object>();

        private Dictionary<string, object> pumpJackResourcesDefault()
        {
            return new Dictionary<string, object>()
            {
                {"gears", 15},
                {"metal.fragments", 1750},
                {"wood", 10000},
            };
        }

        private void LoadVariables()
        {
            quarryLiquid = GetConfig("1. Settings", "1. Quarry can gather oil", false);
            pumpjackSolid = GetConfig("1. Settings", "2. Pump jack can gather ores", false);
            effectStaticPumpjacks = GetConfig("1. Settings", "3. Change gather rate of static pump jacks (at monuments)", true);
            missingPermission = GetConfig("1. Settings", "4. Show 'missing permission' message", true);
            oilCrateChance = GetConfig("2. Oil crate", "1. Chance in % (0.0 - 100.0)", 5f);
            oilCrateDespawn = GetConfig("2. Oil crate", "2. Despawn timer in seconds", 300f);
            dryOnly = GetConfig("2. Oil crate", "3. Only on dry biome", true);
            oilGatherWorkNeededMin = 10 / GetConfig("3. Crude oil gather rate", "1. Minimum crude oil per low grade fuel", 0.525f);
            oilGatherWorkNeededMax = 10 / GetConfig("3. Crude oil gather rate", "2. Maximum crude oil per low grade fuel", 0.725f);
            dropFreePumpjack = GetConfig("4. Get pump jack", "1. Drop a free pump jack out of a oil crate", false);
            craftViaPickaxe = GetConfig("4. Get pump jack", "2. Craft via hit with a pickaxe", true);
            pumpJackResources = GetConfig("4. Get pump jack", "3. Resources to craft a pump jack", pumpJackResourcesDefault());
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            LoadVariables();
        }
        private void Init()
        {
            permission.RegisterPermission(oilCrateAllow, this);
            LoadVariables();
            if (oilCrateChance < 0)
            {
                oilCrateChance = 0;
            }

            if (oilCrateChance > 100)
            {
                oilCrateChance = 100;
            }
        }
        /*private void Unload()
        {
            foreach (Timer time in timers)
            {
                time.Destroy();
            }
        }*/
        private void OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit resourceDeposit)
        {
            if (Random.Range(0f, 100f) >= oilCrateChance)
            {
                return;
            }

            if (!pumpjackSolid)
            {
                resourceDeposit._resources.Clear();
            }



            resourceDeposit.Add(ItemManager.FindItemDefinition("crude.oil"), 1f, 50000, Random.Range(oilGatherWorkNeededMin, oilGatherWorkNeededMax), ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, false);
        }
        private void OnSurveyGather(SurveyCharge survey, Item item)
        {
            if (item.info.name != "crude_oil.item")
            {
                return;
            }

            Vector3 pos = survey.transform.position;
            string posID = $"{pos.x}{pos.y}{pos.z}";
            if (duplicate.Contains(posID))
            {
                timer.In(1f, () =>
                {
                    duplicate.Remove(posID);
                });
                return;
            }
            if (!IsAllowed((BasePlayer)survey.creatorEntity, true))
            {
                item.Remove();
                DeSpawn("survey_crater", pos, 0f);
                if (missingPermission)
                {
                    SendReply((BasePlayer)survey.creatorEntity, lang.GetMessage("NoPriv", this, survey.creatorEntity.ToString()));
                }

                return;
            }
            if (dryOnly && TerrainMeta.BiomeMap.GetBiome(pos, TerrainBiome.ARID) < 0.5f)
            {
                item.Remove();
                DeSpawn("survey_crater", pos, 0f);
                if (missingPermission)
                {
                    SendReply((BasePlayer)survey.creatorEntity, lang.GetMessage("DryOnly", this, survey.creatorEntity.ToString()));
                }

                return;
            }
            if (!quarryLiquid)
            {
                DeSpawn("survey_crater.prefab", pos, 0f);
            }

            Spawn("assets/prefabs/tools/surveycharge/survey_crater_oil.prefab", pos);
            DeSpawn("survey_crater", pos, oilCrateDespawn);
            duplicate.Add(posID);
            if (!dropFreePumpjack)
            {
                return;
            }

            Item pumpJack = ItemManager.CreateByName("mining.pumpjack", 1);
            pumpJack.Drop(pos + new Vector3(.5f, .5f), Vector3.zero, Quaternion.AngleAxis(0, Vector3.left));
        }
        private void OnEntitySpawned(BaseNetworkable entity)
        {
            MiningQuarry quarry = entity as MiningQuarry;
            if (quarry == null)
            {
                return;
            }

            if (!quarry.ShortPrefabName.Contains("pumpjack.static"))
            {
                quarry.canExtractSolid = true;
            }

            if (entity.ShortPrefabName.Contains("mining.quarry"))
            {
                quarry.canExtractLiquid = quarryLiquid;
            }

            if (quarry.ShortPrefabName.Contains("pumpjack.static") && effectStaticPumpjacks)
            {
                MiningQuarry[] quarries = UnityEngine.Object.FindObjectsOfType<MiningQuarry>();
                quarry._linkedDeposit._resources.Clear();
                quarry._linkedDeposit.Add(ItemManager.FindItemDefinition("crude.oil"), 1f, 50000, Random.Range(oilGatherWorkNeededMin, oilGatherWorkNeededMax), ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, true);
                quarry.SendNetworkUpdateImmediate();
            }
        }
        private void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if (!craftViaPickaxe)
            {
                return;
            }

            SurveyCrater oilCrate = info?.HitEntity as SurveyCrater;
            if (oilCrate == null || oilCrate.ShortPrefabName != "survey_crater_oil")
            {
                return;
            }

            Item item = info.Weapon?.GetItem();
            if (item == null || !item.info.name.Contains("pickaxe"))
            {
                return;
            }

            Dictionary<int, int> toTake = new Dictionary<int, int>();
            foreach (KeyValuePair<string, object> resourcePair in pumpJackResources)
            {
                ItemDefinition resource = ItemManager.FindItemDefinition(resourcePair.Key);
                int existingAmount = attacker.inventory.GetAmount(resource.itemid);
                if (existingAmount < (int)resourcePair.Value)
                {
                    SendReply(attacker, lang.GetMessage("NotEnough", this, attacker.UserIDString), resource.displayName.english.ToLower());
                    return;
                }
                toTake.Add(resource.itemid, (int)resourcePair.Value);
            }
            foreach (KeyValuePair<int, int> take in toTake)
            {
                attacker.inventory.Take(null, take.Key, take.Value);
            }

            Item pumpJack = ItemManager.CreateByName("mining.pumpjack", 1);
            pumpJack.Drop(oilCrate.transform.position + new Vector3(.5f, .5f), Vector3.zero, Quaternion.AngleAxis(0, Vector3.left));
        }

        [ConsoleCommand("oilcrate")]
        private void ccmdOilCrate(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Player() == null)
            {
                return;
            }

            cmdOilCrate(arg.Player(), string.Empty, arg.Args);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Help"] = "You can use the following commands:\n- regenerate | to <color=yellow>regenerate</color> each crude oil source\n- refill | to <color=yellow>refill</color> each pump jack\n- clear | to <color=red>remove</color> crude oil out of every source. This cannot be undone\n- destroy | similar use to clear, but only removes out of empty ones.",
                ["QuarryUpdate"] = "The gather rate for crude oil in each pump jack and quarry was successfully updated.",
                ["PumpUpdate"] = "The gather rate for crude oil in each pump jack was successfully updated.",
                ["QuarryRemove"] = "The crude oil of each pump jack and quarry was successfully removed.",
                ["PumpAdd"] = "The crude oil was successfully added to every pump jack.",
                ["NotAllowed"] = "You're not allowed to use this command.\nIf you believe this is an error, please contact the server admin.",
                ["QuarryDestroy"] = "The crude oil of each pump jack and quarry was successfully removed. And blanks were destroyed.",
                ["PumpDestroy"] = "The crude oil of each pump jack was successfully removed. And blanks were destroyed.",
                ["Error"] = "Syntax error: /oilcrate {0}",
                ["PumpRemove"] = "The crude oil of each pump jack was successfully removed.",
                ["NotEnough"] = "You can't gather the pump jack. You don't have enough {0}.",
                ["DryOnly"] = "You can only find oil in the southern desert",
                ["NoPriv"] = "You don't have the privileges to perform an oil drilling",
                //[""] = "",
            }, this);
        }


        [ChatCommand("oilcrate")]
        private void cmdOilCrate(BasePlayer player, string command, string[] args)
        {
            if (player != null && !IsAllowed(player))
            {
                SendReply(player, lang.GetMessage("NotAllowed", this, player.UserIDString));
                return;
            }
            if (args == null || args.Length <= 0 || args.Length > 2)
            {

                SendReply(player, lang.GetMessage("Help", this, player.UserIDString));
                return;
            }
            switch (args[0].ToLower())
            {
                case "regenerate":
                    RefreshQuarries("regenerate");
                    if (player == null)
                    {
                        if (quarryLiquid)
                        {
                            Puts("The gather rate crude oil in each pump jack and quarry was successfully updated.");
                        }
                        else
                        {
                            Puts("The gather rate crude oil in each pump jack was successfully updated.");
                        }
                    }
                    if (quarryLiquid)
                    {
                        SendReply(player, lang.GetMessage("QuarryUpdate", this, player.UserIDString));
                    }
                    else
                    {
                        SendReply(player, lang.GetMessage("PumpUpdate", this, player.UserIDString));
                    }

                    break;
                case "refill":
                    RefreshQuarries("refill");
                    if (player == null)
                    {
                        Puts("The crude oil was successfully added to each pump jack.");
                    }

                    SendReply(player, lang.GetMessage("PumpAdd", this, player.UserIDString));
                    break;
                case "clear":
                    RefreshQuarries("clear");
                    if (player == null)
                    {
                        if (quarryLiquid)
                        {
                            Puts("The crude oil of each pump jack and quarry was successfully removed.");
                        }
                        else
                        {
                            Puts("The crude oil of each pump jack was successfully removed.");
                        }
                    }
                    if (quarryLiquid)
                    {
                        SendReply(player, lang.GetMessage("QuarryRemove", this, player.UserIDString));
                    }
                    else
                    {
                        SendReply(player, lang.GetMessage("PumpRemove", this, player.UserIDString));
                    }

                    break;
                case "destroy":
                    RefreshQuarries("destroy");
                    if (player == null)
                    {
                        if (quarryLiquid)
                        {
                            Puts("The crude oil of each pump jack and quarry was successfully removed. And blanks were destroyed.");
                        }
                        else
                        {
                            Puts("The crude oil of each pump jack was successfully removed. And blanks were destroyed.");
                        }
                    }
                    if (quarryLiquid)
                    {
                        SendReply(player, lang.GetMessage("QuarryDestroy", this, player.UserIDString));
                    }
                    else
                    {
                        SendReply(player, lang.GetMessage("PumpDestroy", this, player.UserIDString));
                    }

                    break;
                default:
                    SendReply(player, lang.GetMessage("Error", this, player.UserIDString), args[0]);
                    break;
            }
        }

        private void RefreshQuarries(string todo)
        {
            MiningQuarry[] quarries = UnityEngine.Object.FindObjectsOfType<MiningQuarry>();
            foreach (MiningQuarry quarry in quarries)
            {
                ResourceDepositManager.ResourceDeposit depo = quarry._linkedDeposit;
                switch (todo)
                {
                    case "regenerate":
                        if (quarry.ShortPrefabName == "pumpjack-static")
                        {
                            depo._resources.Clear();
                            depo.Add(ItemManager.FindItemDefinition("crude.oil"), 1f, 50000, Random.Range(oilGatherWorkNeededMin, oilGatherWorkNeededMax), ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, true);
                            quarry.SendNetworkUpdateImmediate();
                            continue;
                        }
                        if (quarry.ShortPrefabName == "mining_quarry")
                        {
                            quarry.canExtractLiquid = quarryLiquid;
                        }

                        if (quarry.ShortPrefabName.Contains("mining_quarry") && !quarryLiquid)
                        {
                            continue;
                        }

                        foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in depo._resources)
                        {
                            if (resource.type.transform.name != "crude_oil.item")
                            {
                                continue;
                            }

                            depo._resources.Remove(resource);
                            depo.Add(ItemManager.FindItemDefinition("crude.oil"), 1f, 50000, Random.Range(oilGatherWorkNeededMin, oilGatherWorkNeededMax), ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, true);
                            quarry.SendNetworkUpdateImmediate();
                            break;
                        }
                        continue;
                    case "refill":
                        if (quarry.ShortPrefabName == "mining_quarry")
                        {
                            continue;
                        }

                        depo._resources.Clear();
                        depo.Add(ItemManager.FindItemDefinition("crude.oil"), 1f, 50000, Random.Range(oilGatherWorkNeededMin, oilGatherWorkNeededMax), ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, true);
                        quarry.SendNetworkUpdateImmediate();
                        continue;
                    case "clear":
                        if (quarry.ShortPrefabName == "mining_quarry")
                        {
                            quarry.canExtractLiquid = false;
                        }

                        foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in depo._resources)
                        {
                            if (resource.type.transform.name != "crude_oil.item")
                            {
                                continue;
                            }

                            depo._resources.Remove(resource);
                            quarry.SendNetworkUpdateImmediate();
                            break;
                        }
                        continue;
                    case "destroy":
                        if (quarry.ShortPrefabName == "mining_quarry")
                        {
                            quarry.canExtractLiquid = false;
                        }

                        foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in depo._resources)
                        {
                            if (resource.type.transform.name != "crude_oil.item")
                            {
                                continue;
                            }

                            depo._resources.Remove(resource);
                            quarry.SendNetworkUpdateImmediate();
                        }
                        if (depo._resources.Count <= 0)
                        {
                            quarry.KillMessage();
                        }

                        continue;
                }
            }
        }

        private void Spawn(string prefab, Vector3 position)
        {
            Quaternion rot;
            Vector3 pos;
            GetLocation(position, out pos, out rot);
            var createdPrefab = GameManager.server.CreatePrefab(prefab, pos, rot);
            if (createdPrefab == null) return;
            var entity = createdPrefab.GetComponent<BaseEntity>();
            entity.Spawn();
        }
        private void DeSpawn(string prefab, Vector3 position, float time)
        {
            timers.Add(timer.Once(time, () =>
            {
                List<SurveyCrater> nearby = Pool.GetList<SurveyCrater>();
                Vis.Entities(position, 1f, nearby);
                foreach (SurveyCrater ent in nearby)
                {
                    if (ent.PrefabName.Contains(prefab))
                    {
                        ent.KillMessage();
                    }
                }

                Pool.FreeList(ref nearby);
            }));
        }
        private void GetLocation(Vector3 startPos, out Vector3 pos, out Quaternion rot)
        {
            pos = startPos;
            pos.y = 0f;
            rot = Quaternion.Euler(0f, Random.Range(0f, 360f), 0f);
            RaycastHit raycastHit;
            if (TerrainMeta.HeightMap)
            {
                var height = TerrainMeta.HeightMap.GetHeight(pos) - 0.2f;
                pos.y = Mathf.Max(pos.y, height);
            }
            if (TransformUtil.GetGroundInfo(pos, out raycastHit, 20f, -1063190527))
            {
                pos = raycastHit.point;
                rot = Quaternion.LookRotation(rot * Vector3.forward, raycastHit.normal);
            }
        }
        private T GetConfig<T>(string name, string name2, T defaultValue)
        {
            var data = Config[name] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[name] = data;
            }
            object value;
            if (!data.TryGetValue(name2, out value))
            {
                value = defaultValue;
                data[name2] = value;
            }
            return (T)Convert.ChangeType(Config[name, name2], typeof(T));
        }
        private bool IsAllowed(BasePlayer player, bool perm = false)
        {
            return player.net?.connection?.authLevel > 1 || perm && permission.UserHasPermission(player.UserIDString, oilCrateAllow);
        }
    }
}


// --- End of file: OilCrate.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/optimal-burn ---
// --- Original File Path: O/OptimalBurn/OptimalBurn.cs ---

﻿using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Optimal Burn", "Thisha", "0.9.6")]
    [Description("Splitter according to ultimate furnace guide")]
    public class OptimalBurn : RustPlugin
    {
        #region variables
        private const string permUse = "optimalburn.use";
        
        private const int sulfurOre = -1157596551;  //sulfur.ore
        private const int metalOre = -4031221; //metal.ore
        private const int hqOre = -1982036270; //HQ
        private const int wood = -151838493; //wood

        private const string largefurnace = "furnace.large";
        private const string smallfurnace = "furnace";

        private enum furnaceType {invalid, large, small };
        
        private const int sulfurLarge1K = 5106;
        private const int sulfurLarge2K = 7985;
        private const int sulfurLarge2HK = 8759;
        private const int hqmLarge1K = 977;
        private const int metalLarge1K = 2804;
        private const int metalLarge2K = 4772;
        private const int metalLarge3K = 6087;
        private const int metalLarge4K = 6879;
        private const int metalLarge5K = 7314;

        private const int metalSmall = 600;
        private const int sulfurSmall = 900;
        private const int hqmSmallLow = 200;
        private const int hqmSmallHigh = 216;

        private List<Item> items = new List<Item>();
        private readonly Dictionary<ulong, string> openUis = new Dictionary<ulong, string>();
        private Dictionary<ulong, PlayerData> playerData = new Dictionary<ulong, PlayerData>();

        private class PlayerData
        {
            public int sulfurQtyFurnace;
            public int metalQtyFurnace;
            public int hqQtyFurnace;
            public int woodQtyFurnace;
            public int oreQtyFurnace;
            
            public int sulfurQtyPlayer;
            public int metalQtyPlayer;
            public int hqQtyPlayer;
            public int oreQtyPlayer;
            public int woodQQtyPlayer;

            public int ore;
            public int oreQty;
            public int woodQty;

            public int woodToAdd;
            public int oreToAdd;
            public bool divideit = false;
            public bool autoSplit = false;

            public furnaceType currFurnace = furnaceType.invalid;
        }
        #endregion variables

        #region localization
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Invalid source"] = "Invalid furnace",
                ["Multiple ores"] = "You have multiple ores."  + '\n' + "You must either add sulfur, metal or HQM to define what you want to burn",
                ["Nothing to burn"] = "There is nothing to burn",
                ["Invalid items"] = "Please remove invalid items first",
                ["No wood"] = "You don't have wood",
                ["Cannot optimize"] = "Cannot define an optimal burn",
                ["In use"] = "The furnace is in use"
            }, this);
        }
        #endregion localization

        #region hooks
        private void Init()
        {
            permission.RegisterPermission(permUse, this);
        }

        private void Unload()
        {
            foreach (var kv in openUis.ToDictionary(kv => kv.Key, kv => kv.Value))
            {
                BasePlayer player = BasePlayer.FindByID(kv.Key);
                DestroyUI(player);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            DestroyUI(player);
        }

        private void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            DestroyUI(player);
        }

        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            BaseOven oven = entity as BaseOven;

            if (oven == null || !HasPermission(player))
                return;

            if (playerData.ContainsKey(player.userID))
                playerData.Remove(player.userID);

            PlayerData data = new PlayerData();
            playerData[player.userID] = data;

            playerData[player.userID].currFurnace = furnaceType.invalid;

            if (entity.ShortPrefabName.Equals(largefurnace))
                playerData[player.userID].currFurnace = furnaceType.large;
            else
            {
                if (entity.ShortPrefabName.Equals(smallfurnace))
                    playerData[player.userID].currFurnace = furnaceType.small;
            }

            if (playerData[player.userID].currFurnace == furnaceType.invalid)
                return;

            CreateUi(player, oven);
        }
        
        private void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity)
        {
            BaseOven oven = entity as BaseOven;

            if (oven == null || ((!(entity.ShortPrefabName.Equals(largefurnace))) && (!(entity.ShortPrefabName.Equals(smallfurnace)))))
                return;

            DestroyUI(player);
        }
        
        private void OnEntityKill(BaseNetworkable networkable)
        {
            BaseOven oven = networkable as BaseOven;

            if (oven != null)
                DestroyOvenUI(oven);
        }

        object CanPickupEntity(BasePlayer player, BaseEntity entity)
        {
            if (!(entity.ShortPrefabName.Equals(largefurnace)) && !(entity.ShortPrefabName.Equals(smallfurnace)))
                return null;

            if (openUis.ContainsKey(player.userID))
            {
                player.ChatMessage(Lang("In use", player.UserIDString));
                return false;
            }

            return null; 
        }
        #endregion hooks

        #region commands
        [ConsoleCommand("optimalburn.split")]
        private void OptimizeLargefurnace(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();

            if (arg.Connection == null || player == null)
                return;

            BaseOven furnace = player.inventory.loot?.entitySource as BaseOven;

            if (!playerData.ContainsKey(player.userID))
            {
                return;
            }

            if (furnace == null || (playerData[player.userID].currFurnace == furnaceType.invalid))
            {
                player.ChatMessage(Lang("Invalid source", player.UserIDString));
                return;
            }

            Optimizefurnace(player, furnace);
        }
        #endregion commands

        #region methods
        bool HasInvalidItems(BaseOven furnace)
        {
            for (int i = 0; i <= 17; i++)
            {
                Item item = furnace.inventory.GetSlot(i);
                if (item != null)
                {
                    if ((item.info.itemid != metalOre) && (item.info.itemid != sulfurOre) && (item.info.itemid != hqOre) && (item.info.itemid != wood))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        bool BurnableDefined(BasePlayer player)
        {
            //no different ores allowed in furnace
            int types = 0;
            
            if (playerData[player.userID].sulfurQtyFurnace > 0)
                types += 1;
                
            if (playerData[player.userID].metalQtyFurnace > 0)
                types += 1;
            
            if (playerData[player.userID].hqQtyFurnace > 0)
                types += 1;
            
            if (types > 1)
            {
                player.ChatMessage(Lang("Multiple ores", player.UserIDString));
                return false;
            }

            if ((playerData[player.userID].sulfurQtyFurnace == 0) && (playerData[player.userID].metalQtyFurnace == 0) && (playerData[player.userID].hqQtyFurnace == 0))
            {
                //if only containing one of both, auto define
                if ((playerData[player.userID].sulfurQtyPlayer > 0) && (playerData[player.userID].metalQtyPlayer == 0) && (playerData[player.userID].hqQtyFurnace == 0))
                {
                    playerData[player.userID].ore = sulfurOre;
                }
                else
                {
                    if ((playerData[player.userID].sulfurQtyPlayer == 0) && (playerData[player.userID].metalQtyPlayer > 0) && (playerData[player.userID].hqQtyPlayer == 0))
                    {
                        playerData[player.userID].ore = metalOre;
                    }
                    else
                    {
                        if ((playerData[player.userID].sulfurQtyPlayer == 0) && (playerData[player.userID].metalQtyPlayer == 0) && (playerData[player.userID].hqQtyPlayer > 0))
                        {
                            playerData[player.userID].ore = hqOre;
                        }
                        else
                        {
                            if ((playerData[player.userID].sulfurQtyPlayer == 0) && (playerData[player.userID].metalQtyPlayer == 0) && (playerData[player.userID].hqQtyPlayer == 0))
                            {
                                player.ChatMessage(Lang("Nothing to burn", player.UserIDString));
                                return false;
                            }
                            else
                            {
                                player.ChatMessage(Lang("Multiple ores", player.UserIDString));
                                return false;
                            }
                        }
                    }
                }
            }
            else
            {
                if (playerData[player.userID].sulfurQtyFurnace > 0) 
                    playerData[player.userID].ore = sulfurOre;
                else
                {
                    if (playerData[player.userID].metalQtyFurnace > 0)
                        playerData[player.userID].ore = metalOre;
                    else
                        playerData[player.userID].ore = hqOre;
                }
                    
            }
            return true;
        }

        void DefineQuantitesToUseLarge(BasePlayer player)
        {
            playerData[player.userID].autoSplit = false;
            playerData[player.userID].divideit = false;
            playerData[player.userID].oreToAdd = 0;
            playerData[player.userID].woodToAdd = 0;

            if (playerData[player.userID].woodQtyFurnace > 0)
            {
                switch (playerData[player.userID].woodQtyFurnace)
                {
                    case 1000:
                        {
                            switch (playerData[player.userID].ore)
                            {
                                case sulfurOre:
                                    {
                                        if (playerData[player.userID].oreQty >= sulfurLarge1K)
                                        {
                                            playerData[player.userID].oreToAdd = sulfurLarge1K;
                                            playerData[player.userID].woodToAdd = 1000;
                                        }
                                        else
                                            playerData[player.userID].autoSplit = true;

                                        break;
                                    }

                                case metalOre:
                                    {
                                        if (playerData[player.userID].oreQty >= metalLarge1K)
                                        {
                                            playerData[player.userID].oreToAdd = metalLarge1K;
                                            playerData[player.userID].woodToAdd = 1000;
                                        }
                                        else
                                            playerData[player.userID].autoSplit = true;

                                        break;
                                    }

                                case hqOre:
                                    {
                                        if (playerData[player.userID].oreQty >= hqmLarge1K)
                                        {
                                            playerData[player.userID].oreToAdd = hqmLarge1K;
                                            playerData[player.userID].woodToAdd = 1000;
                                        }
                                        else
                                            playerData[player.userID].autoSplit = true;

                                        break;
                                    }

                                default:
                                    {
                                        return;
                                    }

                            }
                            break;
                        }

                    case 2000:
                        {
                            switch (playerData[player.userID].ore)
                            {
                                case (sulfurOre):
                                    {
                                        if (playerData[player.userID].oreQty >= sulfurLarge2K)
                                        {
                                            playerData[player.userID].oreToAdd = sulfurLarge2K;
                                            playerData[player.userID].woodToAdd = 2000;
                                        }
                                        else
                                            playerData[player.userID].autoSplit = true;

                                        break;
                                    }

                                case metalOre:
                                    {
                                        if (playerData[player.userID].oreQty >= metalLarge2K)
                                        {
                                            playerData[player.userID].oreToAdd = metalLarge2K;
                                            playerData[player.userID].woodToAdd = 2000;
                                        }

                                        break;
                                    }

                                case hqOre:
                                    {
                                        playerData[player.userID].autoSplit = true;
                                        break;
                                    }

                                default:
                                    {
                                        return;
                                    }

                            }
                            break;
                        }

                    case 2500:
                        {
                            if (playerData[player.userID].ore == sulfurOre)
                            {
                                if (playerData[player.userID].oreQty >= sulfurLarge2HK)
                                {
                                    playerData[player.userID].oreToAdd = sulfurLarge2HK;
                                    playerData[player.userID].woodToAdd = 2500;
                                }
                                else
                                    playerData[player.userID].autoSplit = true;
                            }
                            else
                            {
                                playerData[player.userID].autoSplit = true;
                            }
                            break;
                        }

                    case 3000:
                        {
                            if (playerData[player.userID].ore == metalOre)
                            {
                                if (playerData[player.userID].oreQty >= metalLarge3K)
                                {
                                    playerData[player.userID].oreToAdd = metalLarge3K;
                                    playerData[player.userID].woodToAdd = 3000;
                                }
                                else
                                    playerData[player.userID].autoSplit = true;
                            }
                            else
                            {
                                playerData[player.userID].autoSplit = true;
                            }
                            break;
                        }

                    case 4000:
                        {
                            if (playerData[player.userID].ore == metalOre)
                            {
                                if (playerData[player.userID].oreQty >= metalLarge4K)
                                {
                                    playerData[player.userID].oreToAdd = metalLarge4K;
                                    playerData[player.userID].woodToAdd = 4000;
                                }
                                else
                                    playerData[player.userID].autoSplit = true;
                            }
                            else
                            {
                                playerData[player.userID].autoSplit = true;
                            }

                            break;
                        }

                    case 5000:
                        {
                            if (playerData[player.userID].ore == metalOre)
                            {
                                if (playerData[player.userID].oreQty >= metalLarge5K)
                                {
                                    playerData[player.userID].oreToAdd = metalLarge5K;
                                    playerData[player.userID].autoSplit = true;
                                }
                                else
                                    playerData[player.userID].autoSplit = true;
                            }
                            else
                            {
                                playerData[player.userID].autoSplit = true;
                            }

                            break;
                        }

                    default:
                        {
                            playerData[player.userID].autoSplit = true;
                            break;
                        }
                        
                }
            }
            else
            {
                playerData[player.userID].autoSplit = true;
            }

            if (playerData[player.userID].autoSplit)
            {
                //if no wood was added or the ore amount is insufficient for it, define according to inventory
                switch (playerData[player.userID].ore)
                {
                    case (metalOre):
                        {
                            if ((playerData[player.userID].oreQty >= metalLarge5K) && (playerData[player.userID].woodQty >= 5000))
                            {
                                playerData[player.userID].woodToAdd = 5000;
                                playerData[player.userID].oreToAdd = metalLarge5K;
                            }
                            else
                            {
                                if ((playerData[player.userID].oreQty >= metalLarge4K) && (playerData[player.userID].woodQty >= 4000))
                                {
                                    playerData[player.userID].woodToAdd = 4000;
                                    playerData[player.userID].oreToAdd = metalLarge4K;
                                }
                                else
                                {
                                    if ((playerData[player.userID].oreQty >= metalLarge3K) && (playerData[player.userID].woodQty >= 3000))
                                    {
                                        playerData[player.userID].woodToAdd = 3000;
                                        playerData[player.userID].oreToAdd = metalLarge3K;
                                    }
                                    else
                                    {
                                        if ((playerData[player.userID].oreQty >= metalLarge2K) && (playerData[player.userID].woodQty >= 2000))
                                        {
                                            playerData[player.userID].woodToAdd = 2000;
                                            playerData[player.userID].oreToAdd = metalLarge2K;
                                        }
                                        else
                                        {
                                            if ((playerData[player.userID].oreQty >= metalLarge1K) && (playerData[player.userID].woodQty >= 1000))
                                            {
                                                playerData[player.userID].woodToAdd = 1000;
                                                playerData[player.userID].oreToAdd = metalLarge1K;
                                            }
                                            else
                                            {
                                                if ((playerData[player.userID].oreQty >= 990) && (playerData[player.userID].woodQty >= 330))
                                                {
                                                    playerData[player.userID].woodToAdd = 330;
                                                    playerData[player.userID].oreToAdd = 990;
                                                    playerData[player.userID].divideit = true;
                                                }
                                                else
                                                {
                                                    playerData[player.userID].divideit = true;

                                                    if (playerData[player.userID].oreQty >= 15)
                                                    {
                                                        int orePartToAdd = 66; //max
                                                        if (orePartToAdd * 15 > playerData[player.userID].oreQty)
                                                            orePartToAdd = (int)playerData[player.userID].oreQty / 15;

                                                        while (orePartToAdd * 5 > playerData[player.userID].woodQty)
                                                        {
                                                            orePartToAdd -= 1;
                                                        }

                                                        playerData[player.userID].oreToAdd = orePartToAdd * 15;
                                                        playerData[player.userID].woodToAdd = orePartToAdd * 5;
                                                    }
                                                    else
                                                        playerData[player.userID].oreToAdd = 0;
                                                    
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            break;
                        }

                    case (sulfurOre):
                        {
                            if ((playerData[player.userID].oreQty >= sulfurLarge2HK) && (playerData[player.userID].woodQty >= 2500))
                            {
                                playerData[player.userID].woodToAdd = 2500;
                                playerData[player.userID].oreToAdd = sulfurLarge2HK;
                            }
                            else
                            {
                                if ((playerData[player.userID].oreQty >= sulfurLarge2K) && (playerData[player.userID].woodQty >= 2000))
                                {
                                    playerData[player.userID].woodToAdd = 2000;
                                    playerData[player.userID].oreToAdd = sulfurLarge2K;
                                } 
                                else
                                {
                                    if ((playerData[player.userID].oreQty >= sulfurLarge1K) && (playerData[player.userID].woodQty >= 1000))
                                    {
                                        playerData[player.userID].woodToAdd = 1000;
                                        playerData[player.userID].oreToAdd = sulfurLarge1K;
                                    }
                                    else
                                    {
                                        if ((playerData[player.userID].oreQty >= 990) && (playerData[player.userID].woodQty >= 165))
                                        {
                                            playerData[player.userID].woodToAdd = 165;
                                            playerData[player.userID].oreToAdd = 990;
                                            playerData[player.userID].divideit = true;
                                        }
                                        else
                                        {
                                            playerData[player.userID].divideit = true;

                                            if (playerData[player.userID].oreQty >= 15)
                                            {
                                                int orePartToAdd = 66; //max
                                                if (orePartToAdd * 15 > playerData[player.userID].oreQty)
                                                    orePartToAdd = (int)playerData[player.userID].oreQty / 15;

                                                while ((int)Math.Ceiling(orePartToAdd * 2.5f) > playerData[player.userID].woodQty)
                                                {
                                                    orePartToAdd -= 1;
                                                }

                                                playerData[player.userID].oreToAdd = orePartToAdd * 15;
                                                playerData[player.userID].woodToAdd = (int)Math.Ceiling(orePartToAdd * 2.5f);
                                            }
                                            else
                                            {
                                                playerData[player.userID].oreToAdd = 0;
                                            }
                                        }
                                        
                                    }
                                }
                            }

                            break;
                        }

                    case (hqOre):
                        {
                            if ((playerData[player.userID].oreQty >= hqmLarge1K) && (playerData[player.userID].woodQty >= 1000))
                            {
                                playerData[player.userID].woodToAdd = 1000;
                                playerData[player.userID].oreToAdd = hqmLarge1K;
                            }

                            else
                            {
                                playerData[player.userID].divideit = true;

                                if (playerData[player.userID].oreQty >= 15)
                                {
                                    int orePartToAdd = 66; //max
                                    if (orePartToAdd * 15 > playerData[player.userID].oreQty)
                                        orePartToAdd = (int)playerData[player.userID].oreQty / 15;

                                    while (orePartToAdd * 10 > playerData[player.userID].woodQty)
                                    {
                                        orePartToAdd -= 1;
                                    }

                                    playerData[player.userID].oreToAdd = orePartToAdd * 15;
                                    playerData[player.userID].woodToAdd = orePartToAdd * 10;
                                }
                                else
                                    playerData[player.userID].oreToAdd = 0;
                            }
                            
                            break;
                        }
                }
            }

        }

        void DefineQuantitesToUseSmall(BasePlayer player)
        {
            playerData[player.userID].autoSplit = false;
            playerData[player.userID].divideit = false;
            playerData[player.userID].oreToAdd = 0;
            playerData[player.userID].woodToAdd = 0;

            if (playerData[player.userID].woodQtyFurnace > 0)
            {
                switch (playerData[player.userID].woodQtyFurnace)
                {
                    case 1000:
                        {
                            switch (playerData[player.userID].ore)
                            {
                                case sulfurOre:
                                    {
                                        if (playerData[player.userID].oreQty >= 999)
                                        {
                                            playerData[player.userID].oreToAdd = 999;
                                            playerData[player.userID].woodToAdd = 833;
                                        }
                                        else
                                        {
                                            if (playerData[player.userID].oreQty >= sulfurSmall)
                                            {
                                                playerData[player.userID].oreToAdd = sulfurSmall;
                                                playerData[player.userID].woodToAdd = 750;
                                            }
                                            else
                                                playerData[player.userID].autoSplit = true;
                                        }

                                        break;
                                    }

                                case metalOre:
                                    {
                                        if (playerData[player.userID].oreQty >= metalSmall)
                                        {
                                            playerData[player.userID].oreToAdd = metalSmall;
                                            playerData[player.userID].woodToAdd = 1000;
                                        }
                                        else
                                            playerData[player.userID].autoSplit = true;

                                        break;
                                    }

                                case (hqOre):
                                    {
                                        if (playerData[player.userID].oreQty >= hqmSmallHigh)
                                        {
                                            playerData[player.userID].oreToAdd = hqmSmallHigh;
                                            playerData[player.userID].woodToAdd = 1000;
                                        }
                                        else
                                        {
                                            if (playerData[player.userID].oreQty >= hqmSmallLow)
                                            {
                                                playerData[player.userID].oreToAdd = hqmSmallLow;
                                                playerData[player.userID].woodToAdd = 1000;
                                            }
                                            else
                                                playerData[player.userID].autoSplit = true;
                                        }

                                        break;
                                    }

                                default:
                                    {
                                        return;
                                    }

                            }
                            break;
                        }

                    case 750:
                        {
                            switch (playerData[player.userID].ore)
                            {
                                case sulfurOre:
                                    {
                                        if (playerData[player.userID].oreQty >= 900)
                                        {
                                            playerData[player.userID].oreToAdd = 900;
                                            playerData[player.userID].woodToAdd = 750;
                                        }
                                        else
                                            playerData[player.userID].autoSplit = true;

                                        break;
                                    }

                                case metalOre:
                                    {
                                        if (playerData[player.userID].oreQty >= 150)
                                        {
                                            playerData[player.userID].oreToAdd = 450;
                                            playerData[player.userID].woodToAdd = 750;
                                        }
                                        else
                                            playerData[player.userID].autoSplit = true;

                                        break;
                                    }

                                case (hqOre):
                                    {
                                        playerData[player.userID].autoSplit = true;

                                        break;
                                    }

                                default:
                                    {
                                        return;
                                    }

                            }
                            break;
                        }

                    case 500:
                        {
                            switch (playerData[player.userID].ore)
                            {
                                case sulfurOre:
                                    {
                                        if (playerData[player.userID].oreQty >= 600)
                                        {
                                            playerData[player.userID].oreToAdd = 600;
                                            playerData[player.userID].woodToAdd = 500;
                                        }
                                        else
                                            playerData[player.userID].autoSplit = true;

                                        break;
                                    }

                                case metalOre:
                                    {
                                        if (playerData[player.userID].oreQty >= 100)
                                        {
                                            playerData[player.userID].oreToAdd = 300;
                                            playerData[player.userID].woodToAdd = 500;
                                        }
                                        else
                                            playerData[player.userID].autoSplit = true;

                                        break;
                                    }

                                case (hqOre):
                                    {
                                        playerData[player.userID].autoSplit = true;

                                        break;
                                    }

                                default:
                                    {
                                        return;
                                    }

                            }
                            break;
                        }

                    default:
                        {
                            playerData[player.userID].autoSplit = true;
                            break;
                        }

                }
            }
            else
            {
                playerData[player.userID].autoSplit = true;
            }

            if (playerData[player.userID].autoSplit)
            {
                //if no wood was added or the ore amount is insufficient for it, define according to inventory
                switch (playerData[player.userID].ore)
                {
                    case (metalOre):
                        {
                            if ((playerData[player.userID].oreQty >= metalSmall) && (playerData[player.userID].woodQty >= 1000)) //enough for the best
                            {
                                playerData[player.userID].woodToAdd = 1000;
                                playerData[player.userID].oreToAdd = metalSmall;
                            }
                            else
                            {
                                playerData[player.userID].divideit = true;

                                if (playerData[player.userID].oreQty >= 3)
                                {
                                    int orePartToAdd = 200; //max
                                    if (orePartToAdd * 3 > playerData[player.userID].oreQty)
                                        orePartToAdd = (int)playerData[player.userID].oreQty / 3;

                                    while (orePartToAdd * 5 > playerData[player.userID].woodQty)
                                    {
                                        orePartToAdd -= 1;
                                    }
                                    playerData[player.userID].woodToAdd = orePartToAdd * 5;
                                    playerData[player.userID].oreToAdd = orePartToAdd * 3;
                                }
                                else
                                    playerData[player.userID].oreToAdd = 0;
                            }

                            break;
                        }

                    case (sulfurOre):
                        {
                            if ((playerData[player.userID].oreQty >= 999) && (playerData[player.userID].woodQty >= 833)) 
                            {
                                playerData[player.userID].oreToAdd = 999;
                                playerData[player.userID].woodToAdd = 833;
                            } else
                            {
                                if ((playerData[player.userID].oreQty >= sulfurSmall) && (playerData[player.userID].woodQty >= 750))
                                {
                                    playerData[player.userID].woodToAdd = 750;
                                    playerData[player.userID].oreToAdd = sulfurSmall;
                                }
                                else
                                {
                                    playerData[player.userID].divideit = true;

                                    if (playerData[player.userID].oreQty >= 3)
                                    {
                                        int orePartToAdd = 333; //max
                                        if (orePartToAdd * 3 > playerData[player.userID].oreQty)
                                            orePartToAdd = (int)playerData[player.userID].oreQty / 3;

                                        while ((int)Math.Ceiling(orePartToAdd * 2.5f) > playerData[player.userID].woodQty)
                                        {
                                            orePartToAdd -= 1;
                                        }

                                        playerData[player.userID].woodToAdd = (int)Math.Ceiling(orePartToAdd * 2.5f);
                                        playerData[player.userID].oreToAdd = orePartToAdd * 3;
                                    }
                                    else
                                        playerData[player.userID].oreToAdd = 0;
                                }
                            }

                            break;
                        }

                    case (hqOre):
                        {
                            if ((playerData[player.userID].oreQty >= hqmSmallHigh) && (playerData[player.userID].woodQty >= 1000)) //enough for the best
                            {
                                playerData[player.userID].woodToAdd = 1000;
                                playerData[player.userID].oreToAdd = hqmSmallHigh;
                            }
                            else
                            {
                                if ((playerData[player.userID].oreQty >= hqmSmallLow) && (playerData[player.userID].woodQty >= 1000)) //enough for the best
                                {
                                    playerData[player.userID].woodToAdd = 1000;
                                    playerData[player.userID].oreToAdd = hqmSmallLow;
                                }

                                else
                                {
                                    playerData[player.userID].divideit = true;

                                    if (playerData[player.userID].oreQty >= 3)
                                    {

                                        int orePartToAdd = 100; //max
                                        if (orePartToAdd * 3 > playerData[player.userID].oreQty)
                                            orePartToAdd = (int)playerData[player.userID].oreQty / 3;
                                        while (orePartToAdd * 10 > playerData[player.userID].woodQty)
                                        {
                                            orePartToAdd -= 1;
                                        }

                                        playerData[player.userID].woodToAdd = orePartToAdd * 10;
                                        playerData[player.userID].oreToAdd = orePartToAdd * 3;
                                    }
                                    else
                                        playerData[player.userID].oreToAdd = 0;

                                }
                            }

                            break;

                        }
                            
                }
            }

        }

        void Optimizefurnace(BasePlayer player, BaseOven furnace)
        {
            //check for items other than wood, sulfur or metal
            if (HasInvalidItems(furnace))
            {
                player.ChatMessage(Lang("Invalid items", player.UserIDString));
                return;
            }

            //get available amounts of resources
            playerData[player.userID].sulfurQtyFurnace = furnace.inventory.GetAmount(sulfurOre, true);
            playerData[player.userID].metalQtyFurnace = furnace.inventory.GetAmount(metalOre, true);
            playerData[player.userID].hqQtyFurnace = furnace.inventory.GetAmount(hqOre, true);
            playerData[player.userID].woodQtyFurnace = furnace.inventory.GetAmount(wood, true);

            playerData[player.userID].sulfurQtyPlayer = player.inventory.GetAmount(sulfurOre);
            playerData[player.userID].metalQtyPlayer = player.inventory.GetAmount(metalOre);
            playerData[player.userID].hqQtyPlayer = player.inventory.GetAmount(hqOre);
            playerData[player.userID].woodQQtyPlayer = player.inventory.GetAmount(wood);

            playerData[player.userID].woodQty = playerData[player.userID].woodQtyFurnace + playerData[player.userID].woodQQtyPlayer;

            //check wood to burn
            if (playerData[player.userID].woodQty == 0)
            {
                player.ChatMessage(Lang("No wood", player.UserIDString));
                return;
            }

            //define what must be burnt
            if (!BurnableDefined(player))
                return;
            
            //get total amount of ore to burn
            switch (playerData[player.userID].ore)
            {
                case (metalOre):
                    {
                        playerData[player.userID].oreQty = playerData[player.userID].metalQtyFurnace + playerData[player.userID].metalQtyPlayer;
                        playerData[player.userID].oreQtyPlayer = playerData[player.userID].metalQtyPlayer;
                        playerData[player.userID].oreQtyFurnace = playerData[player.userID].metalQtyFurnace;

                        break;
                    }

                case (sulfurOre):
                    {
                        playerData[player.userID].oreQty = playerData[player.userID].sulfurQtyFurnace + playerData[player.userID].sulfurQtyPlayer;
                        playerData[player.userID].oreQtyPlayer = playerData[player.userID].sulfurQtyPlayer;
                        playerData[player.userID].oreQtyFurnace = playerData[player.userID].sulfurQtyFurnace;

                        break;
                    }

                case (hqOre):
                    {
                        playerData[player.userID].oreQty = playerData[player.userID].hqQtyFurnace + playerData[player.userID].hqQtyPlayer;
                        playerData[player.userID].oreQtyPlayer = playerData[player.userID].hqQtyPlayer;
                        playerData[player.userID].oreQtyFurnace = playerData[player.userID].hqQtyFurnace;

                        break;
                    }
            }
            
                
            //something to burn at all?
            if (playerData[player.userID].oreQty == 0)
            {
                player.ChatMessage(Lang("Nothing to burn", player.UserIDString));
                return;
            }

            //get the best solution
            if (playerData[player.userID].currFurnace == furnaceType.large)
                DefineQuantitesToUseLarge(player);
            else
                DefineQuantitesToUseSmall(player);

            //no success
            if ((playerData[player.userID].oreToAdd <= 0) || (playerData[player.userID].woodToAdd <= 0))
            {
                player.ChatMessage(Lang("Cannot optimize", player.UserIDString));
                return;
            }

            //split stuff
            if (playerData[player.userID].currFurnace == furnaceType.large)
                Filllargefurnace(furnace, player);
            else
                Fillsmallfurnace(furnace, player);

            //take from or give to player according what was used and what was already in furnace
            Handleremainings(player);
        }

        void Handleremainings(BasePlayer player)
        {
            //take from player what was used that wasn't in the furnace
            if (playerData[player.userID].woodQtyFurnace < playerData[player.userID].woodToAdd)
                player.inventory.Take(items, wood, playerData[player.userID].woodToAdd - playerData[player.userID].woodQtyFurnace);

            if (playerData[player.userID].oreQtyFurnace < playerData[player.userID].oreToAdd) 
            {
                switch(playerData[player.userID].ore)
                {
                    case (metalOre):
                        {
                            player.inventory.Take(items, metalOre, playerData[player.userID].oreToAdd - playerData[player.userID].metalQtyFurnace);
                            break;
                        }

                    case (sulfurOre):
                        {
                            player.inventory.Take(items, sulfurOre, playerData[player.userID].oreToAdd - playerData[player.userID].sulfurQtyFurnace);
                            break;
                        }

                    case (hqOre):
                        {
                            player.inventory.Take(items, hqOre, playerData[player.userID].oreToAdd - playerData[player.userID].hqQtyFurnace);
                            break;
                        }
                }
            }

            //give to player what was too much in the furnace
            if (playerData[player.userID].woodQtyFurnace > playerData[player.userID].woodToAdd)
                ReturnUnstackedToPlayer(player, wood, playerData[player.userID].woodQtyFurnace - playerData[player.userID].woodToAdd);

            switch (playerData[player.userID].ore)
            {
                case (metalOre):
                    {
                        if (playerData[player.userID].metalQtyFurnace > playerData[player.userID].oreToAdd)
                            ReturnUnstackedToPlayer(player, metalOre, playerData[player.userID].metalQtyFurnace - playerData[player.userID].oreToAdd);

                        break;
                    }

                case (sulfurOre):
                    {
                        if (playerData[player.userID].sulfurQtyFurnace > playerData[player.userID].oreToAdd)
                            ReturnUnstackedToPlayer(player, sulfurOre, playerData[player.userID].sulfurQtyFurnace - playerData[player.userID].oreToAdd);

                        break;
                    }

                case (hqOre):
                    {
                        if (playerData[player.userID].hqQtyFurnace > playerData[player.userID].oreToAdd)
                            ReturnUnstackedToPlayer(player, hqOre, playerData[player.userID].hqQtyFurnace - playerData[player.userID].oreToAdd);

                        break;
                    }
            }
        }

        void ReturnUnstackedToPlayer(BasePlayer player, int itemID, int Qty)
        {
            int remaining = Qty;

            while (remaining > 0)
            {
                if (remaining >= 1000)
                {
                    player.GiveItem(ItemManager.CreateByItemID(itemID, 1000), BaseEntity.GiveItemReason.PickedUp);
                    remaining -= 1000;
                }
                    
                else
                {
                    player.GiveItem(ItemManager.CreateByItemID(itemID, remaining), BaseEntity.GiveItemReason.PickedUp);
                    remaining = 0;
                }
            }
        }

        void Filllargefurnace(BaseOven furnace, BasePlayer player)
        {
            //clear the furnace for easy filling
            switch (playerData[player.userID].ore)
            {
                case (metalOre):
                    {
                        furnace.inventory.Take(items, metalOre, playerData[player.userID].metalQtyFurnace);
                        break;
                    }

                case (sulfurOre):
                    {
                        furnace.inventory.Take(items, sulfurOre, playerData[player.userID].sulfurQtyFurnace);
                        break;
                    }

                case (hqOre):
                    {
                        furnace.inventory.Take(items, hqOre, playerData[player.userID].hqQtyFurnace);
                        break;
                    }
            }

            furnace.inventory.Take(items, wood, playerData[player.userID].woodQtyFurnace);

            //make sure wood is in the right place
            if (playerData[player.userID].woodToAdd == 2500)
            {
                ItemManager.CreateByItemID(wood, 500).MoveToContainer(furnace.inventory, 0, false);
                ItemManager.CreateByItemID(wood, 1000).MoveToContainer(furnace.inventory, 1, false);
                ItemManager.CreateByItemID(wood, 1000).MoveToContainer(furnace.inventory, 2, false);
            }
            else
            {
                if (playerData[player.userID].woodToAdd >= 1000)
                {
                    for (int i = 1; i <= playerData[player.userID].woodToAdd / 1000; i++)
                        ItemManager.CreateByItemID(wood, 1000).MoveToContainer(furnace.inventory, i - 1, false);
                }
                else
                {
                    ItemManager.CreateByItemID(wood, playerData[player.userID].woodToAdd).MoveToContainer(furnace.inventory, 0, false);

                }
                    
            }

            //add the ore
            if (playerData[player.userID].divideit)
            {
                for (int i = 3; i <= 17; i++)
                    ItemManager.CreateByItemID(playerData[player.userID].ore, playerData[player.userID].oreToAdd / 15).MoveToContainer(furnace.inventory, i, false);
            }
            else
            {
                switch (playerData[player.userID].ore)
                {
                    case (metalOre):
                        {
                            switch (playerData[player.userID].woodToAdd)
                            {
                                case 1000:
                                    {
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 66).MoveToContainer(furnace.inventory, 3, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 138).MoveToContainer(furnace.inventory, 4, false);
                                        for (int i = 5; i <= 17; i++)
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 200).MoveToContainer(furnace.inventory, i, false);
                                        
                                        break;
                                    }

                                case 2000:
                                    {
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 71).MoveToContainer(furnace.inventory, 4, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 148).MoveToContainer(furnace.inventory, 5, false);
                                        for (int i = 6; i <= 10; i++)
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 400).MoveToContainer(furnace.inventory, i, false);
                                        
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 231).MoveToContainer(furnace.inventory, 11, false);

                                        for (int i = 12; i <= 16; i++)
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 400).MoveToContainer(furnace.inventory, i, false);
                                        
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 322).MoveToContainer(furnace.inventory, 17, false);

                                        break;
                                    }

                                case 3000:
                                    {
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 76).MoveToContainer(furnace.inventory, 5, false);
                                        for (int i = 6; i <= 8; i++)
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 600).MoveToContainer(furnace.inventory, i, false);
                                        
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 587).MoveToContainer(furnace.inventory, 9, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 462).MoveToContainer(furnace.inventory, 10, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 160).MoveToContainer(furnace.inventory, 11, false);

                                        for (int i = 12; i <= 15; i++)
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 600).MoveToContainer(furnace.inventory, i, false);
                                        
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 351).MoveToContainer(furnace.inventory, 16, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 251).MoveToContainer(furnace.inventory, 17, false);

                                        break;
                                    }

                                case 4000:
                                    {
                                        for (int i = 6; i <= 8; i++)
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 800).MoveToContainer(furnace.inventory, i, false);
                                        
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 510).MoveToContainer(furnace.inventory, 9, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 385).MoveToContainer(furnace.inventory, 10, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 83).MoveToContainer(furnace.inventory, 11, false);
                                        for (int i = 12; i <= 14; i++)
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 800).MoveToContainer(furnace.inventory, i, false);
                                        
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 653).MoveToContainer(furnace.inventory, 15, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 274).MoveToContainer(furnace.inventory, 16, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 174).MoveToContainer(furnace.inventory, 17, false);

                                        break;
                                    }

                                case 5000:
                                    {
                                        for (int i = 6; i <= 8; i++)
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 1000).MoveToContainer(furnace.inventory, i, false);
                                        
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 427).MoveToContainer(furnace.inventory, 9, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 302).MoveToContainer(furnace.inventory, 10, false);
                                        
                                        for (int i = 12; i <= 13; i++)
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 1000).MoveToContainer(furnace.inventory, i, false);
                                        
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 736).MoveToContainer(furnace.inventory, 14, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 569).MoveToContainer(furnace.inventory, 15, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 190).MoveToContainer(furnace.inventory, 16, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 90).MoveToContainer(furnace.inventory, 17, false);

                                        break;
                                    }
                            }
                            break;
                        }

                    case (sulfurOre):
                        {
                            switch (playerData[player.userID].woodToAdd)
                            {
                                case 1000:
                                    {
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 66).MoveToContainer(furnace.inventory, 3, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 138).MoveToContainer(furnace.inventory, 4, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 215).MoveToContainer(furnace.inventory, 5, false);

                                        for (int i = 6; i <= 10; i++)
                                        {
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 400).MoveToContainer(furnace.inventory, i, false);
                                        }

                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 298).MoveToContainer(furnace.inventory, 11, false);

                                        for (int i = 12; i <= 16; i++)
                                        {
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 400).MoveToContainer(furnace.inventory, i, false);
                                        }

                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 389).MoveToContainer(furnace.inventory, 17, false);

                                        break;
                                    }

                                case 2000:
                                    {
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 71).MoveToContainer(furnace.inventory, 4, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 148).MoveToContainer(furnace.inventory, 5, false);
                                        for (int i = 6; i <= 8; i++)
                                        {
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 800).MoveToContainer(furnace.inventory, i, false);
                                        }

                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 658).MoveToContainer(furnace.inventory, 9);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 533).MoveToContainer(furnace.inventory, 10);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 231).MoveToContainer(furnace.inventory, 11);

                                        for (int i = 12; i <= 15; i++)
                                        {
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 800).MoveToContainer(furnace.inventory, i);
                                        }

                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 422).MoveToContainer(furnace.inventory, 16);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 322).MoveToContainer(furnace.inventory, 17);

                                        break;
                                    }

                                case 2500:
                                    {
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 76).MoveToContainer(furnace.inventory, 5);
                                        for (int i = 6; i <= 8; i++)
                                        {
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 1000).MoveToContainer(furnace.inventory, i);
                                        }

                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 587).MoveToContainer(furnace.inventory, 9);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 462).MoveToContainer(furnace.inventory, 10);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 160).MoveToContainer(furnace.inventory, 11);

                                        for (int i = 12; i <= 14; i++)
                                        {
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 1000).MoveToContainer(furnace.inventory, i);
                                        }

                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 872).MoveToContainer(furnace.inventory, 15);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 351).MoveToContainer(furnace.inventory, 16);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 251).MoveToContainer(furnace.inventory, 17);

                                        break;
                                    }
                            }
                            break;
                        }

                    case (hqOre):
                        {
                            switch (playerData[player.userID].woodToAdd)
                            {
                                case 1000:
                                    {
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 6).MoveToContainer(furnace.inventory, 3, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 13).MoveToContainer(furnace.inventory, 4, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 21).MoveToContainer(furnace.inventory, 5, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 30).MoveToContainer(furnace.inventory, 6, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 39).MoveToContainer(furnace.inventory, 7, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 49).MoveToContainer(furnace.inventory, 8, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 60).MoveToContainer(furnace.inventory, 9, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 72).MoveToContainer(furnace.inventory, 10, false);
                                        ItemManager.CreateByItemID(playerData[player.userID].ore, 87).MoveToContainer(furnace.inventory, 11, false);
                                        for (int i = 12; i <= 17; i++)
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 100).MoveToContainer(furnace.inventory, i, false);

                                        break;
                                    }
                            }
                            break;
                        }
                    default:
                        return;
                }
            }
        }

        void Fillsmallfurnace(BaseOven furnace, BasePlayer player)
        {
            //clear the furnace for easy filling
            switch (playerData[player.userID].ore)
            {
                case (metalOre):
                    {
                        furnace.inventory.Take(items, metalOre, playerData[player.userID].metalQtyFurnace);
                        break;
                    }

                case (sulfurOre):
                    {
                        furnace.inventory.Take(items, sulfurOre, playerData[player.userID].sulfurQtyFurnace);
                        break;
                    }

                case (hqOre):
                    {
                        furnace.inventory.Take(items, hqOre, playerData[player.userID].hqQtyFurnace);
                        break;
                    }
            }
  
            furnace.inventory.Take(items, wood, playerData[player.userID].woodQtyFurnace);

            //only one spot for wood
            ItemManager.CreateByItemID(wood, playerData[player.userID].woodToAdd).MoveToContainer(furnace.inventory, 0, false);
            
            //add the ore
            if (playerData[player.userID].divideit)
            {
                for (int i = 1; i <= 3; i++)
                    ItemManager.CreateByItemID(playerData[player.userID].ore, playerData[player.userID].oreToAdd / 3).MoveToContainer(furnace.inventory, i, false);
            }
            else
            {
                switch (playerData[player.userID].ore)
                {
                    case (metalOre):
                        {
                            switch (playerData[player.userID].woodToAdd)
                            {
                                case 1000:
                                    {
                                        for (int i = 1; i <= 3; i++)
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 200).MoveToContainer(furnace.inventory, i, false);

                                        break;
                                    }

                                case 750:
                                    {
                                        for (int i = 1; i <= 3; i++)
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 150).MoveToContainer(furnace.inventory, i, false);

                                        break;
                                    }

                                case 500:
                                    {
                                        for (int i = 1; i <= 3; i++)
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 100).MoveToContainer(furnace.inventory, i, false);

                                        break;
                                    }
                            }
                            break;
                        }

                    case (sulfurOre):
                        {
                            switch (playerData[player.userID].woodToAdd)
                            {
                                case 833:
                                    {
                                        for (int i = 1; i <= 3; i++)
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 333).MoveToContainer(furnace.inventory, i, false);

                                        break;
                                    }
                                case 750:
                                    {
                                        for (int i = 1; i <= 3; i++)
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 300).MoveToContainer(furnace.inventory, i, false);

                                        break;
                                    }

                                case 500:
                                    {
                                        for (int i = 1; i <= 3; i++)
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 200).MoveToContainer(furnace.inventory, i, false);

                                        break;
                                    }
                                case 250:
                                    {
                                        for (int i = 1; i <= 3; i++)
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, 100).MoveToContainer(furnace.inventory, i, false);

                                        break;
                                    }

                                default:
                                    {
                                        for (int i = 1; i <= 3; i++)
                                            ItemManager.CreateByItemID(playerData[player.userID].ore, playerData[player.userID].oreToAdd).MoveToContainer(furnace.inventory, i, false);

                                        break;
                                    }
                            }
                            break;
                        }

                    case (hqOre):
                        {
                            switch (playerData[player.userID].woodToAdd)
                            {
                                case 1000:
                                    {
                                        switch (playerData[player.userID].oreToAdd)
                                        {
                                            case 216:
                                                ItemManager.CreateByItemID(playerData[player.userID].ore, 100).MoveToContainer(furnace.inventory, 1, false);
                                                ItemManager.CreateByItemID(playerData[player.userID].ore, 83).MoveToContainer(furnace.inventory, 2, false);
                                                ItemManager.CreateByItemID(playerData[player.userID].ore, 33).MoveToContainer(furnace.inventory, 3, false);

                                                break;

                                            case 200:
                                                ItemManager.CreateByItemID(playerData[player.userID].ore, 100).MoveToContainer(furnace.inventory, 1, false);
                                                ItemManager.CreateByItemID(playerData[player.userID].ore, 100).MoveToContainer(furnace.inventory, 2, false);

                                                break;
                                        }

                                        break;
                                    }
                                
                            }
                            break;
                        }

                    default:
                        return;
                }
            }
        }
        #endregion methods

        #region UI
        private CuiElementContainer CreateUi(BasePlayer player, BaseOven oven)
        {
            float uiScale = 1.0f;
            int contentSize = Convert.ToInt32(10 * uiScale);
            string toggleButtonColor = "0.415 0.5 0.258 0.4"; 
            string toggleButtonTextColor = "0.607 0.705 0.431"; 

            DestroyUI(player);

            Vector2 uiPosition = new Vector2(
                ((((0.6505f) - 0.5f) * uiScale) + 0.5f),
                (0.042f - 0.02f) + 0.02f * uiScale);
            
            Vector2 uiSize = new Vector2(0.1785f * uiScale, 0.111f * uiScale);

            CuiElementContainer result = new CuiElementContainer();
            string rootPanelName = result.Add(new CuiPanel
            {
                Image = new CuiImageComponent
                {
                    Color = "0 0 0 0"
                },
                RectTransform =
                {
                    AnchorMin = uiPosition.x + " " + uiPosition.y,
                    AnchorMax = uiPosition.x + uiSize.x + " " + (uiPosition.y + uiSize.y)
                }
            }, "Hud.Menu");

            string contentPanel = result.Add(new CuiPanel
            {
                Image = new CuiImageComponent
                {
                    Color = "0.65 0.65 0.65 0.06"
                },
                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 0.74"
                }
            }, rootPanelName);

            // Toggle button
            result.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "0.02 0.65",  
                    AnchorMax = "0.25 0.95"
                },
                Button =
                {
                    Command = "optimalburn.split",
                    Color = toggleButtonColor
                },
                Text =
                {
                    Align = TextAnchor.MiddleCenter,
                    Text = "Optimize",
                    Color = toggleButtonTextColor,
                    FontSize = Convert.ToInt32(11 * uiScale)
                }
            }, contentPanel);

            openUis.Add(player.userID, rootPanelName);
            CuiHelper.AddUi(player, result);
            return result;
        }

        private void DestroyUI(BasePlayer player)
        {
            if (!openUis.ContainsKey(player.userID))
                return;

            string uiName = openUis[player.userID];

            if (openUis.Remove(player.userID))
                CuiHelper.DestroyUi(player, uiName);
        }

        private void DestroyOvenUI(BaseOven oven)
        {
            if (oven == null) throw new ArgumentNullException(nameof(oven));

            foreach (KeyValuePair<ulong, string> kv in openUis.ToDictionary(kv => kv.Key, kv => kv.Value))
            {
                BasePlayer player = BasePlayer.FindByID(kv.Key);

                BaseOven playerLootOven = player.inventory.loot?.entitySource as BaseOven;

                if (oven == playerLootOven)
                {
                    DestroyUI(player);
                }
            }
        }
        #endregion UI

        #region helpers
        private bool HasPermission(BasePlayer player)
        {
            return permission.UserHasPermission(player.UserIDString, permUse);
        }

        private string Lang(string key, string userId = null, params object[] args) => string.Format(lang.GetMessage(key, this, userId), args);
        #endregion helpers
    }
}

// --- End of file: OptimalBurn.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ore-bonus-radius-modifier ---
// --- Original File Path: O/OreBonusRadiusModifier/OreBonusRadiusModifier.cs ---

using System;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Ore Bonus Radius Modifier", "Ryz0r", "1.0.1")]
    [Description("Allows you to modify the size of an Ore Bonus (hotspot) radius")]
    public class OreBonusRadiusModifier : RustPlugin
    {
        private static Configuration _config;
        protected override void SaveConfig() => Config.WriteObject(_config);
        protected override void LoadDefaultConfig() => _config = new Configuration();

        private class Configuration
        {
            [JsonProperty(PropertyName = "Bonus Radius (Default 0.15)")]
            public float BonusRadius = 1f;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        private void OnEntitySpawned(OreHotSpot spot) => NextTick(() =>
        {
            spot.GetComponent<SphereCollider>().radius = _config.BonusRadius;
        });

        private void OnServerInitialized()
        {
            foreach (var spot in BaseNetworkable.serverEntities.OfType<OreHotSpot>())
            {
                OnEntitySpawned(spot);
            }
        }

        private void Unload()
        {
            foreach (var spot in BaseNetworkable.serverEntities.OfType<OreHotSpot>())
            {
                spot.GetComponent<SphereCollider>().radius = 0.15f;
            }
        }
    }
}

// --- End of file: OreBonusRadiusModifier.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/object-remover ---
// --- Original File Path: O/ObjectRemover/ObjectRemover.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Object Remover", "Iv Misticos", "3.0.5")]
    [Description("Removes furnaces, lanterns, campfires, buildings etc. on command")]
    class ObjectRemover : RustPlugin
    {
        #region Variables
        
        private const string ShortnameCupboard = "cupboard.tool";

        #endregion

        #region Configuration

        private Configuration _config = new Configuration();

        private class Configuration
        {
            [JsonProperty(PropertyName = "Object Command Permission")]
            public string PermissionObject = "objectremover.use";
            
            [JsonProperty(PropertyName = "Statistics Command Permission")]
            public string PermissionStatistics = "objectremover.statistics";
            
            [JsonProperty(PropertyName = "Object Command")]
            public string CommandObject = "object";
            
            [JsonProperty(PropertyName = "Statistics Command")]
            public string CommandStatistics = "objtop";
            
            public string Prefix = "[<color=#ffbf00> Object Remover </color>] ";
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion
        
        #region Hooks

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "No Rights", "You do not have enough rights" },
                { "Count", "We found {count} entities in {time}s." },
                { "Removed", "You have removed {count} entities in {time}s." },
                { "Help", "Object command usage:\n" +
                          "/object (entity) [parameters]\n" +
                          "Parameters:\n" +
                          "action count/remove - Count or remove entities\n" +
                          "radius NUM - Radius\n" +
                          "inside true/false - Entities inside the cupboard\n" +
                          "outside true/false - Entities outside the cupboard" },
                { "No Console", "Please log in as a player to use that command" },
                { "Statistics Header", "Objects Statistics:" },
                { "Statistics Entry", "\n#{position} - {shortname} x {count}" },
                { "Statistics Footer", "\nDone." }
            }, this);
        }

        private void OnServerInitialized()
        {
            LoadDefaultMessages();
            LoadConfig();
            
            permission.RegisterPermission(_config.PermissionObject, this);
            permission.RegisterPermission(_config.PermissionStatistics, this);

            AddCovalenceCommand(_config.CommandObject, nameof(CommandObject));
            AddCovalenceCommand(_config.CommandStatistics, nameof(CommandStatistics));
        }
        
        #endregion

        #region Commands

        private void CommandObject(IPlayer player, string command, string[] args)
        {
            var prefix = player.IsServer ? string.Empty : _config.Prefix;
            if (!player.HasPermission(_config.PermissionObject))
            {
                player.Reply(prefix + GetMsg("No Rights", player.Id));
                return;
            }

            if (args.Length < 1)
            {
                player.Reply(prefix + GetMsg("Help", player.Id));
                return;
            }

            var options = new RemoveOptions();
            options.Parse(args);
            if (player.IsServer)
                options.Radius = 0f;
            
            var entity = args[0];
            var position = (player.Object as BasePlayer)?.transform.position ?? Vector3.zero;
            var before = Time.realtimeSinceStartup;
            var objects = FindObjects(position, entity, options);
            var count = objects.Count;

            if (!options.Count)
            {
                for (var i = 0; i < count; i++)
                {
                    var ent = objects[i];
                    if (ent == null || ent.IsDestroyed)
                        continue;
                    ent.Kill();
                }
            }

            player.Reply(prefix + GetMsg(options.Count ? "Count" : "Removed", player.Id)
                             .Replace("{count}", count.ToString()).Replace("{time}",
                                 (Time.realtimeSinceStartup - before).ToString("0.###")));
        }

        private void CommandStatistics(IPlayer player, string command, string[] args)
        {
            var prefix = player.IsServer ? string.Empty : _config.Prefix;
            if (!player.HasPermission(_config.PermissionStatistics))
            {
                player.Reply(prefix + GetMsg("No Rights", player.Id));
                return;
            }

            int amount;
            if (args == null || args.Length == 0 || !int.TryParse(args[0], out amount))
                amount = 10;

            var entities = new Dictionary<string, int>();

            using (var enumerator = BaseNetworkable.serverEntities.GetEnumerator())
            {
                while (enumerator.MoveNext())
                {
                    var entity = enumerator.Current;
                    if (entity == null)
                        continue;

                    var shortname = entity.ShortPrefabName;
                    if (entities.ContainsKey(shortname))
                        entities[shortname]++;
                    else
                        entities[shortname] = 1;
                }
            }

            player.Reply(prefix + GetMsg("Statistics Header", player.Id));
            
            var builder = new StringBuilder();
            using (var enumerator = entities.OrderByDescending(x => x.Value).Take(amount).GetEnumerator())
            {
                var currentPosition = 1;
                while (enumerator.MoveNext())
                {
                    builder.Length = 0;
                    builder.Append(GetMsg("Statistics Entry", player.Id));
                    builder.Replace("{position}", $"{currentPosition++}");
                    builder.Replace("{shortname}", $"{enumerator.Current.Key}");
                    builder.Replace("{count}", $"{enumerator.Current.Value}");
                    player.Reply(prefix + builder);
                }
            }
            
            player.Reply(prefix + GetMsg("Statistics Footer", player.Id));
        }

        #endregion
        
        #region Remove Options

        private class RemoveOptions
        {
            public float Radius = 0f;
            public bool Count = true;
            public bool OutsideCupboard = true;
            public bool InsideCupboard = true;

            public void Parse(string[] args)
            {
                for (var i = 1; i + 1 < args.Length; i += 2)
                {
                    switch (args[i])
                    {
                        case "a":
                        case "action":
                        {
                            Count = args[i + 1] != "remove";

                            break;
                        }
                        
                        case "r":
                        case "radius":
                        {
                            if (!float.TryParse(args[i + 1], out Radius))
                                Radius = 0f;

                            break;
                        }

                        case "oc":
                        case "outside":
                        {
                            if (!bool.TryParse(args[i + 1], out OutsideCupboard))
                                OutsideCupboard = true;
                            
                            break;
                        }

                        case "ic":
                        case "inside":
                        {
                            if (!bool.TryParse(args[i + 1], out InsideCupboard))
                                InsideCupboard = true;

                            break;
                        }
                    }
                }
            }
        }
        
        #endregion

        #region Helpers

        private List<BaseEntity> FindObjects(Vector3 startPos, string entity, RemoveOptions options)
        {
            var entities = new List<BaseEntity>();
            var isAll = entity.Equals("all");
            if (options.Radius > 0)
            {
                var entitiesList = new List<BaseEntity>();
                Vis.Entities(startPos, options.Radius, entitiesList);
                var entitiesCount = entitiesList.Count;
                for (var i = entitiesCount - 1; i >= 0; i--)
                {
                    var ent = entitiesList[i];

                    if (IsNeededObject(ent, entity, isAll, options))
                        entities.Add(ent);
                }
            }
            else
            {
                var ents = UnityEngine.Object.FindObjectsOfType<BaseEntity>();
                var entsCount = ents.Length;
                for (var i = 0; i < entsCount; i++)
                {
                    var ent = ents[i];
                    if (IsNeededObject(ent, entity, isAll, options))
                        entities.Add(ent);
                }
            }

            return entities;
        }

        private bool IsNeededObject(BaseEntity entity, string shortname, bool isAll, RemoveOptions options)
        {
            return (isAll || entity.ShortPrefabName.IndexOf(shortname, StringComparison.CurrentCultureIgnoreCase) != -1) &&
                   (options.InsideCupboard && entity.GetBuildingPrivilege() != null ||
                    options.OutsideCupboard && entity.GetBuildingPrivilege() == null);
        }

        private string GetMsg(string key, string userId = null) => lang.GetMessage(key, this, userId);

        #endregion
    }
}

// --- End of file: ObjectRemover.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/oil-rig-discord-notify ---
// --- Original File Path: O/OilRigDiscordNotify/OilRigDiscordNotify.cs ---

using Newtonsoft.Json;
using Oxide.Core.Libraries;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Oil Rig Discord Notify", "Dana", "0.0.6")]
    [Description("Notifies when the hackable locked crate in both Oil Rigs gets activated.")]
    internal class OilRigDiscordNotify : RustPlugin
    {
        //[DiscordClient] DiscordClient Client;
        private Configuration config;
        private Timer LoginCheck;
        const float calgon = 0.0066666666666667f;
        public Dictionary<string, Vector3> GridInfo = new Dictionary<string, Vector3>();
        Vector3 SmallOilRigPos; // OilrigAI2 = monumentinfo.name
        Vector3 BigOilRigPos; // OilrigAI = monumentinfo.name

        public class Configuration
        {
            [JsonProperty(PropertyName = "Plugin - Enabled")]
            public bool Enabled { get; set; } = true;

            [JsonProperty(PropertyName = "Discord - Webhook URL")]
            public string DiscordWebHookUrl { get; set; }

            [JsonProperty(PropertyName = "Discord - Mention Roles (Roles IDs)")]
            public List<string> MentionRoles { get; set; } = new List<string>();

            [JsonProperty(PropertyName = "Discord - Message - Text")]
            public string MessageText { get; set; } = "Oil Rig Hackable Locked Crate has been activated by {0} {1} and 15 minutes timer count down has started.";

            [JsonProperty(PropertyName = "Discord - Embed - Image - URLs")]
            public List<string> EmbedImages { get; set; } = new List<string>() { "https://i.imgur.com/gqctTxU.png", "https://i.imgur.com/1V54pdo.png", "https://i.imgur.com/HFuYyC9.png" };

            [JsonProperty(PropertyName = "Discord - Embed - Image - Randomly Select (false = use the first, true = random)")]
            public bool SelectRandomImage { get; set; } = true;

            [JsonProperty(PropertyName = "Discord - Embed - Color")]
            public int EmbedColor { get; set; } = 3092790;

            [JsonProperty(PropertyName = "Discord - Embed - Field 1 Title")]
            public string EmbedField1Title { get; set; } = "Monument Type";

            [JsonProperty(PropertyName = "Discord - Embed - Field 2 Title")]
            public string EmbedField2Title { get; set; } = "Direction";
        }

        enum Direction { North, South, East, West };

        private void Init()
        {
            config = Config.ReadObject<Configuration>();
        }

        protected override void LoadDefaultConfig()
        {
            config = new Configuration();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        private void OnServerInitialized()
        {
            var monuments = UnityEngine.Object.FindObjectsOfType<MonumentInfo>();
            foreach (var monument in monuments)
            {
                if (monument.name == "OilrigAI") // Small rig
                {
                    SmallOilRigPos = monument.transform.position;
                }
                else if (monument.name == "OilrigAI2") // Big rig
                {
                    BigOilRigPos = monument.transform.position;
                }
            }
        }

        Direction GetDirection(Vector3 location)
        {
            // The grid is split up with an X in the middle
            // location.y is up/down
            var x = location.x;
            var z = location.z;
            if (z > 0)
            {
                // Northern vicinity
                if (x > 0)
                {
                    // Eastern vicinity
                    if (x < z) return Direction.North;
                    else return Direction.East;
                }
                else
                {
                    // Western vicinity
                    x = Math.Abs(x);
                    if (x < z) return Direction.North;
                    else return Direction.West;
                }
            }
            else
            {
                // Southern vicinity
                if (x > 0)
                {
                    // Eastern vicinity
                    z = Math.Abs(z);
                    if (x < z) return Direction.South;
                    else return Direction.East;
                }
                else
                {
                    // Western vicinity
                    x = Math.Abs(x);
                    z = Math.Abs(z);
                    if (x < z) return Direction.South;
                    else return Direction.West;
                }
            }
        }

        bool isOnRig(Vector3 rigVector, Vector3 pos)
        {
            return Math.Sqrt(Math.Pow(Math.Abs(rigVector.x - pos.x), 2) + Math.Pow(Math.Abs(rigVector.z - pos.z), 2)) <= 30;
        }

        void CanHackCrate(BasePlayer player, HackableLockedCrate crate)
        {
            if (!config.Enabled)
                return;

            if (isOnRig(BigOilRigPos, crate.transform.position))
            {
                AccountForRoles(true, player);
            }
            else if (isOnRig(SmallOilRigPos, crate.transform.position))
            {
                AccountForRoles(false, player);
            }
        }

        void AccountForRoles(bool bigRig, BasePlayer hacker)
        {
            if (config.MentionRoles.Count == 0)
            {
                SendToDiscordBot(bigRig, hacker);
                return;
            }
            var mentions = "";
            foreach (var roleId in config.MentionRoles)
            {
                mentions += $"<@&{roleId}> ";
            }
            SendToDiscordBot(bigRig, hacker, mentions);
        }

        void SendToDiscordBot(bool bigRig, BasePlayer hacker, string mentions = null)
        {
            var imageURL = config.EmbedImages.Count == 0 ? "" : config.SelectRandomImage ? config.EmbedImages[UnityEngine.Random.Range(0, config.EmbedImages.Count)] : config.EmbedImages[0];
            var dir = GetDirection(bigRig ? BigOilRigPos : SmallOilRigPos);
            var embed = new WebHookEmbed
            {
                Image = new WebHookImage
                {
                    Url = imageURL
                },
                Color = config.EmbedColor,
                Fields = new List<WebHookField>
                {
                    new WebHookField
                    {
                        Name = config.EmbedField1Title,
                        Value = bigRig ? "Large Oil Rig" : "Small Oil Rig",
                        Inline = true
                    },
                    new WebHookField
                    {
                        Name = config.EmbedField2Title,
                        Value =  dir == Direction.North ? "North" : dir == Direction.South ? "South" : dir == Direction.East ? "East" : "West",
                        Inline = true
                    }
                }
            };

            var contentBody = new WebHookContentBody
            {
                Content = $"{mentions}{string.Format(config.MessageText, hacker.displayName, hacker.userID)}"
            };
            var embedBody = new WebHookEmbedBody
            {
                Embeds = new[]
                {
                    embed
                }
            };
            webrequest.Enqueue(config.DiscordWebHookUrl, JsonConvert.SerializeObject(contentBody, new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore }),
                (headerCode, headerResult) =>
                {
                    if (headerCode >= 200 && headerCode <= 204)
                    {
                        webrequest.Enqueue(config.DiscordWebHookUrl, JsonConvert.SerializeObject(embedBody, new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore }),
                            (code, result) => { }, this, RequestMethod.POST,
                            new Dictionary<string, string> { { "Content-Type", "application/json" } });
                    }
                }, this, RequestMethod.POST,
                new Dictionary<string, string> { { "Content-Type", "application/json" } });
        }

        private class WebHookEmbedBody
        {
            [JsonProperty(PropertyName = "embeds")]
            public WebHookEmbed[] Embeds;
        }

        private class WebHookContentBody
        {
            [JsonProperty(PropertyName = "content")]
            public string Content;
        }

        private class WebHookEmbed
        {
            [JsonProperty(PropertyName = "title")]
            public string Title;

            [JsonProperty(PropertyName = "type")]
            public string Type = "rich";

            [JsonProperty(PropertyName = "description")]
            public string Description;

            [JsonProperty(PropertyName = "color")]
            public int Color;

            [JsonProperty(PropertyName = "author")]
            public WebHookAuthor Author;

            [JsonProperty(PropertyName = "image")]
            public WebHookImage Image;

            [JsonProperty(PropertyName = "fields")]
            public List<WebHookField> Fields;

            [JsonProperty(PropertyName = "footer")]
            public WebHookFooter Footer;
        }
        private class WebHookAuthor
        {
            [JsonProperty(PropertyName = "name")]
            public string Name;

            [JsonProperty(PropertyName = "url")]
            public string AuthorUrl;

            [JsonProperty(PropertyName = "icon_url")]
            public string AuthorIconUrl;
        }
        private class WebHookImage
        {
            [JsonProperty(PropertyName = "proxy_url")]
            public string ProxyUrl;

            [JsonProperty(PropertyName = "url")]
            public string Url;

            [JsonProperty(PropertyName = "height")]
            public int? Height;

            [JsonProperty(PropertyName = "width")]
            public int? Width;
        }
        private class WebHookField
        {
            [JsonProperty(PropertyName = "name")]
            public string Name;

            [JsonProperty(PropertyName = "value")]
            public string Value;

            [JsonProperty(PropertyName = "inline")]
            public bool Inline;
        }
        private class WebHookFooter
        {
            [JsonProperty(PropertyName = "text")]
            public string Text;

            [JsonProperty(PropertyName = "icon_url")]
            public string IconUrl;

            [JsonProperty(PropertyName = "proxy_icon_url")]
            public string ProxyIconUrl;
        }
    }
}

// --- End of file: OilRigDiscordNotify.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/oil-rig-wipe-protection ---
// --- Original File Path: O/OilRigWipeProtection/OilRigWipeProtection.cs ---

using Newtonsoft.Json;
using Oxide.Core.Libraries;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Oil Rig Wipe Protection", "Strrobez", "1.0.2")]
    [Description("Block people from activating oil rig X amount of minutes after a map wipe.")]
    class OilRigWipeProtection : RustPlugin
    {
        private const string CratePrefab = "assets/prefabs/deployable/chinooklockedcrate/codelockedhackablecrate_oilrig.prefab";
        private const string permEnabled = "oilrigwipeprotection.enabled";
        private const string permBypass = "oilrigwipeprotection.bypass";
        private DateTime _cachedWipeTime;

        #region Config & Localization
        protected override void LoadDefaultConfig()
        {
            Config["ShowBlockMessage"] = true;
            Config["WipeBlockMinutes"] = 600;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["BlockMessage"] = "You can't start the crate yet, please wait another {0} minutes.",
            }, this);
        }
        #endregion

        #region Oxide Hooks
        private void Init()
        {
            permission.RegisterPermission(permEnabled, this);
            permission.RegisterPermission(permBypass, this);
        }

        private void OnServerInitialized()
        {
            _cachedWipeTime = SaveRestore.SaveCreatedTime;
        }

        private object CanHackCrate(BasePlayer player, HackableLockedCrate crate)
        {

            if (crate.PrefabName == CratePrefab)
            {
                if (!permission.UserHasPermission(player.UserIDString, permEnabled)) return null;

                if (permission.UserHasPermission(player.UserIDString, permBypass)) return null;

                DateTime wipeBlockOver = _cachedWipeTime.AddMinutes((int)Config["WipeBlockMinutes"]);
                int timeLeft = (int)(DateTime.UtcNow - wipeBlockOver).TotalMinutes;

                if ((wipeBlockOver > DateTime.UtcNow)) return null;

                if ((bool)Config["ShowBlockMessage"])
                {
                    string message = lang.GetMessage("BlockMessage", this, player.UserIDString);
                    player.ChatMessage(string.Format(message, timeLeft.ToString()));
                }

                return true;
            }

            return null;
        }
        #endregion
    }
}


// --- End of file: OilRigWipeProtection.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/offline-doors ---
// --- Original File Path: O/OfflineDoors/OfflineDoors.cs ---

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Offline Doors", "Slydelix", "1.1.2", ResourceId = 2782)]
    class OfflineDoors : RustPlugin
    {
        [PluginReference] Plugin Clans;
        #region Lang

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                {"Clans_detected", "Clans plugin detected"},
                {"Clans_notInstalled_first", "Clans plugin is not installed, will check again in 30 seconds"},
                {"Clans_notInstalled", "Clans plugin is not installed!"},
                {"noperm", "You don't have permission to use this command."},
                {"turnedoff", "<color=silver>Turned <color=red>off</color> automatic door closing on disconnect</color>"},
                {"turnedon", "<color=silver>Turned <color=green>on</color> automatic door closing on disconnect, your doors will now close when you disconnect</color>"},
            }, this);
        }

        #endregion

        private const string perm = "offlinedoors.use";
        private bool usePerms, useClans;

        #region Config

        protected override void LoadDefaultConfig()
        {
            Config["Use permissions"] = usePerms = GetConfig("Use permissions", false);
            Config["Use clans (closes doors only when last clan memeber goes offline)"] = useClans = GetConfig("Use clans (closes doors only when last clan memeber goes offline)", false);
            SaveConfig();
        }
            
        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null) return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        #endregion

        #region Data

        private class StoredData
        {
            public Dictionary<ulong, bool> players = new Dictionary<ulong, bool>();

            public StoredData()
            {
            }
        }

        private StoredData storedData;

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(this.Name, storedData, true);

        #endregion

        #region Hooks

        private void OnUserConnected(IPlayer player)
        {
            ulong ID = ulong.Parse(player.Id);
            if (!storedData.players.ContainsKey(ID)) storedData.players.Add(ID, true);
        }

        private void Init()
        {
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(this.Name);
            permission.RegisterPermission(perm, this);
            LoadDefaultConfig();
        }

        private void Loaded()
        {
            if (useClans && Clans == null)
            {
                PrintWarning(lang.GetMessage("Clans_notInstalled_first", this));
                timer.In(30f, () => {
                    if (Clans == null)
                    {
                        PrintWarning(lang.GetMessage("Clans_notInstalled", this));
                        return;
                    }

                    else PrintWarning(lang.GetMessage("Clans_detected", this));
                });
            }
        }

        private void Unload() => SaveData();

        private void OnServerSave() => SaveData();

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (!useClans)
            {
                ClosePlayerDoors(player);
                return;
            }

            var clan = Clans?.Call<string>("GetClanOf", player.userID) ?? string.Empty;
            if (string.IsNullOrEmpty(clan))
            {
                //Not in clan/clan plugin is missing
                ClosePlayerDoors(player);
                return;
            }

            var clannies = GetOnlineClanMembers(clan);
            if (clannies.Contains(player.userID)) clannies.Remove(player.userID);

            if (clannies.Count == 0)
            {
                ClosePlayerDoors(player);
                return;
            }
            return;
        }

        #endregion

        #region Methods

        private List<ulong> GetOnlineClanMembers(string clanName)
        {
            List<ulong> IDlist = new List<ulong>();

            if (string.IsNullOrEmpty(clanName) || Clans == null) return IDlist;

            //Attempting to filter out as much as possible because there can be quite a lot of players
            foreach (var p in covalence.Players.All.Where(x => x.IsConnected))
            {
                var id = ulong.Parse(p.Id);
                string clan = Clans?.Call<string>("GetClanOf", id) ?? string.Empty;

                if (clan == clanName) IDlist.Add(id);
            }

            return IDlist;
        }

        private void ClosePlayerDoors(BasePlayer player)
        {
            if (usePerms && !permission.UserHasPermission(player.UserIDString, perm)) return;
            if (!storedData.players.ContainsKey(player.userID)) storedData.players.Add(player.userID, true);
            if (!storedData.players[player.userID]) return;

            var entList = BaseEntity.saveList.Where(x => (x as Door) != null && x.OwnerID == player.userID).ToList();
            if (entList.Count == 0) return;

            foreach (var item in entList)
            {
                if (item == null) continue;
                if (item.IsOpen()) (item as Door).CloseRequest();
            }
        }

        #endregion

        #region Command

        [ChatCommand("ofd")]
        private void offlinedoorscmd(BasePlayer player, string command, string[] args)
        {
            if (usePerms && !permission.UserHasPermission(player.UserIDString, perm))
            {
                SendReply(player, lang.GetMessage("noperm", this, player.UserIDString));
                return;
            }

            if (!storedData.players.ContainsKey(player.userID)) storedData.players.Add(player.userID, true);

            if (storedData.players[player.userID])
            {
                storedData.players[player.userID] = false;
                SaveData();
                SendReply(player, lang.GetMessage("turnedoff", this, player.UserIDString));
                return;
            }

            storedData.players[player.userID] = true;
            SaveData();
            SendReply(player, lang.GetMessage("turnedon", this, player.UserIDString));
            return;
        }

        #endregion
    }
}

// --- End of file: OfflineDoors.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/other-building-health ---
// --- Original File Path: O/OtherBuildingHealth/OtherBuildingHealth.cs ---

using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Other Building Health", "Judess69er", "1.6.3")]
    [Description("Multiply the health of other building materials")]
    class OtherBuildingHealth : RustPlugin
    {
        [PluginReference] Plugin RaidableBases;

        private const uint HIGH_EXTERNAL_ICE_WALL = 921229511;
        private const uint DISCO_FLOOR = 286648290;
        private const uint DISCO_FLOOR_LARGE = 1735402444;

        #region Config
        private ConfigData config;

        private class ConfigData
        {
            [JsonProperty("Health Multiplier")]
            public float Multiplier { get; set; }
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData
            {
                Multiplier = 2.0f
            };
            SaveConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<ConfigData>();
            SaveConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config, true);
        }
        #endregion Config
		#region Load
        private void Init()
        {
            Unsubscribe(nameof(OnEntitySpawned));            
        }

        private void OnServerInitialized(bool isStartup)
        {
            foreach (Door door in BaseNetworkable.serverEntities.OfType<Door>().Where(door => isViable(door)))
            {
                door._maxHealth *= config.Multiplier;
                door.health *= config.Multiplier;
                door.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                if(config.Multiplier == 0) return;
            }
			
            foreach (SimpleBuildingBlock block in BaseNetworkable.serverEntities.OfType<SimpleBuildingBlock>().Where(block => isViable(block)))
            {
            block._maxHealth *= config.Multiplier;
            block.health *= config.Multiplier;
            block.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            if(config.Multiplier == 0) return;
            }

            foreach (Barricade barricade in BaseNetworkable.serverEntities.OfType<Barricade>().Where(barricade => isViable(barricade)))
            {
            barricade._maxHealth *= config.Multiplier;
            barricade.health *= config.Multiplier;
            barricade.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            if(config.Multiplier == 0) return;
            }
			
            foreach (StorageContainer container in BaseNetworkable.serverEntities.OfType<StorageContainer>().Where(container => isViable(container)))
            {
            container._maxHealth *= config.Multiplier;
            container.health *= config.Multiplier;
            container.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            if(config.Multiplier == 0) return;
            }
			
            foreach (IceFence fence in BaseNetworkable.serverEntities.OfType<IceFence>().Where(fence => isViable(fence)))
            {
            if (fence.prefabID != HIGH_EXTERNAL_ICE_WALL) return;
            fence._maxHealth *= config.Multiplier;
            fence.health *= config.Multiplier;
            fence.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            if(config.Multiplier == 0) return;
		    }
            Subscribe(nameof(OnEntitySpawned));
        }
		#endregion Load
		#region Unload
        private void Unload()
        {
            foreach (Door door in BaseNetworkable.serverEntities.OfType<Door>().Where(door => isViable(door)))
            {
                door._maxHealth /= config.Multiplier;
                door.health /= config.Multiplier;
                door.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                if(config.Multiplier == 0) return;
            }

            foreach (SimpleBuildingBlock block in BaseNetworkable.serverEntities.OfType<SimpleBuildingBlock>().Where(block => isViable(block)))
            {
            block._maxHealth /= config.Multiplier;
            block.health /= config.Multiplier;
            block.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            if(config.Multiplier == 0) return;
            }

            foreach (Barricade barricade in BaseNetworkable.serverEntities.OfType<Barricade>().Where(barricade => isViable(barricade)))
            {
            barricade._maxHealth /= config.Multiplier;
            barricade.health /= config.Multiplier;
            barricade.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            if(config.Multiplier == 0) return;
            }
			
            foreach (StorageContainer container in BaseNetworkable.serverEntities.OfType<StorageContainer>().Where(container => isViable(container)))
            {
            container._maxHealth /= config.Multiplier;
            container.health /= config.Multiplier;
            container.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            if(config.Multiplier == 0) return;
            }
			
            foreach (IceFence fence in BaseNetworkable.serverEntities.OfType<IceFence>().Where(fence => isViable(fence)))
            {
            if (fence.prefabID != HIGH_EXTERNAL_ICE_WALL) return;
            fence._maxHealth /= config.Multiplier;
            fence.health /= config.Multiplier;
            fence.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            if(config.Multiplier == 0) return;
		    }
        }
		#endregion Unload
		#region Spawn
        private void OnEntitySpawned(Door door)
        {
            if (door != null && isViable(door))
            {
                door._maxHealth *= config.Multiplier;
                door.health *= config.Multiplier;
                door.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                if(config.Multiplier == 0) return;
            }
        }

        private void OnEntitySpawned(SimpleBuildingBlock block)
        {
            block._maxHealth *= config.Multiplier;
            block.health *= config.Multiplier;
            block.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            if(config.Multiplier == 0) return;
        }

        private void OnEntitySpawned(Barricade barricade)
        {
            barricade._maxHealth *= config.Multiplier;
            barricade.health *= config.Multiplier;
            barricade.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            if(config.Multiplier == 0) return;
        }
		
        private void OnEntitySpawned(StorageContainer container)
        {
            container._maxHealth *= config.Multiplier;
            container.health *= config.Multiplier;
            container.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            if(config.Multiplier == 0) return;
        }

        private void OnEntitySpawned(IceFence fence)
        {
            if (fence.prefabID != HIGH_EXTERNAL_ICE_WALL) return;
            fence._maxHealth *= config.Multiplier;
            fence.health *= config.Multiplier;
            fence.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            if(config.Multiplier == 0) return;
		}

        private bool isViable(BaseEntity entity)
        {
            if (entity.OwnerID != 0) return true;
            return RaidableBases != null && Convert.ToBoolean(RaidableBases?.Call("EventTerritory", entity.transform.position));
        }
		#endregion Spawn
    }
}

// --- End of file: OtherBuildingHealth.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/own-casino ---
// --- Original File Path: O/OwnCasino/OwnCasino.cs ---

﻿using Oxide.Core.Libraries.Covalence;
using UnityEngine;
using System.Collections.Generic;
using Physics = UnityEngine.Physics;

namespace Oxide.Plugins
{
    [Info("Own Casino", "NooBlet", "1.0.6")]
    [Description("Make your own Casino Free version")]
    public class OwnCasino : CovalencePlugin
    {
        #region Vars
        private const ulong skinIDwheel = 2763733280;
        private const ulong skinIDterminal = 2763733201;
        private const string wheelprefab = "assets/prefabs/misc/casino/bigwheel/big_wheel.prefab";
        private const string terminalprefab = "assets/prefabs/misc/casino/bigwheel/bigwheelbettingterminal.prefab";
        private const string chairprefab = "assets/prefabs/deployable/chair/chair.deployed.prefab";
        private static OwnCasino plugin;
        static List<string> effects = new List<string>
        {
        "assets/bundled/prefabs/fx/item_break.prefab",
        "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
        };

        #endregion Vars

        #region Hooks
        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            RunChecks(go.ToBaseEntity());
        }

        private void RunChecks(BaseEntity baseEntity)
        {
            CheckDeployTermanal(baseEntity);
            CheckDeployWheel(baseEntity);
        }

        private void OnHammerHit(BasePlayer player, HitInfo info)
        {
            CheckHit(player, info?.HitEntity);

        }
        private void Loaded()
        {
            CheckchildClass();
        }
        private void CheckchildClass()
        {
            timer.Every(600f, () =>
            {
                foreach (var w in BigWheelGame.serverEntities)
                {
                    var wheel = w?.GetComponent<BigWheelGame>();
                    if (wheel == null) continue;
                    if (wheel.OwnerID != 0)
                    {
                        if (!wheel.HasComponent<WheelComponent>())
                        {
                            wheel.gameObject.AddComponent<WheelComponent>();
                            Puts("wheel checked and fixed");
                        }
                    }
                }
              
            });

        }

        #endregion Hooks

        #region Wheel Stuff
        private void CheckDeployWheel(BaseEntity entity)
        {
            if (entity == null)
            {
                return;
            }

            if (!IsWheel(entity.skinID))
            {
                return;
            }


            var transform = entity.transform;
            SpawnWheel(transform.position, transform.rotation, entity.OwnerID);
            entity.transform.position -= new Vector3(0, 3, 0);
            entity.SendNetworkUpdate();
            NextTick(() => { entity?.Kill(); });
        }

        private bool IsWheel(ulong skin)
        {
            return skin == skinIDwheel;
        }

        private void SpawnWheel(Vector3 position, Quaternion rotation = default(Quaternion), ulong ownerID = 0)
        {
            var newpos = new Vector3(position.x, position.y + 1, position.z + 0.2f);
            var wheel = GameManager.server.CreateEntity(wheelprefab, newpos, rotation);
            if (wheel == null)
            {
                return;
            }
            var transform = wheel.transform;
            var old = transform.eulerAngles;

            old.z -= 90;
            old.y -= 90;
            transform.eulerAngles = old;
            wheel.OwnerID = ownerID;
            wheel.gameObject.AddComponent<WheelComponent>();
            wheel.Spawn();
        }

        private void CheckHit(BasePlayer player, BaseEntity entity)
        {
            if (entity == null)
            {
                return;
            }
            if (player.userID == entity.OwnerID)
            {
                if (IsWheel(entity.skinID))
                {

                    timer.Once(0.2f, () =>
                    {
                        if (entity.IsValid() == true)
                        {
                            entity.GetComponent<WheelComponent>()?.TryPickup(player);
                        }
                    });
                }

               
            }
        }


        #endregion Wheel Stuff

        #region Terminal Stuff

        private void CheckDeployTermanal(BaseEntity entity)
        {
            if (entity == null)
            {
                return;
            }

            if (!IsTermanal(entity.skinID))
            {
                return;
            }

            var transform = entity.transform;
            SpawnTerminal(transform.position, transform.rotation, entity.OwnerID);
            entity.transform.position -= new Vector3(0, 3, 0);
            entity.SendNetworkUpdate();
            NextTick(() => { entity?.Kill(); });
        }
        private bool IsTermanal(ulong skin)
        {
            return skin == skinIDterminal;
        }

        private void SpawnTerminal(Vector3 position, Quaternion rotation = default(Quaternion), ulong ownerID = 0)
        {
            var newpos = new Vector3(position.x + 0.8f, position.y, position.z - 0.3f);
            var Terminal = GameManager.server.CreateEntity(terminalprefab, newpos, rotation);
            var chair = GameManager.server.CreateEntity(chairprefab, position, rotation);
            if (Terminal == null || chair == null)
            {
                return;
            }
            chair.OwnerID = ownerID;
            chair.Spawn();
            Terminal.SetParent(chair);
            Terminal.OwnerID = ownerID;
            Terminal.transform.localPosition = new Vector3(0.8f, 0, 0.2f);
            Terminal.transform.localRotation = Quaternion.Euler(new Vector3(0, -90, 0));
            Terminal.SetFlag(BigWheelBettingTerminal.Flags.On, true);
            Terminal.SendNetworkUpdateImmediate();
            Terminal.Spawn();
        }

        #endregion Termanal stuff

        #region Commands

        [Command("casino")]
        private void casinoCommand(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;
            if (player == null) { return; }  // no intent dor console command .. only ingame use
            if (player.IsAdmin)
            {
                player.ChatMessage(string.Format(GetLang("GiveItems", player.UserIDString)));
                GiveItems(player);
            }
            else
            {
                player.ChatMessage(string.Format(GetLang("NoUse", player.UserIDString)));
            }
        }



        #endregion Commands

        #region Item Creation
        private void GiveItems(BasePlayer player)
        {
            var items = CreateItems();

            if (items != null && player != null)
            {
                foreach (var i in items)
                {
                    player.GiveItem(i);
                }
                player.ChatMessage(string.Format(GetLang("GiveItems", player.UserIDString)));

            }
        }

        private Item[] CreateItems()
        {
            var wheel = ItemManager.CreateByName("sign.wooden.large", 1);
            var terminal = ItemManager.CreateByName("chair", 1);
            if (wheel != null || terminal != null)
            {
                wheel.name = "adminbigwheel";
                wheel.skin = skinIDwheel;
                terminal.name = "admintermanal";
                terminal.skin = skinIDterminal;
            }
            Item[] items = { wheel, terminal };
            return items;
        }
        #endregion Item Creation

        #region Classes

        private class WheelComponent : MonoBehaviour
        {
            private BigWheelGame wheel;

            private void Awake()
            {
                wheel = GetComponent<BigWheelGame>();
                InvokeRepeating("CheckGround", 5f, 5f);


            }
            private void CheckGround()
            {
                RaycastHit rhit;
                var cast = Physics.Raycast(wheel.transform.position + new Vector3(0, -0.6f, 0), Vector3.down,
                    out rhit, 21f, LayerMask.GetMask("Terrain", "Construction"));

                var entity = rhit.GetEntity();
                if (entity != null)
                {
                    if (isGroundMissing(entity))
                    {
                        GroundMissing();
                    }
                }
                else
                {
                    GroundMissing();
                }
            }
            bool isGroundMissing(BaseEntity entity)
            {
                if (entity.ShortPrefabName.Contains("foundation")) { return false; }
                if (entity.ShortPrefabName.Contains("floor")) { return false; }

                return true;
            }


            private void GroundMissing()
            {
                foreach (var effect in effects) { Effect.server.Run(effect, wheel.transform.position); }
                wheel.Kill();
            }
            public void TryPickup(BasePlayer player)
            {
                var info = default(SlotMachinePayoutSettings.PayoutInfo);
                Effect.server.Run(info.OverrideWinEffect.resourcePath, wheel.transform.position);
                wheel.Kill();
                plugin.GiveItems(player);
            }

            public void DoDestroy()
            {
                Destroy(this);
            }
        }



      

        #endregion Classes

        #region Lang API

        private string GetLang(string key, string id) => lang.GetMessage(key, this, id);
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoUse"] = "You are not allowed to use this command!",
                ["GiveItems"] = "Casino Items Given!",

            }, this, "en");
        }

        #endregion Lang API

    }
}

// --- End of file: OwnCasino.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/offline-mail ---
// --- Original File Path: O/OfflineMail/OfflineMail.cs ---

﻿using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Offline Mail", "redBDGR", "1.0.2")]
    [Description("Send messages to a player so they receive them on their next login")]
    public class OfflineMail : CovalencePlugin
    {
        private DynamicConfigFile offlineMessageData;
        StoredData storedData;

        class StoredData
        {
            public Dictionary<string, MessageInfo> offlineMessageInformation = new Dictionary<string, MessageInfo>();
        }

        // For Config (do not touch)
        bool Changed = false;

        // Config variables
        public const string permissionName = "offlinemail.use";
        public const string permissionNameADMIN = "offlinemail.admin";
        public string consoleName = "Admin";
        public float waitTime = 3.0f;
        Dictionary<string, MessageInfo> playerMessages = new Dictionary<string, MessageInfo>();

        class MessageInfo
        {
            public string senderName;
            public List<string> messages;
        }

        // Method of saving data
        void SaveData()
        {
            storedData.offlineMessageInformation = playerMessages;
            offlineMessageData.WriteObject(storedData);
        }

        // Method of loading data
        void LoadData()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
                playerMessages = storedData.offlineMessageInformation;
            }
            catch
            {
                Puts("Failed to load data, creating new file");
                storedData = new StoredData();
            }
        }

        // Save data on unload
        void Unload()
        {
            SaveData();
        }

        // Save data on server save
        void OnServerSave()
        {
            SaveData();
        }

        // Register permissions, load data / config variables
        void Init()
        {
            permission.RegisterPermission(permissionName, this);
            permission.RegisterPermission(permissionNameADMIN, this);
            LoadData();
            LoadVariables();
            offlineMessageData = Interface.Oxide.DataFileSystem.GetFile(Name);
        }

        // Config
        void LoadVariables()
        {
            consoleName = Convert.ToString(GetConfig("Settings", "Console Name", "Admin"));
            waitTime = Convert.ToSingle(GetConfig("Settings", "Message Delay Time", 3.0f));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                //chat
                ["Login Message"] = "[{0}] {1}: <color=#00FFFF>{2}</color>",
                ["Message Stored"] = "Your message to {0} has been sent. They will receive it next time they log in!",
                ["Player Online"] = "This player is currently online! your message has not been saved",
                ["Player not Found"] = "Player not found!",
                ["No Permissions"] = "You do not have the correct permissions to use this command",
                ["You received mail!"] = "<color=#00FFFF>You have received new mail since you were last online!</color>",
                ["Chat Invalid Syntax /om"] = "Invalid syntax! /om <steamID/playername> <message>",
                ["Chat Invalid Syntax /omclear"] = "Invalid syntax! /omclear steamID/playername>",
                ["Console Invalid Syntax omclear"] = "Invalid syntax! /omclear steamID/playername>",
                ["Console Invalid Syntax om"] = "Invalid syntax! om <steamID/playername> <message>",
                ["Empty Inbox"] = "This user currently has no messages in their inbox!",
                ["Clear Inbox"] = "Wiping {0}'s inbox!",
            }, this);
        }

        // Checks on player Init if the player has any outstanding mail
        void OnUserConnected(IPlayer player)
        {
            if (playerMessages.ContainsKey(player.Id))
            {
                timer.Once(waitTime, () =>
                {
                    player.Message(msg("You received mail!", player.Id));
                    int y = 1;
                    foreach (string x in playerMessages[player.Id].messages)
                    {
                        player.Message(string.Format(msg("Login Message", player.Id), y, playerMessages[player.Id].senderName, x));
                        y += 1;
                    }
                    playerMessages.Remove(player.Id);
                });
            }
        }

        // Chat command for sending offline mail to players
        [Command("mail")]
        void sendomCMD(IPlayer player, string command, string[] args)
        {
            if (player.HasPermission(permissionName))
            {
                if (args == null)
                {
                    player.Message(msg("Chat Invalid Syntax", player.Id));
                    return;
                }
                if (args.Length != 2)
                {
                    player.Message(msg("Chat Invalid Syntax", player.Id));
                    return;
                }
                var targetUser = players.FindPlayer(args[0]);
                if (targetUser == null)
                {
                    player.Message(msg("Player not Found", player.Id));
                    return;
                }
                if (!targetUser.IsConnected)
                {
                    if (!playerMessages.ContainsKey(targetUser.Id))
                    {
                        playerMessages.Add(targetUser.Id, new MessageInfo { messages = new List<string>(), senderName = player.Name.ToString() });
                        playerMessages[targetUser.Id].messages.Add(args[1]);
                        player.Message(string.Format(msg("Message Stored", player.Id), targetUser.Name));
                        return;
                    }
                    else if (playerMessages[targetUser.Id].messages.Count == 0)
                    {
                        playerMessages[targetUser.Id].messages.Add(args[1]);
                        player.Message(string.Format(msg("Message Stored", player.Id), targetUser.Name));
                        return;
                    }
                    else
                    {
                        playerMessages[targetUser.Id].messages.Add(args[1]);
                        player.Message(string.Format(msg("Message Stored", player.Id), targetUser.Name));
                        return;
                    }
                }
                else
                {
                    player.Message(msg("Player Online", player.Id));
                    return;
                }
            }
            else
            {
                player.Message(msg("No Permissions", player.Id));
                return;
            }
        }

        [Command("clearmail")]
        void omclearCMD(IPlayer player, string command, string[] args)
        {
            if (player.HasPermission(permissionNameADMIN))
            {
                if (args.Length != 1 || args == null)
                {
                    player.Message(msg("Chat Invalid Syntax /omclear", player.Id));
                    return;
                }
                var targetUser = players.FindPlayer(args[0]);
                if (targetUser == null)
                {
                    player.Message(msg("Player not Found", player.Id));
                    return;
                }
                if (playerMessages.ContainsKey(targetUser.Id))
                {
                   player.Message(string.Format(msg("Clear Inbox", player.Id), targetUser.Name));
                   playerMessages.Remove(targetUser.Id);
                }
                else
                {
                    player.Message(msg("Empty Inbox", player.Id));
                    return;
                }
            }
            else
            {
                player.Message(msg("No Permissions", player.Id));
                return;
            }
        }

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
        string msg(string key, string id = null) => lang.GetMessage(key, this, id);
    }
}


// --- End of file: OfflineMail.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/on-screen-logo ---
// --- Original File Path: O/OnScreenLogo/OnScreenLogo.cs ---

using Oxide.Core;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections;
using System.IO;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("OnScreenLogo", "Vlad-00003", "1.1.5", ResourceId = 2601)]
    [Description("Displays the button on the player screen.")]
    //Author info:
    //E-mail: Vlad-00003@mail.ru
    //Vk: vk.com/vlad_00003
    class OnScreenLogo : RustPlugin
    {
        private string PanelName = "GsAdX1wazasdsHs";
        private string Image = null;
        static OnScreenLogo instance;

        #region Config Setup
        private string Amax = "0.34 0.105";
        private string Amin = "0.26 0.025";
        private string ImageAddress = "https://fedoraproject.org/w/uploads/e/ee/Edition-server-full_one-color_black.png";
        #endregion

        #region Initialization
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating default configuration file...");
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            GetConfig("Image. Link or name of the file in the data folder", ref ImageAddress);
            GetConfig("Minimum anchor", ref Amin);
            GetConfig("Maximum anchor", ref Amax);
            if (!ImageAddress.ToLower().Contains("http"))
            {
                ImageAddress = "file://" + Interface.Oxide.DataDirectory + Path.DirectorySeparatorChar + ImageAddress;
            }
            permission.RegisterPermission("OnScreenLogo.refresh", this);
            LoadData();
            SaveConfig();
        }
        private void LoadData()
        {
            try
            {
                Image = Interface.Oxide.DataFileSystem.ReadObject<string>(Title);
            }
            catch (Exception ex)
            {
                if(ex is MissingMethodException)
                {
                    Image = null;
                    return;
                }
                RaiseError($"Failed to load data file. ({ex.Message})\nThe image would now be re-downloaded.");
                Image = null;
            }
        }
        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Title, Image);
        }
        void OnServerInitialized()
        {
            instance = this;
            if (Image == null)
                DownloadImage();
            else
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    CreateButton(player);
                }
        }
        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, PanelName);
            }
        }
        #endregion

        #region Image Downloading
        [ConsoleCommand("osl.refresh")]
        private void cmdRedownload(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.player != null)
            {
                BasePlayer player = arg.Connection.player as BasePlayer;

                if (!permission.UserHasPermission(player.UserIDString, "OnScreenLogo.refresh"))
                    return;
            }
            DownloadImage();
        }
        private void DownloadImage()
        {
            PrintWarning("Downloading image...");
            ServerMgr.Instance.StartCoroutine(DownloadImage(ImageAddress));
        }
        IEnumerator DownloadImage(string url)
        {
            using (var www = new WWW(url))
            {
                yield return www;
                if (instance == null) yield break;
                if (www.error != null)
                {
                    PrintError($"Failed to add image. File address possibly invalide\n {url}");
                }
                else
                {
                    var tex = www.texture;
                    byte[] bytes = tex.EncodeToPNG();
                    Image = FileStorage.server.Store(bytes, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString();
                    SaveData();
                    PrintWarning("Image download is complete.");
                    foreach (BasePlayer player in BasePlayer.activePlayerList)
                    {
                        CreateButton(player);
                    }
                    UnityEngine.Object.DestroyImmediate(tex);
                    yield break;
                }
            }
        }
        #endregion

        #region UI
        void OnPlayerSleepEnded(BasePlayer player) => CreateButton(player);
        private void CreateButton(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelName);
            CuiElementContainer elements = new CuiElementContainer();
            var panel = elements.Add(new CuiPanel
            {
                Image = {
                    Color = "0.00 0.00 0.00 0.00"
                },
                RectTransform = {
                    AnchorMin = Amin,
                    AnchorMax = Amax
                },
                CursorEnabled = false
            }, "Overlay", PanelName);
            var comp = new CuiRawImageComponent { Sprite = "assets/content/textures/generic/fulltransparent.tga" };
            if (Image != null)
            {
                comp.Png = Image;
            }
            elements.Add(new CuiElement
            {
                Parent = PanelName,
                Components =
                {
                    comp,
                    new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });
            CuiHelper.AddUi(player, elements);
        }
        #endregion

        #region Helpers
        private void GetConfig<T>(string Key, ref T var)
        {
            if (Config[Key] != null)
            {
                var = (T)Convert.ChangeType(Config[Key], typeof(T));
            }
            Config[Key] = var;
        }
        #endregion
    }
}

// --- End of file: OnScreenLogo.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/offline-ladder-block ---
// --- Original File Path: O/OfflineLadderBlock/OfflineLadderBlock.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using System.Linq;
using Oxide.Core.Plugins;
using UnityEngine;
using Facepunch;

namespace Oxide.Plugins
{
    [Info("Offline Ladder Block", "Chepzz", "1.0.1")]
    [Description("Prevents ladders being placed if the entity owner is offline.")]
    public class OfflineLadderBlock : RustPlugin
    {
        #region Fields

        const string bypassPerm = "offlineladderblock.bypass";

        #endregion

        #region Configuration

        Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "OfflineLadderBlock Options")]
            public PluginOptions POptions = new PluginOptions();
        }

        public class PluginOptions
        {
            [JsonProperty(PropertyName = "Chat Icon (Steam64ID)")]
            public ulong chatIcon = 0;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Localization

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TargetOffline"] = "<color=#C0C0C0>The owner of the base you are trying to ladder in to is offline.</color>"
            }, this);
        }

        #endregion

        #region Core Methods

        private void Loaded()
        {
            permission.RegisterPermission(bypassPerm, this);
        }


        object CanBuild(Planner planner, Construction prefab, Construction.Target target)
        {
            if (planner == null || prefab == null || target.entity == null) return null;

            BasePlayer player = planner.GetOwnerPlayer();

            var targetPlayer = BasePlayer.Find(target.entity.OwnerID.ToString());

            if (targetPlayer == null || !targetPlayer.IsConnected)
            {
                PrintMsg(player, Lang("TargetOffline", player.UserIDString));
                return true;
            }

            return null;
        }



        #endregion

        #region Helpers

        private void PrintMsg(BasePlayer player, string message) => Player.Message(player, message, config.POptions.chatIcon);

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion
    }
}


// --- End of file: OfflineLadderBlock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/freeze ---
// --- Original File Path: F/Freeze/Freeze.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
#if RUST
using UnityEngine;
#endif

namespace Oxide.Plugins
{
    [Info("Freeze", "Wulf", "3.0.3")]
    [Description("Prevents players from moving, and optionally prevents chat, commands, and damage")]
    internal class Freeze : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        private class Configuration
        {
            [JsonProperty("Block chat while frozen")]
            public bool BlockChat = true;

            [JsonProperty("Block commands while frozen")]
            public bool BlockCommands = true;

            [JsonProperty("Block damage while frozen")]
            public bool BlockDamage = true;

            [JsonProperty("Block movement while frozen")]
            public bool BlockMovement = true;
#if RUST
            [JsonProperty("Enable frozen effect")]
            public bool EnableEffect = true;
#endif
            [JsonProperty("Notify target when frozen")]
            public bool NotifyTarget = true;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandFreeze"] = "freeze",
                ["CommandFreezeAll"] = "freezeall",
                ["CommandUnfreeze"] = "unfreeze",
                ["CommandUnfreezeAll"] = "unfreezeall",
                ["NoPlayersFound"] = "No players found with '{0}'",
                ["NoPlayersToFreeze"] = "No players to freeze",
                ["NoPlayersToUnfreeze"] = "No players to unfreeze",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["PlayerFrozen"] = "{0} has been frozen",
                ["PlayerIsProtected"] = "{0} is protected and cannot be frozen",
                ["PlayerIsFrozen"] = "{0} is already frozen",
                ["PlayerNotFrozen"] = "{0} is not frozen",
                ["PlayerUnfrozen"] = "{0} has been unfrozen",
                ["PlayersFound"] = "Multiple players were found, please specify: {0}",
                ["PlayersFrozen"] = "All players have been frozen",
                ["PlayersUnfrozen"] = "All players have been unfrozen",
                ["UsageFreeze"] = "Usage: {0} <player name or id>",
                ["YouCanNotBeFrozen"] = "You can not be frozen",
                ["YouAreFrozen"] = "You are frozen",
                ["YouWereUnfrozen"] = "You were unfrozen"
            }, this);
        }

        #endregion Localization

        #region Initialization

        private readonly Dictionary<string, Timer> timers = new Dictionary<string, Timer>();

        private const string permFrozen = "freeze.frozen";
        private const string permProtect = "freeze.protect";
        private const string permUse = "freeze.use";

        [PluginReference]
        private Plugin BetterChat;

        private void Init()
        {
            AddLocalizedCommand(nameof(CommandFreeze));
            AddLocalizedCommand(nameof(CommandFreezeAll));
            AddLocalizedCommand(nameof(CommandUnfreeze));
            AddLocalizedCommand(nameof(CommandUnfreezeAll));

            permission.RegisterPermission(permFrozen, this);
            permission.RegisterPermission(permProtect, this);
            permission.RegisterPermission(permUse, this);

            if (!config.BlockChat || BetterChat != null && BetterChat.IsLoaded)
            {
                Unsubscribe(nameof(OnUserChat));
            }
            if (!config.BlockCommands)
            {
                Unsubscribe(nameof(OnUserCommand));
            }
            if (!config.BlockDamage)
            {
#if RUST
                Unsubscribe(nameof(OnEntityTakeDamage));
#endif
            }
#if RUST
            if (!config.EnableEffect)
            {
                Unsubscribe(nameof(OnPlayerMetabolize));
                Unsubscribe(nameof(OnUserPermissionRevoked));
            }
#endif
        }

        #endregion Initialization

        #region Freeze Command

        private void CommandFreeze(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permUse))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args.Length < 1)
            {
                Message(player, "UsageFreeze", command);
                return;
            }

            IPlayer target = FindPlayer(args[0], player);
            if (target == null)
            {
                return;
            }

            if (target.Id == player.Id)
            {
                Message(player, "YouCanNotBeFrozen");
                return;
            }

            if (target.HasPermission(permProtect))
            {
                Message(player, "PlayerIsProtected", target.Name.Sanitize());
            }
            else if (target.HasPermission(permFrozen))
            {
                Message(player, "PlayerIsFrozen", target.Name.Sanitize());
            }
            else
            {
                FreezePlayer(target);

                if (config.NotifyTarget)
                {
                    Message(target, "YouAreFrozen");
                }
                Message(player, "PlayerFrozen", target.Name.Sanitize());
            }
        }

        #endregion Freeze Command

        #region Freeze All Command

        private void CommandFreezeAll(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permUse))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            foreach (IPlayer target in players.Connected)
            {
                if (!target.HasPermission(permProtect) && !target.HasPermission(permFrozen))
                {
                    if (target.Id != player.Id)
                    {
                        FreezePlayer(target);

                        if (config.NotifyTarget)
                        {
                            Message(target, "YouAreFrozen");
                        }
                    }
                }
            }

            Message(player, players.Connected.Any() ? "PlayersFrozen" : "NoPlayersToFreeze");
        }

        #endregion Freeze All Command

        #region Unfreeze Command

        private void CommandUnfreeze(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permUse))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args.Length < 1)
            {
                Message(player, "UsageFreeze", command);
                return;
            }

            IPlayer target = FindPlayer(args[0], player);
            if (target == null)
            {
                return;
            }

            if (target.HasPermission(permFrozen))
            {
                UnfreezePlayer(target);

                Message(target, "YouWereUnfrozen", target.Id);
                Message(player, "PlayerUnfrozen", target.Name.Sanitize());
            }
            else
            {
                Message(player, "PlayerNotFrozen", target.Name.Sanitize());
            }
        }

        #endregion Unfreeze Command

        #region Unfreeze All Command

        private void CommandUnfreezeAll(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permUse))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            foreach (IPlayer target in players.Connected)
            {
                if (target.HasPermission(permFrozen))
                {
                    UnfreezePlayer(target);

                    if (target.IsConnected)
                    {
                        Message(target, "YouWereUnfrozen");
                    }
                }
            }

            Message(player, players.Connected.Any() ? "PlayersUnfrozen" : "NoPlayersToUnfreeze");
        }

        #endregion Unfreeze All Command

        #region Freeze Handling

        private void FreezePlayer(IPlayer player)
        {
            player.GrantPermission(permFrozen);

            if (config.BlockMovement)
            {
                GenericPosition pos = player.Position();
                timers[player.Id] = timer.Every(0.1f, () =>
                {
                    if (!player.IsConnected)
                    {
                        timers[player.Id].Destroy();
                        return;
                    }

                    if (!player.HasPermission(permFrozen))
                    {
                        UnfreezePlayer(player);
                    }
                    else
                    {
                        player.Teleport(pos.X, pos.Y, pos.Z);
                    }
                });
            }
        }

        private void UnfreezePlayer(IPlayer player)
        {
            player.RevokePermission(permFrozen);

            if (timers.ContainsKey(player.Id))
            {
                timers[player.Id].Destroy();
            }
        }

        private object OnUserCommand(IPlayer player)
        {
            if (player.HasPermission(permFrozen))
            {
                return true;
            }

            return null;
        }

        private void OnUserConnected(IPlayer player)
        {
            if (player.HasPermission(permFrozen))
            {
                FreezePlayer(player);

                Log(GetLang("PlayerFrozen", null, player.Name.Sanitize()));
            }
        }

        private object OnUserChat(IPlayer player)
        {
            if (player.HasPermission(permFrozen))
            {
                return true;
            }

            return null;
        }

        private object OnBetterChat(Dictionary<string, object> data)
        {
            if ((data["Player"] as IPlayer).HasPermission(permFrozen))
            {
                data["CancelOption"] = 1;
                return data;
            }

            return null;
        }

        private void OnServerInitialized()
        {
            foreach (IPlayer player in players.Connected)
            {
                if (player.HasPermission(permFrozen))
                {
                    FreezePlayer(player);

                    Log(GetLang("PlayerFrozen", null, player.Name.Sanitize()));
                }
            }
        }

#if RUST

        private void OnPlayerMetabolize(PlayerMetabolism metabolism, BasePlayer basePlayer)
        {
            if (permission.UserHasPermission(basePlayer.UserIDString, permFrozen))
            {
                metabolism.temperature.SetValue(-50f);
                metabolism.SendChangesToClient();

                Vector3 breathPosition = basePlayer.eyes.position + Quaternion.Euler(basePlayer.serverInput.current.aimAngles) * new Vector3(0, 0, 0.2f);
                Effect.server.Run("assets/bundled/prefabs/fx/player/frosty_breath.prefab", breathPosition);
            }
        }

        private void OnEntityTakeDamage(BasePlayer basePlayer, HitInfo hitInfo)
        {
            if (permission.UserHasPermission(basePlayer.UserIDString, permFrozen) && hitInfo != null
                || hitInfo?.InitiatorPlayer != null && permission.UserHasPermission(hitInfo.InitiatorPlayer.UserIDString, permFrozen))
            {
                hitInfo.damageTypes = new global::Rust.DamageTypeList();
                hitInfo.HitMaterial = 0;
                hitInfo.PointStart = Vector3.zero;
            }
        }

        private void OnUserPermissionRevoked(string playerId, string perm)
        {
            IPlayer player = players.FindPlayerById(playerId);
            BasePlayer basePlayer = player?.Object as BasePlayer;
            if (basePlayer != null)
            {
                basePlayer.metabolism.temperature.Reset();
                basePlayer.metabolism.SendChangesToClient();
            }
        }

#endif

        #endregion Freeze Handling

        #region Helpers

        private IPlayer FindPlayer(string playerNameOrId, IPlayer player)
        {
            IPlayer[] foundPlayers = players.FindPlayers(playerNameOrId).ToArray();
            if (foundPlayers.Length > 1)
            {
                Message(player, "PlayersFound", string.Join(", ", foundPlayers.Select(p => p.Name).Take(10).ToArray()).Truncate(60));
                return null;
            }

            IPlayer target = foundPlayers.Length == 1 ? foundPlayers[0] : null;
            if (target == null)
            {
                Message(player, "NoPlayersFound", playerNameOrId);
                return null;
            }

            return target;
        }

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (message.Key.Equals(command))
                    {
                        if (!string.IsNullOrEmpty(message.Value))
                        {
                            AddCovalenceCommand(message.Value, command);
                        }
                    }
                }
            }
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string textOrLang, params object[] args)
        {
            if (player.IsConnected)
            {
                string message = GetLang(textOrLang, player.Id, args);
                player.Reply(message != textOrLang ? message : textOrLang);
            }
        }

        #endregion Helpers
    }
}


// --- End of file: Freeze.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/finder ---
// --- Original File Path: F/Finder/Finder.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Finder", "MON@H", "3.1.1")]
    [Description("Find Players, SleepingBags, Doors, Sleepers, and teleport to them")]
    public class Finder : CovalencePlugin
    {
        #region Initialization
        [PluginReference] private Plugin PlayerDatabase;

        private Dictionary<ulong, PlayerFinder> cachedFinder = new Dictionary<ulong, PlayerFinder>();

        private const string PERMISSION_FIND = "finder.find";
        private const string PERMISSION_TP = "finder.tp";

        private void Init()
        {
            permission.RegisterPermission(PERMISSION_FIND, this);
            permission.RegisterPermission(PERMISSION_TP, this);
            foreach (var command in configData.chatS.commands)
                AddCovalenceCommand(command, nameof(CmdFind));
        }

        private void OnServerInitialized()
        {
            UpdateConfig();
        }

        private void UpdateConfig()
        {
            if (configData.chatS.commands.Length == 0)
                configData.chatS.commands = new[] { "find" };
            SaveConfig();
        }

        #endregion Initialization

        #region Configuration

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Global settings")]
            public GlobalSettings globalS = new GlobalSettings();

            [JsonProperty(PropertyName = "Chat settings")]
            public ChatSettings chatS = new ChatSettings();

            public class GlobalSettings
            {
                [JsonProperty(PropertyName = "Use permissions")]
                public bool usePermission = true;

                [JsonProperty(PropertyName = "Allow admins to use without permission")]
                public bool adminsAllowed = true;
            }

            public class ChatSettings
            {
                [JsonProperty(PropertyName = "Chat command")]
                public string[] commands = new[] { "find" };
                [JsonProperty(PropertyName = "Chat prefix")]
                public string prefix = "<color=#00FFFF>[Finder]</color>: ";

                [JsonProperty(PropertyName = "Chat steamID icon")]
                public ulong steamIDIcon = 0;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                    LoadDefaultConfig();
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        #endregion Configuration

        #region Localization

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "You do not have permission to use this command",
                ["MultiplePlayers"] = "Multiple players found",
                ["NoResults"] = "You didn't find anything yet.",
                ["OutOfRange"] = "This ID is out of range.",
                ["NoPlayers"] = "No matching players found.",
                ["NoPosition"] = "This player doesn't have a position.",
                ["NoBuildings"] = "This player hasn't built anything yet.",
                ["NoBags"] = "This player doesn't have any sleeping bags.",
                ["NoCupboardPrivileges"] = "This player doesn't have any cupboard privileges.",
                ["SelectTargetPlayer"] = "You need to select a target player.",
                ["SelectTargetFindID"] = "You need to select a target findid.",
                ["CantTP"] = "You are using the console, you can't tp!",
                ["ItemUsage"] = "Usage: <color=#FFFF00>/{0} item <ITEMNAME> <MINAMOUNT> optional:<STEAMID></color>.",
                ["InvalidItemName"] = "You didn't use a valid item name.",
                ["SyntaxError"] = "Syntax error occured!\n" +
                "type <color=#FFFF00>/{0} <h | help></color> to view help",
                ["FindSyntax"] = "Command usages:\n" +
                "<color=#FFFF00>/{0} <p | player> <PLAYERNAME | STEAMID></color> - Find player with ID / all players with partial names.\n" +
                "<color=#FFFF00>/{0} <c | cupboard> <PLAYERNAME | STEAMID></color> - Find all cupboards owned by a specific player.</color>\n" +
                "<color=#FFFF00>/{0} bag <PLAYERNAME | STEAMID></color> - Find all sleeping bags owned by a specific player.\n" +
                "<color=#FFFF00>/{0} <b | building> <PLAYERNAME | STEAMID></color> - Find all buildings owned by a specific player.\n" +
                "<color=#FFFF00>/{0} <i | item> <ITEMNAME> <MINAMOUNT></color> - Find all items owned by a specific player.\n" +
                "<color=#FFFF00>/{0} tp FINDID</color> - Teleport to any of your results.",
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "У вас нет разрешения на использование этой команды",
                ["MultiplePlayers"] = "Найдено несколько игроков",
                ["NoResults"] = "Вы ещё ничего не нашли.",
                ["OutOfRange"] = "Этот ID вне допустимого диапазона.",
                ["NoPlayers"] = "Подходящих игроков не найдено.",
                ["NoPosition"] = "У этого игрока нет позиции.",
                ["NoBuildings"] = "Этот игрок еще ничего не построил.",
                ["NoBags"] = "У этого игрока нет спальных мешков.",
                ["NoCupboardPrivileges"] = "Этот игрок не авторизирован ни в одном шкафу.",
                ["SelectTargetPlayer"] = "Вам нужно выбрать целевого игрока.",
                ["SelectTargetFindID"] = "Вам нужно выбрать целевой findID.",
                ["CantTP"] = "Вы используете консоль, вы не можете tp!",
                ["ItemUsage"] = "Использование: <color=#FFFF00>/{0} item <ITEMNAME> <MINAMOUNT> optional:<STEAMID></color>.",
                ["InvalidItemName"] = "Вы использовали неверное название предмета.",
                ["SyntaxError"] = "Синтаксическая ошибка!\n" +
                "напишите <color=#FFFF00>/{0} <h | help></color> чтобы отобразить подсказки",
                ["FindSyntax"] = "Использование команд:\n" +
                "<color=#FFFF00>/{0} <p | player> <PLAYERNAME | STEAMID></color> - Найти игрока по ID / всех игроков с частичным совпадением имён\n" +
                "<color=#FFFF00>/{0} <c | cupboard> <PLAYERNAME | STEAMID></color> - Найти все шкафы, принадлежащие определенному игроку\n" +
                "<color=#FFFF00>/{0} bag <PLAYERNAME | STEAMID></color> - Найти все спальные мешки, принадлежащие определенному игроку\n" +
                "<color=#FFFF00>/{0} <b | building> <PLAYERNAME | STEAMID></color> - Найти все здания, принадлежащие определенному игроку\n" +
                "<color=#FFFF00>/{0} <i | item> <ITEMNAME> <MINAMOUNT></color> - Найти все предметы, принадлежащие определенному игроку\n" +
                "<color=#FFFF00>/{0} tp FINDID</color> - Телепортация к любому из ваших результатов",
            }, this, "ru");
        }

        #endregion Localization

        #region Commands

        private void CmdFind(IPlayer iplayer, string command, string[] args)
        {
            var player = (iplayer.Object as BasePlayer);
            string returnstring = string.Empty;

            if(!hasPermission(iplayer, "find"))
            {
                Print(iplayer, Lang("NotAllowed", player.UserIDString));
                return;
            }

            if (args == null || args.Length == 0)
            {
                Print(iplayer, Lang("SyntaxError", player.UserIDString, configData.chatS.commands[0]));
                return;
            }

            var puserid = player == null ? 0L : player.userID;
            switch(args[0].ToLower())
            {
                case "h":
                case "help":
                    Print(iplayer, Lang("FindSyntax", player.UserIDString, configData.chatS.commands[0]));
                    return;
                case "b":
                case "bag":
                case "building":
                case "c":
                case "cupboard":
                case "p":
                case "player":
                    if(args.Length == 1)
                    {
                        Print(iplayer, Lang("SelectTargetPlayer", player.UserIDString));
                        return;
                    }
                    var f = FindPlayerID(args[1], player);
                    if(!(f is ulong))
                    {
                        Print(iplayer, f.ToString());
                        return;
                    }
                    ulong targetID = (ulong)f;
                    var d = GetPlayerInfo(targetID);
                    returnstring = d.ToString() + ":\n";
                    switch (args[0].ToLower())
                    {
                        case "p":                        
                        case "player":
                            var p = FindPosition(targetID);
                            if(p == null)
                            {
                                returnstring += Lang("NoPosition", player.UserIDString);
                            }
                            else 
                                d.AddFind("Position", (Vector3)p, string.Empty);
                            break;                            
                        case "bag":
                            var bs = SleepingBag.FindForPlayer(targetID, true).ToList();
                            if (bs.Count == 0)
                            {
                                returnstring += Lang("NoBags", player.UserIDString);
                            }
                            foreach(var b in bs)
                            {
                                d.AddFind(b.ShortPrefabName, b.transform.position, b.niceName);
                            }
                            break;
                        case "c":
                        case "cupboard":
                            var cs = Resources.FindObjectsOfTypeAll<BuildingPrivlidge>().Where(x => x.authorizedPlayers.Any((ProtoBuf.PlayerNameID z) => z.userid == targetID)).ToList();
                            if(cs.Count== 0)
                            {
                                returnstring += Lang("NoCupboardPrivileges", player.UserIDString);
                            }
                            foreach(var c in cs)
                            {
                                d.AddFind("Tool Cupboard", c.transform.position, string.Empty);
                            }
                            break;
                        case "b":
                        case "building":
                            var bb = Resources.FindObjectsOfTypeAll<BuildingBlock>().Where(x => x.OwnerID == targetID).ToList();
                            if (bb.Count == 0)
                            {
                                returnstring += Lang("NoBuildings", player.UserIDString);
                            }
                            var dic = new Dictionary<uint, Dictionary<string, object>>();
                            foreach(var b in bb)
                            {
                                if(!dic.ContainsKey(b.buildingID))
                                {
                                Puts("b.transform.position = " + b.transform.position.ToString());
                                    dic.Add(b.buildingID, new Dictionary<string, object>
                                    {
                                        {"pos", b.transform.position },
                                        {"num", 0 }
                                    });
                                }
                                dic[b.buildingID]["num"] = (int)dic[b.buildingID]["num"] + 1;
                            }
                            foreach (var c in dic)
                            {
                                d.AddFind("Building", (Vector3)c.Value["pos"], c.Value["num"].ToString());
                            }
                            break;
                        default:
                            break;
                    }
                    for (int i = 0; i < d.Data.Count; i++)
                    {
                        returnstring += i.ToString() + " - " + d.Data[i].ToString() + "\n";
                    }
                    if (cachedFinder.ContainsKey(puserid))
                    {
                        cachedFinder[puserid].Data.Clear();
                        cachedFinder[puserid] = null;
                        cachedFinder.Remove(puserid);
                    }
                    cachedFinder.Add(puserid, d);
                    break;
                case "i":
                case "item":
                    if(args.Length < 3)
                    {
                        Print(iplayer, Lang("ItemUsage", player.UserIDString, configData.chatS.commands[0]));
                        return;
                    }
                    var pu = GetPlayerInfo(puserid);
                    var itemname = args[1].ToLower();
                    ulong ownerid = 0L;
                    if (args.Length > 3)
                        ulong.TryParse(args[3], out ownerid);
                    var itemamount = 0;
                    if(!(int.TryParse(args[2], out itemamount)))
                    {
                        Print(iplayer, Lang("ItemUsage", player.UserIDString, configData.chatS.commands[0]));
                        return;
                    }
                    ItemDefinition item = null;
                    for(int i = 0; i < ItemManager.itemList.Count; i++)
                    {
                        if(ItemManager.itemList[i].displayName.english.ToLower() == itemname.ToLower())
                        {
                            item = ItemManager.itemList[i];
                            break;
                        }
                    }
                    if(item == null)
                    {
                        Print(iplayer, Lang("InvalidItemName", player.UserIDString));
                        return;
                    }
                    foreach (StorageContainer sc in Resources.FindObjectsOfTypeAll<StorageContainer>())
                    {
                        ItemContainer inventory = sc.inventory;
                        if (inventory == null) continue;
                        List<Item> list = inventory.itemList.FindAll((Item x) => x.info.itemid == item.itemid);
                        int amount = 0;
                        if (amount < itemamount) continue;
                        pu.AddFind("Box", sc.transform.position, amount.ToString());
                    }
                    foreach (BasePlayer bp in Resources.FindObjectsOfTypeAll<BasePlayer>())
                    {
                        PlayerInventory inventory = player.inventory;
                        if (inventory == null) continue;
                        int amount = inventory.GetAmount(item.itemid);
                        if (amount < itemamount) continue;
                        Dictionary<string, object> scdata = new Dictionary<string, object>();
                        pu.AddFind(string.Format("{0} {1}", player.userID.ToString(), player.displayName), bp.transform.position, amount.ToString());
                    }
                    for (int i = 0; i < pu.Data.Count; i++)
                    {
                        returnstring += i.ToString() + " - " + pu.Data[i].ToString() + "\n";
                    }
                    if (cachedFinder.ContainsKey(puserid))
                    {
                        cachedFinder[puserid].Data.Clear();
                        cachedFinder[puserid] = null;
                        cachedFinder.Remove(puserid);
                    }
                    cachedFinder.Add(puserid, pu);
                    break;
                case "tp":
                    if(player == null)
                    {
                        Print(iplayer, Lang("CantTP", player.UserIDString));
                        return;
                    }
                    if(!hasPermission(iplayer, "TP"))
                    {
                        Print(iplayer, Lang("NotAllowed", player.UserIDString));
                        return;
                    }
                    if (!cachedFinder.ContainsKey(puserid))
                    {
                        Print(iplayer, Lang("NoResults", player.UserIDString));
                        return;
                    }
                    if (args.Length == 1)
                    {
                        Print(iplayer, Lang("SelectTargetFindID", player.UserIDString));
                        return;
                    }
                    var fp = cachedFinder[puserid];
                    var id = 0;
                    int.TryParse(args[1], out id);
                    if(id >= fp.Data.Count)
                    {
                        Print(iplayer, Lang("OutOfRange", player.UserIDString));
                        return;
                    }

                    var data = cachedFinder[puserid].Data[id];
                    player.MovePosition(data.Pos);
                    player.ClientRPCPlayer(null, player, "ForcePositionTo", data.Pos);
                    returnstring += data.ToString();
                    break;
                default:
                    returnstring += Lang("FindSyntax", player.UserIDString, configData.chatS.commands[0]);
                    break;
            }
            Print(iplayer, returnstring);
            return;
        }

        #endregion Commands

        #region Helpers

        bool hasPermission(IPlayer player, string perm)
        {
            if (!configData.globalS.usePermission)
                return true;
            
            if (perm.ToLower() == "find" && permission.UserHasPermission(player.Id, PERMISSION_FIND))
                return true;
            
            if (perm.ToLower() == "tp" && permission.UserHasPermission(player.Id, PERMISSION_TP))
                return true;
            
            if (configData.globalS.adminsAllowed && player.IsAdmin)
                return true;

            return false;
        }

        class FindData
        {
            string Name;
            public Vector3 Pos;
            string TypeName;

            public FindData(string TypeName, Vector3 Pos, string Name)
            {
                this.Name = Name;
                this.TypeName = TypeName;
                this.Pos = Pos;
            }

            public override string ToString()
            {
                return string.Format("{0} - {1}{2}", TypeName, Pos.ToString(), Name == string.Empty ? string.Empty : (" - " + Name));
            }            
        }

        class PlayerFinder
        {
            string Name;
            string Id;
            bool Online;

            public List<FindData> Data = new List<FindData>();

            public PlayerFinder(string Name, string Id, bool Online)
            {
                this.Name = Name;
                this.Id = Id;
                this.Online = Online;
            }
            public void AddFind(string TypeName, Vector3 Pos, string Name)
            {
                Data.Add(new FindData(TypeName, Pos, Name));
            }

            public override string ToString()
            {
                return string.Format("{0} {1} - {2}", Id, Name, Online ? "Connected" : "Offline");
            }
        }

        PlayerFinder GetPlayerInfo(ulong userID)
        {
            var steamid = userID.ToString();
            var player = covalence.Players.FindPlayer(steamid);
            if(player != null)
            {
                return new PlayerFinder(player.Name, player.Id, player.IsConnected);
            }

            if(PlayerDatabase != null)
            {
                var name = (string)PlayerDatabase?.Call("GetPlayerData", steamid, "name");
                if(name != null)
                {
                    return new PlayerFinder(name, steamid, false);
                }
            }

            return new PlayerFinder("Unknown", steamid, false);
        }

        private object FindPosition(ulong userID)
        {
            foreach (var p in BasePlayer.activePlayerList)
            {
                if (p.userID == userID)
                {
                    return p.transform.position;
                }
            }
            foreach (var p in BasePlayer.sleepingPlayerList)
            {
                if (p.userID == userID)
                {
                    return p.transform.position;
                }
            }
            return null;
        }

        private object FindPlayerID(string arg, BasePlayer source = null)
        {
            ulong userID = 0L;
            if (arg.Length == 17 && ulong.TryParse(arg, out userID))
                return userID;

            var players = covalence.Players.FindPlayers(arg).ToList();
            if(players.Count > 1)
            {
                var returnstring = Lang("MultiplePlayers", source.UserIDString) + ":\n";
                foreach(var p in players)
                {
                    returnstring += string.Format("{0} - {1}\n", p.Id, p.Name);
                }
                return returnstring;
            }
            if(players.Count == 1)
            {
                return ulong.Parse(players[0].Id);
            }

            if (PlayerDatabase != null)
            {
                string success = PlayerDatabase.Call("FindPlayer", arg) as string;
                if (success.Length == 17 && ulong.TryParse(success, out userID))
                {
                    return userID;
                }
                else
                    return success;
            }

            return Lang("NoPlayers", source.UserIDString);
        }

        private void Print(IPlayer player, string message)
        {
            var text = string.IsNullOrEmpty(configData.chatS.prefix) ? string.Empty : $"{configData.chatS.prefix}{message}";
#if RUST
            (player.Object as BasePlayer).SendConsoleCommand ("chat.add", 2, configData.chatS.steamIDIcon, text);
            return;
#endif
            player.Message(text);
        }

        #endregion Helpers
    }
}


// --- End of file: Finder.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/fps-restart ---
// --- Original File Path: F/FPSRestart/FPSRestart.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("FPS Restart", "RustySpoon342", "1.2.1")]
    [Description("Restarts the server when FPS reaches a specific target")]
    public class FPSRestart : CovalencePlugin
    {
        private Timer timerAborted;
        private Timer timerFirstCheck;
        private Timer timerLastCheck;


        #region Configuration

        private ConfigData config = new ConfigData();

        private class ConfigData
        {
            [JsonProperty(PropertyName = "FPS To Trigger Restart")]
            public float FrameRate = 100;

            [JsonProperty(PropertyName = "How Long The Restart Should Be")]
            public float RestartTime = 300;

            [JsonProperty("Show Restart Message To Server")]
            public bool ShowMessage = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {

                LoadDefaultConfig();
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Oxide Hooks

        private void OnServerInitialized()
        {
            float args = config.RestartTime;

            int offset = (int)(args + 100);

            timerFirstCheck = timer.Every(offset, FramerateFirstCheck);
        }

        private void Unload()
        {
            config = null;
            timerFirstCheck.Destroy();
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["RestartMessage"] = "The Server Has Detected Low FPS That May Cause Lag. A Restart Has Begun, stash yo' loot!",
            }, this);
        }
        #endregion

        #region Core

        private void FramerateFirstCheck()
        {
            if (Performance.report.frameRate > config.FrameRate)
            {
                return;
            }

            timerLastCheck = timer.Once(60, FramerateLastCheck);
        }

        private void FramerateLastCheck()
        {
            string msg = string.Format(lang.GetMessage("RestartMessage", this));

            float args = config.RestartTime;

            if (Performance.report.frameRate > config.FrameRate)
            {
                return;
            }

            if (config.ShowMessage)
            {
             server.Broadcast(msg);
            }

            LogWarning("The Server Has Detected Low FPS That May Cause Lag. A Restart Has Begun!");

            server.Command("restart", args);

            timerFirstCheck.Destroy();
            timerLastCheck.Destroy();

            if (timerFirstCheck.Destroyed)
            {
                int offset = (int)(args + 60);

                timerAborted = timer.Once(offset, OnServerInitialized);
            }
        }

        #endregion
    }
}


//  Copyright (C) <2021>  <RustySpoon342>
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses></https:>.


// --- End of file: FPSRestart.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/family-share-detect ---
// --- Original File Path: F/FamilyShareDetect/FamilyShareDetect.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Plugins;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Family Share Detect", "AVOCoder", "1.2.0")]
    [Description("Checks players if using Family Sharing")]
    class FamilyShareDetect : CovalencePlugin
    {
    	#region Config

        private ConfigData cfg;

        class ConfigData
        {
            [JsonProperty(PropertyName = "Broadcast Check in Console")]
            public bool broadcastConsoleCheck { get; set; }
            [JsonProperty(PropertyName = "Kick Family Sharing Player")]
            public bool kick { get; set; }
            [JsonProperty(PropertyName = "Kick only if App Owner in Server Players list")]
            public bool kickIfOwnerIsPlayer { get; set; }
            [JsonProperty(PropertyName = "Broadcast Kick in Console")]
            public bool broadcastConsoleKick { get; set; }
            [JsonProperty(PropertyName = "Log detects")]
            public bool logDetects { get; set; }
            [JsonProperty(PropertyName = "Whitelist")]
            public List<string> whitelist { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            cfg = Config.ReadObject<ConfigData>();

            var defaultCfg = GetDefaultConfigData();
            foreach (var prop in defaultCfg.GetType().GetProperties()) {
			    if (cfg.GetType().GetProperty(prop.Name).GetValue(cfg, null) == null) {
			    	cfg.GetType().GetProperty(prop.Name).SetValue(cfg, defaultCfg.GetType().GetProperty(prop.Name).GetValue(defaultCfg, null));
			    }
			}

			Config.WriteObject(cfg, true);
        }

        protected override void LoadDefaultConfig()
        {
        	cfg = GetDefaultConfigData();

            Config.WriteObject(cfg, true);
        }

        private ConfigData GetDefaultConfigData()
        {
        	return new ConfigData
            {
            	broadcastConsoleCheck = true,
            	kick = true,
            	kickIfOwnerIsPlayer = true,
            	broadcastConsoleKick = true,
            	logDetects = false,
            	whitelist = new List<string>(){
            		"76561190000000000"
            	}
            };
        }
        
        #endregion Config

        #region Lang
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["SharedDetected"] = "Family Share Detected! for steamid {0}, ownerid {1}",
                ["OwnerFound"] = "Ownerid {0} found in server player list",
                ["PlayerKick"] = "Kicking steamid {0}",
                ["KickReason"] = "Family Share is blocked",
            }, this, "en");
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        #endregion Lang

        #region Broadcasting
        private void BroadcastInConsole(string message)
        {
        	if (cfg.broadcastConsoleCheck)
        		Puts(message);
        }

        private void BroadcastKickInConsole(string message)
        {
        	if (cfg.broadcastConsoleKick)
        		Puts(message);
        }

        private void Log(string name, string message)
        {
        	if (cfg.logDetects)
            	LogToFile(name, $"[{DateTime.Now}] {message}", this);
        }
        #endregion Broadcasting

        #region Hooks

        private void OnUserConnected(IPlayer player)
        {
        	if (cfg.whitelist.Contains(player.Id))
        		return;

            BasePlayer pl = player.Object as BasePlayer;
            if (pl == null || pl.net.connection.ownerid == 0 || pl.userID == pl.net.connection.ownerid)
                return;

            ulong ownerId = pl.net.connection.ownerid;

            BroadcastInConsole(Lang("SharedDetected", null, player.Id, ownerId));

            Log("detects", Lang("SharedDetected", null, player.Id, ownerId));

            object obj = Interface.CallHook("OnFamilyShareDetected", player, ownerId.ToString());
            if (obj != null)
                return;

            IPlayer owner = covalence.Players.FindPlayerById(ownerId.ToString());
            if (owner != null)
                BroadcastInConsole(Lang("OwnerFound", null, ownerId));

            if (!cfg.kick)
                return;

            if (cfg.kickIfOwnerIsPlayer && owner == null)
                return;

            BroadcastKickInConsole(Lang("PlayerKick", null, player.Id, ownerId));

            player.Kick(Lang("KickReason", player.Id));

        }

        #endregion Hooks

    }
}

// --- End of file: FamilyShareDetect.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/flashbang ---
// --- Original File Path: F/Flashbang/Flashbang.cs ---

﻿using System;
using System.Collections.Generic;
using Network;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Flashbang", "birthdates", "1.0.5")]
    [Description("Throw a flashbang to temporarily blind your enemies")]
    public class Flashbang : RustPlugin
    {
        #region Command

        [ConsoleCommand("flashbang")]
        private void FlashbangCommand(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null && !arg.Player().IPlayer.HasPermission(GivePermission) || arg.Args == null ||
                arg.Args.Length < 1) return;
            var amount = 1;
            var count = arg.Args.Length;
            if (arg.Args.Length > 1)
            {
                if (!int.TryParse(arg.Args[arg.Args.Length - 1], out amount)) amount = 1;
                else count--;
            }

            var player = BasePlayer.Find(string.Join(" ", arg.Args, 0, count));
            if (player == null) return;
            var item = ItemManager.CreateByName("grenade.smoke", amount, _config.SkinID);
            item.name = "Flashbang";
            player.GiveItem(item);
        }

        #endregion

        #region Variables

        /// <summary>
        ///     Layer mask containing players
        /// </summary>
        private int PlayerMask { get; } = LayerMask.GetMask("Player (Server)");

        /// <summary>
        ///     Layer mask that will obstruct a flashbang
        /// </summary>
        private int ObstructionMask { get; } = LayerMask.GetMask("Construction", "World", "Terrain");

        /// <summary>
        ///     Intense flash UI
        /// </summary>
        private CuiElementContainer FlashCui { get; } = new CuiElementContainer();

        /// <summary>
        ///     Small flash UI
        /// </summary>
        private CuiElementContainer SmallFlashCui { get; } = new CuiElementContainer();

        /// <summary>
        ///     Flashbang expiry cache
        /// </summary>
        private IDictionary<ulong, long> FlashExpiry { get; } = new Dictionary<ulong, long>();

        /// <summary>
        ///     Main CUI name (for both <see cref="Flashbang.FlashCui" /> & <see cref="Flashbang.SmallFlashCui" />)
        /// </summary>
        private const string CuiName = "Flashed";

        /// <summary>
        ///     The permission for <see cref="Flashbang.FlashbangCommand" />
        /// </summary>
        private const string GivePermission = "flashbang.give";

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(GivePermission, this);
            GenerateUI(FlashCui, "1 1 1 1");
            GenerateUI(SmallFlashCui, "1 1 1 0.6");

            // Unsub if default behaviour
            if (_config.Stack == 3) Unsubscribe(nameof(OnMaxStackable));
        }

        private void OnServerInitialized()
        {
            timer.Every(1f, CheckForExpired);
        }

        private object OnMaxStackable(Item item)
        {
            return item.skin != _config.SkinID ? (object) null : _config.Stack;
        }

        private void OnExplosiveThrown(BasePlayer player, TimedExplosive entity, ThrownWeapon item)
        {
            OnThrown(player, entity, item);
        }

        private void OnExplosiveDropped(BasePlayer player, TimedExplosive entity, ThrownWeapon item)
        {
            OnThrown(player, entity, item);
        }

        private void Unload()
        {
            // Un-flash everyone
            foreach (var entry in FlashExpiry) UnFlash(BasePlayer.FindByID(entry.Key));
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            FlashExpiry.Remove(player.userID);
        }

        #endregion

        #region Core Logic

        /// <summary>
        ///     Generate flashbang UI
        /// </summary>
        /// <param name="container">Target UI container</param>
        /// <param name="color">Flashbang color</param>
        private void GenerateUI(CuiElementContainer container, string color)
        {
            container.Add(
                new CuiPanel
                {
                    FadeOut = _config.FadeOut, Image = {Color = color},
                    RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"}
                }, "Overlay", CuiName);
        }

        /// <summary>
        ///     Check for expired flashes and clear the player's UI
        /// </summary>
        private void CheckForExpired()
        {
            foreach (var entry in new Dictionary<ulong, long>(FlashExpiry))
            {
                if (entry.Value > DateTime.UtcNow.Ticks) continue;
                var player = BasePlayer.FindByID(entry.Key);
                if (player == null)
                {
                    FlashExpiry.Remove(entry.Key);
                    continue;
                }
                UnFlash(player);
            }
        }

        /// <summary>
        ///     Is this item a flashbang?
        /// </summary>
        /// <param name="item">Target item</param>
        /// <returns>True if this item is a flashbang. False, otherwise.</returns>
        [HookMethod("IsFlashbang")]
        private bool IsFlashbang(Item item)
        {
            return item != null && item.skin.Equals(_config.SkinID);
        }

        /// <summary>
        ///     Is this player flashed?
        /// </summary>
        /// <param name="player">Target player</param>
        /// <returns>True, if this player is flashed. False, otherwise.</returns>
        [HookMethod("IsFlashed")]
        private bool IsFlashed(BasePlayer player)
        {
            return IsFlashed(player.userID);
        }

        /// <summary>
        ///     Is this player flashed?
        /// </summary>
        /// <param name="id">Target player's ID</param>
        /// <returns>True, if this player is flashed. False, otherwise.</returns>
        [HookMethod("IsFlashed")]
        private bool IsFlashed(ulong id)
        {
            return FlashExpiry.ContainsKey(id);
        }

        /// <summary>
        ///     Called on explosive thrown
        /// </summary>
        /// <param name="player">Player who threw the explosive</param>
        /// <param name="entity">Explosive entity</param>
        /// <param name="weapon">The weapon</param>
        private void OnThrown(BasePlayer player, TimedExplosive entity, ThrownWeapon weapon)
        {
            var item = weapon.GetItem();
            if (!IsFlashbang(item))
                return;
            var collider = entity.GetComponent<Collider>();
            var rigidBody = collider.attachedRigidbody;
            entity.SetVelocity(rigidBody.velocity * _config.VelocityMultiplier);
            entity.CancelInvoke(entity.Explode);
            entity.Invoke(() => Flash(entity), _config.DeployTime);
        }

        /// <summary>
        ///     Flash a player from a source (this takes the ignore angle into account)
        /// </summary>
        /// <param name="player">Target player</param>
        /// <param name="flash">Source flashbang</param>
        [HookMethod("Flash")]
        private void Flash(BasePlayer player, Component flash)
        {
            if (!player.userID.IsSteamId()) return;
            var angle = AngleTo(player, flash);
            if (angle >= _config.IgnoreAngle) return;
            Flash(player, angle >= _config.SmallAngle);
        }

        /// <summary>
        ///     Flash a player
        /// </summary>
        /// <param name="player">Target player</param>
        /// <param name="small">Small flash?</param>
        private void Flash(BasePlayer player, bool small = false)
        {
            FlashExpiry[player.userID] =
                DateTime.UtcNow.AddSeconds(small ? _config.SmallBlindTime : _config.BlindTime).Ticks;
            CuiHelper.DestroyUi(player, CuiName);
            CuiHelper.AddUi(player, small ? SmallFlashCui : FlashCui);
            if (!small)
                PlayPrefab(_config.ScreamPrefab, player.transform.position);
        }

        /// <summary>
        ///     Un-flash a player
        /// </summary>
        /// <param name="player">Target player</param>
        [HookMethod("UnFlash")]
        private void UnFlash(BasePlayer player)
        {
            if (player == null) return;
            CuiHelper.DestroyUi(player, CuiName);
            FlashExpiry.Remove(player.userID);
        }

        /// <summary>
        ///     Is this player obstructed from this flashbang?
        /// </summary>
        /// <param name="basePlayer">Target player</param>
        /// <param name="flash">Source flashbang</param>
        /// <returns>True if something is obstructing the view of the player's eyes from the flashbang. False, otherwise.</returns>
        private bool IsObstructed(BasePlayer basePlayer, BaseEntity flash)
        {
            var transform = flash.transform;
            var position = transform.position;
            var dir = (basePlayer.eyes.position - position).normalized;
            return Physics.Raycast(position, dir, basePlayer.Distance(flash), ObstructionMask,
                QueryTriggerInteraction.Ignore);
        }

        /// <summary>
        ///     Produce a flashbang effect from a flashbang entity (flash entities around it and destroy the entity)
        /// </summary>
        /// <param name="flash">Target entity</param>
        [HookMethod("Flash")]
        private void Flash(BaseEntity flash)
        {
            flash.Kill();
            var players = new List<BasePlayer>();
            var position = flash.transform.position;
            Vis.Entities(position, _config.Radius, players, PlayerMask, QueryTriggerInteraction.Ignore);
            PlayPrefab(_config.SmokePrefab, position, Vector3.up);
            foreach (var basePlayer in players)
            {
                // Play directionally and close because the default sound is really quiet/mute at distances
                var playerPos = basePlayer.transform.position;
                var dir = (flash.transform.position - playerPos).normalized;
                PlayPrefab(_config.DeployPrefab, playerPos + dir, source: basePlayer.Connection);

                if (!IsObstructed(basePlayer, flash))
                    Flash(basePlayer, flash);
            }
        }

        /// <summary>
        ///     Play a certain prefab at a position (and direction)
        /// </summary>
        /// <param name="prefab">Target prefab</param>
        /// <param name="position">Prefab source position</param>
        /// <param name="direction">Prefab direction</param>
        /// <param name="source">Source connection</param>
        private static void PlayPrefab(string prefab, Vector3 position, Vector3 direction = default(Vector3),
            Connection source = null)
        {
            if (string.IsNullOrEmpty(prefab)) return;
            if (source != null)
            {
                var effect = new Effect();
                effect.Init(Effect.Type.Generic, position, direction);
                effect.pooledString = prefab;
                EffectNetwork.Send(effect, source);
                return;
            }

            Effect.server.Run(prefab, position, direction);
        }

        /// <summary>
        ///     Get an angle in degrees from the player's rotation to a target component
        /// </summary>
        /// <param name="player">Target player</param>
        /// <param name="target">Target component</param>
        /// <returns>An angle in degrees (less than 180, greater than 0)</returns>
        private static float AngleTo(BasePlayer player, Component target)
        {
            var pos = new Vector3(player.eyes.position.x, 0, player.eyes.position.z);
            var targetDir = (pos - target.transform.position).normalized;
            targetDir.y = 0;
            var ray = player.eyes.GetLookRotation() * Vector3.forward;
            ray.y = 0;
            return Math.Abs(180f - Vector3.Angle(ray, targetDir));
        }

        #endregion

        #region Configuration & Localization

        private ConfigFile _config;

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null) LoadDefaultConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        private class ConfigFile
        {
            /// <summary>
            ///     The smoke/flash skin ID (See <see href="https://www.youtube.com/watch?v=Bz8RNnM7Bgo" /> for custom icons)
            /// </summary>
            [JsonProperty("Smoke Skin ID")]
            public ulong SkinID { get; set; }

            /// <summary>
            ///     Time from throw until the flashbang will do it's effects
            /// </summary>
            [JsonProperty("Flashbang Deploy Time (seconds)")]
            public float DeployTime { get; set; }

            /// <summary>
            ///     The flashbang's deploy radius
            /// </summary>
            [JsonProperty("Flashbang Radius (metres)")]
            public float Radius { get; set; }

            /// <summary>
            ///     Flashbang velocity multiplier (speed)
            /// </summary>
            [JsonProperty("Flashbang Velocity Multiplier")]
            public float VelocityMultiplier { get; set; }

            /// <summary>
            ///     The time an intense flash will blind you for (seconds)
            /// </summary>
            [JsonProperty("Flashbang Blind Time (seconds)")]
            public float BlindTime { get; set; }

            /// <summary>
            ///     The time a small flash will blind you for (seconds)
            /// </summary>
            [JsonProperty("Flashbang Small Blind Time (seconds)")]
            public float SmallBlindTime { get; set; }

            /// <summary>
            ///     The minimum angle required for a small flash
            /// </summary>
            [JsonProperty("Flashbang Small Angle (degrees)")]
            public float SmallAngle { get; set; }

            /// <summary>
            ///     The minimum angle at which we don't flash at all
            /// </summary>
            [JsonProperty("Ignore Angle (degrees)")]
            public float IgnoreAngle { get; set; }

            /// <summary>
            ///     The fadeout time for a flash
            /// </summary>
            [JsonProperty("Flashbang Fadeout Time (seconds)")]
            public float FadeOut { get; set; }

            /// <summary>
            ///     The maximum stack for flashbangs
            /// </summary>
            [JsonProperty("Flashbang Stack")]
            public int Stack { get; set; }

            /// <summary>
            ///     The flashbang deploy prefab
            /// </summary>
            [JsonProperty("Flashbang Deploy Prefab (leave blank for disable)")]
            public string DeployPrefab { get; set; }

            /// <summary>
            ///     The flashbang scream prefab (only played on full flash)
            /// </summary>
            [JsonProperty("Scream Prefab (leave blank for disable)")]
            public string ScreamPrefab { get; set; }

            /// <summary>
            ///     The smoke deploy prefab (called on flash on the flashbang)
            /// </summary>
            [JsonProperty("Smoke Prefab (leave blank for disable)")]
            public string SmokePrefab { get; set; }

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    SkinID = 2555437667UL,
                    DeployTime = 3f,
                    DeployPrefab = "assets/prefabs/tools/smoke grenade/effects/ignite.prefab",
                    SmokePrefab = "assets/prefabs/weapons/rocketlauncher/effects/rocket_launch_fx.prefab",
                    ScreamPrefab = "assets/bundled/prefabs/fx/player/gutshot_scream.prefab",
                    Radius = 35f,
                    VelocityMultiplier = 1.5f,
                    BlindTime = 4f,
                    SmallBlindTime = 1f,
                    SmallAngle = 60f,
                    IgnoreAngle = 150f,
                    FadeOut = 1f,
                    Stack = 1
                };
            }
        }

        #endregion
    }
}

// --- End of file: Flashbang.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/fire-arrows ---
// --- Original File Path: F/FireArrows/FireArrows.cs ---

using System;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("FireArrows", "Colon Blow", "1.2.11")]
    class FireArrows : RustPlugin
    {
        // Added Compound Bow to approved weapon list
        // Added Player who shoots arrow as creator of them for Hitinfo
        // Added config options for ITEM id of arrow materials

        #region Loaded

        [PluginReference]
        Plugin ZoneManager;

        bool Changed;

        Dictionary<ulong, FireArrowData> FireArrowOn = new Dictionary<ulong, FireArrowData>();
        Dictionary<ulong, FireBallData> FireBallOn = new Dictionary<ulong, FireBallData>();
        Dictionary<ulong, FireBombData> FireBombOn = new Dictionary<ulong, FireBombData>();
        Dictionary<ulong, FireArrowCooldown> Cooldown = new Dictionary<ulong, FireArrowCooldown>();
        Dictionary<ulong, string> GuiInfoFA = new Dictionary<ulong, string>();

        class FireArrowCooldown
        {
            public BasePlayer player;
        }

        class FireArrowData
        {
            public BasePlayer player;
        }

        class FireBombData
        {
            public BasePlayer player;
        }

        class FireBallData
        {
            public BasePlayer player;
        }

        void Loaded()
        {
            LoadVariables();
            lang.RegisterMessages(messagesFA, this);
            permission.RegisterPermission("firearrows.allowed", this);
            permission.RegisterPermission("firearrows.ball.allowed", this);
            permission.RegisterPermission("firearrows.bomb.allowed", this);
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                string guiInfo;
                if (GuiInfoFA.TryGetValue(player.userID, out guiInfo)) CuiHelper.DestroyUi(player, guiInfo);
            }
        }

        void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        #endregion

        #region Configuration

        static bool ShowArrowTypeIcon = true;
        static bool BlockinRestrictedZone = false;
        static bool UseProt = true;
        static bool UseBasicArrowsOnly = false;
        static float DamageFireArrow = 50f;
        static float DamageFireBall = 200f;
        static float DamageFireBomb = 500f;
        static float DamageRadius = 1f;
        static float DurationFireArrow = 10f;
        static float DurationFireBallArrow = 10f;
        static float DurationFireBombArrow = 10f;
        static float UsageCooldown = 60f;
        static int lowGradeItemID = -946369541;
        static int clothItemID = -858312878;
        static int oilItemID = -321733511;
        static int explosivesItemID = -592016202;

        static string RestrictedZoneID = "24072018";
        static int cloth = 5;
        static int fuel = 5;
        static int oil = 5;
        static int explosives = 5;

        private string IconFireArrow = "http://i.imgur.com/3e8FWvt.png";
        private string IconFireBall = "http://i.imgur.com/USdpXGT.png";
        private string IconFireBomb = "http://i.imgur.com/0DpAHMn.png";

        bool isRestricted;
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        private void LoadConfigVariables()
        {
            CheckCfg("Icon - Show Arrow Type", ref ShowArrowTypeIcon);
            CheckCfg("Restriction - Block usage in Restricted Zone", ref BlockinRestrictedZone);
            CheckCfg("Damage Protection - Use Entity Protection Values", ref UseProt);
            CheckCfg("Ammo - Only allow HV and Wooden arrows", ref UseBasicArrowsOnly);
            CheckCfgFloat("Damage - Fire Arrow", ref DamageFireArrow);
            CheckCfgFloat("Damage - Fire Ball Arrow", ref DamageFireBall);
            CheckCfgFloat("Damage - Fire Bomb Arrow", ref DamageFireBomb);
            CheckCfgFloat("Damage - Radius", ref DamageRadius);
            CheckCfgFloat("Duration - Fire Arrow", ref DurationFireArrow);
            CheckCfgFloat("Duration - Fire Ball Arrow", ref DurationFireBallArrow);
            CheckCfgFloat("Duration - Fire Bomb Arrow", ref DurationFireBombArrow);
            CheckCfg("Zone - Restricted Zone ID", ref RestrictedZoneID);
            CheckCfg("Required - All Arrows - Cloth Amount", ref cloth);
            CheckCfg("Required - All Arrows- Low Grade Fuel Amount", ref fuel);
            CheckCfg("Required - FireBall & FireBomb Arrows - Crude Oil", ref oil);
            CheckCfg("Required - FireBomb Arrows - Explosives", ref explosives);
            CheckCfg("Icon - Fire Arrow", ref IconFireArrow);
            CheckCfg("Icon - Fire Ball Arrow", ref IconFireBall);
            CheckCfg("Icon - Fire Bomb Arrow", ref IconFireBomb);
            CheckCfgFloat("Cooldown - Time needed to wait", ref UsageCooldown);

            CheckCfg("Materials - Cloth Item ID", ref clothItemID);
            CheckCfg("Materials - Low Grade Fuel Item ID", ref lowGradeItemID);
            CheckCfg("Materials - Crude Oil Item ID", ref oilItemID);
            CheckCfg("Materials - Explosivies Item ID", ref explosivesItemID);
        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        private void CheckCfgFloat(string Key, ref float var)
        {

            if (Config[Key] != null)
                var = Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        #endregion

        #region Languange

        Dictionary<string, string> messagesFA = new Dictionary<string, string>()
                {
                    {"firearrowtxt", "Your Arrows are set for Fire."},
                    {"firearrowammotype", "You must only use HV or Wooden Arrows."},
            {"fireballarrowtxt", "Your Arrows are set for FireBall."},
            {"firebombarrowtxt", "Your Arrows are set for FireBomb."},
                    {"doesnothavemattxt", "You don't have required materials..."},
                        {"defaultarrowtxt", "Your Arrows are set for Normal."},
            {"restricted", "You are not allowed FireArrows in this Zone"},
            {"cooldown", "You must wait for cooldown to shoot again."},
            {"deniedarrowtxt", "No Access to This Arrow Tier."}
                };

        #endregion

        #region Hooks

        void OnPlayerAttack(BasePlayer player, HitInfo hitInfo)
        {
            if (usingCorrectWeapon(player))
            {
                if (Cooldown.ContainsKey(player.userID)) return;
                if ((FireArrowOn.ContainsKey(player.userID)) || (FireBallOn.ContainsKey(player.userID)) || (FireBombOn.ContainsKey(player.userID)))
                {
                    if (hitInfo.ProjectilePrefab.ToString().Contains("arrow_hv") || hitInfo.ProjectilePrefab.ToString().Contains("arrow_wooden"))
                    {
                        ArrowFX(player, hitInfo);
                        return;
                    }
                    if (!UseBasicArrowsOnly && (hitInfo.ProjectilePrefab.ToString().Contains("arrow_fire") || hitInfo.ProjectilePrefab.ToString().Contains("arrow_bone")))
                    {
                        ArrowFX(player, hitInfo);
                        return;
                    }
                    SendReply(player, lang.GetMessage("firearrowammotype", this));
                    return;
                }
            }
        }

        void ArrowFX(BasePlayer player, HitInfo hitInfo)
        {
            if (FireArrowOn.ContainsKey(player.userID))
            {
                FireArrowFX(player, hitInfo);
                ArrowCooldownControl(player);
                return;
            }
            if (FireBallOn.ContainsKey(player.userID))
            {
                FireBallFX(player, hitInfo);
                ArrowCooldownControl(player);
                return;
            }
            if (FireBombOn.ContainsKey(player.userID))
            {
                FireBombFX(player, hitInfo);
                ArrowCooldownControl(player);
                return;
            }
            else
                return;
        }

        void ArrowCooldownControl(BasePlayer player)
        {
            if (UsageCooldown <= 0f) return;
            if (UsageCooldown >= 1f)
            {
                Cooldown.Add(player.userID, new FireArrowCooldown { player = player, });
                timer.Once(UsageCooldown, () => Cooldown.Remove(player.userID));
            }
        }

        void ArrowCooldownToggle(BasePlayer player)
        {
            if (UsageCooldown <= 0f) return;
            NormalArrowToggle(player);
        }

        void FireArrowFX(BasePlayer player, HitInfo hitInfo)
        {
            if (!hasResources(player)) { tellDoesNotHaveMaterials(player); NormalArrowToggle(player); return; }
            if (!hitInfo.ProjectilePrefab.ToString().Contains("arrow")) return;
            applyBlastDamage(player, DamageFireArrow, Rust.DamageType.Heat, hitInfo);
            Effect.server.Run("assets/bundled/prefabs/fx/impacts/additive/fire.prefab", hitInfo.HitPositionWorld);
            BaseEntity FireArrow = GameManager.server.CreateEntity("assets/bundled/prefabs/fireball.prefab", hitInfo.HitPositionWorld);
            FireArrow.creatorEntity = player;
            FireArrow?.Spawn();
            timer.Once(DurationFireArrow, () => FireArrow.Kill());
            ArrowCooldownToggle(player);
        }

        void FireBallFX(BasePlayer player, HitInfo hitInfo)
        {
            if (!notZoneRestricted(player)) { tellRestricted(player); return; }
            if (!hasResources(player)) { tellDoesNotHaveMaterials(player); NormalArrowToggle(player); return; }
            if (!hitInfo.ProjectilePrefab.ToString().Contains("arrow")) return;
            applyBlastDamage(player, DamageFireBall, Rust.DamageType.Heat, hitInfo);
            timer.Once(1, () => applyBlastDamage(player, DamageFireBall, Rust.DamageType.Heat, hitInfo));
            timer.Once(2, () => applyBlastDamage(player, DamageFireBall, Rust.DamageType.Heat, hitInfo));
            timer.Once(3, () => applyBlastDamage(player, DamageFireBall, Rust.DamageType.Heat, hitInfo));
            Effect.server.Run("assets/bundled/prefabs/fx/survey_explosion.prefab", hitInfo.HitPositionWorld);
            BaseEntity FireBallArrow = GameManager.server.CreateEntity("assets/bundled/prefabs/napalm.prefab", hitInfo.HitPositionWorld);
            FireBallArrow.creatorEntity = player;
            FireBallArrow?.Spawn();
            timer.Once(DurationFireBallArrow, () => FireBallArrow.Kill());
            ArrowCooldownToggle(player);
        }

        void FireBombFX(BasePlayer player, HitInfo hitInfo)
        {
            if (!notZoneRestricted(player)) { tellRestricted(player); return; }
            if (!hasResources(player)) { tellDoesNotHaveMaterials(player); NormalArrowToggle(player); return; }
            if (!hitInfo.ProjectilePrefab.ToString().Contains("arrow")) return;
            applyBlastDamage(player, DamageFireBomb, Rust.DamageType.Explosion, hitInfo);
            Effect.server.Run("assets/bundled/prefabs/fx/weapons/landmine/landmine_explosion.prefab", hitInfo.HitPositionWorld);
            BaseEntity FireBombArrow = GameManager.server.CreateEntity("assets/bundled/prefabs/oilfireballsmall.prefab", hitInfo.HitPositionWorld);
            FireBombArrow.creatorEntity = player;
            FireBombArrow?.Spawn();
            timer.Once(DurationFireBombArrow, () => FireBombArrow.Kill());
            ArrowCooldownToggle(player);
        }

        void applyBlastDamage(BasePlayer player, float damageamount, Rust.DamageType damagetype, HitInfo hitInfo)
        {
            if (!hitInfo.ProjectilePrefab.ToString().Contains("arrow")) return;
            playerBlastDamage(player, damageamount, damagetype, hitInfo);
        }

        void playerBlastDamage(BasePlayer player, float damageamount, Rust.DamageType damagetype, HitInfo hitInfo)
        {
            List<BaseCombatEntity> playerlist = new List<BaseCombatEntity>();
            Vis.Entities<BaseCombatEntity>(hitInfo.HitPositionWorld, DamageRadius, playerlist);

            foreach (BaseCombatEntity p in playerlist)
            {
                if (!(p is BuildingPrivlidge))
                {
                    if (!hitInfo.ProjectilePrefab.ToString().Contains("arrow")) return;
                    p.Hurt(damageamount, damagetype, player, UseProt);
                }
            }
        }

        void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (input.WasJustPressed(BUTTON.FIRE_THIRD) && usingCorrectWeapon(player))
            {
                if (Cooldown.ContainsKey(player.userID))
                {
                    SendReply(player, lang.GetMessage("cooldown", this));
                    return;
                }
                ToggleArrowType(player);
            }
        }

        #endregion

        #region Commands

        [ChatCommand("firearrow")]
        void cmdChatfirearrow(BasePlayer player, string command, string[] args)
        {
            if (Cooldown.ContainsKey(player.userID))
            {
                SendReply(player, lang.GetMessage("cooldown", this));
                return;
            }
            ToggleArrowType(player);
        }

        [ConsoleCommand("firearrow")]
        void cmdConsolefirearrow(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null)
            {
                SendReply(arg, "You can't use this command from the server console");
                return;
            }
            var player = arg.Player();
            if (Cooldown.ContainsKey(player.userID))
            {
                SendReply(player, lang.GetMessage("cooldown", this));
                return;
            }
            ToggleArrowType(player);
        }

        #endregion

        #region Arrow CUI

        void ArrowCui(BasePlayer player)
        {
            if (ShowArrowTypeIcon) ArrowGui(player);
        }

        void ArrowGui(BasePlayer player)
        {
            DestroyCui(player);

            var elements = new CuiElementContainer();
            GuiInfoFA[player.userID] = CuiHelper.GetGuid();

            if (ShowArrowTypeIcon)
            {
                if (FireArrowOn.ContainsKey(player.userID))
                {
                    elements.Add(new CuiElement
                    {
                        Name = GuiInfoFA[player.userID],
                        Parent = "Overlay",
                        Components =
                            {
                            new CuiRawImageComponent { Color = "1 1 1 1", Url = IconFireArrow, Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                            new CuiRectTransformComponent { AnchorMin = "0.165 0.025",  AnchorMax = "0.210 0.095"}
                            }
                    });
                }
                if (FireBallOn.ContainsKey(player.userID))
                {
                    elements.Add(new CuiElement
                    {
                        Name = GuiInfoFA[player.userID],
                        Parent = "Overlay",
                        Components =
                            {
                            new CuiRawImageComponent { Color = "1 1 1 1", Url = IconFireBall, Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                            new CuiRectTransformComponent { AnchorMin = "0.165 0.025",  AnchorMax = "0.210 0.095"}
                            }
                    });
                }
                if (FireBombOn.ContainsKey(player.userID))
                {
                    elements.Add(new CuiElement
                    {
                        Name = GuiInfoFA[player.userID],
                        Parent = "Overlay",
                        Components =
                            {
                            new CuiRawImageComponent { Color = "1 1 1 1", Url = IconFireBomb, Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                            new CuiRectTransformComponent { AnchorMin = "0.165 0.025",  AnchorMax = "0.210 0.095"}
                            }
                    });
                }

            }
            CuiHelper.AddUi(player, elements);
        }

        #endregion

        #region More Hooks

        void ToggleArrowType(BasePlayer player)
        {
            if (FireArrowOn.ContainsKey(player.userID))
            {
                FireBallToggle(player);
                return;
            }
            if (FireBallOn.ContainsKey(player.userID))
            {
                FireBombToggle(player);
                return;
            }
            if (FireBombOn.ContainsKey(player.userID))
            {
                NormalArrowToggle(player);
                return;
            }
            if ((!FireArrowOn.ContainsKey(player.userID)) || (!FireBallOn.ContainsKey(player.userID)) || (!FireBombOn.ContainsKey(player.userID)))
            {
                FireArrowToggle(player);
                return;
            }
            else
            {
                NormalArrowToggle(player);
            }
            return;
        }

        void NormalArrowToggle(BasePlayer player)
        {
            DestroyArrowData(player);
            SendReply(player, lang.GetMessage("defaultarrowtxt", this));
            DestroyCui(player);
            return;
        }

        void FireArrowToggle(BasePlayer player)
        {
            if (!IsAllowed(player, "firearrows.allowed"))
            {
                FireBallToggle(player);
                return;
            }
            DestroyArrowData(player);
            FireArrowOn.Add(player.userID, new FireArrowData
            {
                player = player,
            });
            SendReply(player, lang.GetMessage("firearrowtxt", this));
            DestroyCui(player);
            ArrowGui(player);
            return;
        }

        void FireBallToggle(BasePlayer player)
        {
            if (!IsAllowed(player, "firearrows.ball.allowed"))
            {
                FireBombToggle(player);
                return;
            }
            DestroyArrowData(player);
            FireBallOn.Add(player.userID, new FireBallData
            {
                player = player,
            });
            SendReply(player, lang.GetMessage("fireballarrowtxt", this));
            DestroyCui(player);
            ArrowGui(player);
            return;
        }

        void FireBombToggle(BasePlayer player)
        {
            if (!IsAllowed(player, "firearrows.bomb.allowed"))
            {
                NormalArrowToggle(player);
                return;
            }
            DestroyArrowData(player);
            FireBombOn.Add(player.userID, new FireBombData
            {
                player = player,
            });
            SendReply(player, lang.GetMessage("firebombarrowtxt", this));
            DestroyCui(player);
            ArrowGui(player);
            return;
        }

        bool hasResources(BasePlayer player)
        {
            int cloth_amount = player.inventory.GetAmount(clothItemID);
            int fuel_amount = player.inventory.GetAmount(lowGradeItemID);
            int oil_amount = player.inventory.GetAmount(oilItemID);
            int explosives_amount = player.inventory.GetAmount(explosivesItemID);

            if (FireArrowOn.ContainsKey(player.userID))
            {
                if (cloth_amount >= cloth && fuel_amount >= fuel)
                {
                    player.inventory.Take(null, lowGradeItemID, fuel);
                    player.inventory.Take(null, clothItemID, cloth);
                    player.Command("note.inv", lowGradeItemID, -fuel);
                    player.Command("note.inv", clothItemID, -cloth);
                    return true;
                }
                return false;
            }
            if (FireBallOn.ContainsKey(player.userID))
            {
                if (cloth_amount >= cloth && fuel_amount >= fuel && oil_amount >= oil)
                {
                    player.inventory.Take(null, lowGradeItemID, fuel);
                    player.inventory.Take(null, clothItemID, cloth);
                    player.inventory.Take(null, oilItemID, oil);
                    player.Command("note.inv", lowGradeItemID, -fuel);
                    player.Command("note.inv", clothItemID, -cloth);
                    player.Command("note.inv", oilItemID, -oil);
                    return true;
                }
                return false;
            }
            if (FireBombOn.ContainsKey(player.userID))
            {
                if (cloth_amount >= cloth && fuel_amount >= fuel && oil_amount >= oil && explosives_amount >= explosives)
                {
                    player.inventory.Take(null, lowGradeItemID, fuel);
                    player.inventory.Take(null, clothItemID, cloth);
                    player.inventory.Take(null, oilItemID, oil);
                    player.inventory.Take(null, explosivesItemID, explosives);
                    player.Command("note.inv", lowGradeItemID, -fuel);
                    player.Command("note.inv", clothItemID, -cloth);
                    player.Command("note.inv", oilItemID, -oil);
                    player.Command("note.inv", explosivesItemID, -explosives);
                    return true;
                }
                return false;
            }

            return false;
        }

        bool notZoneRestricted(BasePlayer player)
        {
            isRestricted = false;
            var ZoneManager = plugins.Find("ZoneManager");
            bool Zone1Check = Convert.ToBoolean(ZoneManager?.Call("isPlayerInZone", RestrictedZoneID, player));
            if (Zone1Check)
            {
                isRestricted = true;
            }
            if (isRestricted) return false;
            return true;
        }

        void tellNotGrantedArrow(BasePlayer player)
        {
            SendReply(player, lang.GetMessage("deniedarrowtxt", this));
        }

        void tellDoesNotHaveMaterials(BasePlayer player)
        {
            SendReply(player, lang.GetMessage("doesnothavemattxt", this));
        }

        void tellRestricted(BasePlayer player)
        {
            SendReply(player, lang.GetMessage("restricted", this));
        }

        bool IsAllowed(BasePlayer player, string perm)
        {
            if (permission.UserHasPermission(player.userID.ToString(), perm)) return true;
            return false;
        }

        bool usingCorrectWeapon(BasePlayer player)
        {
            Item activeItem = player.GetActiveItem();
            if (activeItem != null && activeItem.info.shortname == "crossbow") return true;
            if (activeItem != null && activeItem.info.shortname == "bow.hunting") return true;
            if (activeItem != null && activeItem.info.shortname == "bow.compound") return true;
            return false;
        }

        void DestroyCui(BasePlayer player)
        {
            string guiInfo;
            if (GuiInfoFA.TryGetValue(player.userID, out guiInfo)) CuiHelper.DestroyUi(player, guiInfo);
        }

        void DestroyArrowData(BasePlayer player)
        {
            if (FireArrowOn.ContainsKey(player.userID))
            {
                FireArrowOn.Remove(player.userID);
            }
            if (FireBallOn.ContainsKey(player.userID))
            {
                FireBallOn.Remove(player.userID);
            }
            if (FireBombOn.ContainsKey(player.userID))
            {
                FireBombOn.Remove(player.userID);
            }
            else
                return;
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            DestroyCui(player);
            DestroyArrowData(player);
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            DestroyCui(player);
            DestroyArrowData(player);
        }

        #endregion

    }


}

// --- End of file: FireArrows.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/fix-fireworks ---
// --- Original File Path: F/FixFireworks/FixFireworks.cs ---

﻿using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Fix Fireworks", "Clearshot", "1.1.0")]
    [Description("Fix lit fireworks never firing")]
    class FixFireworks : CovalencePlugin
    {
        private PluginConfig _config;
        private HashSet<BaseFirework> _fireworkList = new HashSet<BaseFirework>();

        private void Init()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnEntityKill));
        }

        private void OnServerInitialized()
        {
            foreach (var firework in BaseNetworkable.serverEntities.OfType<BaseFirework>())
                OnEntitySpawned(firework);

            foreach (var firework in BaseFirework._activeFireworks)
            {
                if (firework != null)
                {
                    firework.SetFlag(BaseEntity.Flags.On, false, false, false);
                    firework.SetFlag(BaseEntity.Flags.OnFire, false, false, true);
                }
            }

            BaseFirework._activeFireworks = new HashSet<BaseFirework>();
            timer.Every(_config.checkFireworksInterval, () => {
                foreach(var firework in _fireworkList)
                    FixFirework(firework);
            });

            Subscribe(nameof(OnEntitySpawned));
            Subscribe(nameof(OnEntityKill));
        }

        private void OnEntitySpawned(BaseFirework firework) => _fireworkList.Add(firework);
        private void OnEntityKill(BaseFirework firework) => _fireworkList.Remove(firework);

        private void FixFirework(BaseFirework firework)
        {
            var isActive = BaseFirework._activeFireworks.Contains(firework);
            var isLitBroken = firework.IsLit() && !isActive;
            var isLitActiveBroken = firework.IsLit() && isActive && !firework.IsInvoking(firework.Begin) && !firework.HasFlag(BaseEntity.Flags.On);
            if (isLitBroken || isLitActiveBroken)
            {
                if (isLitActiveBroken)
                    BaseFirework._activeFireworks.Remove(firework);

                firework.SetFlag(BaseEntity.Flags.OnFire, false, false, false);
                firework.StaggeredTryLightFuse();
            }
        }

        [Command("fixfireworks")]
        private void FixFireworksCommand(IPlayer player, string command, string[] args)
        {
            if (!player.IsServer && !player.IsAdmin) return;

            if (args == null || args.Length < 1)
            {
                foreach (var firework in _fireworkList)
                    FixFirework(firework);
                return;
            }

            switch(args[0].ToLower())
            {
                case "fireall":
                    foreach (var firework in _fireworkList)
                        firework.Begin();
                    break;
                case "stats":
                    int exhausted = 0;
                    int broken = 0;
                    int activeBroken = 0;
                    foreach(var firework in _fireworkList)
                    {
                        var isActive = BaseFirework._activeFireworks.Contains(firework);
                        var isLitBroken = firework.IsLit() && !isActive;
                        var isLitActiveBroken = firework.IsLit() && isActive && !firework.IsInvoking(firework.Begin) && !firework.HasFlag(BaseEntity.Flags.On);
                        if (firework.IsExhausted()) exhausted++;
                        if (isLitBroken) broken++;
                        if (isLitActiveBroken) activeBroken++;
                    }

                    Puts($"\nFirework Stats:" +
                            $"\n\tTotal fireworks: {_fireworkList.Count}" +
                            $"\n\tActive fireworks: {BaseFirework._activeFireworks.Count}" +
                            $"\n\tExhausted fireworks: {exhausted}" +
                            $"\n\tBroken fireworks: {broken}" +
                            $"\n\tBroken active fireworks: {activeBroken}");
                    break;
            }
        }

        #region Config
        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();
            Config.WriteObject(_config, true);
        }

        private class PluginConfig
        {
            public float checkFireworksInterval = 5f;
        }
        #endregion
    }
}

// --- End of file: FixFireworks.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/fishing-multiplier ---
// --- Original File Path: F/FishingMultiplier/FishingMultiplier.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Fishing Multiplier", "Malmo", "1.0.3")]
    [Description("Multiplies the amount of fish caught with rod or traps")]
    class FishingMultiplier : RustPlugin
    {

        #region Fields

        private readonly Hash<ulong, int> _trapMultipliers = new Hash<ulong, int>();

        #endregion

        #region Oxide Hooks

        private void Init()
        {
            _config = Config.ReadObject<ConfigData>();
        }

        private void OnFishCatch(Item item, BaseFishingRod rod, BasePlayer player)
        {
            var multiplier = GetMultiplier(item.info.shortname, CatchTypes.Rod);
            item.amount *= multiplier;
        }

        // private void OnWildlifeTrap(WildlifeTrap trap, TrappableWildlife trapped)
        // {
        //     var multiplier = GetMultiplier(trapped.inventoryObject.shortname, CatchTypes.FishTrap);

        //     if (multiplier > 1)
        //         _trapMultipliers.Add(trap.net.ID, multiplier);
        // }

        // void OnItemAddedToContainer(ItemContainer container, Item item)
        // {
        //     if (!(container.entityOwner is WildlifeTrap)) return;
        //     if (!_trapMultipliers.ContainsKey(container.entityOwner.net.ID)) return;

        //     item.amount *= _trapMultipliers[container.entityOwner.net.ID];
        //     _trapMultipliers.Remove(container.entityOwner.net.ID);
        // }

        #endregion

        #region Helper Methods

        private int GetMultiplier(Dictionary<string, int> dict, string shortname)
        {
            if (dict == null) return 1;

            if (dict.ContainsKey(shortname))
                return dict[shortname];

            if (dict.ContainsKey("*"))
                return dict["*"];

            return 1;
        }

        private int GetMultiplier(string shortname, CatchTypes type)
        {
            if (_config != null && _config.Multipliers != null)
            {
                switch (type)
                {
                    case CatchTypes.FishTrap:
                        return GetMultiplier(_config.Multipliers.FishTrapsMultipler, shortname);
                    case CatchTypes.Rod:
                        return GetMultiplier(_config.Multipliers.RodMultipler, shortname);
                }
            }

            return 1;
        }

        #endregion

        #region Config

        private ConfigData _config;

        class ConfigData
        {
            [JsonProperty("Multipliers")]
            public MultiplierConfig Multipliers { get; set; }
        }

        class MultiplierConfig
        {
            [JsonProperty("Fishing Rod Multiplier")]
            public Dictionary<string, int> RodMultipler { get; set; }

            [JsonProperty("Fish Traps Multiplier")]
            public Dictionary<string, int> FishTrapsMultipler { get; set; }
        }

        private enum CatchTypes
        {
            Rod,
            FishTrap
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData()
            {
                Multipliers = new MultiplierConfig
                {
                    RodMultipler = new Dictionary<string, int>()
                    {
                        ["*"] = 1,
                        ["shortname"] = 5
                    },
                    FishTrapsMultipler = new Dictionary<string, int>()
                    {
                        ["*"] = 1,
                        ["shortname"] = 5
                    }
                }
            };
        }

        #endregion

    }
}

// --- End of file: FishingMultiplier.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/fall-damage ---
// --- Original File Path: F/FallDamage/FallDamage.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Fall Damage", "Wulf", "3.0.0")]
    [Description("Modifies or disables the fall damage for players")]
    class FallDamage : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        class Configuration
        {
            [JsonProperty("Apply realistic fall damage")]
            public bool RealisticDamage { get; set; } = true;

            [JsonProperty("Damage modifier for falls")]
            public float DamageModifier { get; set; } = 12f;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Permissions

        private const string permNone = "falldamage.none";

        private void Init()
        {
            permission.RegisterPermission(permNone, this);
        }

        #endregion Permissions

        #region Damage Modification

#if RUST

        private void OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo)
        {
            if (hitInfo.damageTypes.Total() <= 0)
            {
                return;
            }

            Rust.DamageType damageType = hitInfo.damageTypes.GetMajorityDamageType();
            if (damageType != Rust.DamageType.Fall)
            {
                return;
            }

            if (permission.UserHasPermission(player.UserIDString, permNone))
            {
                hitInfo.damageTypes = new Rust.DamageTypeList();
            }
            else if (config.RealisticDamage)
            {
                float oldDamage = hitInfo.damageTypes.Total();
                float newDamage = (player.Health() / config.DamageModifier) * (oldDamage * 0.35f);
                hitInfo.damageTypes.Set(damageType, newDamage);
            }
            else
            {
                hitInfo.damageTypes.Set(damageType, hitInfo.damageTypes.Total() * config.DamageModifier);
            }
        }

#endif

#if HURTWORLD

        private object OnPlayerTakeDamage(PlayerSession session, EntityEffectSourceData source)
        {
            if (!source.Equals(EntityEffectSourceData.FallDamage))
            {
                return null;
            }

            if (permission.UserHasPermission(session.SteamId.ToString(), permNone))
            {
                return 0f;
            }

            if (config.RealisticDamage)
            {
                IEntityFluidEffect fluidEffect = session.WorldPlayerEntity.Stats.GetFluidEffect(EntityFluidEffectKeyDatabase.Instance.Health);
                if (fluidEffect != null)
                {
                    float health = fluidEffect.GetValue();
                    float newDamage = (health / config.DamageModifier) * (source.Value * 0.35f);
                    return newDamage;
                }
            }

            return source.Value * config.DamageModifier;
        }

#endif

        #endregion Damage Modification
    }
}


// --- End of file: FallDamage.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/factions ---
// --- Original File Path: F/Factions/Factions.cs ---

﻿using System.Collections.Generic;
using System;
using System.Reflection;
using System.Text;
using System.Linq;
using UnityEngine;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Factions", "Absolut", "3.5.5", ResourceId = 1919)]

    class Factions : RustPlugin
    {
        #region Fields

        [PluginReference]
        Plugin EventManager;

        [PluginReference]
        Plugin Economics;

        [PluginReference]
        Plugin ServerRewards;

        [PluginReference]
        Plugin Kits;

        [PluginReference]
        Plugin LustyMap;

        [PluginReference]
        Plugin ZoneManager;

        [PluginReference]
        Plugin ZoneDomes;

        [PluginReference]
        Plugin ActiveCSZone;

        private bool UseFactions;
        private bool TaxBoxFullNotification;
        private int BZPrepTime = 99;
        ushort bZID = 0;
        int GlobalTime = 0;

        static FieldInfo buildingPrivlidges;

        FactionSavedPlayerData playerData;
        private DynamicConfigFile PlayerData;

        PlayerSavedInventories invData;
        private DynamicConfigFile InvData;


        FactionStatistics factionData;
        private DynamicConfigFile FactionData;

        private List<ushort> activeBoxes = new List<ushort>();

        private List<ulong> UnsureWaiting = new List<ulong>();

        private List<ulong> MenuState = new List<ulong>();
        private List<ulong> ButtonState = new List<ulong>();
        private List<ulong> ImmunityList = new List<ulong>();
        private List<ulong> OpenMemberStatus = new List<ulong>();

        private Dictionary<ulong, FactionDesigner> ActiveCreations = new Dictionary<ulong, FactionDesigner>();
        private Dictionary<ulong, FactionDesigner> ActiveEditors = new Dictionary<ulong, FactionDesigner>();
        private Dictionary<ulong, SpawnDesigner> SpawnCreation = new Dictionary<ulong, SpawnDesigner>();
        private Dictionary<ushort, target> FactionInvites = new Dictionary<ushort, target>();
        private Dictionary<ushort, target> FactionKicks = new Dictionary<ushort, target>();
        private Dictionary<ushort, target> LeaderPromotes = new Dictionary<ushort, target>();
        private Dictionary<int, TradeProcessing> TradeAssignments = new Dictionary<int, TradeProcessing>();
        private Dictionary<int, TradeProcessing> TradeRemoval = new Dictionary<int, TradeProcessing>();
        private Dictionary<ulong, List<string>> OpenUI = new Dictionary<ulong, List<string>>();
        private Dictionary<int, Monuments> MonumentLocations = new Dictionary<int, Monuments>();
        private List<BaseEntity> bzBuildings = new List<BaseEntity>();
        private Dictionary<ulong, PlayerCond> Condition = new Dictionary<ulong, PlayerCond>();
        private Dictionary<ushort, string> BattleZones = new Dictionary<ushort, string>();
        private Dictionary<ulong, BattleZonePlayer> BZPlayers = new Dictionary<ulong, BattleZonePlayer>();
        private Dictionary<ushort, float> BZTimes;
        private Dictionary<ushort, Timer> BZTimers;
        private Dictionary<ulong, Timer> BZKillTimers;
        private List<ulong> SpawnTimers;
        /// Turrets///
        private readonly string turretPrefab = "assets/prefabs/npc/autoturret/autoturret_deployed.prefab";
        private uint turretPrefabId;
        Dictionary<ulong, List<AutoTurret>> bzTurrets = new Dictionary<ulong, List<AutoTurret>>();
        FieldInfo bulletDamageField = typeof(AutoTurret).GetField("bulletDamage", (BindingFlags.Instance | BindingFlags.NonPublic));
        FieldInfo healthField = typeof(BaseCombatEntity).GetField("_health", (BindingFlags.Instance | BindingFlags.NonPublic));
        FieldInfo maxHealthField = typeof(BaseCombatEntity).GetField("_maxHealth", (BindingFlags.Instance | BindingFlags.NonPublic));
        static string UIMain = "UIMain";
        static string FactionsUIPanel = "FactionsUIPanel";
        static string UIEntry = "UIEntry";
        static string BattleZoneTimer = "BattleZoneTimer";
        static string SpawnTimerUI = "SpawnTimerUI";  

        #endregion

        #region Hooks    
        void Loaded()
        {
            PlayerData = Interface.Oxide.DataFileSystem.GetFile("factions_playerdata");
            InvData = Interface.Oxide.DataFileSystem.GetFile("factions_invdata");
            FactionData = Interface.Oxide.DataFileSystem.GetFile("factions_factiondata");
            buildingPrivlidges = typeof(BasePlayer).GetField("buildingPrivlidges", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            lang.RegisterMessages(messages, this);
            BZTimers = new Dictionary<ushort, Timer>();
            BZKillTimers = new Dictionary<ulong, Timer>();
            BZTimes = new Dictionary<ushort, float>();
            SpawnTimers = new List<ulong>();
            FindMonuments();
        }

        void Unload()
        {
            activeBoxes.Clear();
            SpawnCreation.Clear();
            FactionKicks.Clear();
            LeaderPromotes.Clear();
            TradeAssignments.Clear();
            TradeRemoval.Clear();
            FactionInvites.Clear();
            SpawnTimers.Clear();
            MonumentLocations.Clear();
            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                DestroyPlayer(p);
            }
            if (BattleZones.Count > 0)
                EndBZ(bZID, "Unloaded");

            UseFactions = false;
            SaveData();
        }

        void OnServerInitialized()
        {
            LoadVariables();
            LoadData();
            if (configData.Use_TokensReward)
            {
                try
                {
                    EventManager.Call("isLoaded", null);
                }
                catch (Exception)
                {
                    PrintWarning($"EventManager is missing. Unloading {Name} as it will not work without EventManager.");
                    Interface.Oxide.UnloadPlugin(Name);
                    return;
                }
            }

            if (configData.Use_ServerRewardsReward)
            {
                try
                {
                    ServerRewards.Call("isLoaded", null);
                }
                catch (Exception)
                {
                    PrintWarning($"ServerRewards is missing. Unloading {Name} as it will not work without ServerRewards.");
                    Interface.Oxide.UnloadPlugin(Name);
                    return;
                }
            }
            if (configData.Use_EconomicsReward)
            {
                try
                {
                    Economics.Call("isLoaded", null);
                }
                catch (Exception)
                {
                    PrintWarning($"Economics is missing. Unloading {Name} as it will not work without Economics.");
                    Interface.Oxide.UnloadPlugin(Name);
                    return;
                }
            }
            if (configData.Use_Kits)
            {
                try
                {
                    Kits.Call("isLoaded", null);
                }
                catch (Exception)
                {
                    PrintWarning($"Kits is missing. Unloading {Name} as it will not work without Kits.");
                    Interface.Oxide.UnloadPlugin(Name);
                    return;
                }
            }

            if (configData.Use_FactionZones)
            {
                try
                {
                    ZoneManager.Call("isLoaded", null);
                }
                catch (Exception)
                {
                    PrintWarning($"ZoneManager is missing. Unloading {Name} as it will not work without ZoneManager. Check Option: FactionZones.");
                    Interface.Oxide.UnloadPlugin(Name);
                    return;
                }
            }

            if (configData.Use_BattleZones)
            {
                try
                {
                    ZoneManager.Call("isLoaded", null);
                }
                catch (Exception)
                {
                    PrintWarning($"ZoneManager is missing. Unloading {Name} as it will not work without ZoneManager. Check Option: BattleZones.");
                    Interface.Oxide.UnloadPlugin(Name);
                    return;
                }
            }

            if (configData.Use_FactionLeaderByRank)
            {
                if (configData.Use_FactionLeaderByTime == true || configData.Use_FactionLeaderByAdmin == true)
                {
                    PrintWarning($"You have more then (1) Use_FactionLeaderBy setting as true. Unloading {Name} as it will not work properly.");
                    Interface.Oxide.UnloadPlugin(Name);
                    return;
                }
            }

            if (configData.Use_FactionLeaderByAdmin)
            {
                if (configData.Use_FactionLeaderByRank == true || configData.Use_FactionLeaderByTime == true)
                {
                    PrintWarning($"You have more then (1) Use_FactionLeaderBy setting as true. Unloading {Name} as it will not work properly.");
                    Interface.Oxide.UnloadPlugin(Name);
                    return;
                }
            }

            if (configData.Use_FactionLeaderByTime)
            {
                if (configData.Use_FactionLeaderByRank == true || configData.Use_FactionLeaderByAdmin == true)
                {
                    PrintWarning($"You have more then (1) Use_FactionLeaderBy setting as true. Unloading {Name} as it will not work properly.");
                    Interface.Oxide.UnloadPlugin(Name);
                    return;
                }
            }
            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                OnPlayerInit(p);
            }
            GlobalTime = 0;
            InfoLoop();
            timer.Once(configData.Save_Interval * 60, () => SaveLoop());
            timer.Once(1 * 60, () => ChangeGlobalTime());
            timer.Once(30, () => RefreshOpenMemberStatus());
            timer.Once(900 * 60, () => CheckLeaderTime());
            SaveData();
        }

        void OnEntityBuilt(Planner planner, GameObject gameobject)
        {
            if (gameobject.GetComponent<BaseEntity>() != null)
            {
                if (bZID != 0)
                {
                    var entityowner = gameobject.GetComponent<BaseEntity>().OwnerID;
                    if (BZPlayers.ContainsKey(entityowner))
                        if (BZPlayers[entityowner].died == false && BZPlayers[entityowner].entered == true)
                        {
                            var position = (Vector3)GetZoneLocation(BattleZones[bZID]);
                            var radius = (float)GetZoneRadius(BattleZones[bZID]);
                            var distance = Vector3.Distance(gameobject.transform.position, position);
                            if (distance <= radius)
                            {
                                bzBuildings.Add(gameobject.GetComponent<BaseEntity>());
                            }
                        }
                }
            }
        }

        private void OnPlayerInit(BasePlayer player)
        {
            if (player != null)
            {
                if (UseFactions)
                {
                    Bindings(player);
                    RefreshTicker(player);
                    if (player.IsSleeping())
                    {
                        timer.Once(5, () =>
                        {
                            player.EndSleeping();
                            SendMSG(player, lang.GetMessage("FactionsInfo", this));
                            if (FactionMemberCheck(player))
                            {
                                playerData.playerFactions[player.userID].Name = $"{player.displayName}";
                                SendPuts(string.Format(lang.GetMessage("PlayerReturns", this, player.UserIDString), player.displayName));
                                InitPlayerTime(player);
                                AuthorizePlayerOnTurrets(player);
                                if (bZID != 0)
                                    if (!BZPlayers.ContainsKey(player.userID))
                                        BZButton(player, bZID);
                            }
                            if (!FactionMemberCheck(player))
                            {
                                if (!playerData.playerFactions.ContainsKey(player.userID))
                                {
                                    playerData.playerFactions.Add(player.userID, new FactionPlayerData { Name = $"{player.displayName}", trade = Trade.None, level = 1, FactionMemberTime = 0, rank = Rank.Recruit });
                                    Kits?.Call("GiveKit", player, configData.StarterKit);
                                    SendPuts(string.Format(lang.GetMessage("PlayerNew", this, player.UserIDString), player.displayName));
                                }
                                {
                                    SetFaction(player);
                                    return;
                                }
                            }
                        });
                    }
                    else
                    {
                        if (FactionMemberCheck(player))
                        {
                            playerData.playerFactions[player.userID].Name = $"{player.displayName}";
                            InitPlayerTime(player);
                            AuthorizePlayerOnTurrets(player);
                            if (bZID != 0)
                                if (!BZPlayers.ContainsKey(player.userID))
                                    BZButton(player, bZID);
                        }
                        if (!FactionMemberCheck(player))
                        {
                            if (!playerData.playerFactions.ContainsKey(player.userID))
                            {
                                playerData.playerFactions.Add(player.userID, new FactionPlayerData { Name = $"{player.displayName}", trade = Trade.None, level = 1, FactionMemberTime = 0, rank = Rank.Recruit });
                                Kits?.Call("GiveKit", player, configData.StarterKit);
                                SendPuts(string.Format(lang.GetMessage("PlayerNew", this, player.UserIDString), player.displayName));
                            }
                            {
                                SetFaction(player);
                                return;
                            }
                        }
                    }
                }
            }
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            if (UseFactions)
            {
                if (FactionMemberCheck(player))
                {
                    var faction = GetPlayerFaction(player);
                    RefreshTicker(player);
                    if (OpenMemberStatus.Contains(player.userID))
                        FactionMemberStatus(player);
                    if (!isCSPlayer(player))
                    {
                        if (playerData.playerFactions[player.userID].SavedInventory == true)
                        {
                            RestoreBZPlayer(player);
                        }
                        else if (configData.Use_Kits) GiveFactionKit(player, faction);
                        if (bZID != 0)
                            if (!BZPlayers.ContainsKey(player.userID))
                                BZButton(player, bZID);
                            else if (BZPlayers[player.userID].entered == true)
                            {
                                BZPlayers[player.userID].died = true;
                                BZPlayers[player.userID].oob = false;
                                if (BZKillTimers.ContainsKey(player.userID))
                                {
                                    BZKillTimers[player.userID].Destroy();
                                    BZKillTimers.Remove(player.userID);
                                }
                                CuiHelper.DestroyUi(player, BattleZoneTimer);
                            }
                        SpawnButtons(player, faction);
                        timer.Once(30, () =>
                        {
                            CuiHelper.DestroyUi(player, PanelSpawnButtons);
                        });
                    }
                }
                else OnPlayerInit(player);
            }
        }

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            try
            {
                if (UseFactions)
                {
                    var attacker = hitInfo.Initiator.ToPlayer();
                    if (!FactionMemberCheck(attacker)) return;
                    if (GetFactionType(attacker) == FactionType.FFA) return;
                    if (configData.Use_Ranks)
                    {
                        int attackerRank = (int)GetPlayerRank(attacker);
                        float dmgMod = (attackerRank * configData.RankBonus + 100) / 100;
                        hitInfo.damageTypes.ScaleAll(dmgMod);
                    }
                    if (entity is BasePlayer && hitInfo.Initiator is BasePlayer)
                    {
                        if (entity as BasePlayer == null || hitInfo == null) return;
                        var victim = entity.ToPlayer();
                        if (BZPlayers.ContainsKey(attacker.userID))
                            if (BZPlayers[attacker.userID].died == false && BZPlayers[attacker.userID].entered == true)
                                if (!BZPlayers.ContainsKey(victim.userID))
                                {
                                    SendMSG(attacker, string.Format(lang.GetMessage("VictimNotinBZ", this)));
                                    return;
                                }
                        if (BZPlayers.ContainsKey(victim.userID))
                            if (BZPlayers[victim.userID].died == false && BZPlayers[victim.userID].entered == true)
                                if (!BZPlayers.ContainsKey(attacker.userID))
                                {
                                    SendMSG(attacker, string.Format(lang.GetMessage("AttackerNotinBZ", this)));
                                    return;
                                }
                        if (ImmunityList.Contains(attacker.userID) || ImmunityList.Contains(victim.userID))
                        {
                            hitInfo.damageTypes.ScaleAll(0);
                            try
                            {
                                SendMSG(attacker, string.Format(lang.GetMessage("CurrentlyImmuneAttacker", this)));
                            }
                            catch { }
                            try
                            {
                                SendMSG(victim, string.Format(lang.GetMessage("CurrentlyImmuneVictim", this)));
                            }
                            catch { }
                            return;                
                        }
                        if (!configData.FFDisabled) return;
                        if (GetFactionType(victim) == FactionType.FFA) return;
                        if (EventManager)
                        {
                            object isPlaying = EventManager?.Call("isPlaying", new object[] { attacker });
                            if (isPlaying is bool)
                                if ((bool)isPlaying)
                                    return;
                        }
                        if (ActiveCSZone)
                        {
                            if (isCSPlayer(attacker)) return;
                        }
                        if (victim != attacker)
                        {
                            if ((FactionMemberCheck(attacker)) && (FactionMemberCheck(victim)))
                            {
                                if (configData.Use_RevoltChallenge)
                                {
                                    if ((playerData.playerFactions[attacker.userID].ChallengeStatus) && (playerData.playerFactions[victim.userID].ChallengeStatus)) return;
                                }
                                if (!SameFactionCheck(attacker, victim.userID)) return;
                                {
                                    hitInfo.damageTypes.ScaleAll(configData.FF_DamageScale);
                                    SendMSG(attacker, string.Format(lang.GetMessage("FFs", this, attacker.UserIDString), victim.displayName));
                                }
                            }
                        }
                    }
                    ///Player Structure Check                    
                    else if (entity is BaseEntity && hitInfo.Initiator is BasePlayer)
                    {
                        if (!configData.BuildingProtectionEnabled) return;
                        var OwnerID = entity.OwnerID;
                        if (!FactionMemberCheck(attacker)) return;
                        if (attacker.userID == OwnerID) return;
                        if (!SameFactionCheck(attacker, OwnerID)) return;
                        if (OwnerID != 0)
                        {
                            {
                                if (EventManager)
                                {
                                    object isPlaying = EventManager?.Call("isPlaying", new object[] { attacker });
                                    if (isPlaying is bool)
                                        if ((bool)isPlaying)
                                            return;
                                }

                                if (configData.Use_RevoltChallenge)
                                {
                                    if ((playerData.playerFactions[attacker.userID].ChallengeStatus) && (playerData.playerFactions[OwnerID].ChallengeStatus)) return;
                                }
                                //if (AuthorizedTC(attacker)) return;
                                hitInfo.damageTypes.ScaleAll(0);
                                SendMSG(attacker, string.Format(lang.GetMessage("FFBuildings", this, attacker.UserIDString), playerData.playerFactions[OwnerID].Name));
                            }
                        }
                    }
                }
            }
            catch (Exception)
            {
            }
        }

        private void OnEntityDeath(BaseEntity entity, HitInfo hitInfo)
        {
            if (UseFactions)
            {
                try
                {
                    if (entity is AutoTurret)
                    {
                        var userid = entity.OwnerID;
                        BasePlayer owner = BasePlayer.FindByID(userid);
                        if (InBZ(owner))
                        {
                            if (bzTurrets.ContainsKey(userid))
                                if (bzTurrets[userid].Contains(entity.GetComponent<AutoTurret>()))
                                    bzTurrets[userid].Remove(entity.GetComponent<AutoTurret>());
                            Item item = BuildItem("autoturret", 1);
                            GiveItem(owner, item, "");
                            return;
                        }
                        else if (playerData.playerFactions[userid].factionTurrets.Contains(entity.GetComponent<AutoTurret>()))
                            playerData.playerFactions[userid].factionTurrets.Remove(entity.GetComponent<AutoTurret>());
                        return;
                    }

                    if (entity is StorageContainer)
                    {
                        Vector3 ContPosition = entity.transform.position;
                        foreach (var box in factionData.Boxes)
                        {
                            BasePlayer factionleader = BasePlayer.FindByID(factionData.leader[box.Key]);
                            if (ContPosition.x == box.Value.x && ContPosition.y == box.Value.y && ContPosition.z == box.Value.z)
                            {
                                factionData.Boxes.Remove(box.Key);
                                if (BasePlayer.activePlayerList.Contains(factionleader))
                                    SendMSG(factionleader, lang.GetMessage("TaxBoxDestroyed", this));
                            }

                        }
                        return;
                    }
                    var attacker = hitInfo.Initiator.ToPlayer() as BasePlayer;
                    var victim = entity.ToPlayer();
                    if (InBZ(victim))
                    {
                        if (bzTurrets.ContainsKey(victim.userID))
                        {
                            foreach (var autoturret in bzTurrets[victim.userID])
                                autoturret.DieInstantly();
                            bzTurrets[victim.userID].Clear();
                        }
                        if (BZPlayers.ContainsKey(victim.userID))
                        {
                            BZPlayers[victim.userID].died = true;
                        }
                        if (BZPlayers[victim.userID].owner == true)
                            EndBZ(GetPlayerFaction(victim), "LeaderDeath");
                        else
                            BZAttackerCheck();
                    }
                    if (GetFactionType(attacker) == FactionType.FFA) return;
                    if (GetFactionType(victim) == FactionType.FFA) return;
                    if (!FactionMemberCheck(attacker) || !FactionMemberCheck(victim)) return;
                    var victimfaction = GetPlayerFaction(victim);
                    if (entity is BasePlayer && hitInfo.Initiator is BasePlayer)
                    {
                        if (entity as BasePlayer == null || hitInfo == null) return;
                        if (victim.userID != attacker.userID)
                        {
                            var attackerFaction = GetPlayerFaction(attacker);
                            if (!SameFactionCheck(attacker, victim.userID))
                            {
                                if (EventManager)
                                {
                                    object isPlaying = EventManager?.Call("isPlaying", new object[] { attacker });
                                    if (isPlaying is bool)
                                        if ((bool)isPlaying)
                                            return;
                                }
                                if (ActiveCSZone)
                                {
                                    if (isCSPlayer(attacker)) return;
                                }
                                if (configData.Use_FactionKillIncentives)
                                {
                                    factionData.Factions[attackerFaction].Kills += 1;
                                    SaveData();
                                    foreach (BasePlayer p in BasePlayer.activePlayerList)
                                        RefreshTicker(p);
                                    if (factionData.Factions[attackerFaction].Kills >= configData.KillLimit)
                                    {
                                        var fname = factionData.Factions[attackerFaction].Name;
                                        SendPuts(string.Format(lang.GetMessage("KillLimitReached", this), fname));
                                        foreach (var entry in playerData.playerFactions)
                                        {
                                            if (entry.Value.faction == attackerFaction)
                                            {
                                                var reward = "";
                                                if (configData.Use_EconomicsReward)
                                                {
                                                    Economics.Call("DepositS", attacker.userID.ToString(), configData.FactionKillsRewardEconomics);
                                                    reward = $"{configData.FactionKillsRewardEconomics.ToString()} Economics!";
                                                }
                                                if (configData.Use_TokensReward)
                                                {
                                                    EventManager.Call("AddTokens", attacker.userID.ToString(), configData.FactionKillsRewardTokens);
                                                    reward = $"{configData.FactionKillsRewardTokens.ToString()} Tokens!";
                                                }
                                                if (configData.Use_ServerRewardsReward)
                                                {
                                                    ServerRewards?.Call("AddPoints", attacker.userID.ToString(), configData.FactionKillsRewardServerRewards);
                                                    reward = $"{configData.FactionKillsRewardServerRewards.ToString()} Reward Points!";
                                                }
                                                SendPuts(string.Format(lang.GetMessage("KillLimitReward", this), reward));
                                            }
                                        }
                                        SendPuts(string.Format(lang.GetMessage("KillTickerReset", this)));
                                        timer.Once(300, () => ResetTicker());
                                    }
                                }
                                playerData.playerFactions[attacker.userID].Kills += 1;
                                if (configData.Use_Ranks)
                                {
                                    var currentrank = playerData.playerFactions[attacker.userID].rank;
                                    if (currentrank != Rank.SharpShooter)
                                    {
                                        playerData.playerFactions[attacker.userID].Kills += 1;
                                        SaveData();
                                        if (GetPlayerKills(attacker) >= configData.RankRequirement * (int)currentrank)
                                        {

                                            playerData.playerFactions[attacker.userID].rank = currentrank + 1;
                                            playerData.playerFactions[attacker.userID].Kills = 0;
                                            SaveData();
                                            RankAdvancement(attacker);
                                        }
                                    }
                                    CheckLeaderRank(attacker);
                                }
                                SendDeathNote(attacker, victim, GetPlayerFaction(attacker));
                                if (configData.Use_EconomicsReward)
                                {
                                    Economics.Call("DepositS", attacker.userID.ToString(), configData.KillAmountEconomics);
                                    SendMSG(attacker, string.Format(lang.GetMessage("Payment", this, attacker.UserIDString), configData.KillAmountEconomics, "Currency"));
                                }
                                if (configData.Use_TokensReward)
                                {
                                    EventManager.Call("AddTokens", attacker.userID.ToString(), configData.KillAmountTokens);
                                    SendMSG(attacker, string.Format(lang.GetMessage("Payment", this, attacker.UserIDString), configData.KillAmountTokens, "Tokens"));
                                }
                                if (configData.Use_ServerRewardsReward)
                                {
                                    ServerRewards?.Call("AddPoints", attacker.userID.ToString(), configData.KillAmountServerRewards);
                                    SendMSG(attacker, string.Format(lang.GetMessage("Payment", this, attacker.UserIDString), configData.KillAmountServerRewards, "Reward Points"));
                                }
                            }
                            else if (configData.Use_RevoltChallenge)
                            {
                                if (factionData.ActiveChallenges.ContainsKey(victim.userID) && factionData.ActiveChallenges.ContainsKey(attacker.userID))
                                {
                                    if (configData.Use_Ranks)
                                    {
                                        var currentrank = playerData.playerFactions[attacker.userID].rank;
                                        if (currentrank != Rank.SharpShooter)
                                        {
                                            //Puts("Trying Rank");
                                            playerData.playerFactions[attacker.userID].Kills += 1;
                                            SaveData();
                                            if (GetPlayerKills(attacker) >= configData.RankRequirement * (int)currentrank)
                                            {

                                                playerData.playerFactions[attacker.userID].rank = currentrank + 1;
                                                playerData.playerFactions[attacker.userID].Kills = 0;
                                                SaveData();
                                                RankAdvancement(attacker);
                                            }
                                        }
                                    }
                                    if (isleader(attacker))
                                    //Leader wins, Challenger is removed from faction.
                                    {
                                        SendPuts(string.Format(lang.GetMessage("ChallengerLost", this, attacker.UserIDString), victim.displayName));
                                        UnassignPlayerFromFaction(victim.userID);
                                        if (configData.Use_FactionLeaderByRank)
                                        {
                                            playerData.playerFactions[victim.userID].rank = Rank.Recruit;
                                            if (BasePlayer.activePlayerList.Contains(victim)) SendMSG(victim, string.Format(lang.GetMessage("ChallengeLostRank", this)));
                                        }
                                        if (configData.Use_FactionLeaderByTime)
                                        {
                                            playerData.playerFactions[victim.userID].time = GlobalTime;
                                            playerData.playerFactions[victim.userID].FactionMemberTime = 0;
                                            if (BasePlayer.activePlayerList.Contains(victim)) SendMSG(victim, string.Format(lang.GetMessage("ChallengeLostTime", this)));
                                        }
                                    }
                                    else if (isleader(victim))
                                    //Challenger wins, Leader playtime set to 0 or Rank set to Recruit or leader just removed.
                                    {
                                        SendPuts(string.Format(lang.GetMessage("LeaderLost", this, attacker.UserIDString), attacker.displayName));
                                        if (configData.Use_FactionLeaderByRank)
                                        {
                                            playerData.playerFactions[victim.userID].rank = Rank.Recruit;
                                            if (BasePlayer.activePlayerList.Contains(victim)) SendMSG(victim, string.Format(lang.GetMessage("ChallengeLostRank", this)));
                                        }

                                        if (configData.Use_FactionLeaderByTime)
                                        {
                                            playerData.playerFactions[victim.userID].time = GlobalTime;
                                            playerData.playerFactions[victim.userID].FactionMemberTime = 0;
                                            if (BasePlayer.activePlayerList.Contains(victim)) SendMSG(victim, string.Format(lang.GetMessage("ChallengeLostTime", this)));
                                        }

                                        if (configData.Use_FactionLeaderByAdmin)
                                        {
                                            factionData.leader.Remove(victimfaction);
                                            factionData.Factions[victimfaction].tax = 0;
                                            if (factionData.Boxes.ContainsKey(victimfaction)) factionData.Boxes.Remove(victimfaction);
                                            if (BasePlayer.activePlayerList.Contains(victim)) SendMSG(victim, string.Format(lang.GetMessage("ChallengeLostLeader", this)));
                                            BroadcastFaction(victim, string.Format(lang.GetMessage("ChallengeNewLeader", this), attacker.displayName, victim.displayName));
                                            factionData.leader[attackerFaction] = attacker.userID;
                                        }
                                    }
                                    //Remove Challenge Stuff
                                    factionData.ActiveChallenges.Remove(victim.userID);
                                    factionData.ActiveChallenges.Remove(attacker.userID);
                                    FactionDamage(attacker);
                                    FactionDamage(victim);
                                    SaveData();

                                    CheckLeaderTime();
                                    CheckLeaderRank(attacker);
                                }
                            }
                        }
                    }

                }
                catch (Exception)
                {
                }
            }
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            DestroyPlayer(player);
            SendPuts(string.Format(lang.GetMessage("PlayerLeft", this, player.UserIDString), player.displayName));
        }

        void DestroyPlayer(BasePlayer player)
        {
            if (player == null) return;
            CuiHelper.DestroyUi(player, SpawnTimerUI);
            player.Command("bind n \"\"");
            player.Command("bind p \"\"");
            DestroyAll(player);
            if (OpenMemberStatus.Contains(player.userID)) OpenMemberStatus.Remove(player.userID);
            if (!FactionMemberCheck(player)) return;
            var faction = GetPlayerFaction(player);
            if (configData.Use_FactionLeaderByTime)
            {
                SaveTimeData(player);
                playerData.playerFactions[player.userID].time = 0;
            }
            if (isleader(player))
            {
                if (activeBoxes.Contains(faction)) activeBoxes.Remove(faction);
            }

        }

        private object OnPlayerChat(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return null;
            bool isCreatingFaction = false;
            bool isEditingFaction = false;
            bool isSpawn = false;
            FactionDesigner Creator = new FactionDesigner();
            Faction Faction = new Faction();
            SpawnDesigner Designer = new SpawnDesigner();
            Coords spawn = new Coords();

            if (ActiveEditors.ContainsKey(player.userID))
            {
                isEditingFaction = true;
                Creator = ActiveEditors[player.userID];
                Faction = Creator.Entry;
            }
            else if (ActiveCreations.ContainsKey(player.userID))
            {
                isCreatingFaction = true;
                Creator = ActiveCreations[player.userID];
                Faction = Creator.Entry;
            }
            else if (SpawnCreation.ContainsKey(player.userID))
            {
                isSpawn = true;
                Designer = SpawnCreation[player.userID];
                spawn = Designer.Entry;
            }
            if (isSpawn)
            {
                var args = string.Join(" ", arg.Args);
                if (args.Contains("quit"))
                {
                    ExitSpawnCreation(player, isSpawn);
                    return true;
                }
                if (args.Contains("save spawn"))
                {
                    SaveSpawn(player, isSpawn);
                    return true;
                }
                switch (Designer.partNum)
                {
                    case 0:
                        spawn.Name = string.Join(" ", arg.Args);
                        CreationHelp(player, 10);
                        return true;
                }
            }
            if (isEditingFaction || isCreatingFaction)
            {

                var args = string.Join(" ", arg.Args);
                if (args.Contains("quit"))
                {
                    QuitFactionCreation(player, isCreatingFaction);
                    return true;
                }
                if (args.Contains("save faction"))
                {
                    SaveFaction(player, isCreatingFaction);
                    return true;
                }

                switch (Creator.partNum)
                {
                    case 0:
                        foreach (var faction in factionData.Factions)
                            if (faction.Value.Name.Contains(string.Join(" ", arg.Args)))
                            {
                                SendMSG(player, string.Format(lang.GetMessage("FactionNameExists", this), args));
                                return true;
                            }
                        Faction.Name = string.Join(" ", arg.Args);
                        Creator.partNum++;
                        SendMSG(player, string.Format(lang.GetMessage("CreatorFactionName", this), args));
                        if (isCreatingFaction)
                            CreationHelp(player, 1);
                        else CreationHelp(player, 20);
                        return true;
                    case 1:
                        Faction.LeaderTitle = string.Join(" ", arg.Args);
                        SendMSG(player, string.Format(lang.GetMessage("CreatorLeaderTitle", this), args));
                        Creator.partNum++;
                        if (isCreatingFaction)
                            CreationHelp(player, 2);
                        else CreationHelp(player, 20);
                        return true;
                    case 2:
                        Faction.group = string.Join(" ", arg.Args);
                        SendMSG(player, string.Format(lang.GetMessage("CreatorFactionGroup", this), args));
                        ConsoleSystem.Run(ConsoleSystem.Option.Server, $"group add {Faction.group}");
                        Creator.partNum++;
                        if (isCreatingFaction)
                            CreationHelp(player, 20);
                        return true;
                }
            }
            if (EventManager)
            {
                object isPlaying = EventManager?.Call("isPlaying", new object[] { player });
                if (isPlaying is bool)
                    if ((bool)isPlaying)
                        return null;
            }
            if (ActiveCSZone)
            {
                if (isCSPlayer(player)) return null;
            }
            if (UseFactions)
                if (configData.Use_FactionChatControl)
                {
                    string message = arg.GetString(0, "text");
                    string color = "";
                    if (FactionMemberCheck(player))
                    {
                        color = factionData.Factions[GetPlayerFaction(player)].ChatColor;
                        if (configData.Use_FactionNamesonChat)
                        {
                            color += "[" + factionData.Factions[GetPlayerFaction(player)].Name + "] ";
                        }

                        if (configData.Use_ChatTitles)
                        {
                            if (isleader(player) && isAuth(player))
                            {
                                string formatMsg = color + "[ADMIN][LEADER] " + player.displayName + "</color> : " + message;
                                Broadcast(formatMsg, player.userID.ToString());
                            }
                            else if (isAuth(player))
                            {
                                string formatMsg = color + "[ADMIN] " + player.displayName + "</color> : " + message;
                                Broadcast(formatMsg, player.userID.ToString());
                            }
                            else if (isleader(player))
                            {
                                string formatMsg = color + "[LEADER] " + player.displayName + "</color> : " + message;
                                Broadcast(formatMsg, player.userID.ToString());
                            }
                            else
                            {
                                string formatMsg = color + player.displayName + "</color> : " + message;
                                Broadcast(formatMsg, player.userID.ToString());
                            }
                            return false;
                        }
                        else
                        {
                            string formatMsg = color + player.displayName + "</color> : " + message;
                            Broadcast(formatMsg, player.userID.ToString());
                        }
                        return false;
                    }
                }
            return null;
        }

        void OnLootEntity(BasePlayer player, object lootable)
        {
            if (!configData.Use_Taxes) return;
            BaseEntity container = lootable as BaseEntity;
            if ((player == null) || (container == null) || (!isleader(player))) return;
            {
                var faction = GetPlayerFaction(player);
                var coords = container.transform.localPosition;
                if (!activeBoxes.Contains(faction))
                {
                    if (GetTaxContainer(faction) == container)
                    {
                        SendMSG(player, lang.GetMessage("TaxBox", this));
                        return;
                    }
                    return;
                }
                if (container.OwnerID == player.userID || SameFactionCheck(player, container.OwnerID))
                {
                    if (container.PrefabName == "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab" || container.PrefabName == "assets/prefabs/deployable/woodenbox/woodbox_deployed.prefab")
                    {
                        if (!hasTaxBox(faction))
                        {
                            activeBoxes.Remove(faction);
                            factionData.Boxes.Add(faction, new Coords { x = coords.x, y = coords.y, z = coords.z });
                            SendMSG(player, lang.GetMessage("NewTaxBox", this));
                            SendMSG(player, lang.GetMessage("TaxBoxDeActivated", this));
                            SaveData();
                            return;
                        }
                        else
                        {
                            activeBoxes.Remove(faction);
                            factionData.Boxes.Remove(faction);
                            factionData.Boxes.Add(faction, new Coords { x = coords.x, y = coords.y, z = coords.z });
                            SendMSG(player, lang.GetMessage("NewTaxBox", this));
                            SendMSG(player, lang.GetMessage("TaxBoxDeActivated", this));
                            SaveData();
                            return;
                        }
                    }
                    SendMSG(player, lang.GetMessage("TaxBoxError", this));
                    return;
                }
                SendMSG(player, lang.GetMessage("TaxBoxOwnerError", this));
                return;
            }
        }

        void OnPlantGather(PlantEntity Plant, Item item, BasePlayer player)
        {
            if (!FactionMemberCheck(player)) return;
            if (configData.Use_Trades)
            {
                if (playerData.playerFactions[player.userID].trade == Trade.Forager)
                {
                    int level = Convert.ToInt32(playerData.playerFactions[player.userID].level);
                    double bonus = Convert.ToInt32(Math.Round(configData.LevelBonus * level));
                    int bonusamount = Convert.ToInt32(Math.Round((bonus * item.amount) / 100));
                    item.amount = item.amount + bonusamount;
                    playerData.playerFactions[player.userID].Gathered += item.amount;
                    SaveData();
                    var currentlevel = playerData.playerFactions[player.userID].level;
                    if (GetPlayerGathered(player) >= (configData.LevelRequirement * currentlevel))
                    {
                        if (currentlevel != configData.MaxLevel)
                        {
                            playerData.playerFactions[player.userID].level += 1;
                            playerData.playerFactions[player.userID].Gathered = 0;
                            SaveData();
                            LevelAdvancement(player);
                        }
                    }
                }
            }
            if (!configData.Use_Taxes) return;
            {
                var faction = GetPlayerFaction(player);
                if (isleader(player)) return;
                if (!factionData.leader.ContainsKey(faction)) return;
                var factionleaderid = factionData.leader[faction];
                BasePlayer factionleader = BasePlayer.FindByID(factionleaderid);
                var taxrate = factionData.Factions[faction].tax;
                StorageContainer TaxContainer = GetTaxContainer(faction);
                if (TaxContainer == null) return;

                int Tax = Convert.ToInt32(Math.Round((item.amount * taxrate) / 100));
                item.amount = item.amount - Tax;

                if (!TaxContainer.inventory.IsFull())
                {
                    ItemDefinition ToAdd = ItemManager.FindItemDefinition(item.info.itemid);

                    if (ToAdd != null)
                    {
                        TaxContainer.inventory.AddItem(ToAdd, Tax);
                    }
                }
                else if (BasePlayer.activePlayerList.Contains(factionleader))
                    if (!TaxBoxFullNotification)
                    {
                        SendMSG(player, lang.GetMessage("TaxBoxFull", this));
                        SetBoxFullNotification();
                        return;
                    }
            }
        }


        void OnCollectiblePickup(Item item, BasePlayer player)
        {
            if (!FactionMemberCheck(player)) return;

            if (configData.Use_Trades)
            {
                if (playerData.playerFactions[player.userID].trade == Trade.Forager)
                {
                    int level = Convert.ToInt32(playerData.playerFactions[player.userID].level);
                    double bonus = Convert.ToInt32(Math.Round(configData.LevelBonus * level));
                    int bonusamount = Convert.ToInt32(Math.Round((bonus * item.amount) / 100));
                    item.amount = item.amount + bonusamount;
                    playerData.playerFactions[player.userID].Gathered += item.amount;
                    SaveData();
                    var currentlevel = playerData.playerFactions[player.userID].level;
                    if (GetPlayerGathered(player) >= (configData.LevelRequirement * currentlevel))
                    {
                        if (currentlevel != configData.MaxLevel)
                        {
                            playerData.playerFactions[player.userID].level += 1;
                            playerData.playerFactions[player.userID].Gathered = 0;
                            SaveData();
                            LevelAdvancement(player);
                        }
                    }
                }
            }
            if (!configData.Use_Taxes) return;
            {
                if (isleader(player)) return;
                var faction = GetPlayerFaction(player);
                if (!factionData.leader.ContainsKey(faction)) return;
                var factionleaderid = factionData.leader[faction];
                BasePlayer factionleader = BasePlayer.FindByID(factionleaderid);
                var taxrate = factionData.Factions[faction].tax;
                StorageContainer TaxContainer = GetTaxContainer(faction);
                if (TaxContainer == null) return;

                int Tax = Convert.ToInt32(Math.Round((item.amount * taxrate) / 100));
                item.amount = item.amount - Tax;

                if (!TaxContainer.inventory.IsFull())
                {
                    ItemDefinition ToAdd = ItemManager.FindItemDefinition(item.info.itemid);

                    if (ToAdd != null)
                    {
                        TaxContainer.inventory.AddItem(ToAdd, Tax);
                    }
                }
                else if (BasePlayer.activePlayerList.Contains(factionleader))
                    if (!TaxBoxFullNotification)
                    {
                        SendMSG(player, lang.GetMessage("TaxBoxFull", this));
                        SetBoxFullNotification();
                        return;
                    }
            }
        }
        void OnDispenserGather(ResourceDispenser Dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity.ToPlayer();
            if (!FactionMemberCheck(player)) return;

            if (configData.Use_Trades)
            {
                var gatherType = Dispenser.gatherType;
                Trade trade = Trade.None;
                switch (gatherType)
                {
                    case ResourceDispenser.GatherType.Tree:
                        trade = Trade.Lumberjack;
                        break;
                    case ResourceDispenser.GatherType.Ore:
                        trade = Trade.Miner;
                        break;
                    case ResourceDispenser.GatherType.Flesh:
                        trade = Trade.Hunter;
                        break;
                }
                if (playerData.playerFactions[player.userID].trade == trade)
                {
                    double bonus = Convert.ToInt32(Math.Round(configData.LevelBonus * playerData.playerFactions[player.userID].level));
                    int bonusamount = Convert.ToInt32(Math.Round((bonus * item.amount) / 100));
                    //Puts($"Item Amount: {item.amount}");
                    item.amount = item.amount + bonusamount;
                    //Puts($"Item Amount with bonus: {item.amount}");
                    var currentlevel = playerData.playerFactions[player.userID].level;
                    if (currentlevel != configData.MaxLevel)
                    {
                        playerData.playerFactions[player.userID].Gathered += item.amount;
                        SaveData();

                        if (GetPlayerGathered(player) >= (configData.LevelRequirement * currentlevel))
                        {
                            playerData.playerFactions[player.userID].level += 1;
                            playerData.playerFactions[player.userID].Gathered = 0;
                            SaveData();
                            LevelAdvancement(player);
                        }
                    }
                }
            }
            //Puts($"{player.displayName} amount of {gatherType} is {item.amount}");
            //Puts($"Trade: {Enum.GetName(typeof(Trade), playerData.playerFactions[player.userID].trade)}");
            if (configData.Use_Taxes)
                {
                    var faction = GetPlayerFaction(player);
                    if (!factionData.leader.ContainsKey(faction)) return;
                    if (isleader(player)) return;
                    var factionleaderid = factionData.leader[faction];
                    BasePlayer factionleader = BasePlayer.FindByID(factionleaderid);
                    var taxrate = factionData.Factions[faction].tax;
                    StorageContainer TaxContainer = GetTaxContainer(faction);
                    if (TaxContainer == null) return;
                    int Tax = Convert.ToInt32(Math.Round((item.amount * taxrate) / 100));


                    if (!TaxContainer.inventory.IsFull())
                    {
                        ItemDefinition ToAdd = ItemManager.FindItemDefinition(item.info.itemid);

                        if (ToAdd != null)
                        {
                            TaxContainer.inventory.AddItem(ToAdd, Tax);
                            item.amount = item.amount - Tax;
                            //Puts($"tax amount {Tax}");
                            return;

                        }
                    }
                    else if (BasePlayer.activePlayerList.Contains(factionleader))
                        if (!TaxBoxFullNotification)
                        {
                            SendMSG(player, lang.GetMessage("TaxBoxFull", this));
                            SetBoxFullNotification();
                            return;
                        }
                }
        }

        object OnItemCraft(ItemCraftTask task, BasePlayer crafter)
        {
            if (!configData.Use_Trades) return null;
            if (playerData.playerFactions[crafter.userID].trade == Trade.Crafter)
            {
                var craftingTime = task.blueprint.time;
                int level = Convert.ToInt32(playerData.playerFactions[crafter.userID].level);
                double bonus = Convert.ToInt32(Math.Round(configData.LevelBonus * level));
                int CraftingReduction = Convert.ToInt32(Math.Round(craftingTime * bonus) / 100);
                craftingTime -= CraftingReduction;
                task.blueprint.time = craftingTime;
                //Puts($"{crafter.displayName} crafted {task.blueprint.targetItem} is done in {task.blueprint.time}");
                return null;
            }
            else
            {
                //Puts($"{crafter.displayName} crafted {task.blueprint.targetItem} is done in {task.blueprint.time}");
                return null;
            }
        }

        object OnItemCraftFinished(ItemCraftTask task, Item item)
        {
            if (!configData.Use_Trades) return null;
            if (playerData.playerFactions[task.owner.userID].trade != Trade.Crafter) return null;
            var currentlevel = playerData.playerFactions[task.owner.userID].level;
            if (currentlevel != configData.MaxLevel)
            {
                playerData.playerFactions[task.owner.userID].Crafted += 1;
                SaveData();
                if (GetPlayerCrafted(task.owner) >= ((configData.LevelRequirement * currentlevel) / 100))
                {

                    playerData.playerFactions[task.owner.userID].level += 1;
                    playerData.playerFactions[task.owner.userID].Crafted = 0;
                    SaveData();
                    LevelAdvancement(task.owner);
                }
            }
            return null;

        }

        //AutoTurrets
        void OnEntitySpawned(BaseNetworkable entity)
        {
            turretPrefabId = StringPool.Get(turretPrefab);
            if (UseFactions)
            {
                if (entity == null) return;
                if (entity.prefabID == turretPrefabId)
                {
                    var userid = entity.GetComponent<AutoTurret>().OwnerID;
                    BasePlayer owner = BasePlayer.FindByID(userid);
                    if (!FactionMemberCheck(owner)) return;
                    if (GetFactionType(owner) == FactionType.FFA) return;
                    var faction = GetPlayerFaction(owner);
                    if (BZPlayers.ContainsKey(userid))
                    {
                        if (BZPlayers[userid].died == false && BZPlayers[userid].entered == true && BZPlayers[userid].owner == true)
                        {
                            if (!bzTurrets.ContainsKey(userid))
                                bzTurrets.Add(userid, new List<AutoTurret>());
                            bzTurrets[userid].Add(entity.GetComponent<AutoTurret>());
                            AssignTurretAuth(faction, entity.GetComponent<AutoTurret>());
                            ConfigureTurret(entity.GetComponent<AutoTurret>());
                        }
                    }
                    else if (configData.Use_AutoAuthorization)
                    {
                        if (factionData.leader.ContainsKey(GetPlayerFaction(owner)))
                            if (factionData.leader.ContainsValue(userid))
                        {
                            playerData.playerFactions[userid].factionTurrets.Add(entity.GetComponent<AutoTurret>());
                            AssignTurretAuth(faction, entity.GetComponent<AutoTurret>());
                        }
                    }
                }
            }
        }

        object CanUseDoor(BasePlayer player, BaseLock door)
        {
            if (!FactionMemberCheck(player)) return null;
            if (GetFactionType(player) == FactionType.FFA) return null;
            var parent = door.parentEntity.Get(true);
            var prefab = parent.LookupPrefab();
            if (parent.IsOpen()) return true;
            if (bZID != 0)
            {
                if (BZPlayers.ContainsKey(player.userID))
                    if (BZPlayers[player.userID].died == false && BZPlayers[player.userID].entered == true)
                        if (BZPlayers[player.userID].faction == GetPlayerFaction(player))
                            return true;
            }
            if (configData.Use_AutoAuthorization)
            {
                if (factionData.leader.ContainsKey(GetPlayerFaction(player)))
                    if (parent.OwnerID == factionData.leader[GetPlayerFaction(player)])
                        return true;
            }
            return null;
        }

        void AssignTurretAuth(ushort faction, AutoTurret turret)
        {
            foreach (var p in playerData.playerFactions.Where(kvp => kvp.Value.faction == faction))
            {
                turret.authorizedPlayers.Add(new ProtoBuf.PlayerNameID() { userid = p.Key, username = p.Value.Name });
            }
        }

        void AuthorizePlayerOnTurrets(BasePlayer player)
        {
            var faction = GetPlayerFaction(player);
            if (configData.Use_BattleZones)
                if (BattleZones.ContainsKey(faction))
                    foreach (var entry in bzTurrets[(ulong)GetLeader(faction)])
                    {
                        var turret = entry as AutoTurret;
                        turret.authorizedPlayers.Add(new ProtoBuf.PlayerNameID() { userid = player.userID, username = player.displayName });
                    }
            if (configData.Use_AutoAuthorization)
                if (factionData.leader.ContainsKey(faction))
                    if (playerData.playerFactions[(ulong)GetLeader(faction)].factionTurrets != null)
                        foreach (var entry in playerData.playerFactions[(ulong)GetLeader(faction)].factionTurrets)
                        {
                            var turret = entry as AutoTurret;
                            turret.authorizedPlayers.Add(new ProtoBuf.PlayerNameID() { userid = player.userID, username = player.displayName });
                        }
        }

        void ConfigureTurret(AutoTurret turret)
        {
            turret.inventory.AddItem(ItemManager.FindItemDefinition(815896488), 256);
            turret.startHealth = 60f;
            healthField.SetValue(turret, 60f);
            maxHealthField.SetValue(turret, 60f);
            bulletDamageField.SetValue(turret, 5f);
            turret.sightRange = 15f;
            turret.InitiateStartup();
        }    

        #endregion

        #region Functions

        private bool SameFactionCheck(BasePlayer self, ulong target)
        {
            if (GetPlayerFaction(self) == playerData.playerFactions[target].faction) return true;
            else return false;
        }

        private bool FactionMemberCheck(BasePlayer player)
        {
            if (!playerData.playerFactions.ContainsKey(player.userID)) return false;
            var factionID = playerData.playerFactions[player.userID].faction;
            if (factionID == default(ushort)) return false;
            foreach (var entry in factionData.Factions)
            {
                if (entry.Key == factionID)
                {
                    return true;
                }
            }
            return false;
        }

        private ushort GetPlayerFaction(BasePlayer player)
        {
            return playerData.playerFactions[player.userID].faction;
        }

        private FactionType GetFactionType(BasePlayer player)
        {
            var faction = GetPlayerFaction(player);
            return factionData.Factions[faction].type;
        }

        private Trade GetPlayerTrade(BasePlayer player)
        {
            if (FactionMemberCheck(player)) return playerData.playerFactions[player.userID].trade;
            return Trade.None;
        }

        private Rank GetPlayerRank(BasePlayer player)
        {
            if (FactionMemberCheck(player)) return playerData.playerFactions[player.userID].rank;
            return Rank.None;
        }

        private int GetPlayerKills(BasePlayer player)
        {
            if (!FactionMemberCheck(player)) return 0;
            else return playerData.playerFactions[player.userID].Kills;
        }

        private int GetFactionKills(ushort faction)
        {
            if (!factionData.Factions.ContainsKey(faction)) return 0;
            return factionData.Factions[faction].Kills;
        }

        private bool CheckForActiveEnemies(ushort faction)
        {
            var p = 0;
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (GetFactionType(player) != FactionType.FFA && GetPlayerFaction(player) != faction)
                {
                    p++;
                    if (p >= configData.RequiredBZParticipants) break;
                }           
            }
            if (p >= configData.RequiredBZParticipants) return true;
            else return false;
        }

        private int GetPlayerGathered(BasePlayer player)
        {
            if (FactionMemberCheck(player)) return playerData.playerFactions[player.userID].Gathered;
            return 0;
        }

        private int GetPlayerCrafted(BasePlayer player)
        {
            if (FactionMemberCheck(player)) return playerData.playerFactions[player.userID].Crafted;
            return 0;
        }

        private int GetPlayerLevel(BasePlayer player)
        {
            if (FactionMemberCheck(player)) return playerData.playerFactions[player.userID].level;
            return 0;
        }

        public void Broadcast(string message, string userid = "0") => PrintToChat(message);

        private void BroadcastFaction(BasePlayer source, string message, ushort faction = 0)
        {
            if (faction == 0)
                faction = GetPlayerFaction(source);
            string color = factionData.Factions[faction].ChatColor;
            string name = "";
            if (configData.Use_FactionNamesonChat)
            {
                name = $"[{factionData.Factions[faction].Name}]";
            }
            foreach (var entry in playerData.playerFactions)
            {
                BasePlayer player = BasePlayer.FindByID(entry.Key);

                if (entry.Value.faction == faction)
                    SendReply(player, color + name + lang.GetMessage("inFactionChat", this) + "</color> " + message);
            }
        }

        private void SendMSG(BasePlayer player, string msg, string keyword = "title")
        {
            if (keyword == "title") keyword = lang.GetMessage("title", this, player.UserIDString);
            SendReply(player, configData.MSG_MainColor + keyword + "</color>" + configData.MSG_Color + msg + "</color>");
        }

        private void SendPuts(string msg, string keyword = "title")
        {
            if (keyword == "title") keyword = lang.GetMessage("title", this);
            PrintToChat(configData.MSG_MainColor + keyword + "</color>" + configData.MSG_Color + msg + "</color>");
        }

        private void SendDeathNote(BasePlayer player, BasePlayer victim, ushort faction)
        {
            string colorAttacker = "";
            string colorVictim = "";
            string prefixAttacker = "";
            string prefixVictim = "";

            colorAttacker = factionData.Factions[faction].ChatColor;
            prefixAttacker = "[" + factionData.Factions[faction].Name + "] ";
            var victimfaction = (GetPlayerFaction(victim));
            colorVictim = factionData.Factions[victimfaction].ChatColor;
            prefixVictim = "[" + factionData.Factions[victimfaction].Name + "] ";

            if (configData.BroadcastDeath)
            {
                string formatMsg = colorAttacker + prefixAttacker + player.displayName + "</color>" + lang.GetMessage("DeathMessage", this, player.UserIDString) + colorVictim + prefixVictim + victim.displayName + "</color>";
                Broadcast(formatMsg);
            }
        }
        private string CountPlayers(ushort faction)
        {
            int i = 0;
            foreach (var entry in playerData.playerFactions)
            {
                if (entry.Value.faction == faction)
                    i++;
            }
            return i.ToString();
        }

        private object RaycastAll<T>(Ray ray) where T : BaseEntity
        {
            var hits = Physics.RaycastAll(ray);
            GamePhysics.Sort(hits);
            var distance = 100f;
            object target = false;
            foreach (var hit in hits)
            {
                var ent = hit.GetEntity();
                if (ent is T && hit.distance < distance)
                {
                    target = ent;
                    break;
                }
            }

            return target;
        }

        static bool AuthorizedTC(BasePlayer player)
        {
            List<BuildingPrivlidge> playerpriv = buildingPrivlidges.GetValue(player) as List<BuildingPrivlidge>;
            if (playerpriv.Count == 0)
            {
                return false;
            }
            foreach (BuildingPrivlidge priv in playerpriv.ToArray())
            {
                List<ProtoBuf.PlayerNameID> authorized = priv.authorizedPlayers;
                bool foundplayer = false;
                foreach (ProtoBuf.PlayerNameID pni in authorized.ToArray())
                {
                    if (pni.userid == player.userID)
                        foundplayer = true;
                }
                if (!foundplayer)
                {
                    return false;
                }
            }
            return true;
        }

        static double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalHours;

        private void SavePlayerFactionTime()
        {
            if (!configData.Use_FactionLeaderByTime) return;
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player != null)
                {
                    SaveTimeData(player);
                }
            }
            SaveData();
            timer.Once(300, () => SavePlayerFactionTime());
        }

        private void SaveTimeData(BasePlayer player)
        {
            playerData.playerFactions[player.userID].FactionMemberTime += (GlobalTime - playerData.playerFactions[player.userID].time);
            playerData.playerFactions[player.userID].time = GlobalTime;

        }

        //private static long GrabCurrentTimestamp()
        //{
        //    long timestamp = 0;
        //    long ticks = DateTime.UtcNow.Ticks - DateTime.Parse("01/01/1970 00:00:00").Ticks;
        //    ticks /= 10000000;
        //    timestamp = ticks;

        //    return timestamp;
        //}

        private void InitPlayerTime(BasePlayer player)
        {
            if (!configData.Use_FactionLeaderByTime) return;
            if (factionData.Factions[GetPlayerFaction(player)].type == FactionType.FFA) return;
            playerData.playerFactions[player.userID].time = GlobalTime;
        }

        private StorageContainer GetTaxContainer(ushort faction)
        {
            foreach (var c in factionData.Boxes)
                if (c.Key == faction)
                {
                    var x = c.Value.x;
                    var y = c.Value.y;
                    var z = c.Value.z;

                    foreach (StorageContainer Cont in StorageContainer.FindObjectsOfType<StorageContainer>())
                    {
                        Vector3 ContPosition = Cont.transform.position;
                        if (ContPosition.x == x && ContPosition.y == y && ContPosition.z == z)
                        {
                            var factionbox = Cont;
                            //Puts($"{factionbox}"); -- Testing
                            return factionbox;
                        }
                    }
                }
            return null;
        }

        string MergeParams(string[] Params, int Start)
        {
            var Merged = new StringBuilder();
            for (int i = Start; i < Params.Length; i++)
            {
                if (i > Start)
                    Merged.Append(" ");
                Merged.Append(Params[i]);
            }

            return Merged.ToString();
        }

        static void MovePlayerPosition(BasePlayer player, Vector3 destination)
        {
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
            if (!BasePlayer.sleepingPlayerList.Contains(player)) BasePlayer.sleepingPlayerList.Add(player);

            player.CancelInvoke("InventoryUpdate");
            player.inventory.crafting.CancelAll(true);

            player.MovePosition(destination);
            player.ClientRPCPlayer(null, player, "ForcePositionTo", destination);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.UpdateNetworkGroup();

            player.SendNetworkUpdateImmediate(false);
            player.ClientRPCPlayer(null, player, "StartLoading");
            player.SendFullSnapshot();
        }

        private void SetBoxFullNotification()
        {
            TaxBoxFullNotification = true;
            timer.Once(5 * 60, () => TaxBoxFullNotification = false);
        }

        object GetTax(ushort faction)
        {
            if (factionData.Factions.ContainsKey(faction))
                return factionData.Factions[faction].tax;
            else return "0";
        }
        object GetLeaderName(ushort faction)
        {
            if (factionData.leader.ContainsKey(faction))
                if (playerData.playerFactions[factionData.leader[faction]].Name == "") return "";
                else return playerData.playerFactions[factionData.leader[faction]].Name;
            else return "";
        }

        object GetLeader(ushort faction)
        {
            if (factionData.leader.ContainsKey(faction)) return factionData.leader[faction];
            else return null;

        }

        private bool isleader(BasePlayer player)
        {
            if (factionData.leader.ContainsValue(player.userID)) return true;
            else return false;
        }

        private bool hasTaxBox(ushort faction)
        {
            if (factionData.Boxes.ContainsKey(faction)) return true;
            else return false;
        }

        void Bindings(BasePlayer player)
        {
            player.Command("bind n \"UI_OpenFactions\"");
            player.Command("bind p \"UI_OpenMemberStatus\"");
        }


        [ChatCommand("buildings")]
        private void cmdtest(BasePlayer player)
        {
            CountFactionBuildings();
            CountTotalPlayerBuildings();
            CountFactionPlayerBuildings();
        }

        private void CountTotalPlayerBuildings()
        {
            foreach (var p in playerData.playerFactions)
            {
                BasePlayer player = BasePlayer.FindByID(p.Key);
                int Count = 0;
                //List<BuildingBlock> PlayerBlocks = new List<BuildingBlock>();
                ////Puts($"Checking {tc.transform.position} owned by {l.Value} ");
                //foreach (BuildingBlock entry in UnityEngine.Object.FindObjectsOfType<BaseEntity>())
                //{
                List<BuildingBlock> AllBlocks = new List<BuildingBlock>();
                //Puts($"Checking {tc.transform.position} owned by {l.Value} ");
                Vis.Entities<BuildingBlock>(new Vector3(0, 0, 0), 999999f, AllBlocks);
                foreach (var entry in AllBlocks)
                {
                    if (entry is BuildingBlock)
                        if (entry.OwnerID == p.Key)
                        {
                            Count++;
                        }
                }
                p.Value.TotalBuildings = Count;
            }
            SaveData();
        }

        private void CountFactionPlayerBuildings()
        {
            foreach (var p in playerData.playerFactions)
            {
                int Count = 0;
                var pfaction = p.Value.faction;
                var leader = factionData.leader[pfaction];
                foreach (BuildingPrivlidge tc in Resources.FindObjectsOfTypeAll<BuildingPrivlidge>())
                    foreach (ProtoBuf.PlayerNameID pni in tc.authorizedPlayers)
                        if (pni.userid == leader)
                        {
                            List<BuildingBlock> PlayerBlocks = new List<BuildingBlock>();
                            //Puts($"Checking {tc.transform.position} owned by {l.Value} "); -- Testing
                            Vis.Entities<BuildingBlock>(tc.transform.position, 100f, PlayerBlocks);
                            foreach (var entry in PlayerBlocks)
                            {
                                if (entry is BuildingBlock)
                                {
                                    if (!playerData.playerFactions.ContainsKey(entry.OwnerID)) continue;
                                    if (entry.OwnerID == p.Key)
                                        Count++;
                                }
                            }
                        }
                playerData.playerFactions[p.Key].FactionBuildings = Count;
            }
            SaveData();
        }

        private void CountFactionBuildings()
        {
            foreach (var leader in factionData.leader)
            {
                var leaderfaction = leader.Key;
                var privileges = new List<Dictionary<string, object>>();
                int Count = 0;
                foreach (BuildingPrivlidge tc in Resources.FindObjectsOfTypeAll<BuildingPrivlidge>())
                    foreach (ProtoBuf.PlayerNameID pni in tc.authorizedPlayers)
                        if (pni.userid == leader.Value)
                        {
                            List<BuildingBlock> FactionBlocks = new List<BuildingBlock>();
                            //Puts($"Checking {tc.transform.position} owned by {l.Value} "); --Testing
                            Vis.Entities<BuildingBlock>(tc.transform.position, 100f, FactionBlocks);
                            foreach (var entry in FactionBlocks)
                            {
                                if (entry is BuildingBlock)
                                {
                                    if (!playerData.playerFactions.ContainsKey(entry.OwnerID)) continue;
                                    if (playerData.playerFactions[entry.OwnerID].faction == leaderfaction)
                                        Count++;
                                }
                            }


                        }
                factionData.Buildings[leaderfaction] = Count;
            }
            SaveData();
        }

        void SpawnTimer(BasePlayer player, int time = 0)
        {
            int interval = 60;
            if (time == 0)
            {
                SpawnTimers.Add(player.userID);
                time = ((configData.SpawnCooldown + 1) * 60);
                timer.Once(1, () => SpawnTimer(player, time));
                return;
            }
            if (BasePlayer.activePlayerList.Contains(player))
            {
                time = time - interval;
                CuiHelper.DestroyUi(player, SpawnTimerUI);
                if (time != 0)
                {
                    var element = UI.CreateElementContainer("SpawnTimerUI", "0.0 0.0 0.0 0.0", "0.88 0.9", "0.98 0.99", false);
                    TimeSpan dateDifference = TimeSpan.FromSeconds(time);
                    string clock = string.Format("{0:D2}", dateDifference.Minutes);
                    UI.CreateLabel(ref element, "SpawnTimerUI", "", $"Spawn Timer\n{clock}", 20, "0 0", "1 1");
                    CuiHelper.AddUi(player, element);
                    timer.Once(interval, () => SpawnTimer(player, time));
                }
            }
            if (time == 0)
            {
                SpawnTimers.Remove(player.userID);
                if (BasePlayer.activePlayerList.Contains(player))
                CuiHelper.DestroyUi(player, SpawnTimerUI);
            }
        }

        private void InitializeBZPlayer(BasePlayer player, ushort BZFaction, string ZoneID)
        {
            SaveInventory(player);
            SaveHealth(player);
            player.health = 100;
            player.metabolism.calories.value = 500;
            player.metabolism.hydration.value = 250;
            player.metabolism.bleeding.value = 0;
            player.metabolism.SendChangesToClient();
            if (ImmunityList.Contains(player.userID)) ImmunityList.Remove(player.userID);
            BZPlayers.Add(player.userID, new BattleZonePlayer { faction = BZFaction, bz = ZoneID, died = false, entered = false, oob = false });
        }

        private IEnumerable<PlayerInv> GetItems(ItemContainer container, string containerName)
        {
            return container.itemList.Select(item => new PlayerInv
            {
                itemid = item.info.itemid,
                container = containerName,
                amount = item.amount,
                ammo = (item.GetHeldEntity() as BaseProjectile)?.primaryMagazine.contents ?? 0,
                skin = item.skin,
                condition = item.condition,
                InvContents = item.contents?.itemList.Select(item1 => new PlayerInv
                {
                    itemid = item1.info.itemid,
                    amount = item1.amount,
                    condition = item1.condition
                }).ToArray()
            });
        }

        public void SaveHealth(BasePlayer player)
        {
            if (Condition.ContainsKey(player.userID))
                Condition.Remove(player.userID);
            Condition.Add(player.userID, new PlayerCond { health = player.health, calories = player.metabolism.calories.value, hydration = player.metabolism.hydration.value });
        }

        public void SaveInventory(BasePlayer player)
        {
            if (playerData.playerFactions[player.userID].SavedInventory)
                invData.PlayerInventory.Remove(player.userID);
            invData.PlayerInventory.Add(player.userID, new List<PlayerInv>());
            invData.PlayerInventory[player.userID].AddRange(GetItems(player.inventory.containerWear, "wear"));
            invData.PlayerInventory[player.userID].AddRange(GetItems(player.inventory.containerMain, "main"));
            invData.PlayerInventory[player.userID].AddRange(GetItems(player.inventory.containerBelt, "belt"));
            playerData.playerFactions[player.userID].SavedInventory = true;
            SaveData();
        }

        public void RestoreBZPlayer(BasePlayer player)
        {
                RestoreInventory(player);
                RestorePlayerHealth(player);
        }

        public void RestoreInventory(BasePlayer player)
        {
            var i = 0;
            player.inventory.Strip();
            foreach (var inv in invData.PlayerInventory[player.userID])
            {
                    i++;
                    var item = ItemManager.CreateByItemID(inv.itemid, inv.amount, inv.skin);
                    item.condition = inv.condition;
                    var weapon = item.GetHeldEntity() as BaseProjectile;
                    if (weapon != null) weapon.primaryMagazine.contents = inv.ammo;
                    player.inventory.GiveItem(item, inv.container == "belt" ? player.inventory.containerBelt : inv.container == "wear" ? player.inventory.containerWear : player.inventory.containerMain);
                    if (inv.InvContents == null) continue;
                    foreach (var ckitem in inv.InvContents)
                    {
                        var item1 = ItemManager.CreateByItemID(ckitem.itemid, ckitem.amount);
                        if (item1 == null) continue;
                        item1.condition = ckitem.condition;
                        item1.MoveToContainer(item.contents);
                    }
            }
            playerData.playerFactions[player.userID].SavedInventory = false;
            if (invData.PreviousInventory.ContainsKey(player.userID))
                invData.PreviousInventory.Remove(player.userID);
            invData.PreviousInventory.Add(player.userID, new List<PlayerInv>());
            invData.PreviousInventory[player.userID] = invData.PlayerInventory[player.userID];
            invData.PlayerInventory.Remove(player.userID);
            SaveData();
        }

        private void GiveBZItems(BasePlayer player, string role)
        {
            var gear = new List<Gear>();
                gear = BZItems[role];
            if (gear != null)
                foreach (var entry in gear)

                    GiveItem(player, BuildItem(entry.shortname, entry.amount, entry.skin), "");
        }

        private Item BuildItem(string shortname, int amount = 1, ulong skin = 0)
        {
            var definition = ItemManager.FindItemDefinition(shortname);
            if (definition != null)
            {
                var item = ItemManager.Create(definition, amount, skin);
                if (item != null)
                    return item;
            }
            Puts("Error making item: " + shortname);
            return null;
        }

        public void GiveItem(BasePlayer player, Item item, string container)
        {
            if (item == null) return;
            ItemContainer cont;
            switch (container)
            {
                case "wear":
                    cont = player.inventory.containerWear;
                    break;
                case "belt":
                    cont = player.inventory.containerBelt;
                    break;
                default:
                    cont = player.inventory.containerMain;
                    break;
            }
            player.inventory.GiveItem(item, cont);
        }

        void RestorePlayerHealth(BasePlayer player)
        {
            if (Condition.ContainsKey(player.userID))
            {
                player.health = Condition[player.userID].health;
                player.metabolism.calories.value = Condition[player.userID].calories;
                player.metabolism.hydration.value = Condition[player.userID].hydration;
                player.metabolism.bleeding.value = 0;
                player.metabolism.SendChangesToClient();
            }
        }

        void ChangeGlobalTime()
        {
            if (!configData.Use_FactionLeaderByTime) return;
            GlobalTime++;
            timer.Once(1 * 60, () => ChangeGlobalTime());
        }

        void RefreshOpenMemberStatus()
        {
            foreach (var entry in OpenMemberStatus)
            {
                try { FactionMemberStatus(BasePlayer.FindByID(entry)); }
                catch { OpenMemberStatus.Remove(entry); }
            }
            timer.Once(30, () => RefreshOpenMemberStatus());
        }

        #endregion

        #region Zones
        private object GetZoneLocation(string zoneid) => ZoneManager?.Call("GetZoneLocation", zoneid);
        private object GetZoneRadius(string zoneid) => ZoneManager?.Call("GetZoneRadius", zoneid);

        void DestroyZoneEntities()
        {
            foreach (var entity in bzBuildings)
                entity.KillMessage();
            bzBuildings.Clear();
        }


        void OnEnterZone(string zoneID, BasePlayer player)
        {
            if (configData.Use_BattleZones)
                if (BattleZones.ContainsValue(zoneID))
                {
                    if (BZPlayers.ContainsKey(player.userID))
                        if (BZPlayers[player.userID].bz == zoneID)
                            if (BZPlayers[player.userID].died == false)
                            {
                                if (BZPlayers[player.userID].entered == false)
                                {
                                    if (BZPlayers[player.userID].owner)
                                        GiveBZItems(player, "owner");
                                    else if (!BZPlayers[player.userID].owner && (GetPlayerFaction(player) == BZPlayers[player.userID].faction))
                                        GiveBZItems(player, "defender");
                                    else if (GetPlayerFaction(player) != BZPlayers[player.userID].faction)
                                        GiveBZItems(player, "attacker");
                                    BZPlayers[player.userID].entered = true;
                                }
                                BZPlayers[player.userID].oob = false;
                                if (BZKillTimers.ContainsKey(player.userID))
                                {
                                    BZKillTimers[player.userID].Destroy();
                                    BZKillTimers.Remove(player.userID);
                                }
                                return;
                            }
                    SendMSG(player, lang.GetMessage("NotAllowed", this));
                    Vector3 newPos = CalculateOutsidePos(player, zoneID);
                    MovePlayerPosition(player, newPos);
                    return;
                }
            if (configData.Use_FactionSafeZones)
            {
                if (isAuth(player)) return;
                if (GetPlayerFaction(player).ToString() == zoneID) return;
                else
                {
                    SendMSG(player, lang.GetMessage("NotAllowedFZone", this));
                    Vector3 newPos = CalculateOutsidePos(player, zoneID);
                    MovePlayerPosition(player, newPos);
                }
            }
        }

        void OnExitZone(string zoneID, BasePlayer player)
        {
            if (configData.Use_BattleZones)
                if (bZID != 0)
                {
                    if (BZPlayers.ContainsKey(player.userID))
                    {
                        var faction = BZPlayers[player.userID].faction;
                        BZPlayers[player.userID].oob = true;
                        if (!BZKillTimers.ContainsKey(player.userID))
                        {
                            SendMSG(player, lang.GetMessage("OOBWarning", this));
                            int time = 10;
                            BZKillTimers.Add(player.userID, timer.Repeat(1, time, () =>
                            {
                                if (BZKillTimers.ContainsKey(player.userID))
                                {
                                    if (BZPlayers[player.userID].oob)
                                    {
                                        time--;
                                        SendMSG(player, string.Format(lang.GetMessage("OOBRepeater", this), time));
                                        if (time == 0)
                                        {
                                            BZPlayers[player.userID].died = true;
                                            if (BZPlayers[player.userID].owner == true)
                                                EndBZ(GetPlayerFaction(player), "LeaderDeath");
                                            Effect.server.Run("assets/prefabs/tools/c4/effects/c4_explosion.prefab", (player.transform.position));
                                            player.Hurt(200f, Rust.DamageType.Explosion, null, true);
                                            SendPuts(string.Format(lang.GetMessage("OOBDeath", this), player.displayName, factionData.Factions[faction].Name));
                                        }
                                    }
                                    else BZKillTimers.Remove(player.userID);
                                }
                            }));
                        }
                    }
                    else
                    {
                        SendMSG(player, lang.GetMessage("NotAllowed", this));
                        Vector3 newPos = CalculateOutsidePos(player, zoneID);
                        MovePlayerPosition(player, newPos);
                    }
                }
        }

        private void createZone(BasePlayer player, ushort ID, string type)
        {
            if (type == "faction")
            {
                if (!factionData.Factions[ID].FactionZone)
                {
                    var factionname = factionData.Factions[ID].Name;
                    string msg = $"{string.Format(lang.GetMessage("EnterFactionZone", this), factionname)}";
                    Vector3 pos = player.transform.localPosition;
                    List<string> build = new List<string>();
                    build.Add("enter_message");
                    build.Add(msg.ToString());
                    build.Add("radius");
                    build.Add(configData.ZoneRadius.ToString());
                    string[] zoneArgs = build.ToArray();
                    ZoneManager?.Call("CreateOrUpdateZone", ID.ToString(), zoneArgs, pos);
                    factionData.Factions[ID].FactionZone = true;
                    ShadeZone(player, ID.ToString());
                    AddMapMarker(pos.x, pos.z, $"{factionname} {lang.GetMessage("FactionZone", this)}");
                    ZoneManagement(player, "admin");
                    return;
                }
                SendMSG(player, lang.GetMessage("CurrentFZ", this));
                return;
            }
            else if (type == "battle")
            {
                string zone = ID.ToString();
                var faction = GetPlayerFaction(player);
                if (!BattleZones.ContainsKey(faction))
                {
                    var factionname = factionData.Factions[faction].Name;
                    string msg = $"{string.Format(lang.GetMessage("EnterBattleZone", this), factionname)}";
                    Vector3 pos = player.transform.localPosition;
                    if (!BuildingCheck(player, pos, configData.ZoneRadius)) return;
                    InitializeBZPlayer(player, faction, zone);
                    BZPlayers[player.userID].owner = true;
                    List<string> build = new List<string>();
                    build.Add("enter_message");
                    build.Add(msg.ToString());
                    build.Add("radius");
                    build.Add(configData.ZoneRadius.ToString());
                    build.Add("nocorpse ");
                    build.Add("true");
                    build.Add("nogather");
                    build.Add("true");
                    build.Add("noplayerloot");
                    build.Add("true");
                    build.Add("nosuicide");
                    build.Add("true");
                    build.Add("nopickup");
                    build.Add("true");
                    build.Add("nocollect");
                    build.Add("true");
                    build.Add("nodrop");
                    build.Add("true");
                    build.Add("autolights");
                    build.Add("true");
                    string[] zoneArgs = build.ToArray();
                    ZoneManager?.Call("CreateOrUpdateZone", zone, zoneArgs, pos);
                    ShadeZone(player, zone);
                    AddMapMarker(pos.x, pos.z, $"{factionname} {lang.GetMessage("BattleZone", this)}");
                    BattleZones.Add(faction, zone);
                    BZPrepTime = 99;
                    BZPrep(faction, zone);
                    DestroyFactionMenu(player);
                    return;
                }
                else SendMSG(player, lang.GetMessage("CurrentBZ", this));
            }
        }

        private bool BuildingCheck(BasePlayer player, Vector3 pos, float radius)
        {
            foreach (var entry in MonumentLocations)
            {
                var distance = Vector3.Distance(pos, entry.Value.position);
                if (distance < entry.Value.radius + configData.ZoneRadius)
                {
                    SendMSG(player, lang.GetMessage("MonumentFailed", this));
                    return false; 
                }
            }
            List<BuildingBlock> playerbuildings = new List<BuildingBlock>();
            Vis.Entities(pos, radius, playerbuildings);
            if (playerbuildings.Count > 4)
            {
                SendMSG(player, lang.GetMessage("PlayerStructureFailed", this));
                return false;
            }
            else return true;
        }

        private void BZPrep(ushort ID, string zone)
        {
            if (!BattleZones.ContainsKey(ID)) return;
            if (BZPrepTime == 99)
            {
                BZPrepTime = configData.BZPrepTime;
                bZID = ID;
                AnnounceBZ(ID);
                timer.Once(60, () => BZPrep(ID, zone));
                return;
            }
            if (BZPrepTime != 0)
            {
                {
                    BZPrepTime -= 1;
                    AnnounceBZ(ID);
                    timer.Once(60, () => BZPrep(ID, zone));
                    return;
                }
            }
            if (BZPrepTime == 0)
            {
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    if (BZPlayers.ContainsKey(player.userID)) continue;
                    BZButton(player, ID);
                }
                InitializeBZTime(ID, 3600);
                BZTimerCountdown(ID);
                List<string> build = new List<string>();
                string[] zoneArgs = build.ToArray();
                ZoneManager?.Call("CreateOrUpdateZone", zone, zoneArgs);
            }
        }

        private void eraseZone(BasePlayer player, ushort ID, string type)
        {
            if (type == "faction")
            {
                var factionname = factionData.Factions[ID].Name;
                {
                    ZoneManager.Call("EraseZone", ID.ToString());
                    factionData.Factions[ID].FactionZone = false;
                    SendPuts(string.Format(lang.GetMessage("FactionZoneDestroyed", this), factionname));
                    UnShadeZone(player, ID.ToString());
                    RemoveMapMarker($"{factionname} {lang.GetMessage("FactionZone", this)}");
                    ZoneManagement(player, "admin");
                    return;
                }
            }
            else if (type == "battle")
            {
                var zone = BattleZones[ID];
                var factionname = factionData.Factions[ID].Name;
                ZoneManager.Call("EraseZone", zone);
                UnShadeZone(player, zone);
                RemoveMapMarker($"{factionname} {lang.GetMessage("BattleZone", this)}");
                DestroyFactionMenu(player);
            }
        }

        private void ShadeZone(BasePlayer player, string zoneID)
        {
            if (ZoneDomes)
            {
                ZoneDomes.Call("AddNewDome", player, zoneID);
            }
        }

        private void UnShadeZone(BasePlayer player, string zoneID)
        {
            if (ZoneDomes)
            {
                ZoneDomes.Call("RemoveExistingDome", player, zoneID);
            }
        }

        private object VerifyZoneID(string zoneid) => ZoneManager?.Call("CheckZoneID", zoneid);

        private void AddMapMarker(float x, float z, string name, string icon = "special")
        {
            if (LustyMap)
            {
                LustyMap.Call("AddMarker", x, z, name, icon);
            }
        }
        private void RemoveMapMarker(string name)
        {
            if (LustyMap)
                LustyMap.Call("RemoveMarker", name);
        }

        private void InitializeBZTime(ushort ID, int time)
        {
            BZTimers.Add(ID, timer.Once(time, () => EndBZ(ID, "TimeLimit")));
            var num = ID - 1;
            ushort tempID = (ushort)num;
            BZTimers.Add(tempID, timer.Every(time/6, () => BZIntermidiateCheck(tempID)));
            BZTimes.Add(ID, time);
        }

        private void BZIntermidiateCheck(ushort ID)
        {
            BZTimers.Remove(ID);
            var enemydeath = 0;
            var enemyjoined = 0;
            var activeenemies = 0;
            foreach (var player in BZPlayers)
            {
                if (player.Value.faction != playerData.playerFactions[player.Key].faction)
                {
                    if (player.Value.died == true) enemydeath++;
                    if (player.Value.entered == true) enemyjoined++;
                }
            }
            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                if (GetPlayerFaction(p) != bZID) activeenemies++;
            }
            if (enemyjoined == enemydeath && activeenemies <= enemyjoined)
                EndBZ(bZID, "EnemiesDead");
            else BZTimers.Add(ID, timer.Once(BZTimes[bZID] / 2, () => BZIntermidiateCheck(ID)));
        }

        private void BZAttackerCheck()
        {
            var enemydeath = 0;
            var enemyjoined = 0;
            var activeenemies = 0;
            foreach (var player in BZPlayers)
            {
                if (player.Value.faction != playerData.playerFactions[player.Key].faction)
                {
                    if (player.Value.died == true) enemydeath++;
                    if (player.Value.entered == true) enemyjoined++;
                }
            }
            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                if (GetPlayerFaction(p) != bZID) activeenemies++;
            }
            if (enemyjoined == enemydeath && activeenemies <= enemyjoined)
                EndBZ(bZID, "EnemiesDead");
        }

        private bool InBZ(BasePlayer player)
        {
            if (BZPlayers.ContainsKey(player.userID))
            {
                var zone = BZPlayers[player.userID].bz;
                object inZone = ZoneManager?.Call("isPlayerInZone", zone, player);
                if (inZone is bool)
                {
                    return (bool)inZone;
                }
            }
            return false;
        }
 

        private void BZTimerCountdown(ushort ID)
        {
            if (bZID == 0) return;
            var num = ID + 1;
            string zone = num.ToString();
            object success = ZoneManager?.Call("GetPlayersInZone", zone);
            if (success == null) return;
            var playersList = success as List<ulong>;
            BZTimes[ID]--;
            foreach (var p in playersList)
            {
                BasePlayer player = BasePlayer.FindByID(p);
                RefreshBZTimer(player, ID);
            }
            timer.Once(1, () => BZTimerCountdown(ID));
        }

        private void RefreshBZTimer(BasePlayer player, ushort ID)
        {
            CuiHelper.DestroyUi(player, BattleZoneTimer);
            var element = UI.CreateElementContainer("BattleZoneTimer", "0.3 0.3 0.3 0.6", "0.45 0.91", "0.55 0.948", false);
            TimeSpan dateDifference = TimeSpan.FromSeconds(BZTimes[ID]);
            string clock = string.Format("{0:D2}:{1:D2}", dateDifference.Minutes, dateDifference.Seconds);
            UI.CreateLabel(ref element, "BattleZoneTimer", "", clock, 20, "0 0", "1 1");
            if (BattleZones.ContainsKey(ID))
            {
                CuiHelper.AddUi(player, element);
               
            }
        }

        private Vector3 CalculateOutsidePos(BasePlayer player, string zoneID)
        {
            float distance = 0;
            Vector3 zonePos = (Vector3)ZoneManager?.Call("GetZoneLocation", new object[] { zoneID });
            object zoneRadius = ZoneManager?.Call("GetZoneRadius", new object[] { zoneID });
            Vector3 zoneSize = (Vector3)ZoneManager?.Call("GetZoneSize", new object[] { zoneID });
            var playerPos = player.transform.position;
            var cachedDirection = playerPos - zonePos;
            if (zoneSize != Vector3.zero)
                distance = zoneSize.x > zoneSize.z ? zoneSize.x : zoneSize.z;
            else
                distance = (float)zoneRadius;

            var newPos = zonePos + (cachedDirection / cachedDirection.magnitude * (distance + 2f));
            newPos.y = TerrainMeta.HeightMap.GetHeight(newPos);
            return newPos;
        }

        void DestroyBZTimers(ushort ID)
        {
            foreach (var entry in BZTimers)
                entry.Value.Destroy();
            BZTimers.Clear();
            foreach (var p in BZKillTimers)
                BZKillTimers[p.Key].Destroy();
            BZKillTimers.Clear();
            BZTimes.Clear();
        }

        void EndBZ(ushort ID, string reason)
        {
            if (GetLeader(ID) != null)
                if (bzTurrets.ContainsKey((ulong)GetLeader(ID)))
                {
                    foreach (var autoturret in bzTurrets[(ulong)GetLeader(ID)])
                        autoturret.DieInstantly();
                    bzTurrets[(ulong)GetLeader(ID)].Clear();
                }
            eraseZone(null, ID, "battle");
            DestroyBZTimers(ID);
            var faction = ID;
            var factionname = factionData.Factions[faction].Name;
            SendPuts(string.Format(lang.GetMessage("BZEnded", this), factionname, lang.GetMessage(reason, this)));
            bZID = 0;
            timer.Once(configData.BattleZonesCooldown * 60, () => BattleZones.Remove(ID));
            int rewardamount = 0;
            var rewardtype = "";
            if (configData.Use_EconomicsReward)
            {
                rewardamount = configData.BattleZoneRewardEconomics;
                rewardtype = "Economics";
            }
            if (configData.Use_TokensReward)
            {
                rewardamount = configData.BattleZoneRewardTokens;
                rewardtype = "Tokens";
            }
            if (configData.Use_ServerRewardsReward)
            {
                rewardamount = configData.BattleZoneRewardServerRewards;
                rewardtype = "Server Reward Points";
            }
            foreach (var player in BZPlayers)
            {
                if (player.Value.died == false && player.Value.entered == true)
                {
                    BasePlayer surviver = BasePlayer.FindByID(player.Key);
                    ImmunityList.Add(player.Key);
                    RestoreBZPlayer(surviver);
                    SendMSG(surviver, string.Format(lang.GetMessage("Immune", this))); 
                }
                if (reason == "LeaderDeath" && player.Value.entered == true)
                {
                    if (playerData.playerFactions[player.Key].faction != ID)
                    {
                        if (configData.Use_EconomicsReward)
                        {
                            Economics.Call("DepositS", player.Key.ToString(), rewardamount);
                        }
                        if (configData.Use_TokensReward)
                        {
                            EventManager.Call("AddTokens", player.Key.ToString(), rewardamount);
                        }
                        if (configData.Use_ServerRewardsReward)
                        {
                            ServerRewards?.Call("AddPoints", player.Key.ToString(), rewardamount);
                        }
                        try
                        {
                            BasePlayer participant = BasePlayer.FindByID(player.Key);
                            SendMSG(participant, string.Format(lang.GetMessage("LeaderDeathWinner", this), rewardtype, rewardamount));
                        }
                        catch { }
                    }
                }
                if (reason == "TimeLimit" && player.Value.entered == true)
                {
                    if (playerData.playerFactions[player.Key].faction == ID)
                    {
                        if (configData.Use_EconomicsReward)
                        {
                            Economics.Call("DepositS", player.Key.ToString(), rewardamount);
                        }
                        if (configData.Use_TokensReward)
                        {
                            EventManager.Call("AddTokens", player.Key.ToString(), rewardamount);
                        }
                        if (configData.Use_ServerRewardsReward)
                        {
                            ServerRewards?.Call("AddPoints", player.Key.ToString(), rewardamount);
                        }
                        try
                        {
                            BasePlayer participant = BasePlayer.FindByID(player.Key);
                            SendMSG(participant, string.Format(lang.GetMessage("TimeLimitWinner", this), rewardtype, rewardamount));
                        }
                        catch { }
                    }
                }
                if (reason == "EnemiesDead" && player.Value.entered == true)
                {
                    if (playerData.playerFactions[player.Key].faction == ID)
                    {
                        if (configData.Use_EconomicsReward)
                        {
                            Economics.Call("DepositS", player.Key.ToString(), rewardamount);
                        }
                        if (configData.Use_TokensReward)
                        {
                            EventManager.Call("AddTokens", player.Key.ToString(), rewardamount);
                        }
                        if (configData.Use_ServerRewardsReward)
                        {
                            ServerRewards?.Call("AddPoints", player.Key.ToString(), rewardamount);
                        }
                        try
                        {
                            BasePlayer participant = BasePlayer.FindByID(player.Key);
                            SendMSG(participant, string.Format(lang.GetMessage("EnemiesDeadWinner", this), rewardtype, rewardamount));
                        }
                        catch { }           
                    }
                }
            }
            BZPlayers.Clear();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, BattleZoneTimer);
            DestroyZoneEntities();
            timer.Once(600, () => ClearImmunity());
        }

        void ClearImmunity()
        {
            foreach (var p in ImmunityList)
            {
                if (BasePlayer.activePlayerList.Contains(BasePlayer.FindByID(p)))
                {
                    BasePlayer player = BasePlayer.FindByID(p);
                    SendMSG(player, string.Format(lang.GetMessage("ImmunityGone", this))); 
                }
            }
            ImmunityList.Clear();
        }

        void AnnounceBZ(ushort ID)
        {
            var faction = ID;
            var factionname = factionData.Factions[faction].Name;
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (BZPrepTime != 0)
                    SendMSG(player, string.Format(lang.GetMessage("NewBZ", this), factionname, BZPrepTime));
                else
                    SendMSG(player, string.Format(lang.GetMessage("BZStart", this), factionname));
            }

        }
        void AnnounceDuringBZ()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (!BZPlayers.ContainsKey(player.userID))
                {
                    SendMSG(player, string.Format(lang.GetMessage("StartedBZ", this)));
                }
                
            }
        }

        private void FindMonuments()
        {
            var i = 0;
            var allobjects = UnityEngine.Object.FindObjectsOfType<GameObject>();
            foreach (var gobject in allobjects)
            {
                if (gobject.name.Contains("autospawn/monument"))
                {
                    var pos = gobject.transform.position;
                    var radius = 60f;
                    MonumentLocations.Add(i, new Monuments { position = pos, radius = radius });
                    i++;
                }
            }
        }

        #endregion

        #region Faction Creation Functions

        private void QuitFactionCreation(BasePlayer player, bool isCreatingFaction)
        {
            if (isCreatingFaction)
            {
                if (ActiveCreations[player.userID].Entry.group != "")
                {
                    ConsoleSystem.Run(ConsoleSystem.Option.Server, $"group remove {ActiveCreations[player.userID].Entry.group}");
                }
                ActiveCreations.Remove(player.userID);
            }
            else ActiveEditors.Remove(player.userID);
            SendMSG(player, lang.GetMessage("QuitFactionCreation", this));
            DestroyUI(player);
        }

        private void RemoveFaction(BasePlayer player, ushort ID)
        {
            var factionname = factionData.Factions[ID].Name;
            DestroyUI(player);
            if (factionData.Factions[ID].FactionZone == true)
                eraseZone(player, ID, "faction");
            factionData.Factions.Remove(ID);
            ReassignPlayers(ID);
            SendPuts($"{factionname} {lang.GetMessage("FactionDeleted", this)}");
            SaveData();
            FactionManager(player);
            foreach (BasePlayer p in BasePlayer.activePlayerList)
                RefreshTicker(p);
        }

        private void ReassignPlayers(ushort ID)
        {
            foreach (var entry in playerData.playerFactions)
                if (entry.Value.faction == ID)
                {
                    playerData.playerFactions[entry.Key].faction = default(ushort);
                    BasePlayer player = BasePlayer.FindByID(entry.Key);
                    SetFaction(player);
                }
        }

        private void SaveFaction(BasePlayer player, bool isCreatingFaction)
        {
            FactionDesigner Creator;
            Faction Faction;

            if (isCreatingFaction)
                Creator = ActiveCreations[player.userID];
            else Creator = ActiveEditors[player.userID];

            Faction = Creator.Entry;

            if (isCreatingFaction)
            {
                factionData.Factions.Add(Creator.ID, Faction);
                ActiveCreations.Remove(player.userID);
            }
            else
            {
                factionData.Factions.Remove(Creator.ID);
                factionData.Factions.Add(Creator.ID, Faction);
                ActiveEditors.Remove(player.userID);
            }
            DestroyUI(player);
            SaveData();
            foreach (BasePlayer p in BasePlayer.activePlayerList)
                RefreshTicker(p);
            SendMSG(player,string.Format(lang.GetMessage("NewFactionCreated", this),Faction.Name));
        }
        private void ExitFactionEditor(BasePlayer player, bool isEditingFaction)
        {
            if (isEditingFaction)
            {
                ActiveEditors.Remove(player.userID);
                SendMSG(player, lang.GetMessage("QuitFactionEditor", this));
                DestroyUI(player);
            }
        }

        private void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UIMain);
            DestroyEntries(player);
        }
        private void DestroyEntries(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            if (OpenUI.ContainsKey(player.userID))
            {
                foreach (var entry in OpenUI[player.userID])
                    CuiHelper.DestroyUi(player, entry);
                OpenUI.Remove(player.userID);
            }
        }

        private int GetRandomNumber()
        {
            var random = new System.Random();
            int number = random.Next(int.MinValue, int.MaxValue);
            return number;
        }

        private Faction GetFactionInfo(ushort ID)
        {
            foreach (var entry in factionData.Factions)
            {
                if (entry.Key == ID)
                    return entry.Value;
            }
            return null;
        }

        public static class StringTool
        {
            public static string Truncate(string source, int length)
            {
                if (source.Length > length)
                {
                    source = source.Substring(0, length);
                }
                return source;
            }
        }

        #endregion

        #region Faction Creation Console Commands

        [ConsoleCommand("CUI_SelectColor")]
        private void cmdSelectColor(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (player.IsAdmin)
            {
                var Color = arg.Args[0];
                FactionDesigner Creator;
                if (ActiveCreations.ContainsKey(player.userID))
                    Creator = ActiveCreations[player.userID];
                else Creator = ActiveEditors[player.userID];
                foreach (var entry in Colors.Where(kvp => kvp.Color == Color))
                {
                    Creator.Entry.ChatColor = entry.ChatColor;
                    Creator.Entry.UIColor = entry.UIColor;
                }
                DestroyUI(player);
                if (ActiveEditors.ContainsKey(player.userID))
                {
                    CreationHelp(player, 20);
                    return;
                }
                CreationHelp(player, 3);
            }
        }


        [ConsoleCommand("CUI_SelectFactionType")]
        private void cmdSelectFactionType(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (player.IsAdmin)
            {
                var type = (FactionType)Enum.Parse(typeof(FactionType), arg.Args[0]);
                FactionDesigner Creator;
                if (ActiveCreations.ContainsKey(player.userID))
                    Creator = ActiveCreations[player.userID];
                else Creator = ActiveEditors[player.userID];
                Creator.Entry.type = type;
                Creator.Entry.Kills = 0;
                Creator.Entry.PlayerCount = 0;
                DestroyUI(player);
                if (ActiveEditors.ContainsKey(player.userID))
                {
                    CreationHelp(player, 20);
                    return;
                }
                if (configData.Use_Kits)
                {
                    CreationHelp(player, 4);
                }
                else if (configData.Use_Groups)
                {
                    CreationHelp(player, 5);
                }
                else
                    CreationHelp(player, 20);
            }
        }


        [ConsoleCommand("CUI_SelectFactionKit")]
        private void cmdSelectFactionKit(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (player.IsAdmin)
            {
                var kit = arg.Args[0];
                FactionDesigner Creator;
                if (ActiveCreations.ContainsKey(player.userID))
                    Creator = ActiveCreations[player.userID];
                else Creator = ActiveEditors[player.userID];
                Creator.Entry.kit = kit;
                DestroyUI(player);
                if (ActiveEditors.ContainsKey(player.userID))
                {
                    CreationHelp(player, 20);
                    return;
                }
                if (configData.Use_Groups)
                {
                    CreationHelp(player, 5);
                }
                else
                    CreationHelp(player, 20);
            }
        }

        [ConsoleCommand("CUI_NewFaction")]
        private void cmdNewFaction(ConsoleSystem.Arg arg)
        {
            ActiveCreations.Clear();
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyFactionMenu(player);
            if (player.IsAdmin)
            {
                var random = new System.Random();
                int number;
                int r = 0;
                int Number = GetRandomNumber();
                ushort ID = (ushort)Number;
                while (r >= 1)
                {
                    number = random.Next(int.MinValue, int.MaxValue);
                    if (ID >= ushort.MinValue & ID <= ushort.MaxValue)
                    {
                        foreach (var entry in factionData.Factions.Where(kvp => kvp.Key == ID)) r++;
                    }
                }
                ActiveCreations.Add(player.userID, new FactionDesigner { ID = ID, Entry = new Faction { } });
                DestroyUI(player);
                CreationHelp(player, 0);
            }
        }

        [ConsoleCommand("CUI_TryDeleteFaction")]
        private void cmdTryDeleteFaction(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (player.IsAdmin)
            {
                ushort ID = Convert.ToUInt16(arg.Args[0]);
                foreach (var faction in factionData.Factions)
                {
                    if (faction.Key == ID)
                    {
                        DestroyUI(player);
                        ConfirmFactionDeletion(player, ID);
                        return;
                    }
                }
            }
        }

        [ConsoleCommand("UI_CUI_LeaderEditing")]
        private void cmdCUI_LeaderEditing(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (player.IsAdmin)
            {
                ushort faction = Convert.ToUInt16(arg.Args[0]);
                int page = Convert.ToInt16(arg.Args[1]);
                LeaderEditing(player, faction, page);
                return;
            }
        }

        [ConsoleCommand("UI_CUIUnassignLeader")]
        private void cmdCUI_UnassignLeader(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (player.IsAdmin)
            {
                ushort faction = Convert.ToUInt16(arg.Args[0]);
                var oldleaderID = factionData.leader[faction];
                factionData.leader.Remove(faction);
                try
                {
                    BasePlayer oldleader = BasePlayer.FindByID(oldleaderID);
                    SendMSG(oldleader, string.Format(lang.GetMessage("RemovedAsLeader", this), factionData.Factions[faction].Name));
                    SendMSG(player, string.Format(lang.GetMessage("AdminMSGRemovedLeader", this), oldleader.displayName, factionData.Factions[faction].Name));
                }
                catch
                {
                    SendMSG(player, string.Format(lang.GetMessage("AdminMSGRemovedLeader", this), playerData.playerFactions[oldleaderID].Name, factionData.Factions[faction].Name));
                }
                SaveData();
                FactionMenuBar(player);
                LeaderEditing(player, faction);
            }
        }

        [ConsoleCommand("UI_CUIAssignLeader")]
        private void cmdCUIAssignLeader(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (player.IsAdmin)
            {
                ushort UID = Convert.ToUInt16(arg.Args[0]);
                var faction = LeaderPromotes[UID].factionID;
                foreach (var entry in LeaderPromotes)
                    if (entry.Key == UID)
                    {
                        var factionname = factionData.Factions[entry.Value.factionID].Name;
                        factionData.leader.Remove(faction);
                        factionData.leader.Add(entry.Value.factionID, entry.Value.playerID);
                        try
                        {
                            BasePlayer newleader = BasePlayer.FindByID(entry.Value.playerID);
                            BroadcastFaction(newleader, $"{ playerData.playerFactions[entry.Value.playerID].Name} {lang.GetMessage("newassignedleader", this)} {factionname}");
                            SendMSG(player, string.Format(lang.GetMessage("AdminMSGAssignedLeader", this), newleader.displayName, factionname));
                        }
                        catch
                        {
                            foreach (BasePlayer p in BasePlayer.activePlayerList)
                                if (GetPlayerFaction(p) == entry.Value.factionID)
                                {
                                    BroadcastFaction(p, $"{ playerData.playerFactions[entry.Value.playerID].Name} {lang.GetMessage("newassignedleader", this)} {factionname}");
                                    break;
                                }
                            SendMSG(player, string.Format(lang.GetMessage("AdminMSGAssignedLeader", this), playerData.playerFactions[entry.Value.playerID].Name, factionname));
                        }
                    }
                foreach (var entry in LeaderPromotes.Where(kvp => kvp.Value.factionID == faction).ToList())
                {
                    LeaderPromotes.Remove(entry.Key);
                }
                SaveData();
                FactionMenuBar(player);
                LeaderEditing(player, faction);
            }
        }

        [ConsoleCommand("CUI_DeleteFaction")]
        private void cmdDeleteFaction(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (arg.Args[0] == "reject")
            {
                DestroyUI(player);
                SendMSG(player, string.Format(lang.GetMessage("ExitedFactionDeletion", this)));
                return;
            }
            if (player.IsAdmin)
            {
                ushort ID = Convert.ToUInt16(arg.Args[0]);
                RemoveFaction(player, ID);
                return;

            }
        }

        [ConsoleCommand("CUI_EditFaction")]
        private void cmdEditFaction(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (player.IsAdmin)
            {
                if (ActiveEditors.ContainsKey(player.userID))
                    ActiveEditors.Remove(player.userID);
                ActiveEditors.Add(player.userID, new FactionDesigner());

                ushort ID = Convert.ToUInt16(arg.Args[0]);
                var Faction = GetFactionInfo(ID);
                if (Faction == null) return;
                ActiveEditors[player.userID].ID = ID;
                ActiveEditors[player.userID].Entry = Faction;
                ActiveEditors[player.userID].OldEntry = Faction;
                DestroyFactionMenu(player);
                FactionEditorMenu(player);
            }
        }

        [ConsoleCommand("CUI_EditFactionVar")]
        private void cmdEditFactionVar(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (player.IsAdmin)
            {
                if (ActiveEditors.ContainsKey(player.userID))
                {
                    DestroyUI(player);
                    switch (arg.Args[0].ToLower())
                    {
                        case "name":
                            CreationHelp(player, 0);
                            break;
                        case "title":
                            CreationHelp(player, 1);
                            break;
                        case "color":
                            CreationHelp(player, 2);
                            break;
                        case "type":
                            CreationHelp(player, 3);
                            break;
                        case "kit":
                            CreationHelp(player, 4);
                            break;
                        case "group":
                            CreationHelp(player, 5);
                            break;
                        default:
                            return;
                    }
                }
            }
        }

        [ConsoleCommand("CUI_SaveFaction")]
        private void cmdSaveFaction(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (player.IsAdmin)
            {
                bool creating = false;
                if (ActiveCreations.ContainsKey(player.userID))
                    creating = true;
                SaveFaction(player, creating);
            }
        }
        [ConsoleCommand("CUI_ExitFaction")]
        private void cmdExitFaction(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (player.IsAdmin)
            {
                bool creating = false;
                if (ActiveCreations.ContainsKey(player.userID))
                    creating = true;
                QuitFactionCreation(player, creating);
            }
        }

        [ConsoleCommand("CUI_ExitFactionEditor")]
        private void cmdExitFactionEditor(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (player.IsAdmin)
            {
                bool IsEditing = false;
                if (ActiveEditors.ContainsKey(player.userID))
                    IsEditing = true;
                ExitFactionEditor(player, IsEditing);
            }
        }

        [ConsoleCommand("CUI_TryDeleteSpawn")]
        private void cmdTryDeleteSpawn(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (player.IsAdmin)
            {
                ushort ID = Convert.ToUInt16(arg.Args[1]);
                string name = "";
                string spawntype = "";
                if (arg.Args.Contains("rally"))
                    foreach (var rally in factionData.RallySpawns)
                    {
                        if (rally.Key == ID)
                        {
                            spawntype = "rally";
                            name = factionData.RallySpawns[ID].Name;
                            DestroyUI(player);
                            ConfirmSpawnDeletion(player, ID, name, spawntype);
                            return;
                        }
                    }
                if (arg.Args.Contains("faction"))
                    foreach (var spawn in factionData.FactionSpawns)
                    {
                        if (spawn.Key == ID)
                        {
                            spawntype = "faction";
                            name = factionData.FactionSpawns[ID].Name;
                            DestroyUI(player);
                            ConfirmSpawnDeletion(player, ID, name, spawntype);
                            return;
                        }
                    }
            }
        }

        [ConsoleCommand("CUI_DeleteSpawn")]
        private void cmdDeleteSpawn(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (arg.Args[0] == "reject")
            {
                DestroyUI(player);
                SendMSG(player, string.Format(lang.GetMessage("ExitedFactionDeletion", this)));
                return;
            }
            if (player.IsAdmin)
            {
                if (arg.Args[0] == "rally")
                {
                    ushort ID = Convert.ToUInt16(arg.Args[0]);
                    CUIRemoveRallySpawn(player, ID);
                    return;
                }
                else if (arg.Args[0] == "faction")
                {
                    ushort ID = Convert.ToUInt16(arg.Args[0]);
                    CUIRemoveRallySpawn(player, ID);
                    return;
                }

            }
        }

        #endregion

        #region FactionCreationUI

        private void CreationHelp(BasePlayer player, int page = 0, ushort factionID = 0)
        {
            DestroyEntries(player);
            FactionDesigner faction = null;
            SpawnDesigner spawn = null;
            if (ActiveCreations.ContainsKey(player.userID))
                faction = ActiveCreations[player.userID];
            else if (ActiveEditors.ContainsKey(player.userID))
                faction = ActiveEditors[player.userID];
            else if (SpawnCreation.ContainsKey(player.userID))
                spawn = SpawnCreation[player.userID];
            //if (faction == null && spawn == null) return;

            var HelpMain = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.3 0.3", "0.7 0.9");
            UI.CreatePanel(ref HelpMain, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98");
            switch (page)
            {
                case 0:
                    UI.CreateLabel(ref HelpMain, FactionsUIPanel, "", $"{configData.MSG_MainColor}This is the faction creation help menu.\n</color> {configData.MSG_Color}Follow the instructions given by typing in chat.\n\nYou can exit faction creation at any time by typing </color>{configData.MSG_MainColor}'quit'\n\n\n\nTo proceed enter the name of the new Faction!</color>", 20, "0 0", "1 1");
                    break;
                case 1:
                    CuiHelper.DestroyUi(player, FactionsUIPanel);
                    UI.CreateLabel(ref HelpMain, FactionsUIPanel, UIColors["red"], $"{configData.MSG_MainColor}Provide a Faction Leader Title</color>", 20, "0 0", "1 1");
                    break;
                case 2:
                    CuiHelper.DestroyUi(player, FactionsUIPanel);
                    UI.CreatePanel(ref HelpMain, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
                    UI.CreateLabel(ref HelpMain, FactionsUIPanel, "", $"{configData.MSG_MainColor}Select a Faction Color</color>", 20, "0 0", "1 1");
                    int i = 0;
                    foreach (var entry in Colors)
                    {
                        CreateOptionButton(ref HelpMain, FactionsUIPanel, entry.UIColor, entry.Color, $"CUI_SelectColor {entry.Color}", i); i++;
                    }
                    break;
                case 3:
                    CuiHelper.DestroyUi(player, FactionsUIPanel);
                    UI.CreatePanel(ref HelpMain, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
                    UI.CreateLabel(ref HelpMain, FactionsUIPanel, "", $"{configData.MSG_MainColor}Select a Faction Type</color>", 20, "0 0", "1 1");
                    var values = Enum.GetValues(typeof(FactionType));
                    i = 0;
                    foreach (var entry in values)
                    {
                        CreateOptionButton(ref HelpMain, FactionsUIPanel, UIColors["buttonbg"], $"{ Enum.GetName(typeof(FactionType), entry)}", $"CUI_SelectFactionType {entry}", i); i++;
                    }
                    break;

                case 4:
                    CuiHelper.DestroyUi(player, FactionsUIPanel);
                    UI.CreatePanel(ref HelpMain, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
                    UI.CreateLabel(ref HelpMain, FactionsUIPanel, "", $"{configData.MSG_MainColor}Select a Faction Kit</color>", 20, "0 0", "1 1");
                    i = 0;
                    CreateKitButton(ref HelpMain, FactionsUIPanel, UIColors["buttonbg"], "No Kit", $"CUI_SelectFactionKit None", i);i++;
                    foreach (string kitname in GetKitNames())
                    {
                        CreateKitButton(ref HelpMain, FactionsUIPanel, UIColors["buttonbg"], kitname, $"CUI_SelectFactionKit {kitname}", i); i++;
                    }
                    break;
                case 5:
                    CuiHelper.DestroyUi(player, FactionsUIPanel);
                    UI.CreateLabel(ref HelpMain, FactionsUIPanel, "", $"{configData.MSG_MainColor}Provide a Faction Group</color>", 20, "0 0", "1 1");
                    break;
                case 9:

                    UI.CreateLabel(ref HelpMain, FactionsUIPanel, UIColors["red"], $"{configData.MSG_MainColor}Please Type a Spawn Point Name</color>", 20, "0 0", "1 1");
                    break;
                case 10:
                    CuiHelper.DestroyUi(player, FactionsUIPanel);
                    UI.CreatePanel(ref HelpMain, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
                    UI.CreateLabel(ref HelpMain, FactionsUIPanel, configData.MSG_Color, $"You have successfully created a New Spawn Point. To confirm click 'Save Spawn'", 20, "0.1 0.1", "0.9 0.89");
                    UI.CreateButton(ref HelpMain, FactionsUIPanel, UIColors["buttonbg"], "Save Spawn", 18, "0.2 0.05", "0.4 0.15", $"CUI_SaveSpawn");
                    UI.CreateButton(ref HelpMain, FactionsUIPanel, UIColors["buttonred"], "Cancel", 18, "0.6 0.05", "0.8 0.15", $"CUI_ExitSpawn");
                    break;
                case 11:
                    CuiHelper.DestroyUi(player, FactionsUIPanel);
                    foreach (var entry in FactionInvites)
                        if (entry.Value.confirm)
                        {
                            var FactionName = factionData.Factions[entry.Value.factionID].Name;
                            UI.CreatePanel(ref HelpMain, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
                            UI.CreateLabel(ref HelpMain, FactionsUIPanel, configData.MSG_Color, $"You have been invited to join the Faction: {FactionName}. Click 'Accept' or 'Decline'", 20, "0.1 0.1", "0.9 0.89");
                            UI.CreateButton(ref HelpMain, FactionsUIPanel, UIColors["buttonbg"], "Accept", 18, "0.2 0.05", "0.4 0.15", $"CUI_AcceptInvite");
                            UI.CreateButton(ref HelpMain, FactionsUIPanel, UIColors["buttonred"], "Decline", 18, "0.6 0.05", "0.8 0.15", $"CUI_DeclineInvite");
                            break;
                        }
                    break;
                case 12:
                    CuiHelper.DestroyUi(player, FactionsUIPanel);
                    foreach (var entry in FactionKicks)
                        if (entry.Value.executerID == player.userID && (entry.Value.confirm))
                        {
                            UI.CreatePanel(ref HelpMain, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
                            UI.CreateLabel(ref HelpMain, FactionsUIPanel, configData.MSG_Color, lang.GetMessage("ConfirmKick", this), 20, "0.1 0.1", "0.9 0.89");
                            UI.CreateButton(ref HelpMain, FactionsUIPanel, UIColors["buttonbg"], "Yes", 18, "0.2 0.05", "0.4 0.15", $"UI_ConfirmKickPlayer yes");
                            UI.CreateButton(ref HelpMain, FactionsUIPanel, UIColors["buttonred"], "No", 18, "0.6 0.05", "0.8 0.15", $"UI_ConfirmKickPlayer no");
                            break;
                        }
                    break;
                default:
                    CuiHelper.DestroyUi(player, FactionsUIPanel);
                    HelpMain = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.3 0.3", "0.7 0.9", true);
                    UI.CreatePanel(ref HelpMain, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98");
                    UI.CreateLabel(ref HelpMain, FactionsUIPanel, configData.MSG_Color, $"You have successfully created a new faction. To confirm click 'Save Faction'", 20, "0 .9", "1 1");
                    string factionDetails = $"Faction Name: {faction.Entry.Name}\nLeader Title: {faction.Entry.LeaderTitle}\nFaction Type: {faction.Entry.type}";
                    if (configData.Use_Kits)
                    {
                        factionDetails += $"\nFaction Kit: {faction.Entry.FactionKit}";
                    }
                    if (configData.Use_Groups)
                    {
                        factionDetails += $"\nFaction Group: {faction.Entry.group}";
                    }
                    UI.CreateLabel(ref HelpMain, FactionsUIPanel, faction.Entry.UIColor, factionDetails, 20, "0.1 0.1", "0.9 0.89", TextAnchor.MiddleLeft);
                    UI.CreateButton(ref HelpMain, FactionsUIPanel, UIColors["buttonbg"], "Save Faction", 18, "0.2 0.05", "0.4 0.15", $"CUI_SaveFaction");
                    if (ActiveCreations.ContainsKey(player.userID))
                        UI.CreateButton(ref HelpMain, FactionsUIPanel, UIColors["buttonred"], "Cancel", 18, "0.6 0.05", "0.8 0.15", $"CUI_ExitFaction");
                    else if (ActiveEditors.ContainsKey(player.userID))
                        UI.CreateButton(ref HelpMain, FactionsUIPanel, UIColors["buttonred"], "Cancel", 18, "0.6 0.05", "0.8 0.15", $"CUI_ExitFactionEditor");
                    break;
            }
            CuiHelper.AddUi(player, HelpMain);
        }

        private void FactionInfo(BasePlayer player, ushort faction, int page)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.3 0.3", "0.7 0.9", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98");
            UI.CreateLabel(ref element, FactionsUIPanel, "1 1 1 0.025", "FACTION INFO", 100, "0.01 0.01", "0.99 0.99");
            int i = 0;
            var f = factionData.Factions[faction];
            var typeinfo = "";
            var leadername = "None";
            if (f.type == FactionType.FFA) typeinfo = lang.GetMessage("Normal", this);
            if (f.type == FactionType.Regular)
            {
                if (configData.BuildingProtectionEnabled == true && configData.FFDisabled == true)
                    typeinfo = lang.GetMessage("Normal", this);
                if (configData.BuildingProtectionEnabled == false && configData.FFDisabled == false)
                    typeinfo = lang.GetMessage("NormalNoBuildingProtection", this);
                if (configData.BuildingProtectionEnabled == true && configData.FFDisabled == false)
                    typeinfo = lang.GetMessage("NormalFFEnabled", this);
                if (configData.BuildingProtectionEnabled == false && configData.FFDisabled == true)
                    typeinfo = lang.GetMessage("FFEnabledNoBuildingProtection", this);
            }
            if (factionData.leader.ContainsKey(faction))
            {
                leadername = playerData.playerFactions[factionData.leader[faction]].Name;
            }
            CreateFactionDetails(ref element, FactionsUIPanel, $"Faction Name: {f.ChatColor}{f.Name}</color>", i); i++;
            CreateFactionDetails(ref element, FactionsUIPanel, $"Faction Type: {f.ChatColor}{ typeinfo}</color>", i); i++;
            CreateFactionDetails(ref element, FactionsUIPanel, $"Faction Player Count: {f.ChatColor}{f.PlayerCount}</color>", i); i++;
            if (configData.Use_FactionKillIncentives)
            {
                CreateFactionDetails(ref element, FactionsUIPanel, $"Faction Kill Total: {f.ChatColor}{f.Kills}</color>", i); i++;
            }
            CreateFactionDetails(ref element, FactionsUIPanel, $"Faction Leader: {f.ChatColor}{leadername}</color>", i); i++;
            if (configData.Use_Taxes)
            {
                CreateFactionDetails(ref element, FactionsUIPanel, $"Faction Tax: {f.ChatColor}{f.tax}</color>", i); i++;
            }
            UI.CreateButton(ref element, FactionsUIPanel, UIColors["buttonbg"], "Go Back", 18, "0.2 0.05", "0.4 0.15", $"UI_FactionSelection {page}");
            UI.CreateButton(ref element, FactionsUIPanel, f.UIColor, "Join Faction", 18, "0.6 0.05", "0.8 0.15", $"CUI_FactionSelection {faction}");
            CuiHelper.AddUi(player, element);
        }

        private void CreateFactionEditButton(ref CuiElementContainer container, string panelName, string buttonname, string command, int number)
        {
            Vector2 dimensions = new Vector2(0.2f, 0.1f);
            Vector2 origin = new Vector2(0.4f, 0.7f);
            Vector2 offset = new Vector2(0, (0.01f + dimensions.y) * number);

            Vector2 posMin = origin - offset;
            Vector2 posMax = posMin + dimensions;

            UI.CreateButton(ref container, panelName, UIColors["buttonbg"], buttonname, 18, $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}", command);
        }

        private void CreateFactionDetails(ref CuiElementContainer container, string panelName, string text, int number)
        {
            Vector2 dimensions = new Vector2(0.8f, 0.1f);
            Vector2 origin = new Vector2(0.1f, 0.7f);
            Vector2 offset = new Vector2(0, (0.01f + dimensions.y) * number);

            Vector2 posMin = origin - offset;
            Vector2 posMax = posMin + dimensions;
            UI.CreateLabel(ref container, panelName, UIColors["buttonbg"], text, 18, $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}");
        }

        private void DeletionMenu(BasePlayer player, string page, string command)
        {
            DestroyEntries(player);
            var Main = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.12 0", "1 1");
            UI.CreatePanel(ref Main, FactionsUIPanel, UIColors["light"], "0.01 0.01", "0.99 0.99", true);
            UI.CreateLabel(ref Main, FactionsUIPanel, "1 1 1 0.025", page, 200, "0.01 0.01", "0.99 0.99");
            int i = 0;
            CreateDelEditButton(ref Main, 0.795f, FactionsUIPanel, "Delete", i, command); i++;
            CuiHelper.AddUi(player, Main);
        }

        private void ConfirmFactionDeletion(BasePlayer player, ushort ID)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var FactionName = factionData.Factions[ID].Name;
            var ConfirmDelete = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.2 0.4", "0.8 0.8", true);
            UI.CreatePanel(ref ConfirmDelete, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98");
            UI.CreateLabel(ref ConfirmDelete, FactionsUIPanel, "", $"{configData.MSG_MainColor}Are you sure you want to delete: {FactionName}</color>", 20, "0.1 0.6", "0.9 0.9");
            UI.CreateButton(ref ConfirmDelete, FactionsUIPanel, UIColors["buttonbg"], "Yes", 18, "0.6 0.2", "0.8 0.3", $"CUI_DeleteFaction {ID}");
            UI.CreateButton(ref ConfirmDelete, FactionsUIPanel, UIColors["buttonbg"], "No", 18, "0.2 0.2", "0.4 0.3", $"CUI_DeleteFaction reject");

            CuiHelper.AddUi(player, ConfirmDelete);
        }

        private void ConfirmSpawnDeletion(BasePlayer player, ushort ID, string name, string spawntype)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var ConfirmDelete = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.2 0.4", "0.8 0.8", true);
            UI.CreatePanel(ref ConfirmDelete, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98");
            UI.CreateLabel(ref ConfirmDelete, FactionsUIPanel, "", $"{configData.MSG_MainColor}Are you sure you want to delete the {spawntype.ToUpper()} spawn: {name}</color>", 20, "0.1 0.6", "0.9 0.9");
            UI.CreateButton(ref ConfirmDelete, FactionsUIPanel, UIColors["buttonbg"], "Yes", 18, "0.6 0.2", "0.8 0.3", $"CUI_DeleteSpawn {ID} {spawntype}");
            UI.CreateButton(ref ConfirmDelete, FactionsUIPanel, UIColors["buttonbg"], "No", 18, "0.2 0.2", "0.4 0.3", $"CUI_DeleteSpawn reject");

            CuiHelper.AddUi(player, ConfirmDelete);
        }

        private void CreateDelEditButton(ref CuiElementContainer container, float xPos, string panelName, string buttonname, int number, string command)
        {
            Vector2 dimensions = new Vector2(0.18f, 0.05f);
            Vector2 origin = new Vector2(xPos, 0.8f);
            Vector2 offset = new Vector2(0, (-0.01f - dimensions.y) * number);

            Vector2 posMin = origin + offset;
            Vector2 posMax = posMin + dimensions;

            UI.CreateButton(ref container, panelName, UIColors["buttonbg"], buttonname, 14, $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}", $"{command} {buttonname}");
        }

        private void FactionEditorMenu(BasePlayer player)
        {
            DestroyEntries(player);
            var Main = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.2 0.4", "0.8 0.8");
            UI.CreatePanel(ref Main, FactionsUIPanel, UIColors["light"], "0.01 0.01", "0.99 0.99", true);
            UI.CreateLabel(ref Main, FactionsUIPanel, "1 1 1 0.025", "EDITOR", 200, "0.01 0.01", "0.99 0.99");

            int i = 0;
            UI.CreateLabel(ref Main, FactionsUIPanel, "", $"{configData.MSG_MainColor}Select a value to change</color>", 20, "0.25 0.8", "0.75 0.9");
            CreateFactionEditButton(ref Main, FactionsUIPanel, "Faction Name", "CUI_EditFactionVar name", i); i++;
            CreateFactionEditButton(ref Main, FactionsUIPanel, "Faction Leader Title", "CUI_EditFactionVar title", i); i++;
            CreateFactionEditButton(ref Main, FactionsUIPanel, "Faction Color", "CUI_EditFactionVar color", i); i++;
            CreateFactionEditButton(ref Main, FactionsUIPanel, "Faction Type", "CUI_EditFactionVar type", i); i++;
            CreateFactionEditButton(ref Main, FactionsUIPanel, "Faction Kit", "CUI_EditFactionVar kit", i); i++;
            CreateFactionEditButton(ref Main, FactionsUIPanel, "Faction Group", "CUI_EditFactionVar group", i); i++;
            CuiHelper.AddUi(player, Main);
        }
        private void NumberPad(BasePlayer player, string msg, string cmd)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.3 0.2", "0.7 0.8", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98");
            UI.CreateLabel(ref element, FactionsUIPanel, "", $"{configData.MSG_MainColor}{msg}</color>", 12, "0.1 0.7", "0.9 0.9",TextAnchor.UpperCenter);
            var i = 0;
            while (i < 60)
            {
                CreateNumberPadButton(ref element, FactionsUIPanel, .02f, i, cmd); i++;
            }
            CuiHelper.AddUi(player, element);
        }
        private void CreateNumberPadButton(ref CuiElementContainer container, string panelName, float xPos, int number, string command)
        {
            var pos = CalcNumButtonPos(number);
            UI.CreateButton(ref container, panelName, UIColors["buttonbg"], number.ToString(), 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"{command} {number}");
        }

        private float[] CalcNumButtonPos(int number)
        {
            Vector2 position = new Vector2(0.085f, 0.65f);
            Vector2 dimensions = new Vector2(0.0725f, 0.0875f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 10)
            {
                offsetX = (0.01f + dimensions.x) * number;
            }
            if (number > 9 && number < 20)
            {
                offsetX = (0.01f + dimensions.x) * (number - 10);
                offsetY = (-0.02f - dimensions.y) * 1;
            }
            if (number > 19 && number < 30)
            {
                offsetX = (0.01f + dimensions.x) * (number - 20);
                offsetY = (-0.02f - dimensions.y) * 2;
            }
            if (number > 29 && number < 40)
            {
                offsetX = (0.01f + dimensions.x) * (number - 30);
                offsetY = (-0.02f - dimensions.y) * 3;
            }
            if (number > 39 && number < 50)
            {
                offsetX = (0.01f + dimensions.x) * (number - 40);
                offsetY = (-0.02f - dimensions.y) * 4;
            }
            if (number > 49 && number < 60)
            {
                offsetX = (0.01f + dimensions.x) * (number - 50);
                offsetY = (-0.02f - dimensions.y) * 5;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        #endregion

        #region UI Creation

        //UI
        private string PanelLevelAdvanced = "LevelAdvancement";
        private string PanelRankAdvanced = "RankAdvancement";
        private string PanelKillTicker = "KillTicker";
        private string PanelFactionMenuBar = "FactionMenuBar";
        private string PanelSpawnButtons = "SpawnButtons";
        private string PanelBZButton = "BZButton";
        private string PanelMemberStatus = "MemberStatus";

        public class UI
        {
            static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor = false)
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor
                    },
                    new CuiElement().Parent,
                    panelName
                }
            };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = 1.0f, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);
            }

            static public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 1.0f },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }

        }

        private void CreateInstructionEntry(ref CuiElementContainer container, string panelName, string color, string command, int num)
        {
            var pos = InstructionPos(num);
            UI.CreateLabel(ref container, panelName, color, command, 18, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", TextAnchor.UpperLeft);
        }

        private float[] InstructionPos(int number)
        {
            Vector2 position = new Vector2(0.02f, 0.3f);
            Vector2 dimensions = new Vector2(0.75f, 0.5f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 20)
            {
                offsetY = (-0.0001f - dimensions.y) * number;
            }
            if (number > 19 && number < 40)
            {
                offsetX = (0.35f + dimensions.x) * 1;
                offsetY = (-0.0001f - dimensions.y) * (number - 20);
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }



        private void CreateStatusEntry(ref CuiElementContainer container, string panelName, string name, float health, int num)
        {
            var percent = System.Convert.ToDouble((float)health / (float)100f);
            var xMax = 0.6f + (0.4f * percent);
            var ydifference = .0505;
            var ymin = 0.85 - (ydifference * num);
            var ymax = 0.89 - (ydifference * num);
            UI.CreateLabel(ref container, panelName, "1 1 1 1", name, 12, $"0.02 {ymin}", $"0.59 {ymax}", TextAnchor.MiddleLeft);
            UI.CreatePanel(ref container, panelName, UIColors["buttonbg"], $"0.6 {ymin}", $"1.0 {ymax}");
            UI.CreatePanel(ref container, panelName, UIColors["green"], $"0.6 {ymin}", $"{xMax} {ymax}");
        }

        private void CreateTickerEntry(ref CuiElementContainer container, string panelName, ushort faction, int num)
        {
            string name = factionData.Factions[faction].Name.ToUpper();
            string color = factionData.Factions[faction].UIColor;
            int kills = factionData.Factions[faction].Kills;
            var pos = TickerEntryPos(num);
            UI.CreateLabel(ref container, panelName, color, $"{name}: {kills}", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", TextAnchor.MiddleCenter);
        }

        private float[] TickerEntryPos(int number)
        {
            var c = 0;
            foreach (var faction in factionData.Factions.Where(kvp => kvp.Value.type == FactionType.Regular))
            {
                c++;
            }
            Vector2 position = new Vector2(0.1f, 0.5f);
            Vector2 dimensions = new Vector2(0.2f, 0.2f);
            if (c < 10)
            {
                position = new Vector2(0.2f, 0.5f);
                dimensions = new Vector2(0.2f, 0.2f);
            }
            if (c < 7)
            {
                position = new Vector2(0.3f, 0.5f);
                dimensions = new Vector2(0.2f, 0.2f);
            }
            if (c < 4)
            {
                position = new Vector2(0.4f, 0.5f);
                dimensions = new Vector2(0.2f, 0.2f);
            }
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 3)
            {
                offsetY = (-0.00001f - dimensions.y) * number;
            }
            if (number > 2 && number < 6)
            {
                offsetX = (0.0001f + dimensions.x) * 1;
                offsetY = (-0.00001f - dimensions.y) * (number - 3);
            }
            if (number > 5 && number < 9)
            {
                offsetX = (0.0001f + dimensions.x) * 2;
                offsetY = (-0.00001f - dimensions.y) * (number - 6);
            }
            if (number > 8 && number < 12)
            {
                offsetX = (0.0001f + dimensions.x) * 3;
                offsetY = (-0.00001f - dimensions.y) * (number - 9);
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private void CreateOptionButton(ref CuiElementContainer container, string panelName, string color, string name, string cmd, int num)
        {
            var pos = CalcButtonPos(num);
            UI.CreateButton(ref container, panelName, color, name, 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", cmd);
        }

        private void CreateKitButton(ref CuiElementContainer container, string panelName, string color, string name, string cmd, int num)
        {
            var pos = CalcKitButtonPos(num);
            UI.CreateButton(ref container, panelName, color, name, 10, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", cmd);
        }

        private float[] CalcKitButtonPos(int number)
        {
            Vector2 position = new Vector2(0.05f, 0.82f);
            Vector2 dimensions = new Vector2(0.125f, 0.125f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 6)
            {
                offsetX = (0.03f + dimensions.x) * number;
            }
            if (number > 5 && number < 12)
            {
                offsetX = (0.03f + dimensions.x) * (number - 6);
                offsetY = (-0.06f - dimensions.y) * 1;
            }
            if (number > 11 && number < 18)
            {
                offsetX = (0.03f + dimensions.x) * (number - 12);
                offsetY = (-0.06f - dimensions.y) * 2;
            }
            if (number > 17 && number < 24)
            {
                offsetX = (0.03f + dimensions.x) * (number - 18);
                offsetY = (-0.06f - dimensions.y) * 3;
            }
            if (number > 23 && number < 36)
            {
                offsetX = (0.03f + dimensions.x) * (number - 24);
                offsetY = (-0.06f - dimensions.y) * 4;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private void CreateCMDButton(ref CuiElementContainer container, string panelName, ushort faction, string text, string cmd, int num)
        {
            var color = "";
            if (faction == 0)
            {
                color = UIColors["orange"];
            }
            else
            {
                color = factionData.Factions[faction].UIColor;
                //if (name1.Contains("Remove")) color = UIColors["red"];
                //if (name1.Contains("Add")) color = UIColors["green"];
            }
            var pos = CalcButtonPos(num);
            UI.CreateButton(ref container, panelName, color, text, 16, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", cmd);
        }

        private float[] CalcButtonPos(int number)
        {
            Vector2 position = new Vector2(0.05f, 0.8f);
            Vector2 dimensions = new Vector2(0.125f, 0.125f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 6)
            {
                offsetX = (0.03f + dimensions.x) * number;
            }
            if (number > 5 && number < 12)
            {
                offsetX = (0.03f + dimensions.x) * (number - 6);
                offsetY = (-0.05f - dimensions.y) * 1;
            }
            if (number > 11 && number < 18)
            {
                offsetX = (0.03f + dimensions.x) * (number - 12);
                offsetY = (-0.05f - dimensions.y) * 2;
            }
            if (number > 17 && number < 24)
            {
                offsetX = (0.03f + dimensions.x) * (number - 18);
                offsetY = (-0.05f - dimensions.y) * 3;
            }
            if (number > 23 && number < 32)
            {
                offsetX = (0.03f + dimensions.x) * (number - 24);
                offsetY = (-0.05f - dimensions.y) * 4;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private void CreatePlayerEntry(ref CuiElementContainer container, string panelName, string color, string info, int num)
        {
            var pos = PlayerEntryPos(num);
            UI.CreateLabel(ref container, panelName, color, info, 16, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", TextAnchor.UpperCenter);
        }

        private float[] PlayerEntryPos(int number)
        {
            Vector2 position = new Vector2(0.02f, 0.6f);
            Vector2 dimensions = new Vector2(0.22f, 0.20f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 3)
            {
                offsetY = (-0.05f - dimensions.y) * number;
            }
            if (number > 2 && number < 6)
            {
                offsetX = (0.025f + dimensions.x) * 1;
                offsetY = (-0.05f - dimensions.y) * (number - 3);
            }
            if (number > 5 && number < 9)
            {
                offsetX = (0.025f + dimensions.x) * 2;
                offsetY = (-0.05f - dimensions.y) * (number - 6);
            }
            if (number > 8 && number < 12)
            {
                offsetX = (0.025f + dimensions.x) * 3;
                offsetY = (-0.05f - dimensions.y) * (number - 9);
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private void CreateSBEntry(ref CuiElementContainer container, string panelName, string color, string name, int kills, string faction, int num)
        {
            var pos = SBNamePos(num);
            UI.CreateLabel(ref container, panelName, UIColors["header"], $"Player Name", 20, "0.01 0.87", "0.12 0.909");
            UI.CreateLabel(ref container, panelName, UIColors["header"], $"Faction", 20, "0.18 0.87", "0.27 0.909");
            UI.CreateLabel(ref container, panelName, UIColors["header"], $"Kills", 20, "0.34 0.87", "0.4 0.909");
            if (num > 50)
            {
                UI.CreateLabel(ref container, panelName, UIColors["header"], $"Player Name", 20, "0.5 0.87", ".6 0.909");
                UI.CreateLabel(ref container, panelName, UIColors["header"], $"Faction", 20, "0.68 0.87", "0.77 0.909");
                UI.CreateLabel(ref container, panelName, UIColors["header"], $"Kills", 20, "0.84 0.87", "0.9 0.909");
            }
            UI.CreateLabel(ref container, panelName, color, $"{name}", 11, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", TextAnchor.MiddleLeft);
            UI.CreateLabel(ref container, panelName, color, $"{faction}", 11, $"{pos[0] + .09} {pos[1]}", $"{pos[2] + .15} {pos[3]}", TextAnchor.MiddleCenter);
            UI.CreateLabel(ref container, panelName, color, $"{kills}", 11, $"{pos[0] + .25} {pos[1]}", $"{pos[2] + .28} {pos[3]}", TextAnchor.MiddleCenter);

        }

        private float[] SBNamePos(int number)
        {
            Vector2 position = new Vector2(0.03f, 0.84f);
            Vector2 dimensions = new Vector2(0.15f, 0.0205f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 40)
            {
                offsetY = (-0.0001f - dimensions.y) * number;
            }
            if (number > 39 && number < 78)
            {
                offsetX = (0.35f + dimensions.x) * 1;
                offsetY = (-0.0001f - dimensions.y) * (number - 40);
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private void CreateFactionSelectionButton(ref CuiElementContainer container, string panelName, ushort faction, int num, int page)
        {
            string name = factionData.Factions[faction].Name;
            string color = factionData.Factions[faction].UIColor;
            string count = $"Player Count: {factionData.Factions[faction].PlayerCount}";
            string cmd = $"UI_CUI_FactionInfo {faction} {page}";
            var pos = CalcButtonPos(num);
            UI.CreateButton(ref container, panelName, color, $"{name}\n{count}", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", cmd);
        }

        private void CreateFactionListButton(ref CuiElementContainer container, string panelName, ushort faction, int num)
        {
            string name = factionData.Factions[faction].Name;
            string color = factionData.Factions[faction].UIColor;
            int count = 0;
            foreach (var entry in playerData.playerFactions.Where(kvp => kvp.Value.faction == faction))
            {
                count++;
            }
            string cmd = $"UI_CUIFactionList {faction} {count} {0}";
            var pos = CalcButtonPos(num);
            UI.CreateButton(ref container, panelName, color, $"{name}", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", cmd);
        }

        private void CreateSpawnIDButton(ref CuiElementContainer container, string panelName, string type, string spawnName, ushort faction, ushort SpawnID, int num)
        {
            string cmd = "";
            if (type == "rally") cmd = $"UI_RallyMovePlayerPosition {SpawnID}";
            if (type == "faction") cmd = $"UI_FactionMovePlayerPosition {SpawnID}";
            string color = factionData.Factions[faction].UIColor;
            var pos = CalcButtonPos(num);
            UI.CreateButton(ref container, panelName, color, $"{spawnName}", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", cmd);
        }

        private void CreateSpawnButton(ref CuiElementContainer container, string panelName, string type, string spawnName, ushort faction, ushort SpawnID, int num)
        {
            var pos = SpawnButtonPos(num);
            string cmd = "";
            if (type == "rally") cmd = $"UI_RallyMovePlayerPosition {SpawnID}";
            if (type == "faction") cmd = $"UI_FactionMovePlayerPosition {SpawnID}";
            string color = factionData.Factions[faction].UIColor;
            UI.CreateButton(ref container, panelName, color, $"{spawnName}", 10, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", cmd);

        }

        private float[] SpawnButtonPos(int number)
        {
            Vector2 position = new Vector2(0.0f, 0.8f);
            Vector2 dimensions = new Vector2(0.25f, 0.1f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 4)
            {
                offsetX = (0.01f + dimensions.x) * number;
            }
            if (number > 3 && number < 8)
            {
                offsetX = (0.01f + dimensions.x) * (number - 4);
                offsetY = (-0.1f - dimensions.y) * 1;
            }
            if (number > 7 && number < 12)
            {
                offsetX = (0.01f + dimensions.x) * (number - 8);
                offsetY = (-0.1f - dimensions.y) * 2;
            }
            if (number > 11 && number < 16)
            {
                offsetX = (0.01f + dimensions.x) * (number - 12);
                offsetY = (-0.1f - dimensions.y) * 3;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private Dictionary<string, string> UIColors = new Dictionary<string, string>
        {
            {"dark", "0.1 0.1 0.1 0.98" },
            {"header", "0 0 0 0.6" },
            {"light", ".85 .85 .85 1.0" },
            {"grey1", "0.6 0.6 0.6 1.0" },
            {"brown", "0.3 0.16 0.0 1.0" },
            {"yellow", "0.9 0.9 0.0 1.0" },
            {"orange", "1.0 0.65 0.0 1.0" },
            {"blue", "0.2 0.6 1.0 1.0" },
            {"red", "1.0 0.1 0.1 1.0" },
            {"green", "0.28 0.82 0.28 1.0" },
            {"grey", "0.85 0.85 0.85 1.0" },
            {"lightblue", "0.6 0.86 1.0 1.0" },
            {"buttonbg", "0.2 0.2 0.2 0.7" },
            {"buttongreen", "0.133 0.965 0.133 0.9" },
            {"buttonred", "0.964 0.133 0.133 0.9" },
            {"buttongrey", "0.8 0.8 0.8 0.9" }
        };

        void SetFaction(BasePlayer player, int page = 0)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.1 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.03 0.05", "0.97 0.95", true);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["header"], lang.GetMessage("FactionSelectionTitle", this), 100, "0.01 0.01", "0.99 0.99");
            var count = factionData.Factions.Count();
            int entriesallowed = 30;
            int remainingentries = count - (page * entriesallowed);
            {
                if (remainingentries > entriesallowed)
                    UI.CreateButton(ref element, FactionsUIPanel, UIColors["buttonbg"], $"{lang.GetMessage("Next", this)}", 18, "0.87 0.03", "0.97 0.085", $"UI_FactionSelection {page + 1}");
                if (page > 0)
                    UI.CreateButton(ref element, FactionsUIPanel, UIColors["buttonred"], $"{lang.GetMessage("Back", this)}", 18, "0.73 0.03", "0.83 0.085", $"UI_FactionSelection {page - 1}");

            }
            int shownentries = page * entriesallowed;
            int i = 0;
            int n = 0;
            if (!configData.Use_FactionsByInvite)
            {
                foreach (var entry in factionData.Factions)
                {
                    i++;
                    if (i < shownentries + 1) continue;
                    else if (i <= shownentries + entriesallowed)
                    {
                        CreateFactionSelectionButton(ref element, FactionsUIPanel, entry.Key, n, page); n++;
                    }
                }
            }
            else if (configData.Use_FactionsByInvite)
            {
                foreach (var entry in factionData.Factions.Where(kvp => kvp.Value.type == FactionType.FFA))
                {
                    i++;
                    if (i < shownentries + 1) continue;
                    else if (i <= shownentries + entriesallowed)
                    {

                        CreateFactionSelectionButton(ref element, FactionsUIPanel, entry.Key, n, page); n++;
                    }
                }
            }
            UI.CreateButton(ref element, FactionsUIPanel, UIColors["buttonred"], lang.GetMessage("NoJoin", this), 12, "0.8 0.05", "0.87 0.09", "UI_DestroyFS");
            CuiHelper.AddUi(player, element);
        }

        void FactionMenuBar(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelFactionMenuBar);
            var element = UI.CreateElementContainer(PanelFactionMenuBar, UIColors["dark"], "0.1 0.1", "0.205 0.5", true);
            UI.CreatePanel(ref element, PanelFactionMenuBar, UIColors["light"], "0.05 0.03", "0.95 0.97", true);
            
            if (configData.Use_FactionKillIncentives)
            {
                var p = 0;
                    foreach (var entry in playerData.playerFactions.Where(kvp => kvp.Value.faction != 0))
                {
                    if (factionData.Factions[entry.Value.faction].type == FactionType.Regular)
                    p++;
                }
                UI.CreateButton(ref element, PanelFactionMenuBar, UIColors["blue"], lang.GetMessage("ScoreBoard", this), 14, "0.1 0.86", "0.9 0.96", $"UI_CUIScoreBoard {p} {0}");
            }
            UI.CreateButton(ref element, PanelFactionMenuBar, UIColors["green"], lang.GetMessage("FactionLists",this), 14, "0.1 0.73", "0.9 0.83", "UI_CUIFactionLists");
            UI.CreateButton(ref element, PanelFactionMenuBar, UIColors["orange"], lang.GetMessage("PlayerCommands", this), 14, "0.1 0.59", "0.9 0.69", "UI_CUIPlayer");
            if (FactionMemberCheck(player))
            {
                if (isleader(player))
                    UI.CreateButton(ref element, PanelFactionMenuBar, UIColors["lightblue"], lang.GetMessage("LeaderCommands", this), 14, "0.1 0.45", "0.9 0.55", "UI_CUILeader");
            }
            if (isAuth(player))
            {
                UI.CreateButton(ref element, PanelFactionMenuBar, UIColors["red"], lang.GetMessage("AdminCommands", this), 14, "0.1 0.31", "0.9 0.41", "UI_CUIAdmin");
                UI.CreateButton(ref element, PanelFactionMenuBar, UIColors["brown"], lang.GetMessage("Options", this), 14, "0.1 0.17", "0.9 0.27", "UI_CUIOptions");
            }

            UI.CreateButton(ref element, PanelFactionMenuBar, UIColors["buttonred"], lang.GetMessage("Close", this), 16, "0.1 0.04", "0.9 0.14", "UI_DestroyFactionMenu");
            CuiHelper.AddUi(player, element);
        }

        void Instructions(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var i = 0;
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["header"], lang.GetMessage("Information", this), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);
            //CreateInstructionEntry(ref element, FactionsUIPanel, UIColors["orange"], string.Format("V " + Version.ToString() + "--  by " + Author, lang.GetMessage("title", this)), i); i++;
            CreateInstructionEntry(ref element, FactionsUIPanel, "1.0 1.0 1.0 1.0", lang.GetMessage("FactionPlayerInfo", this), i); i++;          
            UI.CreateButton(ref element, FactionsUIPanel, UIColors["orange"], $"{lang.GetMessage("Back", this)}", 16, "0.03 0.05", "0.09 0.09", "UI_CUIPlayer");
            CuiHelper.AddUi(player, element);
        }

        void Leader(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var i = 0;
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["header"], lang.GetMessage("LeaderCommands", this), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);
            var faction = GetPlayerFaction(player);
            if (configData.Use_RallySpawns)
            {
                CreateCMDButton(ref element, FactionsUIPanel, 0, lang.GetMessage("SpawnManagement", this), "UI_CUISpawnManager leader", i); i++;
            }
            if (configData.Use_Trades)
            {
                CreateCMDButton(ref element, FactionsUIPanel, 0, lang.GetMessage("TradeManagement", this), "UI_CUITrades", i); i++;
            }
            if (configData.Use_Taxes)
            {
                CreateCMDButton(ref element, FactionsUIPanel, faction, $"{lang.GetMessage("TaxBoxMode", this)}", "UI_CUISetTaxBox", i); i++;
                CreateCMDButton(ref element, FactionsUIPanel, faction, $"{lang.GetMessage("RemoveTaxBox", this)}", "UI_CUIRemoveTaxBox", i); i++;
                CreateCMDButton(ref element, FactionsUIPanel, faction, $"{lang.GetMessage("SetTax", this)}", "UI_CUIRequestFactionTax", i); i++;
            }
            if (configData.Use_FactionsByInvite)
            {
                CreateCMDButton(ref element, FactionsUIPanel, faction, string.Format(lang.GetMessage("InvitePlayers", this), factionData.Factions[faction].Name), $"UI_CUIFactionInvite {0} {0}", i); i++;
                CreateCMDButton(ref element, FactionsUIPanel, faction, string.Format(lang.GetMessage("KickPlayers", this), factionData.Factions[faction].Name), $"UI_CUIKickPlayerMenu {0} {0}", i); i++;

            }
            if (configData.Use_BattleZones)
            {
                if (bZID == 0)
                    if (!BattleZones.ContainsKey(faction))
                        if (CheckForActiveEnemies(faction))
                        {
                            var num = faction + 1;
                            ushort ID = (ushort)num;

                            CreateCMDButton(ref element, FactionsUIPanel, faction, string.Format(lang.GetMessage("CreateBZ", this), factionData.Factions[faction].Name), $"UI_CreateZone battle {ID}", i); i++;
                        }
            }
            CuiHelper.AddUi(player, element);
        }

        void BZButton(BasePlayer player, ushort ID)
        {
            CuiHelper.DestroyUi(player, PanelBZButton);
            if (bZID == 0) return;
            var element = UI.CreateElementContainer(PanelBZButton, "0.0 0.0 0.0 0.0", "0.89 0.2", "0.99 0.3", false);
            UI.CreateButton(ref element, PanelBZButton, factionData.Factions[ID].UIColor, string.Format(lang.GetMessage("BZButtonText", this), factionData.Factions[ID].Name), 18, "0 0", "1 1", $"UI_BzConfirmation {ID}");
            CuiHelper.AddUi(player, element);
            return;
        }

        private void BZConfirmation(BasePlayer player, ushort BZID)
        {
            CuiHelper.DestroyUi(player, PanelBZButton);
            var BzFactionOwner = factionData.Factions[BZID].Name;
            var BzLeaderTitle = factionData.Factions[BZID].LeaderTitle;
            if (!BZPlayers.ContainsKey(player.userID))
            {
                var invite = UI.CreateElementContainer(PanelBZButton, UIColors["dark"], "0.3 0.3", "0.7 0.9", true);
                UI.CreatePanel(ref invite, PanelBZButton, UIColors["light"], "0.01 0.02", "0.99 0.98");
                UI.CreateLabel(ref invite, PanelBZButton, configData.MSG_Color, string.Format(lang.GetMessage("BZJoinDescription", this), BzFactionOwner, BzLeaderTitle), 18, "0.1 0.1", "0.9 0.89", TextAnchor.MiddleLeft);
                UI.CreateButton(ref invite, PanelBZButton, UIColors["buttongreen"], "Yes", 18, "0.2 0.05", "0.39 0.15", $"UI_BZYes {BZID}");
                UI.CreateButton(ref invite, PanelBZButton, UIColors["buttonred"], "No", 18, "0.4 0.05", "0.59 0.15", $"UI_DestroyBZPanel");
                UI.CreateButton(ref invite, PanelBZButton, UIColors["buttonbg"], "Not Yet", 18, "0.6 0.05", "0.8 0.15", $"UI_BzButton {BZID}");
                CuiHelper.AddUi(player, invite);
            }
        }

        private void KickPlayersMenu(BasePlayer player, ushort factionID = 0, int page = 0)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var count = 0;
            int i = 0;
            int n = 0;
            ushort faction = factionID;
            if (faction == 0)
                faction = GetPlayerFaction(player);
            foreach (var p in playerData.playerFactions.Where(kvp => kvp.Value.faction == faction))
                count++;
            int entriesallowed = 30;
            int remainingentries = count - (page * entriesallowed);
            int shownentries = page * entriesallowed;
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, FactionsUIPanel, "1 1 1 0.025", lang.GetMessage("UnassignPlayers", this), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);
            if (remainingentries > entriesallowed)
                UI.CreateButton(ref element, FactionsUIPanel, UIColors["buttonbg"], $"{lang.GetMessage("Next", this)}", 18, "0.87 0.03", "0.97 0.085", $"UI_CUIKickPlayerMenu {factionID} {page + 1}");
            if (page > 0)
                UI.CreateButton(ref element, FactionsUIPanel, UIColors["buttonred"], $"{lang.GetMessage("Back", this)}", 18, "0.73 0.03", "0.83 0.085", $"UI_CUIKickPlayerMenu {factionID} {page - 1}");
            foreach (var entry in FactionKicks.Where(kvp => kvp.Value.factionID == faction).ToList())
            {
                FactionKicks.Remove(entry.Key);
            }
            foreach (var p in playerData.playerFactions)
                if (p.Value.faction == faction)
                {
                    i++;
                    if (i < shownentries + 1) continue;
                    else if (i <= (shownentries + entriesallowed))
                    {
                        var num = faction + i;
                        ushort ID = (ushort)num;
                        if (factionID == 0)
                            CreateCMDButton(ref element, FactionsUIPanel, faction, string.Format(lang.GetMessage("KickPlayer", this), p.Value.Name, factionData.Factions[faction].Name), $"UI_ConfirmKickPlayer {ID}", n);
                        else
                            CreateCMDButton(ref element, FactionsUIPanel, faction, string.Format(lang.GetMessage("RemovePlayer", this), p.Value.Name, factionData.Factions[faction].Name), $"UI_ConfirmKickPlayer {ID}", n);
                        FactionKicks.Add(ID, new target { playerID = p.Key, factionID = faction, executerID = player.userID });
                        n++;
                    }
                }
            if (factionID == 0)
                UI.CreateButton(ref element, FactionsUIPanel, UIColors["orange"], $"{lang.GetMessage("Back", this)}", 16, "0.03 0.05", "0.09 0.09", "UI_CUILeader");
            else
                UI.CreateButton(ref element, FactionsUIPanel, UIColors["orange"], $"{lang.GetMessage("Back", this)}", 16, "0.03 0.05", "0.09 0.09", "UI_CUIPlayerManager");
            CuiHelper.AddUi(player, element);
        }

        void FactionInviteScreen(BasePlayer player, ushort factionID = 0, int page = 0)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var count = 0;
            int i = 0;
            int n = 0;
            ushort faction = factionID;
            if (faction == 0)
                faction = GetPlayerFaction(player);
            foreach (var p in playerData.playerFactions.Where(kvp => kvp.Value.faction == faction))
                count++;
            int entriesallowed = 30;
            int remainingentries = count - (page * entriesallowed);
            int shownentries = page * entriesallowed;
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["header"], lang.GetMessage("FactionInviteScreen", this), 18, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);
            if (remainingentries > entriesallowed)
                UI.CreateButton(ref element, FactionsUIPanel, UIColors["buttonbg"], $"{lang.GetMessage("Next", this)}", 18, "0.87 0.03", "0.97 0.085", $"UI_CUIFactionInvite {factionID} {page + 1}");
            if (page > 0)
                UI.CreateButton(ref element, FactionsUIPanel, UIColors["buttonred"], $"{lang.GetMessage("Back", this)}", 18, "0.73 0.03", "0.83 0.085", $"UI_CUIFactionInvite {factionID} {page - 1}");
            foreach (var entry in FactionInvites.Where(kvp => kvp.Value.factionID == faction).ToList())
            {
                FactionInvites.Remove(entry.Key);
            }
            foreach (BasePlayer p in BasePlayer.activePlayerList)
                if (!FactionMemberCheck(p))
                {
                    i++;
                    if (i < shownentries + 1) continue;
                    else if (i <= (shownentries + entriesallowed))
                    {
                        var num = faction + i;
                        ushort ID = (ushort)num;
                        CreateCMDButton(ref element, FactionsUIPanel, faction, string.Format(lang.GetMessage("InvitePlayer", this), p.displayName, factionData.Factions[faction].Name), $"UI_TryInvitePlayerToFaction {ID}", n);
                        if (factionID == 0)
                        { FactionInvites.Add(ID, new target { playerID = p.userID, factionID = faction, executerID = player.userID }); n++; }
                        else
                        { FactionInvites.Add(ID, new target { playerID = p.userID, factionID = faction, executerID = player.userID, assign = true }); n++; }
                    }
                }
            if (factionID == 0)
                UI.CreateButton(ref element, FactionsUIPanel, UIColors["orange"], $"{lang.GetMessage("Back", this)}", 16, "0.03 0.05", "0.09 0.09", "UI_CUILeader");
            else
                UI.CreateButton(ref element, FactionsUIPanel, UIColors["orange"], $"{lang.GetMessage("Back", this)}", 16, "0.03 0.05", "0.09 0.09", "UI_CUIPlayerManager");
            CuiHelper.AddUi(player, element);
        }

        void FactionListsUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var i = 0;
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["header"], lang.GetMessage("FactionLists", this), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);
            foreach (var entry in factionData.Factions)
            {
                CreateFactionListButton(ref element, FactionsUIPanel, entry.Key, i); i++;
            }
            CuiHelper.AddUi(player, element);
        }


        void Player(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var i = 0;
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["header"], lang.GetMessage("PlayerCommands", this), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);
            //CreateCMDButton(ref element, FactionsUIPanel, 0, lang.GetMessage("Information", this), "UI_CUIInstructions", i); i++;
            if (FactionMemberCheck(player))
            {
                var faction = GetPlayerFaction(player);
                if (factionData.Factions[faction].type == FactionType.Regular && configData.AllowTradesByPlayer)
                {
                    CreateCMDButton(ref element, FactionsUIPanel, 0, lang.GetMessage("TradeManagement", this), "UI_PlayerTradeMenu", i); i++;
                }
                if (configData.Use_PersistantSpawns)
                {
                    if (configData.Use_RallySpawns)
                        foreach (var spawn in factionData.RallySpawns.Where(kvp => kvp.Value.FactionID == faction))
                        {
                            CreateSpawnIDButton(ref element, FactionsUIPanel, "rally", spawn.Value.Name, spawn.Value.FactionID, spawn.Key, i); i++;
                        }
                    if (configData.Use_FactionSpawns)
                        foreach (var spawn in factionData.FactionSpawns.Where(kvp => kvp.Value.FactionID == faction))
                        {
                            CreateSpawnIDButton(ref element, FactionsUIPanel, "faction", spawn.Value.Name, spawn.Value.FactionID, spawn.Key, i); i++;
                        }
                }
                i = 27;
                if (configData.Use_RevoltChallenge && factionData.leader.ContainsKey(playerData.playerFactions[player.userID].faction))
                    if (factionData.leader[playerData.playerFactions[player.userID].faction] != player.userID)
                        CreateCMDButton(ref element, FactionsUIPanel, 0, lang.GetMessage("ChallengeLeader", this), "UI_CUIChallengeLeader", i); i++;
                if (configData.AllowPlayerToLeaveFactions)
                {
                    CreateCMDButton(ref element, FactionsUIPanel, 0, lang.GetMessage("LeaveFaction", this), "UI_CUILeaveFaction", i); i++;
                }

            }
            if (!FactionMemberCheck(player))
            {
                CreateCMDButton(ref element, FactionsUIPanel, 0, lang.GetMessage("FactionSelection", this), $"UI_FactionSelection {0}", i); i++;
            }
            CuiHelper.AddUi(player, element);
        }

        void Admin(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var i = 0;
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["header"], lang.GetMessage("AdminCommands", this), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);
            CreateCMDButton(ref element, FactionsUIPanel, 0, lang.GetMessage("FactionManagement", this), "UI_CUIFactionManager", i); i++;
            CreateCMDButton(ref element, FactionsUIPanel, 0, lang.GetMessage("PlayerManagement", this), "UI_CUIPlayerManager", i); i++;
            if (configData.Use_FactionSpawns)
            {
                CreateCMDButton(ref element, FactionsUIPanel, 0, lang.GetMessage("SpawnManagement", this), "UI_CUISpawnManager admin", i); i++;
            }
            if (configData.Use_FactionZones)
            {
                CreateCMDButton(ref element, FactionsUIPanel, 0, lang.GetMessage("ZoneManagement", this), "UI_CUIZoneManager admin", i); i++;
            }
            i = 11;
            if (configData.Use_BattleZones)
            {
                foreach (var faction in factionData.Factions)
                {
                    if (BattleZones.ContainsKey(faction.Key) && bZID != 0)
                        CreateCMDButton(ref element, FactionsUIPanel, faction.Key, string.Format(lang.GetMessage("DestroyBZ", this), faction.Value.Name), $"UI_CancelBZ {faction.Key} Cancelled", i); i++;
                }
            }
            if (configData.Use_FactionKillIncentives)
            {
                UI.CreateButton(ref element, FactionsUIPanel, UIColors["red"], "RESET KILL TICKER", 16, "0.85 0.03", "0.975 0.155", "UI_CUIResetTicker");
            }

            CuiHelper.AddUi(player, element);
        }

        void SpawnManager(BasePlayer player, string user)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var i = 0;
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["header"], lang.GetMessage("SpawnManagement", this), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);
            if (user == "admin")
            {
                foreach (var entry in factionData.Factions)
                {
                    CreateCMDButton(ref element, FactionsUIPanel, entry.Key, string.Format(lang.GetMessage("CreateFactionSpawn", this), entry.Value.Name), $"UI_CUISetSpawnPoint faction {entry.Key}", i); i++;
                    foreach (var spawn in factionData.FactionSpawns.Where(kvp => kvp.Value.FactionID == entry.Key))
                    {
                        CreateCMDButton(ref element, FactionsUIPanel, entry.Key, string.Format(lang.GetMessage("RemoveFactionSpawn", this), entry.Value.Name, spawn.Value.Name), $"UI_CUIRemoveFactionSpawn {spawn.Key}", i); i++;
                    }
                }
                UI.CreateButton(ref element, FactionsUIPanel, UIColors["orange"], $"{lang.GetMessage("Back", this)}", 16, "0.03 0.05", "0.09 0.09", "UI_CUIAdmin");
            }
            else if (user == "leader")
            {
                var faction = GetPlayerFaction(player);
                    CreateCMDButton(ref element, FactionsUIPanel, faction, string.Format(lang.GetMessage("CreateRallySpawn", this), factionData.Factions[faction].Name), "UI_CUISetSpawnPoint rally", i); i++;
                    foreach (var entry in factionData.RallySpawns.Where(kvp => kvp.Value.FactionID == faction))
                    {
                        CreateCMDButton(ref element, FactionsUIPanel, faction, string.Format(lang.GetMessage("RemoveRallySpawn", this), entry.Value.Name), $"UI_CUIRemoveRallySpawn {entry.Key}", i); i++;
                    }
                UI.CreateButton(ref element, FactionsUIPanel, UIColors["orange"], $"{lang.GetMessage("Back", this)}", 16, "0.03 0.05", "0.09 0.09", "UI_CUILeader");
            }
            CuiHelper.AddUi(player, element);
        }

        void ZoneManagement(BasePlayer player, string user)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var i = 0;
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["header"], lang.GetMessage("ZoneManagement", this), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);
            if (user == "admin")
            {
                object zoneid = "";
                foreach (var faction in factionData.Factions.Where(kvp => kvp.Value.type == FactionType.Regular))
                {
                    if (!factionData.Factions[faction.Key].FactionZone)
                    {
                        CreateCMDButton(ref element, FactionsUIPanel, faction.Key, string.Format(lang.GetMessage("AddFZ", this), faction.Value.Name), $"UI_CreateZone faction {faction.Key}", i); i++;
                    }
                    else if (factionData.Factions[faction.Key].FactionZone)
                    {
                        CreateCMDButton(ref element, FactionsUIPanel, 0, string.Format(lang.GetMessage("RemoveFZ", this), faction.Value.Name), $"UI_EraseZone {faction.Key} faction", i); i++;
                    }
                }
                UI.CreateButton(ref element, FactionsUIPanel, UIColors["orange"], $"{lang.GetMessage("Back", this)}", 16, "0.03 0.05", "0.09 0.09", "UI_CUIAdmin");
            }
            CuiHelper.AddUi(player, element);
        }
        

        void FactionManager(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var i = 0;
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["header"], lang.GetMessage("FactionManagement", this), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);
            CreateCMDButton(ref element, FactionsUIPanel, 0, string.Format(lang.GetMessage("CreateFaction", this)), "CUI_NewFaction", i); i++;
            //CreateCMDButton(ref element, FactionsUIPanel, 0, "Edit", "Factions","", "UI_CUI_FactionEditor", i); i++;
            if (configData.Use_FactionLeaderByAdmin)
            {
                CreateCMDButton(ref element, FactionsUIPanel, 0, lang.GetMessage("LeaderManagement", this), "UI_CUI_FactionLeaders", i); i++;
            }
            i = 6;
            foreach (var entry in factionData.Factions)
            {
                CreateCMDButton(ref element, FactionsUIPanel, entry.Key, string.Format(lang.GetMessage("DeleteFaction", this), entry.Value.Name), $"CUI_TryDeleteFaction {entry.Key}", i); i++;
            } 
            UI.CreateButton(ref element, FactionsUIPanel, UIColors["orange"], $"{lang.GetMessage("Back", this)}", 16, "0.03 0.05", "0.09 0.09", "UI_CUIAdmin");
            CuiHelper.AddUi(player, element);
        }

        void PlayerManager(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            int i = 0;
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["header"], lang.GetMessage("PlayerManagement", this), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);
            foreach (var entry in factionData.Factions)
            {
                CreateCMDButton(ref element, FactionsUIPanel, entry.Key, string.Format(lang.GetMessage("AssignPlayer", this), entry.Value.Name), $"UI_CUIFactionInvite {entry.Key} {0}", i); i++;
                CreateCMDButton(ref element, FactionsUIPanel, entry.Key, string.Format(lang.GetMessage("UnAssignPlayer", this), entry.Value.Name), $"UI_CUIKickPlayerMenu {entry.Key} {0}", i); i++;
            }
            UI.CreateButton(ref element, FactionsUIPanel, UIColors["orange"], $"{lang.GetMessage("Back", this)}", 16, "0.03 0.05", "0.09 0.09", "UI_CUIAdmin");
            CuiHelper.AddUi(player, element);
        }

        void FactionLeaders(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var i = 0;
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["header"], lang.GetMessage("LeaderManagement", this), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);
            foreach (var entry in factionData.Factions.Where(kvp => kvp.Value.type != FactionType.FFA))
            {
                CreateCMDButton(ref element, FactionsUIPanel, entry.Key, string.Format(lang.GetMessage("EditLeader", this), entry.Value.Name, entry.Value.LeaderTitle), $"UI_CUI_LeaderEditing {entry.Key} {0}", i); i++;
            }
            CuiHelper.AddUi(player, element);
            UI.CreateButton(ref element, FactionsUIPanel, UIColors["orange"], $"{lang.GetMessage("Back", this)}", 16, "0.03 0.05", "0.09 0.09", "UI_CUIAdmin");
        }

        void LeaderEditing(BasePlayer player, ushort faction, int page = 0)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var count = 0;
            int i = 0;
            int n = 0;
            foreach (var entry in LeaderPromotes.Where(kvp => kvp.Value.factionID == faction).ToList())
            {
                LeaderPromotes.Remove(entry.Key);
            }
            foreach (var p in playerData.playerFactions.Where(kvp => kvp.Value.faction == faction))
                count++;
            int entriesallowed = 30;
            int remainingentries = count - (page * entriesallowed);
            int shownentries = page * entriesallowed;
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["header"], lang.GetMessage("LeaderManagement", this), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);
            if (!factionData.leader.ContainsKey(faction))
            {
                if (remainingentries > entriesallowed)
                    UI.CreateButton(ref element, FactionsUIPanel, UIColors["buttonbg"], $"{lang.GetMessage("Next", this)}", 18, "0.87 0.03", "0.97 0.085", $"UI_CUI_LeaderEditing {faction} {page + 1}");
                if (page > 0)
                    UI.CreateButton(ref element, FactionsUIPanel, UIColors["buttonred"], $"{lang.GetMessage("Back", this)}", 18, "0.73 0.03", "0.83 0.085", $"UI_CUI_LeaderEditing {faction} {page - 1}");
            }
            foreach (var p in playerData.playerFactions.Where(kvp => kvp.Value.faction == faction))
            {
                if (factionData.leader.ContainsValue(p.Key))
                {
                    CreateCMDButton(ref element, FactionsUIPanel, 0, string.Format(lang.GetMessage("RemoveLeader", this), p.Value.Name, factionData.Factions[faction].LeaderTitle), $"UI_CUIUnassignLeader {faction}", i); i++;
                }

                else if (!factionData.leader.ContainsKey(faction))
                {
                    i++;
                    if (i < shownentries + 1) continue;
                    else if (i <= (shownentries + entriesallowed))
                    {
                        var num = faction + i;
                        ushort ID = (ushort)num;
                        CreateCMDButton(ref element, FactionsUIPanel, 0, string.Format(lang.GetMessage("PromoteLeader", this), p.Value.Name, factionData.Factions[faction].LeaderTitle), $"UI_CUIAssignLeader {ID}", n);
                        LeaderPromotes.Add(ID, new target { playerID = p.Key, factionID = faction, executerID = player.userID }); n++;
                    }
                }
            }
            UI.CreateButton(ref element, FactionsUIPanel, UIColors["orange"], $"{lang.GetMessage("Back", this)}", 16, "0.03 0.05", "0.09 0.09", "UI_CUI_FactionLeaders");
            CuiHelper.AddUi(player, element);
        }

        void FactionEditor(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var i = 0;
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["header"], lang.GetMessage("FactionEditor", this), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);
            foreach (var entry in factionData.Factions)
            {
                CreateCMDButton(ref element, FactionsUIPanel, entry.Key, string.Format(lang.GetMessage("EditFaction", this), entry.Value.Name), $"CUI_EditFaction {entry.Key}", i); i++;
            }
            CuiHelper.AddUi(player, element);
        }

        void PlayerTradeMenu(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var i = -1;
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["header"], lang.GetMessage("PlayerTradeSelection", this), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);
            var faction = GetPlayerFaction(player);
            if (factionData.Factions[faction].type == FactionType.FFA) return;
            foreach (Trade trade in Enum.GetValues(typeof(Trade)))
            {
                if (trade != Trade.None)
                    CreateCMDButton(ref element, FactionsUIPanel, 0, string.Format(lang.GetMessage("AssignTradeSkill", this), Enum.GetName(typeof(Trade), trade).ToUpper()), $"UI_PlayerTradeAssignment {Enum.GetName(typeof(Trade), trade)}", i); i++;
                
            }
            if (playerData.playerFactions[player.userID].trade != Trade.None)
            {
                Trade trade = playerData.playerFactions[player.userID].trade;
                i = 24; 
                CreateCMDButton(ref element, FactionsUIPanel, 0, string.Format(lang.GetMessage("UnassignTradeSkill", this), Enum.GetName(typeof(Trade), trade).ToUpper()), $"UI_PlayerTradeUnassignment", i);
            }
            UI.CreateButton(ref element, FactionsUIPanel, UIColors["orange"], $"{lang.GetMessage("Back", this)}", 16, "0.03 0.05", "0.09 0.09", "UI_CUIPlayer");
            CuiHelper.AddUi(player, element);
        }

        void TradesManager(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var i = -1;
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["header"], lang.GetMessage("TradeManagement", this), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);
            var faction = GetPlayerFaction(player);
            foreach (Trade trade in Enum.GetValues(typeof(Trade)))
            {
                if (trade != Trade.None)
                    CreateCMDButton(ref element, FactionsUIPanel, 0, string.Format(lang.GetMessage("TradeSkill", this), Enum.GetName(typeof(Trade), trade)), $"UI_TradeAssignment {Enum.GetName(typeof(Trade), trade)}", i); i++;
            }
            UI.CreateButton(ref element, FactionsUIPanel, UIColors["orange"], $"{lang.GetMessage("Back", this)}", 16, "0.03 0.05", "0.09 0.09", "UI_CUILeader");
            CuiHelper.AddUi(player, element);
        }

        void TradeOverview(BasePlayer player, Trade trade)
        {
            foreach (var entry in TradeRemoval.Where(kvp => kvp.Value.leaderID == player.userID).ToList())
            {
                TradeRemoval.Remove(entry.Key);
            }
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var i = 0;
            var c = 0;
            string limitmsg = "";
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["header"], Enum.GetName(typeof(Trade), trade).ToUpper(), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);
            var faction = GetPlayerFaction(player);
            string names = "";
            foreach (var assigned in playerData.playerFactions)
                if (assigned.Value.faction == faction && assigned.Value.trade == trade)
                {
                    var num = faction + i;
                    ushort ID = (ushort)num;
                    CreateCMDButton(ref element, FactionsUIPanel, 0, string.Format(lang.GetMessage("UnassignPlayerTradeSkill", this), Enum.GetName(typeof(Trade), trade).ToUpper(), assigned.Value.Name), $"UI_CUIUnassignTradeSkill {ID}", i);
                    TradeRemoval.Add(ID, new TradeProcessing { playerID = assigned.Key, factionID = faction, leaderID = player.userID, trade = trade }); i++;
                    c++;
                    if (c > 0)
                        names += $"\nPlayers: {assigned.Value.Name}\n";
                }
            if (c >= configData.TradeLimit) limitmsg = " at MAX";
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["dark"], $"Current Trade Count:{c}{limitmsg}{names}", 22, "0.1 0.8", "0.9 0.9", TextAnchor.UpperCenter);
            if (c < configData.TradeLimit)
                CreateCMDButton(ref element, FactionsUIPanel, 0, string.Format(lang.GetMessage("AssignTradeSkill", this), Enum.GetName(typeof(Trade), trade).ToUpper()), $"UI_CUITradeAssignmentMenu {trade}", 23);
            UI.CreateButton(ref element, FactionsUIPanel, UIColors["orange"], $"{lang.GetMessage("Back", this)}", 16, "0.03 0.05", "0.09 0.09", $"UI_CUITrades");
            CuiHelper.AddUi(player, element);
        }

        private void TradeAssignmentMenu(BasePlayer player, Trade trade)
        {
            foreach (var entry in TradeAssignments.Where(kvp => kvp.Value.leaderID == player.userID).ToList())
            {
                TradeAssignments.Remove(entry.Key);
            }
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var i = 0;
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["header"], lang.GetMessage("AssignTrades", this), 100, "0.01 0.01", "0.99 0.99");
            var faction = GetPlayerFaction(player);
            foreach (var unassigned in playerData.playerFactions)
                if (unassigned.Value.faction == faction && unassigned.Value.trade != trade)
                {
                    var num = faction + i;
                    ushort ID = (ushort)num;
                    CreateCMDButton(ref element, FactionsUIPanel, 0, string.Format(lang.GetMessage("AssignPlayerTradeSkill", this), Enum.GetName(typeof(Trade), trade).ToUpper(), unassigned.Value.Name), $"UI_CUIAssignTradeSkill {ID}", i);
                    TradeAssignments.Add(ID, new TradeProcessing { playerID = unassigned.Key, factionID = faction, leaderID = player.userID, trade = trade }); i++;
                }
            UI.CreateButton(ref element, FactionsUIPanel, UIColors["orange"], $"{lang.GetMessage("Back", this)}", 16, "0.03 0.05", "0.09 0.09", $"UI_TradeAssignment {Enum.GetName(typeof(Trade), trade)}");
            CuiHelper.AddUi(player, element);
        }

        void Options(BasePlayer player)
        {
            var i = 0;
            var color = "";
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["header"], lang.GetMessage("Options", this), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);

            if (configData.Use_FactionChatControl == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("ChatControlTitle", this), $"UI_CUIChangeOption UI_Use_FactionChatControl ChatControlInfo ChatControlTitle {configData.Use_FactionChatControl}", i); i++;

            if (configData.Use_FactionNamesonChat == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("NameOnChatTitle", this), $"UI_CUIChangeOption UI_Use_FactionNamesonChat NameOnChatInfo NameOnChatTitle {configData.Use_FactionNamesonChat}", i); i++;

            if (configData.Use_ChatTitles == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("ChatTitlesTitle", this), $"UI_CUIChangeOption UI_Use_ChatTitles ChatTitlesInfo ChatTitlesTitle {configData.Use_ChatTitles}", i); i++;

            if (configData.BroadcastDeath == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("BroadcastDeathTitle", this), $"UI_CUIChangeOption UI_BroadcastDeath BroadcastDeathInfo BroadcastDeathTitle {configData.BroadcastDeath}", i); i++;

            if (configData.Use_FactionsInfo == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("FactionsInfoTitle", this), $"UI_CUIChangeOption UI_Use_FactionsInfo FactionsInfoInfo FactionsInfoTitle {configData.Use_FactionsInfo}", i); i++;

            if (configData.Use_FactionKillIncentives == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("FactionKillIncentivesTitle", this), $"UI_CUIChangeOption UI_Use_FactionKillIncentives FactionKillIncentivesInfo FactionKillIncentivesTitle {configData.Use_FactionKillIncentives}", i); i++;



            if (configData.Use_Kits == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("KitsTitle", this), $"UI_CUIChangeOption UI_Use_Kits KitsInfo KitsTitle {configData.Use_Kits}", i); i++;

            if (configData.Use_Groups == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("OxideGroupsTitle", this), $"UI_CUIChangeOption UI_Use_Groups OxideGroupsInfo OxideGroupsTitle {configData.Use_Groups}", i); i++;

            if (configData.Use_Taxes == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("TaxesTitle", this), $"UI_CUIChangeOption UI_Use_Taxes TaxesInfo TaxesTitle {configData.Use_Taxes}", i); i++;

            if (configData.Use_Trades == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("TradesTitle", this), $"UI_CUIChangeOption UI_Use_Trades TradesInfo TradesTitle {configData.Use_Trades}", i); i++;

            if (configData.Use_Ranks == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("RanksTitle", this), $"UI_CUIChangeOption UI_Use_Ranks RanksInfo RanksTitle {configData.Use_Ranks}", i); i++;

            if (configData.AllowTradesByPlayer == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("AllowTradesByPlayerTitle", this), $"UI_CUIChangeOption UI_AllowTradesByPlayer AllowTradesByPlayerInfo AllowTradesByPlayerTitle {configData.AllowTradesByPlayer}", i); i++;



            if (configData.Use_FactionsByInvite == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("FactionsByInviteTitle", this), $"UI_CUIChangeOption UI_Use_FactionsByInvite FactionsByInviteInfo FactionsByInviteTitle {configData.Use_FactionsByInvite}", i); i++;

            if (configData.AllowPlayerToLeaveFactions == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("AllowPlayerToLeaveFactionsTitle", this), $"UI_CUIChangeOption UI_AllowPlayerToLeaveFactions AllowPlayerToLeaveFactionsInfo AllowPlayerToLeaveFactionsTitle {configData.AllowPlayerToLeaveFactions}", i); i++;           

            if (configData.Use_FactionBalancing == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("FactionBalancingTitle", this), $"UI_CUIChangeOption UI_Use_FactionBalancing FactionBalancingInfo FactionBalancingTitle {configData.Use_FactionBalancing}", i); i++;

            if (configData.Use_RallySpawns == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("RallySpawnsTitle", this), $"UI_CUIChangeOption UI_Use_RallySpawns RallySpawnsInfo RallySpawnsTitle {configData.Use_RallySpawns}", i); i++;

            if (configData.Use_FactionSpawns == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("FactionSpawnsTitle", this), $"UI_CUIChangeOption UI_Use_FactionSpawns FactionSpawnsInfo FactionSpawnsTitle {configData.Use_FactionSpawns}", i); i++;

            if (configData.Use_PersistantSpawns == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("PersistantSpawnsTitle", this), $"UI_CUIChangeOption UI_Use_PersistentSpawns PersistantSpawnsInfo PersistantSpawnsTitle {configData.Use_PersistantSpawns}", i); i++;



            if (configData.FFDisabled == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("FFDisabledTitle", this), $"UI_CUIChangeOption UI_FFDisabled FFDisabledInfo FFDisabledTitle {configData.FFDisabled}", i); i++;

            if (configData.BuildingProtectionEnabled == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("BuildingProtectionEnabledTitle", this), $"UI_CUIChangeOption UI_BuildingProtectionEnabled BuildingProtectionEnabledInfo BuildingProtectionEnabledTitle {configData.BuildingProtectionEnabled}", i); i++;

            if (configData.Use_RevoltChallenge == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("RevoltChallengeTitle", this), $"UI_CUIChangeOption UI_Use_RevoltChallenge RevoltChallengeInfo RevoltChallengeTitle {configData.Use_RevoltChallenge}", i); i++;

            if (configData.Use_FactionZones == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("FactionZonesTitle", this), $"UI_CUIChangeOption UI_Use_FactionZones FactionZonesInfo FactionZonesTitle {configData.Use_FactionZones}", i); i++;

            if (configData.Use_BattleZones == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("BattleZonesTitle", this), $"UI_CUIChangeOption UI_Use_BattleZones BattleZonesInfo BattleZonesTitle {configData.Use_BattleZones}", i); i++;

            if (configData.Use_AutoAuthorization == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("AutoAuthorizationTitle", this), $"UI_CUIChangeOption UI_Use_AutoAuthorization AutoAuthorizationInfo AutoAuthorizationTitle {configData.Use_AutoAuthorization}", i); i++;



            if (configData.Use_FactionSafeZones == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("FactionSafeZonesTitle", this), $"UI_CUIChangeOption Use_FactionSafeZones FactionSafeZonesInfo FactionSafeZonesTitle {configData.Use_FactionSafeZones}", i); i++;

            if (configData.Use_FactionLeaderByRank == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("FactionLeaderByRankTitle", this), $"UI_CUIChangeOption UI_Use_FactionLeaderByRank FactionLeaderByRankInfo FactionLeaderByRankTitle {configData.Use_FactionLeaderByRank}", i); i++;

            if (configData.Use_FactionLeaderByTime == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("FactionLeaderByTimeTitle", this), $"UI_CUIChangeOption UI_Use_FactionLeaderByTime FactionLeaderByTimeInfo FactionLeaderByTimeTitle {configData.Use_FactionLeaderByTime}", i); i++;

            if (configData.Use_FactionLeaderByAdmin == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("FactionLeaderByAdminTitle", this), $"UI_CUIChangeOption UI_Use_FactionLeaderByAdmin FactionLeaderByAdminInfo FactionLeaderByAdminTitle {configData.Use_FactionLeaderByAdmin}", i); i++;

            if (configData.Use_EconomicsReward == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("EconomicsRewardTitle", this), $"UI_CUIChangeOption UI_UseEconomics EconomicsRewardInfo EconomicsRewardTitle {configData.Use_TokensReward}", i); i++;

            if (configData.Use_ServerRewardsReward == true) color = UIColors["green"];
            else color = UIColors["red"];
            CreateOptionButton(ref element, FactionsUIPanel, color, lang.GetMessage("ServerRewardsRewardTitle", this), $"UI_CUIChangeOption UI_UseRewards ServerRewardsRewardInfo ServerRewardsRewardTitle {configData.Use_ServerRewardsReward}", i); i++;

            CuiHelper.AddUi(player, element);
        }

        [ConsoleCommand("UI_CUIChangeOption")]
        private void cmdCUIChangeOption(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var cmd = arg.Args[0];
            var verbiage = arg.Args[1];
            var optionName = arg.Args[2];
            var status = arg.Args[3];
            ChangeOption(player, cmd, verbiage, optionName, status);
        }

        void ChangeOption(BasePlayer player, string cmd, string verbiage, string optionName, string status)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            string state = "";
            if (status.ToUpper() == "FALSE") state = lang.GetMessage($"FALSE", this);
            if (status.ToUpper() == "TRUE") state = lang.GetMessage($"TRUE", this);
            string title = string.Format(lang.GetMessage($"OptionChangeTitle", this), lang.GetMessage($"{optionName}", this), state);
            string change = "";
            if (status.ToUpper() == "FALSE") change = lang.GetMessage($"TRUE", this);
            else change = lang.GetMessage($"FALSE", this);
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.3 0.3", "0.7 0.7", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["header"], title, 18, "0.03 0.85", "0.97 .95", TextAnchor.UpperCenter);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["dark"], lang.GetMessage($"{verbiage}", this), 18, "0.03 0.27", "0.97 0.83", TextAnchor.UpperLeft);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["dark"], string.Format(lang.GetMessage($"OptionChangeMSG", this), change), 18, "0.2 0.18", "0.8 0.26", TextAnchor.MiddleCenter);
            UI.CreateButton(ref element, FactionsUIPanel, UIColors["buttonbg"], "Yes", 18, "0.2 0.05", "0.4 0.15", $"{cmd}");
            UI.CreateButton(ref element, FactionsUIPanel, UIColors["buttonred"], "No", 16, "0.6 0.05", "0.8 0.15", "UI_CUIOptions");
            CuiHelper.AddUi(player, element);
        }

        void ScoreBoardUI(BasePlayer player, int count, int page = 0)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            if (configData.Use_FactionKillIncentives)
            {
                var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
                UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
                UI.CreateLabel(ref element, FactionsUIPanel, UIColors["header"], lang.GetMessage("ScoreBoard", this), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);
                int entriesallowed = 78;
                int remainingentries = count - (page * entriesallowed);
                {
                    if (remainingentries > entriesallowed)
                        UI.CreateButton(ref element, FactionsUIPanel, UIColors["buttonbg"], $"{lang.GetMessage("Next", this)}", 18, "0.87 0.03", "0.97 0.085", $"UI_CUIScoreBoard {count} {page + 1}");
                    if (page > 0)
                        UI.CreateButton(ref element, FactionsUIPanel, UIColors["buttonred"], $"{lang.GetMessage("Back", this)}", 18, "0.73 0.03", "0.83 0.085", $"UI_CUIScoreBoard {count} {page - 1}");

                }
                int shownentries = page * entriesallowed;
                int i = 0;
                int n = 0;
                foreach (var entry in playerData.playerFactions.OrderByDescending(e => e.Value.Kills))
                {
                    if (entry.Value.faction != 0)
                    {
                        if (factionData.Factions[entry.Value.faction].type == FactionType.Regular)
                        {
                            i++;
                            if (i < shownentries + 1) continue;
                            else if (i <= (shownentries + entriesallowed))
                            {
                                var kills = entry.Value.Kills;
                                string pname = entry.Value.Name;
                                string fname = factionData.Factions[entry.Value.faction].Name;
                                var color = factionData.Factions[entry.Value.faction].UIColor;
                                CreateSBEntry(ref element, FactionsUIPanel, color, pname, kills, fname, n); n++;
                            }
                        }
                    }
                }
                CuiHelper.AddUi(player, element);
            }
        }

        void ShowFaction(BasePlayer player, ushort faction, int count, int page = 0)
        {
            var color = factionData.Factions[faction].UIColor;
            var name = factionData.Factions[faction].Name;
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            var element = UI.CreateElementContainer(FactionsUIPanel, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, FactionsUIPanel, UIColors["header"], name, 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);
            if (factionData.Factions[faction].type == FactionType.Regular)
                UI.CreateLabel(ref element, FactionsUIPanel, color, "Leader: " + GetLeaderName(faction) + "  Tax: " + GetTax(faction) + "%" + "  Kills: " + GetFactionKills(faction), 22, "0.1 0.9", "0.9 0.98", TextAnchor.MiddleCenter);
            UI.CreateLabel(ref element, FactionsUIPanel, color, lang.GetMessage("MembersGUI", this), 18, "0.4 0.84", "0.6 0.89", TextAnchor.MiddleCenter);
            UI.CreatePanel(ref element, FactionsUIPanel, UIColors["dark"], "0.0 0.83", "0.99 0.839", true);
            int entriesallowed = 12;
            int remainingentries = count - (page * entriesallowed);
            {
                if (remainingentries > entriesallowed)
                    UI.CreateButton(ref element, FactionsUIPanel, UIColors["buttonbg"], $"{lang.GetMessage("Next", this)}", 18, "0.87 0.03", "0.97 0.085", $"UI_CUIFactionList {faction} {count} {page + 1}");
                if (page > 0)
                    UI.CreateButton(ref element, FactionsUIPanel, UIColors["buttonred"], $"{lang.GetMessage("Back", this)}", 18, "0.73 0.03", "0.83 0.085", $"UI_CUIFactionList {faction} {count} {page - 1}");

            }
            int shownentries = page * entriesallowed;
            int i = 0;
            int n = 0;
            string status = "";
            foreach (var entry in playerData.playerFactions.OrderByDescending(e => e.Value.Name))
            {
                if (BasePlayer.activePlayerList.Contains(BasePlayer.FindByID(entry.Key)))
                    status = "Status: <color=#44ff44>Online</color>";
                else status = "Status: <color=#ff4444>Offline</color>";
                if (entry.Value.faction == faction && factionData.Factions[faction].type == FactionType.Regular)
                {
                    i++;
                    if (i < shownentries + 1) continue;
                    else if (i <= shownentries + entriesallowed)
                    {
                        var level = "";
                        var rank = "";
                        var trade = "";
                        var time = "";
                        string pname = entry.Value.Name;
                        string kills = "";

                        if (configData.Use_Ranks)
                            rank = $"{Enum.GetName(typeof(Rank), entry.Value.rank)}-";
                        if (configData.Use_FactionKillIncentives)
                            kills = "Kills:" + entry.Value.Kills.ToString();
                        if (configData.Use_Trades)
                        {
                            level = "Level:" + entry.Value.level.ToString();
                            trade = $"-{Enum.GetName(typeof(Trade), entry.Value.trade)}\n";
                        }
                        if (configData.Use_FactionLeaderByTime)
                            time = " Time:" + playerData.playerFactions[entry.Key].time.ToString();
                        string info = $"{rank}{pname}\n{level}{trade}{kills}{time}\n{status}";
                        CreatePlayerEntry(ref element, FactionsUIPanel, color, info, n); n++;
                    }
                }
                else if (entry.Value.faction == faction && factionData.Factions[faction].type == FactionType.FFA)
                {
                    i++;
                    if (i < shownentries + 1) continue;
                    else if (i <= shownentries + entriesallowed)
                    {
                        string info = $"{entry.Value.Name}\n{status}";
                        CreatePlayerEntry(ref element, FactionsUIPanel, color, info, n); n++;
                    }
                }
            }
            UI.CreateButton(ref element, FactionsUIPanel, UIColors["orange"], $"{lang.GetMessage("FactionLists", this)}", 16, "0.02 0.03", "0.12 0.085", $"UI_CUIFactionLists");
            CuiHelper.AddUi(player, element);
        }

        void FactionMemberStatus(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelMemberStatus);
            if (FactionMemberCheck(player))
            {
                var faction = GetPlayerFaction(player);
                var element = UI.CreateElementContainer(PanelMemberStatus, "0.0 0.0 0.0 0.0", "0.89 0.4", "0.99 0.8", false);
                UI.CreateLabel(ref element, PanelMemberStatus, "1.0 1.0 1.0 1.0", $"{factionData.Factions[faction].Name} - {lang.GetMessage("PLAYERS", this)}", 12, "0.0 0.91", "1.0 0.99");
                int i = 0;
                List<BasePlayer> list = new List<BasePlayer>();
                Vis.Entities(player.transform.position, 40f, list);
                foreach (var p in list)
                {
                    if (p.userID == player.userID) continue;
                    if (FactionMemberCheck(p))
                        if (playerData.playerFactions[p.userID].faction == faction)
                        {
                            var health = p.health;
                            var name = p.displayName;
                            CreateStatusEntry(ref element, PanelMemberStatus, name, health, i); i++;
                        }
                }
                UI.CreateButton(ref element, PanelMemberStatus, UIColors["buttonred"], $"{lang.GetMessage("Close", this)}", 8, "0.79 0.03", "0.99 0.08", $"DestroyMemberStatus");
                CuiHelper.AddUi(player, element);
            }
        }

        void KillTicker(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelKillTicker);
            var element = UI.CreateElementContainer(PanelKillTicker, "0.0 0.0 0.0 0.0", "0.55 0.87", "0.85 1.0", false);
            UI.CreateLabel(ref element, PanelKillTicker, "1.0 1.0 1.0 1.0", $"{lang.GetMessage("FactionKillTotals", this)} - Goal:{configData.KillLimit}" , 12, "0.0 0.7", "1.0 0.99");
            int i = 0;
            foreach (var entry in factionData.Factions.Where(kvp => kvp.Value.type == FactionType.Regular))
            {
                    CreateTickerEntry(ref element, PanelKillTicker, entry.Key, i); i++;
            }
            CuiHelper.AddUi(player, element);
        }

        void RankAdvancement(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelRankAdvanced);
            var element = UI.CreateElementContainer(PanelRankAdvanced, "0.0 0.0 0.0 0.0", "0.85 0.2", ".99 0.35", false);
            UI.CreateLabel(ref element, PanelRankAdvanced, UIColors["header"], $"{configData.MSG_MainColor}<b>Congratulations!!!</b></color>\n\n You have advanced to\nRank\n{Enum.GetName(typeof(Rank), GetPlayerRank(player))}", 16, "0.0 0.0", "1.0 1.0", TextAnchor.UpperCenter);
            CuiHelper.AddUi(player, element);
            timer.Once(10, () => CuiHelper.DestroyUi(player, PanelRankAdvanced));
        }

        void LevelAdvancement(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelLevelAdvanced);
            var element = UI.CreateElementContainer(PanelLevelAdvanced, "0.0 0.0 0.0 0.0", "0.85 0.2", ".99 0.35", false);
            UI.CreateLabel(ref element, PanelLevelAdvanced, UIColors["header"], $"{configData.MSG_MainColor}<b>Congratulations!!!</b></color>\n\n You have advanced to\nLevel\n{GetPlayerLevel(player)}", 16, "0.0 0.0", "1.0 1.0", TextAnchor.UpperCenter);
            CuiHelper.AddUi(player, element);
            timer.Once(10, () => CuiHelper.DestroyUi(player, PanelLevelAdvanced));
        }

        void SpawnButtons(BasePlayer player, ushort faction)
        {
            var c = 0;
            foreach (var spawn in factionData.RallySpawns.Where(kvp => kvp.Value.FactionID == faction))
            {
                c++;
            }
            foreach (var spawn in factionData.FactionSpawns.Where(kvp => kvp.Value.FactionID == faction))
            {
                c++;
            }
            if (c < 1) return;
            var i = 0;
            var color = factionData.Factions[faction].UIColor;
            var name = factionData.Factions[faction].Name;
            CuiHelper.DestroyUi(player, PanelSpawnButtons);
            var element = UI.CreateElementContainer(PanelSpawnButtons, "0.0 0.0 0.0 0.0", "0.8 0.2", "1.0 .8", false);
            if (configData.Use_RallySpawns || configData.Use_FactionSpawns)              
                UI.CreateButton(ref element, PanelSpawnButtons, "0.0 0.0 0.0 0.0", "Close", 10, "0.8 0.96", "0.9 1.0", "DestroySpawnButtons");
            if (configData.Use_RallySpawns)
            {
                UI.CreateLabel(ref element, PanelSpawnButtons, "1.0 1.0 1.0 1.0", lang.GetMessage("Rally Spawns", this), 12, "0.0 0.90", "1.0 0.95");
                foreach (var spawn in factionData.RallySpawns.Where(kvp => kvp.Value.FactionID == faction))
                {
                    CreateSpawnButton(ref element, PanelSpawnButtons, "rally", spawn.Value.Name, spawn.Value.FactionID, spawn.Key, i); i++;
                }
            }
            if (configData.Use_FactionSpawns)
            {
                i = 8;
                UI.CreateLabel(ref element, PanelSpawnButtons, "1.0 1.0 1.0 1.0", lang.GetMessage("Faction Spawns", this), 12, "0.0 0.51", "1.0 0.55");
                foreach (var spawn in factionData.FactionSpawns.Where(kvp => kvp.Value.FactionID == faction))
                {
                    CreateSpawnButton(ref element, PanelSpawnButtons, "faction", spawn.Value.Name, spawn.Value.FactionID, spawn.Key, i); i++;
                }
            }
            CuiHelper.AddUi(player, element);
            return;
        }

        [ConsoleCommand("UI_Use_FactionChatControl")]
        private void cmdChatConfig(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_FactionChatControl == true) configData.Use_FactionChatControl = false;
            else configData.Use_FactionChatControl = true;
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_FFDisabled")]
        private void cmdFFConfig(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.FFDisabled == true) configData.FFDisabled = false;
            else configData.FFDisabled = true;
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_BuildingProtectionEnabled")]
        private void cmdBuildingConfig(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.BuildingProtectionEnabled == true) configData.BuildingProtectionEnabled = false;
            else configData.BuildingProtectionEnabled = true;
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_Use_Trades")]
        private void cmdTradesConfig(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_Trades == true) configData.Use_Trades = false;
            else configData.Use_Trades = true;
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_Use_Taxes")]
        private void cmdTaxesConfig(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_Taxes == true) configData.Use_Taxes = false;
            else configData.Use_Taxes = true;
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_Use_Ranks")]
        private void cmdRanks(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_Ranks == true) configData.Use_Ranks = false;
            else configData.Use_Ranks = true;
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_AllowTradesByPlayer")]
        private void cmdAllowTradesByPlayer(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.AllowTradesByPlayer == true) configData.AllowTradesByPlayer = false;
            else
            {
                configData.AllowTradesByPlayer = true;
                configData.Use_Trades = true;
            }
            CUIOptions(player);
            SaveConfig(configData);
        }
        

        [ConsoleCommand("UI_Use_Groups")]
        private void cmdGroups(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_Groups == true) configData.Use_Groups = false;
            else configData.Use_Groups = true;
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_Use_FactionsInfo")]
        private void cmdUse_FactionsInfo(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_FactionsInfo == true) configData.Use_FactionsInfo = false;
            else configData.Use_FactionsInfo = true;
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_Use_Kits")]
        private void cmdUse_Kits(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_Kits == true) configData.Use_Kits = false;
            else configData.Use_Kits = true;
            CUIOptions(player);
            SaveConfig(configData);
        }
        

             [ConsoleCommand("UI_AllowPlayerToLeaveFactions")]
        private void cmdAllowPlayerToLeaveFactions(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.AllowPlayerToLeaveFactions == true) configData.AllowPlayerToLeaveFactions = false;
            else configData.AllowPlayerToLeaveFactions = true;
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_Use_FactionBalancing")]
        private void cmdUse_FactionBalancing(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_FactionBalancing == true) configData.Use_FactionBalancing = false;
            else configData.Use_FactionBalancing = true;
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_Use_FactionNamesonChat")]
        private void cmdUse_FactionNamesonChat(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_FactionNamesonChat == true) configData.Use_FactionNamesonChat = false;
            else
            {
                configData.Use_FactionNamesonChat = true;
                configData.Use_FactionChatControl = true;
            }
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_Use_ChatTitles")]
        private void cmdUse_ChatTitles(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_ChatTitles == true) configData.Use_ChatTitles = false;
            else
            {
                configData.Use_ChatTitles = true;
                configData.Use_FactionChatControl = true;
            }
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_Use_FactionLeaderByRank")]
        private void cmdUse_FactionLeaderByRank(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_FactionLeaderByRank == true) configData.Use_FactionLeaderByRank = false;
            else
            {
                configData.Use_FactionLeaderByAdmin = false;
                configData.Use_FactionLeaderByRank = true;
                configData.Use_FactionLeaderByTime = false;
            }
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_Use_FactionLeaderByTime")]
        private void cmdUse_FactionLeaderByTime(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_FactionLeaderByTime == true) configData.Use_FactionLeaderByTime = false;
            else
            {
                configData.Use_FactionLeaderByAdmin = false;
                configData.Use_FactionLeaderByRank = false;
                configData.Use_FactionLeaderByTime = true;
                foreach (BasePlayer p in BasePlayer.activePlayerList) InitPlayerTime(p);
                ChangeGlobalTime();
                timer.Once(180, () => SavePlayerFactionTime());
            }
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_Use_FactionLeaderByAdmin")]
        private void cmdUse_FactionLeaderByAdmin(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_FactionLeaderByAdmin == true) configData.Use_FactionLeaderByAdmin = false;
            else
            {
                configData.Use_FactionLeaderByAdmin = true;
                configData.Use_FactionLeaderByRank = false;
                configData.Use_FactionLeaderByTime = false;
            }
                CUIOptions(player);
            SaveConfig(configData);
        }


        [ConsoleCommand("UI_Use_RevoltChallenge")]
        private void cmdUse_RevoltChallengeConfig(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_RevoltChallenge == true) configData.Use_RevoltChallenge = false;
            else configData.Use_RevoltChallenge = true;
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_Use_FactionZones")]
        private void cmdUI_Use_FactionZones(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_FactionZones == true) configData.Use_FactionZones = false;
            else configData.Use_FactionZones = true;
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("Use_FactionSafeZones")]
        private void cmdUse_FactionSafeZones(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_FactionSafeZones == true) configData.Use_FactionSafeZones = false;
            else
            {
                configData.Use_FactionSafeZones = true;
                configData.Use_FactionZones = true;
            }
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_Use_BattleZones")]
        private void cmdUI_Use_BattleZones(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_BattleZones == true) configData.Use_BattleZones = false;
            else configData.Use_BattleZones = true;
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_Use_AutoAuthorization")]
        private void cmdUI_Use_AutoAuthorization(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_AutoAuthorization == true) configData.Use_AutoAuthorization = false;
            else configData.Use_AutoAuthorization = true;
            CUIOptions(player);
            SaveConfig(configData);
        }
        


        [ConsoleCommand("UI_Use_RallySpawns")]
        private void cmdUse_RallySpawnsConfig(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_RallySpawns == true) configData.Use_RallySpawns = false;
            else configData.Use_RallySpawns = true;
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_Use_FactionSpawns")]
        private void cmdUse_FactionSpawnsConfig(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_FactionSpawns == true) configData.Use_FactionSpawns = false;
            else configData.Use_FactionSpawns = true;
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_Use_PersistentSpawns")]
        private void cmdUI_Use_PersistentSpawns(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_PersistantSpawns == true) configData.Use_PersistantSpawns = false;
            else
            {
                configData.Use_PersistantSpawns = true;
            }
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_Use_FactionsByInvite")]
        private void cmdUI_Use_FactionsByInvite(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_FactionsByInvite == true) configData.Use_FactionsByInvite = false;
            else configData.Use_FactionsByInvite = true;
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_UseEconomics")]
        private void cmdUseEconomicsConfig(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_EconomicsReward == true) configData.Use_EconomicsReward = false;
            else configData.Use_EconomicsReward = true;
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_UseRewards")]
        private void cmdUseRewardsConfig(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_ServerRewardsReward == true) configData.Use_ServerRewardsReward = false;
            else configData.Use_ServerRewardsReward = true;
            DestroyFS(player);
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_BroadcastDeath")]
        private void cmdBroadcastDeath(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.BroadcastDeath == true) configData.BroadcastDeath = false;
            else configData.BroadcastDeath = true;
            CUIOptions(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_Use_FactionKillIncentives")]
        private void cmdUse_FactionKillIncentives(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_FactionKillIncentives == true) configData.Use_FactionKillIncentives = false;
            else
            {
                configData.Use_FactionKillIncentives = true;
                ResetTicker();
            }
            FactionMenuBar(player);
            CUIOptions(player);
            SaveConfig(configData);
            foreach (BasePlayer p in BasePlayer.activePlayerList)
                RefreshTicker(p);
        }

        //[ConsoleCommand("UI_AskLater")]
        //private void cmdAskLater(ConsoleSystem.Arg arg)
        //{
        //    var player = arg.Connection.player as BasePlayer;
        //    if (player == null)
        //        return;
        //    AskLater(player);
        //}

        //private void AskLater(BasePlayer player)
        //{
        //    CuiHelper.DestroyUi(player, FactionsUIPanel);
        //    UnsureWaiting.Add(player.userID);
        //    timer.Once(30 * 60, () => CheckForFactionSelect(player));

        //}

        [ConsoleCommand("UI_CUIFactionLists")]
        private void cmdCUIFactionLists(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            CUIFactionLists(player);
        }

        private void CUIFactionLists(BasePlayer player)
        {
            DestroyFactionsUIPanel(player);
            FactionListsUI(player);
        }

        [ConsoleCommand("UI_CUIFactionList")]
        private void cmdCUIFactionList(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            ushort FactionID = Convert.ToUInt16(arg.Args[0]);
            if (player == null)
                return;
            int count = Convert.ToInt16(arg.Args[1]);
            int page = Convert.ToInt16(arg.Args[2]);
            CUIFactionList(player, FactionID, count, page);
        }

        private void CUIFactionList(BasePlayer player, ushort faction, int count, int page)
        {
            DestroyFactionsUIPanel(player);
            ShowFaction(player, faction, count, page);
        }

        [ConsoleCommand("UI_CUIScoreBoard")]
        private void cmdCUIScoreBoard(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int count = Convert.ToInt16(arg.Args[0]);
            int page = Convert.ToInt16(arg.Args[1]);
            CUIScoreBoard(player, count, page);
        }

        private void CUIScoreBoard(BasePlayer player, int count, int page )
        {
            DestroyFactionsUIPanel(player);
            ScoreBoardUI(player, count, page);
        }

        [ConsoleCommand("UI_CUIInstructions")]
        private void cmdCUIInstructions(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            CUIInstructions(player);
        }

        private void CUIInstructions(BasePlayer player)
        {
            DestroyFactionsUIPanel(player);
            Instructions(player);
        }

        [ConsoleCommand("UI_CUILeader")]
        private void cmdCUILeader(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            CUILeader(player);
        }

        private void CUILeader(BasePlayer player)
        {
            var playerfaction = GetPlayerFaction(player);
            DestroyFactionsUIPanel(player);
            Leader(player);
        }

        [ConsoleCommand("UI_CUIAdmin")]
        private void cmdCUIAdmin(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            CUIAdmin(player);
        }

        private void CUIAdmin(BasePlayer player)
        {
            DestroyFactionsUIPanel(player);
            Admin(player);
        }

        [ConsoleCommand("UI_CUITrades")]
        private void cmdCUITrades(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            CUITradesdmin(player);
        }

        private void CUITradesdmin(BasePlayer player)
        {
            DestroyFactionsUIPanel(player);
            TradesManager(player);
        }

        [ConsoleCommand("UI_CUITradeAssignmentMenu")]
        private void cmdCUITradeAssignmentMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            Trade trade;
            trade = (Trade)Enum.Parse(typeof(Trade), arg.Args[0]);
            CUITradeAssignmentMenu(player, trade);
        }

        private void CUITradeAssignmentMenu(BasePlayer player, Trade trade)
        {
            DestroyFactionsUIPanel(player);
            TradeAssignmentMenu(player, trade);
        }

        [ConsoleCommand("UI_CreateZone")]
        private void cmdUI_CreateZone(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            string type = arg.Args[0];
            ushort ID = Convert.ToUInt16(arg.Args[1]);            
                createZone(player, ID, type);
        }

        [ConsoleCommand("UI_EraseZone")]
        private void cmdUI_EraseZone(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            ushort ID = Convert.ToUInt16(arg.Args[0]);
            string type = arg.Args[1];
            eraseZone(player, ID, type);
        }

        [ConsoleCommand("UI_CancelBZ")]
        private void cmdUI_CancelBZ(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            ushort ID = Convert.ToUInt16(arg.Args[0]);
            string reason = arg.Args[1];
            EndBZ(ID, reason);
            Admin(player);
        }


        [ConsoleCommand("UI_CUISpawnManager")]
        private void cmdCUISpawnManager(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (arg.Args.Contains("admin"))
                CUISpawnManager(player, "admin");
            if (arg.Args.Contains("leader"))
                CUISpawnManager(player, "leader");
        }

        [ConsoleCommand("UI_CUIZoneManager")]
        private void cmdCUIZoneManager(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (arg.Args.Contains("admin"))
                CUIZoneManager(player, "admin");
            //if (arg.Args.Contains("leader"))
                //CUISpawnManager(player, "leader");
        }

        private void CUISpawnManager(BasePlayer player, string user)
        {
            DestroyFactionsUIPanel(player);
            SpawnManager(player, user);
        }

        private void CUIZoneManager(BasePlayer player, string user)
        {
            DestroyFactionsUIPanel(player);
            ZoneManagement(player, user);
        }

        [ConsoleCommand("UI_CUIFactionManager")]
        private void cmdCUIFactionManager(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            CUIFactionManager(player);
        }

        private void CUIFactionManager(BasePlayer player)
        {
            DestroyFactionsUIPanel(player);
            FactionManager(player);
        }

        [ConsoleCommand("UI_CUI_FactionLeaders")]
        private void cmdCUI_FactionLeaders(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            CUI_FactionLeaders(player);
        }

        private void CUI_FactionLeaders(BasePlayer player)
        {
            DestroyFactionsUIPanel(player);
            FactionLeaders(player);
        }



        [ConsoleCommand("UI_CUI_FactionEditor")]
        private void cmdCUI_FactionEditor(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null) return;
            CUI_FactionEditor(player);
        }

        private void CUI_FactionEditor(BasePlayer player)
        {
            DestroyFactionsUIPanel(player);
            FactionEditor(player);
        }



        [ConsoleCommand("UI_CUIPlayer")]
        private void cmdCUIPlayer(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            CUIPlayer(player);
        }

        private void CUIPlayer(BasePlayer player)
        {
            DestroyFactionsUIPanel(player);
            Player(player);
        }



        [ConsoleCommand("UI_FactionSelection")]
        private void cmdUI_FactionSelection(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var page = Convert.ToInt16(arg.Args[0]);
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            DestroyFactionMenu(player);
            SetFaction(player, page);

        }

        [ConsoleCommand("UI_CUIFactionInvite")]
        private void cmdCUIFactionInvite(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var faction = Convert.ToUInt16(arg.Args[0]);
            var page = Convert.ToInt16(arg.Args[1]);
            CUIFactionInvite(player, faction, page);
        }

        private void CUIFactionInvite(BasePlayer player, ushort faction, int page)
        {
            DestroyFactionsUIPanel(player);
            FactionInviteScreen(player, faction, page);
        }


        [ConsoleCommand("UI_CUIKickPlayerMenu")]
        private void cmdUI_CUIKickPlayerMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            ushort faction = 0;
            int page = 0;
            if (arg.Args[0] != null)
            {
                faction = Convert.ToUInt16(arg.Args[0]);
                page = Convert.ToInt16(arg.Args[1]);
            }
            CUIKickPlayerMenu(player, faction, page);
        }

        private void CUIKickPlayerMenu(BasePlayer player, ushort faction, int page)
        {
            DestroyFactionsUIPanel(player);
            KickPlayersMenu(player, faction, page);
        }


        [ConsoleCommand("UI_CUIOptions")]
        private void cmdCUIOptions(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            CUIOptions(player);
        }

        private void CUIOptions(BasePlayer player)
        {
            DestroyFactionsUIPanel(player);
            Options(player);
        }


        [ConsoleCommand("UI_PlayerTradeUnassignment")]
        private void cmdPlayerTradeUnassignment(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            Trade trade = playerData.playerFactions[player.userID].trade;
            playerData.playerFactions[player.userID].trade = Trade.None;
            SendMSG(player, string.Format(lang.GetMessage("PlayerTradeRemoved", this), Enum.GetName(typeof(Trade), trade)));
            SaveData();
            PlayerTradeMenu(player);
        }

        [ConsoleCommand("UI_CUIUnassignTradeSkill")]
        private void cmdCUIUnassignTradeSkill(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            ushort UID = Convert.ToUInt16(arg.Args[0]);
            var trade = TradeRemoval[UID].trade;
            foreach (var entry in TradeRemoval)
                if (entry.Key == UID)
                {
                    playerData.playerFactions[entry.Value.playerID].trade = Trade.None;
                    try
                    {
                        BasePlayer unassigned = BasePlayer.FindByID(entry.Value.playerID);
                        SendMSG(unassigned, string.Format(lang.GetMessage("PlayerTradeRemoved", this), Enum.GetName(typeof(Trade), entry.Value.trade)));
                        SendMSG(player, string.Format(lang.GetMessage("LeaderTradeRemoved", this), Enum.GetName(typeof(Trade), entry.Value.trade), playerData.playerFactions[entry.Value.playerID].Name));
                    }
                    catch
                    {
                        SendMSG(player, string.Format(lang.GetMessage("LeaderTradeRemoved", this), Enum.GetName(typeof(Trade), entry.Value.trade), playerData.playerFactions[entry.Value.playerID].Name));
                    }
                }
            foreach (var entry in TradeRemoval.Where(kvp => kvp.Value.leaderID == player.userID).ToList())
            {
                TradeRemoval.Remove(entry.Key);
            }
            SaveData();
            TradeOverview(player, trade);
        }

        [ConsoleCommand("UI_CUIAssignTradeSkill")]
        private void cmdCUIAssignTradeSkill(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            ushort UID = Convert.ToUInt16(arg.Args[0]);
            var trade = TradeAssignments[UID].trade;
            foreach (var entry in TradeAssignments)
                if (entry.Key == UID)
                {
                    playerData.playerFactions[entry.Value.playerID].trade = entry.Value.trade;
                    try
                    {
                        BasePlayer assigned = BasePlayer.FindByID(entry.Value.playerID);
                        SendMSG(assigned, string.Format(lang.GetMessage("PlayerTradeSuccess", this), Enum.GetName(typeof(Trade), entry.Value.trade)));
                        SendMSG(player, string.Format(lang.GetMessage("LeaderTradeSuccess", this), playerData.playerFactions[entry.Value.playerID].Name, Enum.GetName(typeof(Trade), entry.Value.trade)));
                    }
                    catch
                    {
                        SendMSG(player, string.Format(lang.GetMessage("LeaderTradeSuccess", this), playerData.playerFactions[entry.Value.playerID].Name, Enum.GetName(typeof(Trade), entry.Value.trade)));
                    }
                }
            foreach (var entry in TradeAssignments.Where(kvp => kvp.Value.leaderID == player.userID).ToList())
            {
                TradeAssignments.Remove(entry.Key);
            }
            SaveData();
            TradeOverview(player, trade);
        }

        [ConsoleCommand("UI_RallyMovePlayerPosition")]
        private void cmdCUIRallyMovePlayer(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            ushort SpawnID = Convert.ToUInt16(arg.Args[0]);
            CUIRallyMovePlayer(player, SpawnID);
        }

        private void CUIRallyMovePlayer(BasePlayer player, ushort SpawnID)
        {
            if (SpawnTimers.Contains(player.userID))
            {
                SendMSG(player, string.Format(lang.GetMessage("ActiveSpawnCooldown", this)));
                return;
            }
            var faction = playerData.playerFactions[player.userID].faction;
            foreach (var spawn in factionData.RallySpawns.Where(kvp => kvp.Key == SpawnID))
            {
                var x = factionData.RallySpawns[spawn.Key].x;
                var y = factionData.RallySpawns[spawn.Key].y;
                var z = factionData.RallySpawns[spawn.Key].z;
                MovePlayerPosition(player, new Vector3(x, y, z));
                CuiHelper.DestroyUi(player, PanelSpawnButtons);
                DestroyFactionMenu(player);
                SpawnTimer(player, 0);
            }
        }
        

        [ConsoleCommand("UI_FactionMovePlayerPosition")]
        private void cmdCUISpawnMovePlayer(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            ushort SpawnID = Convert.ToUInt16(arg.Args[0]);
            CUISpawnMovePlayer(player, SpawnID);
        }

        private void CUISpawnMovePlayer(BasePlayer player, ushort SpawnID)
        {
            if (SpawnTimers.Contains(player.userID))
            {
                SendMSG(player, string.Format(lang.GetMessage("ActiveSpawnCooldown", this)));
                return;
            }
            var faction = playerData.playerFactions[player.userID].faction;
            foreach (var spawn in factionData.FactionSpawns.Where(kvp => kvp.Key == SpawnID))
            {
                var x = factionData.FactionSpawns[spawn.Key].x;
                var y = factionData.FactionSpawns[spawn.Key].y;
                var z = factionData.FactionSpawns[spawn.Key].z;
                MovePlayerPosition(player, new Vector3(x, y, z));
                CuiHelper.DestroyUi(player, PanelSpawnButtons);
                DestroyFactionMenu(player);
                SpawnTimer(player, 0);
            }
        }

        [ConsoleCommand("UI_CUIRemoveRallySpawn")]
        private void cmdCUIRemoveRallySpawn(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            ushort SpawnID = Convert.ToUInt16(arg.Args[0]);
            CUIRemoveRallySpawn(player, SpawnID);
        }

        private void CUIRemoveRallySpawn(BasePlayer player, ushort SpawnID)
        {
            var playerfaction = GetPlayerFaction(player);
            foreach (var spawn in factionData.RallySpawns.Where(kvp => kvp.Key == SpawnID))
            {
                factionData.RallySpawns.Remove(spawn.Key);
                BroadcastFaction(player, lang.GetMessage("RallySpawnRemoved", this));
                CUISpawnManager(player, "leader");
            }
            SaveData();
        }

        [ConsoleCommand("UI_CUISetSpawnPoint")]
        private void cmdCUISetSpawnPoint(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyFactionMenu(player);
            if (arg.Args.Contains("faction"))
            {
                ushort faction = Convert.ToUInt16(arg.Args[1]);
                var i = 0;
                foreach (var spawn in factionData.FactionSpawns.Where(kvp => kvp.Value.FactionID == faction))
                {
                    i++;
                }

                if (i >= configData.SpawnCountLimit)
                {
                    SendMSG(player, string.Format(lang.GetMessage("ToManySpawns", this), configData.SpawnCountLimit));
                    return;
                }
                else
                {
                    int Number = GetRandomNumber();
                    ushort ID = (ushort)Number;
                    var adminCoords = player.transform.localPosition;

                    SpawnCreation.Add(player.userID, new SpawnDesigner { SpawnID = ID, type = "faction", Entry = new Coords { FactionID = faction, x = adminCoords.x, y = adminCoords.y, z = adminCoords.z } });
                    DestroyUI(player);
                    CreationHelp(player, 9);
                }
            }
            if (arg.Args.Contains("rally"))
            {
                var faction = GetPlayerFaction(player);
                var i = 0;
                foreach (var spawn in factionData.RallySpawns.Where(kvp => kvp.Value.FactionID == faction))
                {
                    i++;
                }

                if (i >= configData.SpawnCountLimit)
                {
                    SendMSG(player, string.Format(lang.GetMessage("ToManySpawns", this), configData.SpawnCountLimit));
                    return;
                }

                else
                {
                    int Number = GetRandomNumber();
                    ushort ID = (ushort)Number;
                    var leaderCoords = player.transform.localPosition;

                    SpawnCreation.Add(player.userID, new SpawnDesigner { SpawnID = ID, type = "rally", Entry = new Coords { FactionID = faction, x = leaderCoords.x, y = leaderCoords.y, z = leaderCoords.z } });
                    DestroyUI(player);
                    CreationHelp(player, 9);
                }
            }
        }


        [ConsoleCommand("UI_TryInvitePlayerToFaction")]
        private void cmdUI_TryInvitePlayerToFaction(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            ushort UID = Convert.ToUInt16(arg.Args[0]);
            foreach (var entry in FactionInvites)
                if (entry.Key == UID)
                {
                    entry.Value.confirm = true;
                    BasePlayer invitee = BasePlayer.FindByID(entry.Value.playerID);
                    CreationHelp(invitee, 11);
                    break;
                }
        }

        [ConsoleCommand("UI_PlayerTradeMenu")]
        private void cmdUI_PlayerTradeMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            PlayerTradeMenu(player);
        }


        [ConsoleCommand("UI_PlayerTradeAssignment")]
        private void cmdPlayerTradeAssignment(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            Trade trade;
            var faction = playerData.playerFactions[player.userID].faction;
            try
            {
                trade = (Trade)Enum.Parse(typeof(Trade), arg.Args[0]);
            }
            catch (Exception)
            {
                return;
            }
            var c = 0;
            foreach (var assigned in playerData.playerFactions)
                if (assigned.Value.faction == faction && assigned.Value.trade == trade)
                {
                    c++;
                }
            if (c >= configData.TradeLimit)
            {
                SendMSG(player, string.Format(lang.GetMessage("PlayerTradeFull", this), Enum.GetName(typeof(Trade), trade)));
                PlayerTradeMenu(player);
                return;
            }
            playerData.playerFactions[player.userID].trade = trade;
            SendMSG(player, string.Format(lang.GetMessage("PlayerTradeSuccess", this), Enum.GetName(typeof(Trade), trade)));
            DestroyFactionMenu(player);
        }

        [ConsoleCommand("UI_TradeAssignment")]
        private void cmdUI_TradeAssignment(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            Trade trade;
            try
            {
                trade = (Trade)Enum.Parse(typeof(Trade), arg.Args[0]);
            }
            catch (Exception)
            {
                return;
            }
            TradeOverview(player, trade);
        }



        [ConsoleCommand("UI_CUILeaveFaction")]
        private void cmdCUILeaveFaction(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var faction = GetPlayerFaction(player);
            var factionname = factionData.Factions[faction].Name;
            if (factionData.leader.ContainsValue(player.userID))
                factionData.leader.Remove(faction);
            BroadcastFaction(player, string.Format(lang.GetMessage("LeftTheFaction", this), player.displayName));
            UnassignPlayerFromFaction(player.userID);
            CUIPlayer(player);
        }


        [ConsoleCommand("UI_ConfirmKickPlayer")]
        private void cmdUI_ConfirmKickPlayer(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (arg.Args[0].Contains("yes"))
            {
                foreach (var entry in FactionKicks)
                    if (entry.Value.executerID == player.userID && (entry.Value.confirm))
                    {
                        var factionname = factionData.Factions[entry.Value.factionID].Name;
                        try
                        {
                            UnassignPlayerFromFaction(entry.Value.playerID);
                        }
                        catch
                        {
                            UnassignPlayerFromFaction(entry.Value.playerID);
                        }
                        if (factionData.leader.ContainsValue(entry.Value.playerID))
                            factionData.leader.Remove(entry.Value.factionID);
                        FactionKicks.Remove(entry.Key);
                        SendMSG(player, string.Format(lang.GetMessage("KickSuccessful", this), playerData.playerFactions[entry.Value.playerID].Name, factionname));
                        break;
                    }
                DestroyUI(player);
                return;
            }
            if (arg.Args[0].Contains("no"))
            {
                foreach (var entry in FactionKicks)
                    if (entry.Value.executerID == player.userID && (entry.Value.confirm))
                    {
                        FactionKicks.Remove(entry.Key);
                        SendMSG(player, string.Format(lang.GetMessage("KickCanceled", this)));
                        break;
                    }
                DestroyUI(player);
                return;
            }
            else
            {
                ushort UID = Convert.ToUInt16(arg.Args[0]);
                foreach (var entry in FactionKicks)
                    if (entry.Key == UID)
                    {
                        entry.Value.confirm = true;
                        break;
                    }
                CreationHelp(player, 12);

            }
        }

        

        [ConsoleCommand("UI_BzButton")]
        private void cmdUI_BzButton(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            ushort ID = Convert.ToUInt16(arg.Args[0]);
            BZButton(player, ID);
        }

        [ConsoleCommand("UI_BzConfirmation")]
        private void cmdUI_BzConfirmation(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            ushort ID = Convert.ToUInt16(arg.Args[0]);
            BZConfirmation(player, ID);
        }


        [ConsoleCommand("UI_BZYes")]
        private void cmdUI_BZYes(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyBZ(player);
            ushort ID = Convert.ToUInt16(arg.Args[0]);
            var faction = GetPlayerFaction(player);
            var zone = BattleZones[ID];
            InitializeBZPlayer(player, ID, zone);
            Vector3 newPos = CalculateOutsidePos(player, BattleZones[bZID]);
            MovePlayerPosition(player, newPos);
            PrintToChat($"{factionData.Factions[faction].ChatColor} {player.displayName} {lang.GetMessage("BZJoin", this)}{factionData.Factions[ID].Name}!</color>");
            DestroyUI(player);
        }

        [ConsoleCommand("CUI_AcceptInvite")]
        private void cmdCUI_AcceptInvite(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            foreach (var entry in FactionInvites)
                if (entry.Value.playerID == player.userID && entry.Value.confirm == true)
                {
                    var faction = entry.Value.factionID;
                    AssignPlayerToFaction(player, faction);
                    PrintToChat($"{factionData.Factions[faction].ChatColor} {player.displayName} {lang.GetMessage("Joined", this)} {factionData.Factions[faction].Name}!</color>");
                    FactionInvites.Remove(entry.Key);
                    break;
                }
            DestroyUI(player);
        }

       [ConsoleCommand("CUI_DeclineInvite")]
        private void cmdCUI_DeclineInvite(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            foreach (var entry in FactionInvites)
                if (entry.Value.playerID == player.userID && entry.Value.confirm == true)
                {
                    var faction = entry.Value.factionID;
                    if (entry.Value.assign == false)
                    {
                        BasePlayer factionleader = BasePlayer.FindByID(factionData.leader[faction]);
                        SendMSG(factionleader, string.Format(lang.GetMessage("RejectedInviteToLeader", this), player.displayName));
                    }
                    FactionInvites.Remove(entry.Key);
                    SendMSG(player, string.Format(lang.GetMessage("RejectedInvite", this)));
                }
            DestroyUI(player);
        }

        [ConsoleCommand("CUI_SaveSpawn")]
        private void cmdSaveSpawn(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (player.IsAdmin)
            {
                bool isSpawn = false;
                if (SpawnCreation.ContainsKey(player.userID))
                    isSpawn = true;
                SaveSpawn(player, isSpawn);
            }
        }
        [ConsoleCommand("CUI_ExitSpawn")]
        private void cmdExitSpawn(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (player.IsAdmin)
            {
                bool isSpawn = false;
                if (SpawnCreation.ContainsKey(player.userID))
                    isSpawn = true;
                ExitSpawnCreation(player, isSpawn);
            }
        }

        private void SaveSpawn(BasePlayer player, bool isSpawn)
        {
            SpawnDesigner Designer;
            Coords spawn;
            if (isSpawn)
            {
                Designer = SpawnCreation[player.userID];
                spawn = Designer.Entry;
                ushort faction = spawn.FactionID;
                if (Designer.type == "faction")
                {
                    factionData.FactionSpawns.Add(Designer.SpawnID, spawn);
                    SpawnCreation.Remove(player.userID);
                    BroadcastFaction(null, lang.GetMessage("NewFactionSpawn", this), faction);
                    SendMSG(player, string.Format(lang.GetMessage("NewSpawnAdmin", this)));
                }

                if (Designer.type == "rally")
                {
                    factionData.RallySpawns.Add(Designer.SpawnID, spawn);
                    SpawnCreation.Remove(player.userID);
                    BroadcastFaction(player, lang.GetMessage("NewRallySpawn", this));
                }
            }
            DestroyUI(player);
            SaveData();
        }
        private void ExitSpawnCreation(BasePlayer player, bool isSpawn)
        {
            if (isSpawn)
            {
                SpawnCreation.Remove(player.userID);

                SendMSG(player, "You have cancelled Spawn creation", "Spawn Designer:");
                DestroyUI(player);
            }
        }

        [ConsoleCommand("UI_CUIRemoveFactionSpawn")]
        private void cmdCUIRemoveFactionSpawn(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            ushort SpawnID = Convert.ToUInt16(arg.Args[0]);
            CUIRemoveFactionSpawn(player, SpawnID);
        }

        private void CUIRemoveFactionSpawn(BasePlayer player, ushort SpawnID)
        {
            foreach (var spawn in factionData.FactionSpawns.Where(kvp => kvp.Key == SpawnID))
            {
                factionData.FactionSpawns.Remove(spawn.Key);
                BroadcastFaction(null, string.Format(lang.GetMessage("FactionSpawnRemoved", this), factionData.Factions[spawn.Value.FactionID].Name, spawn.Value.Name), spawn.Value.FactionID);
                SendMSG(player, string.Format(lang.GetMessage("RemovedSpawnAdmin", this)));
                CUISpawnManager(player, "admin");
            }
            SaveData();
        }

        [ConsoleCommand("UI_CUISetTaxBox")]
        private void cmdCUISetTaxBox(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            CUISetTaxBox(player);
        }

        private void CUISetTaxBox(BasePlayer player)
        {
            var playerfaction = GetPlayerFaction(player);
            if (!activeBoxes.Contains(playerfaction))
            {
                DestroyFactionMenu(player);
                activeBoxes.Add(playerfaction);
                SendMSG(player, lang.GetMessage("TaxBoxActivated", this));
                return;
            }
            DestroyFactionMenu(player);
            activeBoxes.Remove(playerfaction);
            SendMSG(player, lang.GetMessage("TaxBoxDeActivated", this));
            return;
        }

        [ConsoleCommand("UI_CUIRemoveTaxBox")]
        private void cmdCUIRemoveTaxBox(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            CUIRemoveTaxBox(player);
        }

        private void CUIRemoveTaxBox(BasePlayer player)
        {
            var playerfaction = GetPlayerFaction(player);
            var leaderCoords = player.transform.localPosition;
            if (factionData.Boxes.ContainsKey(playerfaction))
            {
                factionData.Boxes.Remove(playerfaction);
                BroadcastFaction(player, lang.GetMessage("TaxBoxRemoved", this));
            }
            SaveData();
        }

        [ConsoleCommand("UI_CUIChallengeLeader")]
        private void cmdCUIChallengeLeader(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            CUIChallengeLeader(player);
        }

        private void CUIChallengeLeader(BasePlayer player)
        {
            var playerfaction = playerData.playerFactions[player.userID].faction;
            var factionleaderID = factionData.leader[playerfaction];
            BasePlayer factionleader = BasePlayer.FindByID(factionleaderID);
            if ((!factionData.ActiveChallenges.ContainsKey(player.userID)) || (!factionData.ActiveChallenges.ContainsKey(factionleaderID)))
            {
                if (!BasePlayer.activePlayerList.Contains(factionleader))
                {
                    SendMSG(player, lang.GetMessage("ChallengeFactionLeaderOffline", this));
                    return;
                }
                factionData.ActiveChallenges.Add(player.userID, playerfaction);
                factionData.ActiveChallenges.Add(factionleaderID, playerfaction);
                SendMSG(player, lang.GetMessage("ChallengeActivated", this));
                SendMSG(factionleader, string.Format(lang.GetMessage("ChallengeToLeader", this), player.displayName));
                timer.Once(900, () =>
                {
                    FactionDamage(player);
                    FactionDamage(factionleader);
                });
                return;
            }
            if ((!factionData.ActiveChallenges.ContainsKey(player.userID)) && (factionData.ActiveChallenges.ContainsKey(factionleaderID)))
            {
                foreach (var entry in factionData.ActiveChallenges)
                    if (entry.Value == playerfaction && entry.Key != factionleaderID)
                    {
                        var activechallengeID = entry.Key;
                        BasePlayer activechallengeplayer = BasePlayer.FindByID(activechallengeID);
                        SendMSG(player, string.Format(lang.GetMessage("CurrentChallengePlayer", this), activechallengeplayer.displayName));
                        return;
                    }
            }
        }

        [ConsoleCommand("UI_CUIResetTicker")]
        private void cmdCUIResetTicker(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            ResetTicker();
        }

        private void ResetTicker()
        {
            foreach (var entry in factionData.Factions)
                entry.Value.Kills = 0;
            SaveData();
            foreach (BasePlayer p in BasePlayer.activePlayerList)
                RefreshTicker(p);
            return;
        }

        private void CheckForFactionSelect(BasePlayer player)
        {
            if (UnsureWaiting.Contains(player.userID)) SetFaction(player);
            UnsureWaiting.Remove(player.userID);
        }

        [ConsoleCommand("UI_DestroyBZPanel")]
        private void cmdDestroyBZPanel(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyBZ(player);
        }

        private void DestroyBZ(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelBZButton);
        }

        [ConsoleCommand("UI_DestroyFS")]
        private void cmdDestroyFS(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyFS(player);
        }

        private void DestroyFS(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
        }

        [ConsoleCommand("UI_DestroyTicker")]
        private void cmdDestroyTicker(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyTicker(player);
        }

        private void DestroyTicker(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelKillTicker);
        }

        private void RefreshTicker(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelKillTicker);
            if (configData.Use_FactionKillIncentives)
                KillTicker(player);
        }

        [ConsoleCommand("UI_DestroySP")]
        private void cmdDestroySP(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyFactionsUIPanel(player);
        }

        private void DestroyFactionsUIPanel(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
        }

        [ConsoleCommand("UI_DestroyFactionMenu")]
        private void cmdDestroyFM(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyFactionMenu(player);
            OpenMap(player);
        }

        private void DestroyFactionMenu(BasePlayer player)
        {
            DestroyFactionsUIPanel(player);
            CuiHelper.DestroyUi(player, PanelFactionMenuBar);
        }

        [ConsoleCommand("UI_OpenFactions")]
        private void cmdOpenFactions(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            OpenFactions(player);
        }

        private void OpenFactions(BasePlayer player)
        {
            if (MenuState.Contains(player.userID))
            {
                DestroyFactionMenu(player);
                MenuState.Remove(player.userID);
            }
            else
            {
                MenuState.Add(player.userID);
                CloseMap(player);
                FactionMenuBar(player);
                Player(player);
            }

        }

        [ConsoleCommand("UI_CUIRequestFactionTax")]
        private void cmdCUIRequestFactionTax(ConsoleSystem.Arg arg)
        {
        var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            string msg = lang.GetMessage("TaxRequestMessage", this);
            string cmd = $"UI_CUISetFactionTax";
            NumberPad(player, msg, cmd);
        }

        [ConsoleCommand("UI_CUISetFactionTax")]
        private void cmdCUISetFactionTax(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyFactionsUIPanel(player);
            int tax = Convert.ToInt16(arg.Args[0]);
            var faction = playerData.playerFactions[player.userID].faction;
            factionData.Factions[faction].tax = tax;
            SendMSG(player, string.Format(lang.GetMessage("NewTax", this), tax));
            Leader(player);
        }

        [ConsoleCommand("DestroyAll")]
        private void cmdDestroyAll(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyAll(player);
        }

        [ConsoleCommand("UI_OpenMemberStatus")]
        private void cmdOpenMemberStatus(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            FactionMemberStatus(player);
            OpenMemberStatus.Add(player.userID);
        }

        [ConsoleCommand("DestroyMemberStatus")]
        private void cmdDestroyMemberStatus(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            CuiHelper.DestroyUi(player, PanelMemberStatus);
            OpenMemberStatus.Remove(player.userID);
        }


        private void DestroyAll(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            CuiHelper.DestroyUi(player, PanelKillTicker);
            CuiHelper.DestroyUi(player, PanelLevelAdvanced);
            CuiHelper.DestroyUi(player, PanelRankAdvanced);
            CuiHelper.DestroyUi(player, PanelSpawnButtons);
            CuiHelper.DestroyUi(player, FactionsUIPanel);
            CuiHelper.DestroyUi(player, PanelBZButton);
            CuiHelper.DestroyUi(player, PanelMemberStatus); 
            DestroyFactionMenu(player);
        }

        [ConsoleCommand("DestroySpawnButtons")]
        private void cmdDestroySpawnButtons(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            DestroySpawnButtons(player);
        }

        private void DestroySpawnButtons(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelSpawnButtons);
        }

        

        #endregion

        #region Console Commands

        [ConsoleCommand("faction.unassign")]
        private void cmdFactionUnAssign(ConsoleSystem.Arg arg)
        {
            if (!isAuthCon(arg)) return;
            if (arg.Args == null || arg.Args.Length == 0)
            {
                SendReply(arg, string.Format(lang.GetMessage("FactionUnassignFormating", this)));
                return;
            }
            if (arg.Args.Length > 1)
            {
                SendReply(arg, string.Format(lang.GetMessage("FactionUnassignFormating", this)));
                return;
            }
            if (arg.Args.Length == 1)
            {
                var partialPlayerName = arg.Args[0];
                var foundPlayers = FindPlayer(partialPlayerName);
                if (foundPlayers.Count == 0)
                {
                    SendReply(arg, string.Format(lang.GetMessage("NoPlayers", this)));
                    return;
                }
                if (foundPlayers.Count > 1)
                {
                    SendReply(arg, string.Format(lang.GetMessage("multiPlayers", this)));
                    return;
                }
                if (!FactionMemberCheck(foundPlayers[0]))
                {
                    SendReply(arg, string.Format(lang.GetMessage("TargetNotInFaction", this), foundPlayers[0].displayName, factionData.Factions[GetPlayerFaction(foundPlayers[0])].Name));
                    return;
                }

                if (foundPlayers[0] != null)
                {
                    UnassignPlayerFromFaction(foundPlayers[0].userID);
                    SendReply(arg, string.Format(lang.GetMessage("UnassignSuccess", this), foundPlayers[0].displayName, factionData.Factions[GetPlayerFaction(foundPlayers[0])].Name));
                    SendMSG(foundPlayers[0], string.Format(lang.GetMessage("RemovedFromFaction", this), factionData.Factions[GetPlayerFaction(foundPlayers[0])].Name));
                    timer.Once(5, () =>
                    {
                        SetFaction(foundPlayers[0]);
                    });
                }
                else SendReply(arg, string.Format(lang.GetMessage("UnassignError", this)));
            }
        }

        #endregion

        #region Chat Commands
        ///FactionChat		
        [ChatCommand("fc")]
        private void cmdfactionchat(BasePlayer player, string command, string[] args)
        {
            if (!FactionMemberCheck(player))
            {
                SendMSG(player, lang.GetMessage("NoFactionError", this, player.UserIDString));
                return;
            }
            var faction = (GetPlayerFaction(player));
            var message = string.Join(" ", args);
            if (string.IsNullOrEmpty(message))
                return;
            if (isleader(player))
            {
                BroadcastFaction(player, $"{factionData.Factions[faction].ChatColor}[LEADER]{player.displayName}</color>: " + message);
            }
            else
            {
                BroadcastFaction(player, $"{factionData.Factions[faction].ChatColor}{player.displayName}</color>: " + message);
            }
        }

        [ChatCommand("faction")]
        private void cmdfaction(BasePlayer player, string command, string[] args)
        {
            if (args == null || args.Length == 0)
            {
                CloseMap(player);
                FactionMenuBar(player);
                Player(player);
                return;
            }
        }

        bool isAuth(BasePlayer player)
        {
            if (player.net.connection != null)
                if (player.net.connection.authLevel < 1)
                    return false;
            return true;
        }

        bool isAuthCon(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                var player = arg.Connection.player as BasePlayer;
                if (arg.Connection.authLevel < 1)
                {
                    SendMSG(player, lang.GetMessage("NotAuth", this));
                    return false;
                }
            }
            return true;
        }
        #endregion

        #region UI Commands

        [ConsoleCommand("UI_CUI_FactionInfo")]
        private void cmdCUI_FactionInfo(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            ushort faction = Convert.ToUInt16(arg.Args[0]);
            var page = Convert.ToInt16(arg.Args[1]);
            FactionInfo(player, faction, page);
        }

        [ConsoleCommand("CUI_FactionSelection")]
        private void cmdFactionSelection(ConsoleSystem.Arg arg)
        {

            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            ushort faction = Convert.ToUInt16(arg.Args[0]);
            if (configData.Use_FactionBalancing)
            {
                var max = GetMax();
                var min = GetMin();
                int diff = max - min;
                var selectioncount = factionData.Factions[faction].PlayerCount;
                if (min != selectioncount && diff > configData.AllowedFactionDifference)
                {
                    SendMSG(player, string.Format(lang.GetMessage("FactionToFull", this, player.UserIDString), factionData.Factions[faction].Name));
                    return;
                }
            }
            DestroyFS(player);
            AssignPlayerToFaction(player, faction);
            PrintToChat($"{factionData.Factions[faction].ChatColor} {player.displayName} {lang.GetMessage("Joined", this)} {factionData.Factions[faction].Name}!</color>");

            if (UnsureWaiting.Contains(player.userID)) UnsureWaiting.Remove(player.userID);
        }

        private int GetMax()
        {
            KeyValuePair<ushort, Faction> max = factionData.Factions.First();
            foreach (KeyValuePair<ushort, Faction> count in factionData.Factions)
            {
                if (count.Value.PlayerCount > max.Value.PlayerCount) max = count;
            }
            int num = max.Value.PlayerCount;
            return num;
        }

        private int GetMin()
        {
            KeyValuePair<ushort, Faction> max = factionData.Factions.First();
            foreach (KeyValuePair<ushort, Faction> count in factionData.Factions)
            {
                if (count.Value.PlayerCount < max.Value.PlayerCount) max = count;
            }
            int num = max.Value.PlayerCount;
            return num;
        }

        [ConsoleCommand("UI_CUIPlayerManager")]
        private void cmdUI_CUIPlayerManager(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            CUIPlayerManager(player);
        }

        private void CUIPlayerManager(BasePlayer player)
        {
           DestroyFactionsUIPanel(player);
            PlayerManager(player);
        }

        #endregion

        #region AdminOptions



            #endregion

        #region Faction Management

        enum Rank
        {
            None,
            Recruit,
            Apprentice,
            Novice,
            Advanced,
            Expert,
            SharpShooter
        }
        enum Trade
        {
            None,
            Lumberjack,
            Miner,
            Hunter,
            Crafter,
            Forager
        }
        enum FactionType
        {
            Regular,
            FFA
        }
        private List<BasePlayer> FindPlayer(string arg)
        {
            var foundPlayers = new List<BasePlayer>();
            ulong steamid;
            ulong.TryParse(arg, out steamid);
            string lowerarg = arg.ToLower();

            foreach (var p in BasePlayer.activePlayerList)
                if (p != null)
                {
                    if (steamid != 0L)
                        if (p.userID == steamid)
                        {
                            foundPlayers.Add(p);
                            return foundPlayers;
                        }
                    string lowername = p.displayName.ToLower();
                    if (lowername.Contains(lowerarg))
                        foundPlayers.Add(p);
                }
            return foundPlayers;
        }

        private void AssignPlayerToFaction(BasePlayer player, ushort faction)
        {
            var ID = player.userID;
            var p = playerData.playerFactions;
            var fl = factionData.leader;
            var factionname = factionData.Factions[faction].Name;

            if (FactionMemberCheck(player))
                if (p[ID].faction == faction)
                    return;

            if (!p.ContainsKey(ID))
            {
                p.Add(ID, new FactionPlayerData { faction = faction, Name = $"{player.displayName}", trade = Trade.None, level = 1, FactionMemberTime = 0, rank = Rank.Recruit });
                factionData.Factions[faction].PlayerCount += 1;
            }
            else
            {
                p[ID].faction = faction;
                p[ID].Name = $"{player.displayName}";
                p[ID].FactionMemberTime = 0;
                p[ID].trade = Trade.None;
                p[ID].level = 1;
                p[ID].rank = Rank.Recruit;
                factionData.Factions[faction].PlayerCount += 1;
            }
            if (fl.ContainsValue(ID))
            {
                foreach (var entry in fl.Where(kvp => kvp.Value == ID).ToList())
                {
                    fl.Remove(entry.Key);
                }
            }
            if (configData.Use_Groups)
            {
                foreach (var entry in factionData.Factions) { ConsoleSystem.Run(ConsoleSystem.Option.Server, $"usergroup remove {player.userID} {factionData.Factions[entry.Key].group}"); }
                ConsoleSystem.Run(ConsoleSystem.Option.Server, $"usergroup add {player.userID} {factionData.Factions[faction].group}");
            }
            if (configData.Use_Kits) GiveFactionKit(player, faction);
            if (configData.AllowTradesByPlayer)
                PlayerTradeMenu(player);
            AuthorizePlayerOnTurrets(player);
            InitPlayerTime(player);
            CheckLeaderTime();
            SaveData();
        }

        private void UnassignPlayerFromFaction(ulong playerID)
        {
            var ID = playerID;
            var p = playerData.playerFactions;
            var fl = factionData.leader;
            var oldFaction = p[ID].faction;
            var oldfactionname = factionData.Factions[oldFaction].Name;
            p[ID].faction = default(ushort);
            p[ID].FactionMemberTime = 0;
            p[ID].trade = Trade.None;
            p[ID].level = 1;
            p[ID].rank = Rank.Recruit;
            p[ID].ChallengeStatus = false;

            factionData.Factions[oldFaction].PlayerCount -= 1;
            if (factionData.Factions[oldFaction].PlayerCount < 0)
                factionData.Factions[oldFaction].PlayerCount = 0;

            if (fl.ContainsValue(ID))
            {
                foreach (var entry in fl.Where(kvp => kvp.Value == ID).ToList())
                {
                    fl.Remove(entry.Key);
                }
            }
            try
            {
                BasePlayer player = BasePlayer.FindByID(playerID);
                SendMSG(player, string.Format(lang.GetMessage("RemovedFromFaction", this), oldfactionname));
            }
            catch
            {

            }

            CheckLeaderTime();
            SaveData();
        }

        private void CheckLeaderTime()
        {
            if (!configData.Use_FactionLeaderByTime) return;

            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                if (!FactionMemberCheck(p)) continue;
                var ID = p.userID;
                var pfaction = playerData.playerFactions[ID].faction;
                if (factionData.Factions[pfaction].type == FactionType.FFA) continue;
                var ptime = playerData.playerFactions[ID].FactionMemberTime;
                ulong CurrentLeaderID = 0L;

                if (!factionData.leader.ContainsKey(pfaction))
                {
                    factionData.leader.Add(pfaction, ID); BroadcastFaction(p, $"{factionData.Factions[pfaction].Name} + {lang.GetMessage("NewLeader", this)}");
                    factionData.Factions[pfaction].tax = 0;
                    if (factionData.Boxes.ContainsKey(pfaction)) factionData.Boxes.Remove(pfaction);
                }
                factionData.leader.TryGetValue(pfaction, out CurrentLeaderID);
                if (CurrentLeaderID == ID) continue;
                var CurrentLeadertime = playerData.playerFactions[CurrentLeaderID].FactionMemberTime;
                if (CurrentLeadertime < ptime)
                {
                    BasePlayer leader = BasePlayer.FindByID(CurrentLeaderID);
                    factionData.leader.Remove(pfaction);
                    factionData.leader.Add(pfaction, ID);
                    factionData.Factions[pfaction].tax = 0;
                    if (factionData.Boxes.ContainsKey(pfaction)) factionData.Boxes.Remove(pfaction);
                    if (BasePlayer.activePlayerList.Contains(leader)) SendMSG(leader, string.Format(lang.GetMessage("RemovedAsLeader", this), factionData.Factions[pfaction].Name));
                    BroadcastFaction(p, $"{factionData.Factions[pfaction].Name} + {lang.GetMessage("NewLeader", this)}");
                }
            }
            SaveData();
            timer.Once(1800, () => CheckLeaderTime());
        }

        private void CheckLeaderRank(BasePlayer player)
        {
            if (!configData.Use_FactionLeaderByRank) return;
            if (!FactionMemberCheck(player)) return;
            var pfaction = GetPlayerFaction(player);
            if (factionData.Factions[pfaction].type == FactionType.FFA) return ;
            int leaderrank = 0;
            int playerrank = Convert.ToInt32(playerData.playerFactions[player.userID].rank);
            if (factionData.leader.ContainsKey(pfaction))
            {
                var factionleader = factionData.leader[pfaction];
                if (factionleader == player.userID) return;
                leaderrank = Convert.ToInt32(playerData.playerFactions[factionleader].rank);
            }
            if (leaderrank < playerrank)
            {
                factionData.leader[pfaction] = player.userID;
                factionData.Factions[pfaction].tax = 0;
                if (factionData.Boxes.ContainsKey(pfaction)) factionData.Boxes.Remove(pfaction);
                if (factionData.ActiveChallenges.ContainsValue(pfaction))
                {
                    foreach (var entry in factionData.ActiveChallenges.Where(kvp => kvp.Value == pfaction).ToList())
                    {
                        factionData.ActiveChallenges.Remove(entry.Key);
                        var Challenger = BasePlayer.FindByID(entry.Key);
                        BroadcastFaction(player, lang.GetMessage("LeaderChangedChallengeDone", this));

                    }
                }
                BroadcastFaction(player, $"{player.displayName} is the new Leader!");
                SaveData();
            }
        }

        private void FactionDamage(BasePlayer player)
        {
            var playerfaction = GetPlayerFaction(player);
            var factionleaderID = factionData.leader[playerfaction];
            BasePlayer factionleader = BasePlayer.FindByID(factionleaderID);
            if (!playerData.playerFactions[player.userID].ChallengeStatus)
            {
                playerData.playerFactions[player.userID].ChallengeStatus = true;
                if (factionData.leader.ContainsValue(player.userID))
                {
                    SendMSG(player, lang.GetMessage("FactionDamageEnabledLeader", this));
                    return;
                }
                else SendMSG(player, string.Format(lang.GetMessage("FactionDamageEnabledChallenger", this), factionleader.displayName));
                return;
            }
            if (playerData.playerFactions[player.userID].ChallengeStatus)
            {
                playerData.playerFactions[player.userID].ChallengeStatus = false;
                SendMSG(player, lang.GetMessage("FactionDamageDisabled", this));
            }
        }

        private int Count(ushort faction)
        {
            int count = 0;
            foreach (var player in playerData.playerFactions)
            {
                if (playerData.playerFactions[player.Key].faction == faction) count++;
            }
            return count;
        }

        #endregion

        #region Externally Called Functions

        string GetPlayerFactionEx(ulong playerID)

        {
            foreach (var entry in playerData.playerFactions)
                if (entry.Key == playerID)
                    return entry.Value.faction.ToString();
            return null;
        }

        bool CheckSameFaction(ulong player1ID, ulong player2ID)
        {
            if (ActiveCSZone)
            {
                if (isCSPlayer(BasePlayer.FindByID(player1ID)) || isCSPlayer(BasePlayer.FindByID(player2ID))) return false;
            }
            if (!playerData.playerFactions.ContainsKey(player1ID) || !playerData.playerFactions.ContainsKey(player2ID)) return false;
            var player1faction = playerData.playerFactions[player1ID].faction;
            var player2faction = playerData.playerFactions[player2ID].faction;
            if (player1faction == default(ushort) || player2faction == default(ushort)) return false;
            if (factionData.Factions[player1faction].type == FactionType.FFA) return false;
            if (factionData.Factions[player2faction].type == FactionType.FFA) return false;
            if (player1faction == player2faction)
            {
                foreach (var entry in factionData.Factions)
                {
                    if (entry.Key == player1faction)
                        return true;
                }
                return false;
            }
            else return false;

        }
        bool isCSPlayer(BasePlayer player)
        {
            try
            {
                bool result = (bool)ActiveCSZone?.Call("isCSPlayer", player);
                return result;
            }
            catch
            {
                return false;
            }
        }

        private object GetKits() => Kits?.Call("GetAllKits");

        public string[] GetKitNames()
        {
            var kits = GetKits();
            if (kits != null)
            {
                if (kits is string[])
                {
                    var array = kits as string[];
                    return array;
                }
            }
            return null;
        }

        private void CloseMap(BasePlayer player)
        {
            if (LustyMap)
            {
                LustyMap.Call("disableMap", player);
            }
        }
        private void OpenMap(BasePlayer player)
        {
            if (LustyMap)
            {
                LustyMap.Call("enableMap", player);
            }
        }

        #endregion

        #region Giving Items
        private void GiveFactionKit(BasePlayer player, ushort faction)
        {
            if (!configData.Use_Kits) return;
            object isKit = Kits?.Call("isKit", new object[] { factionData.Factions[faction].kit });
            if (isKit is bool)
                if ((bool)isKit)
                {
                    Kits?.Call("GiveKit", player, factionData.Factions[faction].kit);
                    return;
                }
            Puts($"{factionData.Factions[faction].kit} {lang.GetMessage("NotAValidKit", this)}");
        }
        #endregion

        #region Classes

        class FactionSavedPlayerData
        {
            public Dictionary<ulong, FactionPlayerData> playerFactions = new Dictionary<ulong, FactionPlayerData>();
        }
        class FactionPlayerData
        {
            public ushort faction;
            public string Name;
            public Rank rank;
            public int level;
            public Trade trade;
            public long LastConnection;
            public int FactionMemberTime;
            public bool ChallengeStatus;
            public int time;
            public int FactionBuildings;
            public int TotalBuildings;
            public int Kills = 0;
            public int Gathered;
            public int Crafted;
            public List<EquipmentKits> AvailableKits { get; set; }
            public string LastKit;
            public ushort LastFaction;
            public bool SavedInventory;
            public List<AutoTurret> factionTurrets {get; set;}
        }

        class PlayerSavedInventories
        {
            public Dictionary<ulong, List<PlayerInv>> PlayerInventory = new Dictionary<ulong, List<PlayerInv>>();
            public Dictionary<ulong, List<PlayerInv>> PreviousInventory = new Dictionary<ulong, List<PlayerInv>>();
        }

        class FactionStatistics
        {
            public Dictionary<ushort, Faction> Factions = new Dictionary<ushort, Faction>();
            public Dictionary<ushort, ulong> leader = new Dictionary<ushort, ulong>();
            public Dictionary<ushort, Coords> Boxes = new Dictionary<ushort, Coords>();
            public Dictionary<ushort, Coords> FactionSpawns = new Dictionary<ushort, Coords>();
            public Dictionary<ushort, Coords> RallySpawns = new Dictionary<ushort, Coords>();
            public Dictionary<ulong, ushort> ActiveChallenges = new Dictionary<ulong, ushort>();
            public Dictionary<ushort, int> Buildings = new Dictionary<ushort, int>();
        }

        class Faction
        {
            public string Name;
            public string FactionKit;
            public string UIColor;
            public string ChatColor;
            public string LeaderTitle;
            public int Kills;
            public int PlayerCount;
            public double tax;
            public string group;
            public string kit;
            public FactionType type;
            public bool FactionZone;
        }

        class target
        {
            public ulong playerID;
            public ulong executerID;
            public ushort factionID;
            public bool confirm;
            public bool assign;

        }

        class EquipmentKits
        {
            public ushort KitID;
            public string KitName;
            public ushort KitLevel;
        }

        class TradeProcessing
        {
            public ushort factionID;
            public ulong playerID;
            public ulong leaderID;
            public Trade trade;
        }

        class Monuments
        {
            public Vector3 position;
            public float radius;
        }

        class Inventory
        {
            List<PlayerInv> InvItems = new List<PlayerInv>();
        }

        class PlayerInv
        {
            public int itemid;
            public ulong skin;
            public string container;
            public int amount;
            public float condition;
            public int ammo;
            public PlayerInv[] InvContents;
        }

        class PlayerCond
        {
            public float health;
            public float calories;
            public float hydration;
        }
        
        class BattleZonePlayer
        {
            public bool oob;
            public ushort faction;
            public string bz;
            public bool entered;
            public bool died;
            public bool owner;
        }

        class FactionDesigner
        {
            public ushort ID;
            public Faction Entry;
            public Faction OldEntry;
            public int partNum = 0;
        }

        class SpawnDesigner
        {
            public ushort SpawnID;
            public string type;
            public Coords Entry;
            public Coords OldEntry;
            public int partNum = 0;
        }

        class FactionColors
        {
            public string Color;
            public string ChatColor;
            public string UIColor;
        }

        class Coords
        {
            public ushort FactionID;
            public string Name;
            public float x;
            public float y;
            public float z;
        }

        class Gear
        {
            public string shortname;
            public ulong skin;
            public int amount;
        }

        #endregion

        #region Data Management

        private List<FactionColors> Colors = new List<FactionColors>
                {
                    new FactionColors
                    {
                        Color = "red",
                        ChatColor = "<color=#e60000>",
                        UIColor = "0.91 0.0 0.0 1.0"
                    },

                    new FactionColors
                    {
                        Color = "blue",
                        ChatColor = "<color=#3366ff>",
                        UIColor = "0.2 0.4 1.0 1.0"
                    },

                    new FactionColors
                    {
                        Color = "green",
                        ChatColor = "<color=#29a329>",
                        UIColor = "0.16 0.63 0.16 1.0"
                    },

                    new FactionColors
                    {
                        Color = "yellow",
                        ChatColor = "<color=#ffff00>",
                        UIColor = "1.0 1.0 0.0 1.0"
                    },

                    new FactionColors
                    {
                        Color = "orange",
                        ChatColor = "<color=#ff9933>",
                        UIColor = "1.0 0.51 0.2 1.0"
                    },

                    new FactionColors
                    {
                        Color = "purple",
                        ChatColor = "<color=#7300e6>",
                        UIColor = "0.45 0.0 0.9 1.0"
                    },
                    new FactionColors
                    {
                        Color = "darkred",
                        ChatColor = "<color=#A93226>",
                        UIColor = "0.66 0.19 0.15 1.0"
                    },
                    new FactionColors
                    {
                        Color = "darkpurple",
                        ChatColor = "<color=#4A235A>",
                        UIColor = "0.29 0.14 0.35 1.0"
                    },
                    new FactionColors
                    {
                        Color = "darkblue",
                        ChatColor = "<color=#1F618D>",
                        UIColor = "0.12 0.38 0.55 1.0"
                    },
                    new FactionColors
                    {
                        Color = "darkgreen",
                        ChatColor = "<color=#117864>",
                        UIColor = "0.06 0.47 0.39 1.0"
                    },
                    new FactionColors
                    {
                        Color = "darkorange",
                        ChatColor = "<color=#D35400>",
                        UIColor = "0.83 0.33 0.0 1.0"
                    },
                    new FactionColors
                    {
                        Color = "darkgrey",
                        ChatColor = "<color=#626567>",
                        UIColor = "0.38 0.39 0.4 1.0"
                    },
                    new FactionColors
                    {
                        Color = "bluegrey",
                        ChatColor = "<color=#34495E>",
                        UIColor = "0.20 0.28 0.37 1.0"
                    },
                    new FactionColors
                    {
                        Color = "hotpink",
                        ChatColor = "<color=#FA0091>",
                        UIColor = "1.0 0.0 0.57 1.0"
                    },
                    new FactionColors
                    {
                        Color = "limegreen",
                        ChatColor = "<color=#3EFF00>",
                        UIColor = "0.24 1.0 0.0 1.0"
                    },
                    new FactionColors
                    {
                        Color = "teal",
                        ChatColor = "<color=#00E0B8>",
                        UIColor = "0.0 0.88 0.72 1.0"
                    }
                };

        private Dictionary<ushort, Faction> defaultFactions = new Dictionary<ushort, Faction>
                {
                    {1254, new Faction
                    {
                    Name = "Faction A",
                        LeaderTitle = "Leader",
                        ChatColor = "<color=#7300e6>",
                        UIColor = "0.45 0.0 0.9 1.0",
                        type = FactionType.Regular
                    }
                    },

                    { 1241, new Faction
                    {
                    Name = "Faction B",
                        LeaderTitle = "Leader",
                        ChatColor = "<color=#ff9933>",
                        UIColor = "1.0 0.51 0.2 1.0",
                        type = FactionType.Regular
                    }
                    },

                    { 1287, new Faction
                    {
                    Name = "Faction C",
                        LeaderTitle = "Leader",
                        ChatColor = "<color=#29a329>",
                        UIColor = "0.16 0.63 0.16 1.0",
                        type = FactionType.Regular
                    }
                    },

                { 2872, new Faction
                    {
                    Name = "Rebels",
                        LeaderTitle = "None",
                        ChatColor = "<color=#85adad>",
                        UIColor = "0.52 0.68 0.68 1.0",
                        type = FactionType.FFA
                    }

            }
        };


        private Dictionary<string, List<Gear>> BZItems = new Dictionary<string, List<Gear>>
                {
                    {"owner", new List<Gear>
                    {
                        new Gear
                        {
                        shortname = "hammer",
                        amount = 1,
                        skin = 0,
                        },
                        new Gear
                        {
                        shortname = "building.planner",
                        amount = 1,
                        skin = 0,
                        },
                        new Gear
                        {
                        shortname = "autoturret",
                        amount = 2,
                        skin = 0,
                        },
                        new Gear
                        {
                        shortname = "door.hinged.toptier",
                        amount = 4,
                        skin = 0,
                        },
                        new Gear
                        {
                        shortname = "lock.code",
                        amount = 4,
                        skin = 0,
                        },
                        new Gear
                        {
                        shortname = "stones",
                        amount = 20000,
                        skin = 0,
                        },
                        new Gear
                        {
                        shortname = "wood",
                        amount = 7500,
                        skin = 0,
                        }
                    }
                    },
                    //  {"defender", new List<Gear>
                    //{
                    //    new Gear
                    //    {
                    //    shortname = "Leader",
                    //    amount = 1,
                    //    skin = 1111,
                    //    }
                    //  }

                    //},
                      {"attacker", new List<Gear>
                    {
                        new Gear
                        {
                        shortname = "explosive.timed",
                        amount = 2,
                        skin = 0,
                        },
                        new Gear
                        {
                        shortname = "rocket.launcher",
                        amount = 1,
                        skin = 0,
                        },
                        new Gear
                        {
                        shortname = "ammo.rocket.basic",
                        amount = 4,
                        skin = 0,
                        }
                      }

                    }
                };



        private void SaveLoop()
        {
            SaveData();
            timer.Once(configData.Save_Interval * 60, () => SaveLoop());
        }

        private void InfoLoop()
        {
            if (!configData.Use_FactionsInfo) return;
            SendPuts(lang.GetMessage("FactionsInfo", this));
            timer.Once(900, () => InfoLoop());
        }

        void SaveData()
        {
            PlayerData.WriteObject(playerData);
            InvData.WriteObject(invData);
            FactionData.WriteObject(factionData);
        }

        void LoadData()
        {
            try
            {
                playerData = PlayerData.ReadObject<FactionSavedPlayerData>();
            }
            catch
            {

                Puts("Couldn't load player data, creating new datafile");
                playerData = new FactionSavedPlayerData();
            }
            try
            {
                invData = InvData.ReadObject<PlayerSavedInventories>();
            }
            catch
            {

                Puts("Couldn't load inventory data, creating new datafile");
                invData = new PlayerSavedInventories();
            }
            try
            {
                factionData = FactionData.ReadObject<FactionStatistics>();
            }
            catch
            {
                Puts("Couldn't load FactionBattleZones data, creating new datafile");
                factionData = new FactionStatistics();
            }
            if (factionData.Factions == null || factionData.Factions.Count == 0)
                LoadDefaultData();
        }

        void LoadDefaultData()
        {
            factionData.Factions = defaultFactions;
            SaveData();
        }
        #endregion

        #region Config        
        private ConfigData configData;
        class ConfigData
        {
            //--------//General Settings//--------//
            public int Save_Interval { get; set; }
            public bool Use_FactionsInfo { get; set; }
            public float ZoneRadius { get; set; }

            //--------//Chat Settings//--------//
            public string MSG_MainColor { get; set; }
            public string MSG_Color { get; set; }
            public bool BroadcastDeath { get; set; }
            public bool Use_FactionNamesonChat { get; set; }
            public bool Use_FactionChatControl { get; set; }
            public bool Use_ChatTitles { get; set; }

            //--------//Faction Settings//--------//

            ////////////////////////////
            //Faction Option Settings//
            ///////////////////////////

            public bool Use_Kits { get; set; }
            public bool Use_Taxes { get; set; }
            public bool Use_Groups { get; set; }
            public bool Use_PersistantSpawns { get; set; }
            public int SpawnCountLimit { get; set; }
            public int SpawnCooldown { get; set; }
            public bool Use_RallySpawns { get; set; }
            public bool Use_FactionSpawns { get; set; }
            public bool Use_BattleZones { get; set; }
            public int BattleZonesCooldown { get; set; }
            public int RequiredBZParticipants { get; set; }
            public int BZPrepTime { get; set; }
            public bool Use_FactionSafeZones { get; set; }


            public bool Use_FactionsByInvite { get; set; }
            public bool AllowPlayerToLeaveFactions { get; set; }

            public bool Use_RevoltChallenge { get; set; }
            public bool Use_FactionBalancing { get; set; }
            public int AllowedFactionDifference { get; set; }
            public bool FFDisabled { get; set; }
            public bool BuildingProtectionEnabled { get; set; }
            public float FF_DamageScale { get; set; }

            /////////////////////////////
            //Faction  Specific Options//
            /////////////////////////////

            public string StarterKit { get; set; }

            //////////////////
            //Trades & Ranks//
            //////////////////
            public bool Use_Ranks { get; set; }
            public bool Use_Trades { get; set; }
            public bool AllowTradesByPlayer { get; set; }
            public float RankBonus { get; set; }
            public double LevelBonus { get; set; }
            public int TradeLimit { get; set; }
            public int LevelRequirement { get; set; }
            public int RankRequirement { get; set; }
            public int MaxLevel { get; set; }
            public bool Use_AutoAuthorization { get; set; }


            /////////////////////
            //Faction Buildings//
            /////////////////////


            //--------//Game Modes//--------//

            ///////////////
            //Kill Ticker//
            //////////////
            public bool Use_FactionKillIncentives { get; set; }
            public int KillLimit { get; set; }


            //--------//Leader Modes//--------//

            /////////
            //Time//
            ////////
            public bool Use_FactionLeaderByTime { get; set; }

            /////////
            //Admin//
            ////////
            public bool Use_FactionLeaderByAdmin { get; set; }


            /////////
            //Rank//
            ////////
            public bool Use_FactionLeaderByRank { get; set; }


            ////////////////////
            //FactionZones Mode//
            ////////////////////
            public bool Use_FactionZones { get; set; }

            ///////////////////
            //Reward Settings//
            ///////////////////

            public bool Use_EconomicsReward { get; set; }
            public int KillAmountEconomics { get; set; }
            public int FactionKillsRewardEconomics { get; set; }
            public int BattleZoneRewardEconomics { get; set; }

            public bool Use_TokensReward { get; set; }
            public int KillAmountTokens { get; set; }
            public int FactionKillsRewardTokens { get; set; }
            public int BattleZoneRewardTokens { get; set; }

            public bool Use_ServerRewardsReward { get; set; }
            public int KillAmountServerRewards { get; set; }
            public int FactionKillsRewardServerRewards { get; set; }
            public int BattleZoneRewardServerRewards { get; set; }
        }
        private void LoadVariables()
        {
            UseFactions = true;
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                MSG_MainColor = "<color=orange>",
                MSG_Color = "<color=#A9A9A9>",
                BroadcastDeath = true,
                Use_EconomicsReward = false,
                KillAmountEconomics = 100,
                FactionKillsRewardEconomics = 500,
                BattleZoneRewardEconomics = 500,
                Use_TokensReward = false,
                KillAmountTokens = 10,
                FactionKillsRewardTokens = 50,
                BattleZoneRewardTokens = 50,
                Use_ServerRewardsReward = false,
                KillAmountServerRewards = 10,
                FactionKillsRewardServerRewards = 50,
                BattleZoneRewardServerRewards = 50,
                RankBonus = 25f,
                LevelBonus = 10,
                TradeLimit = 2,
                LevelRequirement = 5000,
                RankRequirement = 1,
                MaxLevel = 20,
                SpawnCooldown = 30,
                SpawnCountLimit = 4,
                Use_PersistantSpawns = false,
                AllowTradesByPlayer = false,
                AllowPlayerToLeaveFactions = false,
                ZoneRadius = 80f,
                Use_FactionZones = false,
                Use_BattleZones = false,
                BattleZonesCooldown = 60,
                Use_AutoAuthorization = false,
                RequiredBZParticipants = 2,
                BZPrepTime = 10,


                StarterKit = "StarterKit",

                FFDisabled = true,
                BuildingProtectionEnabled = true,

                FF_DamageScale = 0.0f,
                Use_FactionChatControl = true,
                Save_Interval = 15,
                Use_Ranks = false,
                Use_Trades = false,
                Use_Taxes = false,
                Use_Groups = false,
                Use_RallySpawns = false,
                Use_FactionSpawns = false,
                Use_FactionsInfo = true,
                Use_RevoltChallenge = false,
                Use_FactionsByInvite = false,
                Use_FactionLeaderByAdmin = false,
                Use_Kits = false,
                AllowedFactionDifference = 5,
                Use_FactionKillIncentives = false,
                Use_FactionLeaderByRank = false,
                Use_FactionLeaderByTime = false,
                Use_FactionBalancing = false,
                KillLimit = 200,
                Use_FactionNamesonChat = true,
                Use_ChatTitles = true,
                Use_FactionSafeZones = false,
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Messages
        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"title", "Factions: " },
            {"FactionsInfo", "This server is running Factions(type /faction or Press 'N')."},
            {"FFBuildings", "This is a friendly structure owned by {0}! You must be authorized on a nearby Tool Cupboard to damage it!"},
            {"FFs", "{0} is on your faction!"},
            {"Payment", "You have received {0} {1} for that kill!" },
            {"FactionUnassignFormating", "Format: faction.unassign <PARTIAL_PLAYERNAME>"},
            {"PlayerReturns", "{0} has returned!"},
            {"PlayerLeft", "{0} has left!"},
            {"PlayerNew", "{0} has joined the fight!"},
            {"UnassignSuccess", "{0} has been successfully removed from {1}."},
            {"RemovedFromFaction", "You have been removed from {0}."},
            {"UnassignError", "There was an error unassigning the faction"},
            {"multiPlayers", "Multiple players found with that name" },
            {"NoPlayers", "No players found" },
            {"NoFactionError", "You are not a faction member"},
            {"NotAuth", "You do not have permission to use this command."},
            {"DeathMessage", " has killed " },
            {"inFactionChat", "[FACTIONCHAT]" },
            {"FactionSelectionTitle", "Which Faction would you like to join?" },
            {"MembersGUI", "Members" },
            {"Close", "Close" },
            {"Next", "Next" },
            {"Previous", "Previous" },
            {"Information", "Factions Information" },
            {"FactionPlayerInfo", "The Factions Mod enables players to have a different experience in Rust then what is normally expected.\nThis particular server has (3) Factions named Albion, Midgard, and Hibernia. Each Faction has a Leader which can set a Tax on the members.\nThe Leader can also set Spawn Points which can be used by members of the Faction every 15 minutes from within the Player Commands Menu or on respawn.\n\nYou can become the Leader by killing members of the other Faction.\nAs you kill you will increase in Rank. If you have the highest Rank in the Faction, you will become the Leader.\n\nYou can also select one of four professions which provide a bonus to harvesting resources.\nAs you harvest these skills increase in level giving higher and higher bonuses.\n\nEnjoy!" },
            {"ScoreBoard", "ScoreBoard" },
            {"PlayerCommands", "<b><i>Player Commands</i></b>" },
            {"LeaderCommands", "<b><i>Leader Commands</i></b>" },
            {"AdminCommands", "<b><i>Admin Commands</i></b>" },
            {"Options", "Options" },
            {"Joined", "has joined" },
            {"PlayerStructureFailed","You can not build a zone within the radius of a player structure. Move further away and try again!" },
            {"MonumentFailed", "You can not build a zone within the radius of a monument. Move further away and try again!" },
            { "BZJoin", "has joined the BattleZone created by " },
            {"LeftTheFaction", "{0} has left the Faction! If they knew your code locks you should change them!" },
            {"NewLeader", " has a new leader!!" },
            {"TaxBoxActivated", "You have activated Tax Box Selection Mode. Please open a Large Wooden Box or Wooden Box to make it a Faction Tax Box. You can deactivate this mode by 'Pressing the Button Again'" },
            {"TaxBoxDeActivated", "You have Deactivated Tax Box Selection Mode." },
            {"NewTaxBox", "You have activated a new Tax Box. Set a tax to start collecting!." },
            {"TaxBoxRemoved", "The Faction Tax Box has been removed!" },
            {"TaxBoxError", "A Tax Box must be a Large Wooden Box or Wooden Box." },
            {"TaxBoxOwnerError", "The Tax Box must be owned by yourself or a Faction Member." },
            {"TaxBox", "This is your Tax Box." },
            {"TaxBoxFull", "Your Tax Box is Full. Remove items or designate a new one to continue collecting." },
            {"FactionChat1"," - Sends the message to other Faction Members ONLY" },
            {"FactionChat", "/fc <message>" },
            {"NewFactionSpawn", "Attention: A new Faction Spawn has been created for your faction!" },
            {"FactionSpawnRemoved", "Attention: The {0} Spawn: {1} has been removed." },
            {"NewRallySpawn", "Attention: A new Rally Spawn has been created for your faction!" },
            {"RallySpawnRemoved", "Attention: The Rally Spawn has been removed." },
            {"ChallengerLost", "{0} challenged the faction leader and lost. {0} has been removed from the faction." },
            {"LeaderLost", "{0} challenged the faction leader and won!"},
            {"ChallengeActivated", "You have succesfully challenged the faction leader. In 15 minutes you will be able to attack and raid the leader. Losing this challenge will remove you from the faction." },
            {"ChallengeToLeader", "You have been challenged for your leadership by {0}. In 15 minutes you will be able to attack and raid {0}." },
            {"CurrentChallengePlayer", "You can not challenge the leader because {0} has an active challange." },
            {"ChallengeFactionLeaderOffline", "The leader is not currently online. You can not challenge an offline leader."},
            {"FactionDamageEnabledLeader", "The Challenge has begun. Friendly fire between between yourself and the challenger has been enabled." },
            {"FactionDamageEnabledChallenger", "The Challenge has begun. Friendly fire between yourself and your leader {1} has been enabled." },
            {"FactionDamageDisabled", "The Challenge has ended. Friendly fire is once again disabled." },
            {"newassignedleader", "has become the new Faction Leader of" },
            {"TaxBoxDestroyed", "Your Tax Box has been destroyed!" },
            {"FactionToFull", "This Faction can not accept new players at this time because it has to many players compared to the other Factions." },
            {"TargetNotInFaction", "{0} is not in a faction!" },
            {"LeaderTradeRemoved", "Trade: {1} has been removed from {0}"},
            {"PlayerTradeRemoved", "You are no longer a {0}"},
            {"PlayerTradeSuccess", "You are now a {0}"},
            {"LeaderTradeSuccess", "{0} has been added to Trade: {1}" },
            {"ChallengeLostRank", "Your Rank has been set back to Recruit!" },
            {"ChallengeLostTime", "Your FactionTime has been set back to 0" },
            {"ChallengeLostLeader", "You are no longer the leader of the Faction!!" },
            {"ChallengeNewLeader", "{0} has defeated {1} and become the new Leader!" },
            {"FactionKillTotals", "Faction Kill Totals" },
            {"KillLimitReached", "{0} has reached the Kill Limit! CONGRATULATIONS!!!" },
            {"KillTickerReset",  "The Kill Ticker will reset in 5 minutes!" },
            {"KillLimitReward",  "Each Player on the winning Faction received {0}" },
            {"NewSpawnAdmin", "You have successfully created a new Faction Spawn." },
            {"RemovedSpawnAdmin", "You have successfully removed a Faction Spawn." },
            {"LeaderChangedChallengeDone", "The Leader has changed. If you were in an Leader Challenge, it has been terminated." },
            {"RemovedAsLeader", "You have been removed as the Leader of {0}. If you had a Tax Box it has been disabled!" },
            {"NotAValidKit", "is not a valid kit! Please check the Faction Kit Configuration." },
            {"FactionLists", "Faction Lists" },
            { "Immune", "You have recently left a BattleZone and have been granted immunity from attacking or being attacked. This will last 10 minutes. Take this time to get to safety."},
            { "LeaderDeathWinner", "You helped successfully kill the Leader. You have been given {1) {0}"},
            { "TimeLimitWinner", "You helped successfully defend the Leader. You have been given {1) {0}"},
            { "EnemiesDeadWinner", "You helped successfully kill all enemies while protecting the Leader. You have been given {1) {0}"},
            { "ImmunityGone", "You are no longer immune to attacking or being attacked"},
            {"CurrentlyImmuneAttacker", "You or your target are currently immune from combat." },
            {"CurrentlyImmuneVictim", "You or your attacker are currently immune from combat." },
            { "VictimNotinBZ", "You can not attack a player outside of a BattleZone while you are in one."},
            { "AttackerNotinBZ", "You can not attack a player inside a BattleZone if you are not in one."},
            {"CreatorFactionName", "Faction Name Set to {0}"},
            {"CreatorLeaderTitle", "Faction Leader Title Set to {0}"},
            {"CreatorFactionKit", "Faction Kit Set to {0}"},
            {"CreatorFactionGroup", "Faction Group Set to {0}"},
            {"ActiveSpawnCooldown", "Unable to use Spawn as you are on a Cooldown!" },
            {"ToManySpawns", "Unable to add a new spawn! Your spawn count exceeds the limit of {0}" },
            {"SpawnManagement", "Spawn Management" },
            {"ZoneManagement", "Zone Management" },
            {"FactionManagement", "Faction Management" },
            {"PlayerManagement", "Player Management" },
            {"LeaderManagement", "Leader Management" },   
            {"ExitedFactionDeletion", "Faction deletion has been canceled!" },
            {"FactionDeleted", "has been removed! All players in the Faction were removed." },
            {"QuitFactionCreation", "You have successfully quit Faction Creation." },
            {"NewFactionCreated", "You have successfully saved the Faction: {0}" },
            {"QuitFactionEditor", "You have successfully quit Faction Editor." },
            {"FactionEditor", "Faction Editor" },
            {"FactionInviteScreen", "Faction Player Invite Menu\n Players shown below are not currently in a Faction." },
            {"RejectedInviteToLeader", "{0} has rejected your Faction Invite!" },
            {"RejectedInvite", "You have rejected the Faction Invite." },
            {"UnassignPlayers", "Player Unassignment Menu" },
            {"ConfirmKick", "Are you sure you want to kick this player from the faction?" },
            {"KickSuccessful", "You have successfully kicked {0} from {1}!" },
            {"KickCanceled", "The kick has been canceled!" },
            {"TradeManagement", "Trade Manager" },
            {"PlayerTradeSelection", "Please Selection a Trade" },
            {"AdminMSGRemovedLeader", "{0} has been successfully removed as Leader of {1}" },
            {"AdminMSGAssignedLeader", "{0} has been successfully promoted to Leader of {1}" },
            {"Rally Spawns", "Rally Spawns" },
            {"Faction Spawns", "Faction Spawns" },
            {"TaxRequestMessage", "Please select the number you would like to set the Faction Tax at"},
            {"NewTax", "You have set a new tax of {0}%." },
            {"PlayerTradeFull", "Unable to become a {0} becuase the trade is full. " },
            {"AssignTrades", "Assign Trades" },
            {"ServerRewardsRewardInfo", "This setting controls the Kill Incentives 'Victory' Reward and Other Faction Kills. Setting this as 'TRUE' makes it so players received a Server Reward Points Reward for each kill. On Kill Limit reached, it also gives each player on the winning Faction a reward in the form of Server Reward Points. This setting requires the Plugin ServerRewards. The amount of points given per kill 'KillAmountServerRewards' and for Kill limit 'FactionKillsRewardServerRewards' are configured in the Config File." },
            {"ServerRewardsRewardTitle", "Server Rewards Reward Setting" },
            {"OptionChangeMSG", "Do you want to change this setting to: {0}" },
            {"OptionChangeTitle", "{0} is currently set to: {1}" },
            {"TRUE", "<color=#005800>TRUE</color>" },
            {"FALSE", "<color=#FF0000>FALSE</color>" },
            {"TradeSkill", "Trade Skill\n{0}" },
            {"Unassign", "<color=#e60000>Unassign</color>" },
            {"Remove", "<color=#e60000>Remove</color>" },
            {"AssignPlayer", "Assign\nPlayers to\n{0}" },
            {"UnAssignPlayer", "Unassign\nPlayers from\n{0}" },
            {"EditLeader", "Edit\n{0}\n{1}" },
            {"Assign", "Assign" },
            {"Kick", "Kick" },
            {"Invite", "Invite" },
            {"FactionSelection", "Faction Selection" },
            {"Back", "Back" },
            {"PLAYERS", "PLAYERS" },
            {"DeleteFaction", "Delete\n{0}" },
            {"CreateFaction", "Create New Faction" },
            {"EditFaction", "Edit\n{0}" },
            {"AssignTradeSkill", "Assign\n{0}" },
            {"UnassignTradeSkill", "Unassign\n{0}" },
            {"AssignPlayerTradeSkill", "Assign\n{1} as\n{0}" },
            {"UnassignPlayerTradeSkill", "Unassign\n{1} as\n{0}" },
            {"FFA", "A Free for All Faction. No Leader, No Trade Skills, No Protecton." },
            {"Normal", "A Standard Faction with FF Disabled and Building Protection."},
            {"NormalNoBuildingProtection", "A Standard Faction with FF Enabled and Building Protection Disabled."},
            {"NormalFFEnabled", "A Standard Faction with FF Enabled and Building Protection Enabled."},
            {"FFEnabledNoBuildingProtection", "A Standard Faction with FF Disabled and Building Protection Disabled."},
            {"OOBWarning", "You have 10 seconds to return to the arena! "},
            {"OOBRepeater", "{0} seconds remaining..." },
            {"OOBDeath", "{0} left the {1} BattleZone and paid the price." },
            {"SpawnRepeater", "{0} minutes remaining..." },
            {"NotAllowedFZone", "You are not allowed in this Faction Zone!" },
            {"NotAllowed", "You are not allowed to enter this BattleZone. You have either already entered and died or were not online when it began." },
            {"FactionZoneDestroyed", "The Faction Zone for {0} has been destroyed!" },
            {"BZButtonText","Click to Join\nthe {0}\nBattle Zone" },
            {"BZJoinDescription", "Would you like to join the Battle Zone created by {0}?\n\nBefore you decide here is some general information...\n\nJoining the Battle Zone automatically saves your entire current inventory so equip yourself for battle before clicking 'YES'. Once you join you will be teleported outside the Battle Zone. Once you enter the Battle Zone you can not leave until the event ends or you die. If you try to leave the Battle Zone before it ends you will have 10 seconds to return to the zone or you will be killed. Upon death you can not rejoin the Battle Zone, your inventory will be restored as well as health.\n\nThe objective of the Battle Zone is to kill the Leader that created it which will result in a reward. If you are a member of {0} you will want to protect your {1}. Defending your {1} will result in a victory reward.\n\nThe Battle will last 1 hour or until all possible enemies are killed or the Leader is killed.\n\nGOODLUCK!\n\n" },
            {"BattleZone", "BattleZone" },
            {"AddFZ", "Add\n{0}\nFactionZone" },
            {"RemoveFZ", "Remove\n{0}\nFactionZone" },
            {"CurrentFZ", "Your Faction already has a Zone. Delete the current one to create a new one." },
            {"CurrentBZ", "Your Faction already has a BattleZone." },
            {"EnterFactionZone", "You have entered the {0} Faction Zone" },
            {"FactionZone", "Faction Zone" },
            {"EnterBattleZone", "You have entered a BattleZone created by {0}. If you die you may not re-enter. Surviving will result in a Faction Reward." },
            {"NewBZ", "A new BattleZone has been created by {0}. In {1} minutes you will be able to join the Battle. Equip yourself in preparation as this Battle requires you bring your own equipment. However, do not worry your inventory will be restored after the Battle!" },
            {"StartedBZ", "A BattleZone is currently in progress. You can join the battle by clicking the 'Join BattleZone' button. Equip yourself in preparation as this Battle requires you bring your own equipment. However, do not worry your inventory will be restored after the Battle!"},
            {"BZStart", "A new BattleZone created by {0} is now open! You can join the battle by clicking the 'Join BattleZone' button. Equip yourself in preparation as this Battle requires you bring your own equipment. However, do not worry your inventory will be restored after the Battle!"},
            {"BZEnded", "The Battle Zone created by {0} has ended because {1}" },
            {"NoFZ", "This Faction does not have a Zone to remove!" },
            {"ChallengeLeader", "Challenge The Leader" },
            {"LeaveFaction", "Leave Your\nFaction?" },
            {"TaxBoxMode", "Toggle\nTax Box\nMode" },
            {"RemoveTaxBox", "Remove\nTax Box" },
            {"SetTax", "Set\na Faction\nTax" },
            {"Cancelled", "it was cancelled by the Admin!" },
            {"LeaderDeath", "the Leader that created the Zone died!" },
            {"Unloaded", "Factions has been unloaded and therefore the event has ended!" },
            {"TimeLimit", "the Time Limit has been reached!"},
            {"EnemiesDead", "all the opposing Faction members online have been killed!"},
            {"ChatControlTitle", "Factions Chat Control" },
            {"ChatControlInfo", "This setting controls the use of Faction colors and attributes when players send a message. This setting has no impact on the /fc chat command for private internal faction communication." },
            {"NameOnChatTitle", "Name of Faction on Chat Messages" },
            {"NameOnChatInfo", "This setting controls the addition of the Faction Name on Faction Member chat messages. For Example: [FACTIONNAME]PLAYERNAME: MSG… If this setting is set to ‘TRUE’ it will automatically set Faction Chat Control to ‘TRUE’ as it is a requirement. This can also be used with ChatTitles." },
            {"ChatTitlesTitle", "Faction Leader Titles on Chat" },
            {"ChatTitlesInfo", "This setting controls the addition of the Faction Leaders Title on each chat submission by the Leader. For Example: [LEADERTITLE]PLAYERNAME: MSG… If this setting is set to ‘TRUE’ it will automatically set Faction Chat Control to ‘TRUE’ as it is a requirement. This can also be used with Faction Name on Chat." },
            {"BroadcastDeathTitle", "Broadcast Death Messages" },
            {"BroadcastDeathInfo", "This setting controls the announcement of Faction Player deaths and kills from other Factions. If this setting is set to ‘TRUE’, on player deaths an announcement will occur in chat with color coded Faction Player names." },
            {"FactionsInfoTitle", "Factions Info Notifier" },
            {"FactionsInfoInfo", "This setting controls the periodic announcement in chat that this server is running Factions and some helpful information. The announcement is hardcoded at every 15 minutes." },
            {"KitsTitle", "Faction Kits and Starter Kit" },
            {"KitsInfo", "This setting controls the ability to assign kits to Factions as well as enables the StarterKit. If this setting is set to ‘TRUE’ it will enable the prompt to pick a kit when creating a Faction. The available kits must be created prior to starting the Faction Creation process by following the steps required by the Kits Plugin. The kit selected at that time will then be given to members of that Faction on each respawn. Having the setting as ‘TRUE’ also enables the StarterKit which also must be created using the Kits Plugin. This kit is given automatically to any player that joins the server for the first time. On server wipes this will not reset unless you delete the factions_playerdata.json in the Oxide Data Folder. The StarterKit name can be set in the Config File." },
            {"OxideGroupsTitle", "Oxide Groups" },
            {"OxideGroupsInfo", "This setting controls the ability to assign Faction players to oxide groups automatically when joining a Faction. These groups are assigned to a Faction during Faction Creation. If the group provided does not exist it will automatically be created for you and assigned to the Faction. If the Faction is deleted the group will also be deleted." },
            {"TaxesTitle", "Faction Leader Taxes" },
            {"TaxesInfo", "This setting controls the ability to set a Faction Tax imposed by the Faction Leader. This setting also controls the ability to create a Faction Tax Box which will automatically collect taxed resource upon being harvested by a Faction Member. If this setting is set to ‘TRUE’ the Faction Leader will have a button under ‘Leader Commands’ to assign a ‘New Tax Box’ ‘Remove Tax Box’ and ‘Set Faction Tax’." },
            {"TradesTitle", "Faction Trade Skills" },
            {"TradesInfo", "This setting controls the ability to have Faction Trade Skills. If this setting is set to ‘TRUE’ it will enable a ‘Trade Manager’ under ‘Leader Commands’. This manager allows the Leader to assign and remove Trade Skills from Faction Members. Having a Trade Skill gives the player increased gather rates which can get better with leveling. There is a separate setting that allows Faction Players to choose a Trade Skill on joining a Faction. There are also settings in the Config to alter the amount of resources required to level ‘LevelRequirement’, to set the maximum allowed Level ‘MaxLevel’, and the bonus in percentage gained for each level ‘LevelBonus’." },
            {"RanksTitle", "Faction Rank System" },
            {"RanksInfo", "This setting controls the ability to allow Faction Members to Rank based on killing players in other Factions. With each Rank the player increases the strength of his or her attack. If GameMode ‘FactionLeaderByRank’ is set to ‘TRUE’ this setting will also be set to ‘TRUE’ as it is a requirement. There are also settings in the Config to alter the amount of kills required to Rank ‘RankRequirement’ and the bonus strength in percentage gained for each Rank ‘RankBonus’." },
            {"AllowTradesByPlayerTitle", "Players can Select Trade Skills" },
            {"AllowTradesByPlayerInfo", "This setting controls allowing players to choose their own Trade Skills versus being assigned by the Leader. On joining a Faction the player will be able to choose a Trade Skill. If this is set to ‘TRUE’, Use_Trades will automatically be set to ‘TRUE’ as it is a requirement." },
            {"FactionsByInviteTitle", "Factions can only be joined by Invitation" },
            {"FactionsByInviteInfo", "This setting controls how players are able to join a Faction. If this setting is set to ‘TRUE’ it disables the default behavior of prompting a player to join a Faction. Instead players must be invited by the Faction Leader to join the Faction. The invite process is found within ‘Leader Commands’ by clicking ‘Invite Players’. This will present a window with all players not currently in a Faction. Clicking one of them will process a request to the player asking if they want to join the Faction. If they select ‘Yes’ they will join. This also enables the ability for Faction Leaders to ‘Kick Players’ within their Faction using the same process. " },
            {"FactionBalancingTitle", "Faction Balancing" },
            {"FactionBalancingInfo", "This setting controls Faction Balancing. If this setting is set to ‘TRUE’ it will enforce Faction Balancing based on the ‘AllowedFactionDifference’ set within the Config File. If a player tries to join a Faction that has too many players compared to the least populated Faction then they will not be allowed to join. This setting has no impact on ‘FactionsByInvite’." },
            {"FactionKillIncentivesTitle", "Factions Kill Incentives – Kill Ticker" },
            {"FactionKillIncentivesInfo", "This setting controls Faction Kill Incentives. If this setting is set to ‘TRUE’ it enables a Kill Ticker at the top of the screen for all players. It tracks the number of kills each Faction has and enforces a Kill Limit which is set in the Config File. Each time a player kills a member of a different Faction they are given a reward if one has been enabled. If a Faction reaches the Kill Limit the entire Faction is given a reward if one has been enabled. Additional settings related to this setting include: ‘EconomicsReward’ ‘TokensReward’ and ‘ServerRewardsReward’." },
            {"RallySpawnsTitle", "Rally Spawns" },
            {"RallySpawnsInfo", "This setting controls the ability for Faction Leaders to set Rally Spawns. These spawns show up as buttons on the screen on Faction player respawn. These buttons only last 30 seconds preventing abuse of the teleportation system. Upon use spawns are not available to players until they have foregone the Spawn Cooldown which is configurable in the Config File. Admins can also configure the maximum number of Rally Spawns allowed to be created by a Leader by setting the ‘SpawnCountLimit’.These spawns can also be active all the time with the same cooldown by setting ‘Persistant Spawns’ to ‘TRUE’.. see ‘Persistant Spawns’. Rally Spawns are set by the Faction Leader by clicking ‘LeaderCommands’ in the Faction Menu. " },
            {"FactionSpawnsTitle", "Faction Spawns" },
            {"FactionSpawnsInfo", "This setting controls the ability for Admins to set Faction Spawns. These spawns show up as buttons on the screen on Faction player respawn. These buttons only last 30 seconds preventing abuse of the teleportation system. Upon use spawns are not available to players until they have foregone the Spawn Cooldown which is configurable in the Config File. Admins can also configure the maximum number of Faction Spawns allowed to be created by setting the ‘SpawnCountLimit’.These spawns can also be active all the time with the same cooldown by setting ‘Persistant Spawns’ to ‘TRUE’.. see ‘Persistant Spawns’. Faction Spawns are set by the Admin by clicking ‘AdminCommands’ and selecting ‘Spawn Management’ in the Faction Menu. " },
            {"PersistantSpawnsTitle", "Persistent Spawn Buttons" },
            {"PersistantSpawnsInfo", "This setting controls whether spawns are available to players all the time or only after respawn. If this setting is set to ‘TRUE’ Faction Members will see available spawns listed under the ‘PlayerCommands’ Menu." },
            {"FFDisabledTitle", "Friendly Fire Protection" },
            {"FFDisabledInfo", "This setting controls whether Faction Members can be damaged by Friendly Fire. If this setting is set to ‘TRUE’ players within Factions will not be able to damage eachother. ‘FF_DamageScale’ can be changed in the Config File to determine how much damage is done even if Friendly Fire Protection is set to ‘TRUE’. The default setting for ‘FF_DamageScale’ is ‘0’. By default Factions configured as Type: FFA will not be subjected to this option as these Factions do not have internal protection. " },
            {"BuildingProtectionEnabledTitle", "Building Protection" },
            {"BuildingProtectionEnabledInfo", "This setting controls whether Faction Members can damage other Faction Members buildings. If this setting is set to ‘TRUE’ players within Factions will not be able to damage eachothers buildings. By default Factions configured as Type: FFA will not be subjected to this option as these Factions do not have internal protection. " },
            {"AllowPlayerToLeaveFactionsTitle", "Allow a Player to Leave the Faction" },
            {"AllowPlayerToLeaveFactionsInfo", "This setting controls whether Faction Members can leave the Faction. If this setting is set to ‘TRUE’ Faction Members will have a button within ‘PlayerCommands’ called ‘Leave Your Faction’. Clicking this button will remove the Player from the Faction and promote the Faction that they have left." },
            {"RevoltChallengeTitle", "Leader Revolt Challenge" },
            {"RevoltChallengeInfo", "This setting controls whether Faction Members can challenge the Faction Leader for leadership. If this setting is set to ‘TRUE’ and there is a Faction Leader for the Faction then Faction Members will have a button within ‘PlayerCommands’ called ‘Challenge The Leader’. Clicking this button will initiate a Challenge. During the Challenge Friendly Fire is Enabled and Building Protection is Disabled. Winning or Losing has repercussions based on other settings.. see Faction Leader Settings." },
            {"FactionZonesTitle", "Faction Zones" },
            {"FactionZonesInfo", "This setting controls whether Admins can create a Faction Zone per Faction. If this setting is  set to 'TRUE' Admins will have a button in 'Zone Management' within Admin Commands that allows them to create a Faction Zone on their current position. The radius of the Zone can be configured in the Config File by setting: ZoneRadius" },    
            {"AutoAuthorizationTitle", "Automatic Faction Authorization" },
            {"AutoAuthorizationInfo", "This setting controls whether members of the faction are automatically authorized on Faction Leader Turrets and Doors. If this setting is set to 'TRUE' when a Leader creates a Turret it will automatically add all Faction Members to the Authorization list. It will also add players as they join the Faction to active turrets. On being removed as Leader this list will NOT reset. This setting also allows Faction Members to open code locked doors without knowing the code." },
            {"BattleZonesTitle", "Faction Battle Zones" },
            {"BattleZonesInfo", "This setting controls whether Faction Leaders can create and participate in Faction Battle Zones. If this setting is set to 'TRUE' each Leader will be able to create a Battle Zone; however only one at a time. These zones require the player to bring their own gear which is saved and restored upon death. Dying will result in ejection from the zone and the inability to rejoin. The objective of the zone is for the Faction Leader to survive. On creation a zone is made around the Leader and he or she is given building materials and turrets. Losing a turret results in the Leader being given a new one. After a 15 minute preparation phase the zone is opened to everyone to join. Enemy Faction members join the zone with C4 and Rockets. If the Faction Leaders Faction can survive all possible enemies (checked every 20 minutes) or last 1 hour then they are given a reward. If any enemy is able to kill the Leader all opposing Faction Members that participated are given a reward. These zones also have a cooldown which is configurable in the Config File. " },
            {"FactionLeaderByRankTitle", "Faction Leader Selection By Rank" },
            {"FactionLeaderByRankInfo", "This setting controls how a Faction Leader is chosen. If this setting is set to ‘TRUE’ the player on each Faction with the highest Rank will become the Leader. Setting this setting to ‘TRUE’ will also set “Use_Ranks’ to ‘TRUE’ as it is a requirement. There can only be one ‘Leader By’ setting at a time and therefore any other Faction Leader Selection Setting will be set to ‘FALSE’ upon this one being set to ‘TRUE’." },
            {"FactionLeaderByTimeTitle", "Faction Leader Selection By Time" },
            {"FactionLeaderByTimeInfo", "This setting controls how a Faction Leader is chosen. If this setting is set to ‘TRUE’ the player on each Faction with the most in Faction Time will become the Leader. There can only be one ‘Leader By’ setting at a time and therefore any other Faction Leader Selection Setting will be set to ‘FALSE’ upon this one being set to ‘TRUE’." },
            {"FactionLeaderByAdminTitle", "Faction Leader Selection By Admin" },
            {"FactionLeaderByAdminInfo", "This setting controls how a Faction Leader is chosen. If this setting is set to ‘TRUE’ Leaders will only be assigned by the Admin. If ‘Leader Revolt Challenge’ is set to ‘TRUE’ Faction Members can obtain leadership by defeating the Leader in a Revolt. There can only be one ‘Leader By’ setting at a time and therefore any other Faction Leader Selection Setting will be set to ‘FALSE’ upon this one being set to ‘TRUE’." },
            {"EconomicsRewardTitle", "Economics Rewards Reward Setting" },
            {"EconomicsRewardInfo", "This setting controls the Kill Incentives 'Victory' Reward and Other Faction Kills. Setting this as 'TRUE' makes it so players received an Economics Reward for each kill. On Kill Limit reached, it also gives each player on the winning Faction a reward in the form of Economics. This setting requires the Plugin Economics. The amount of economics given per kill ‘KillAmountEconomics’ and for Kill limit ‘FactionKillsRewardEconomics’ are configured in the Config File." },
            {"FactionSafeZonesTitle", "Faction Safe Zone Setting" },
            {"FactionSafeZonesInfo", "This setting controls whether Faction Zones are restricted to only members of the given Faction. Setting this as 'TRUE' makes it so players in other Factions will be ejected from the given Faction Zone. This setting requires that Faction" },
            {"PromoteLeader", "Promote\n{0}\nas {1}" },
            {"RemoveLeader", "<color=#e60000>Remove</color>\n{0}\nas {1}" },
            {"InvitePlayer", "Invite\n{0}\nto {1}" },
            {"RemovePlayer", "<color=#e60000>Remove</color>\n{0}\nfrom {1}" },
            {"KickPlayer", "<color=#e60000>Kick</color>\n{0}\nfrom {1}" },
            {"InvitePlayers", "Invite\nPlayers to\n{0}" },
            {"KickPlayers", "Kick\nPlayers from\n{0}" },
            {"CreateBZ", "Create\n{0}\nBattle Zone" },
            {"DestroyBZ", "Destroy\n{0}\nBattle Zone" },
            {"CreateFactionSpawn", "Create\n{0}\nFaction Spawn" },
            {"CreateRallySpawn", "Create\nRally Spawn" },
            {"RemoveFactionSpawn", "Remove\n{1}\nSpawn: {0}" },
            {"RemoveRallySpawn", "Remove\nRally Spawn\n{0}" },
            {"NoJoin", "Do Not Join" }
        };
        #endregion
    }
}

// --- End of file: Factions.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/floating-items ---
// --- Original File Path: F/FloatingItems/FloatingItems.cs ---

using Oxide.Core;
using System.Collections.Generic;
using System.Linq;
using System;
using Oxide.Core.Libraries;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("FloatingItems", "Diametric", "1.0.1")]
    [Description("Adds buoyancy to items dropped, causing them to float in water")]
    class FloatingItems : RustPlugin
    {
        class ItemFloater : MonoBehaviour
        {
            public BaseEntity entity;
            public float buoyancyScale;
            public int waterDetectionRate;

            private void AddBuoyancyComponent()
            {
                Buoyancy buoyancy = GetComponent<Buoyancy>();

                if (buoyancy != null)
                {
                    if (buoyancy.rigidBody == null)
                    {
                        buoyancy.rigidBody = entity.gameObject.GetComponent<Rigidbody>();
                    }
                }
                else
                {
                    buoyancy = entity.gameObject.AddComponent<Buoyancy>();
                    buoyancy.rigidBody = entity.gameObject.GetComponent<Rigidbody>();
                }

                // Sets the velocity/angularVelocity to 0 so thrown items
                // don't go pond skipping like crazy.
                buoyancy.rigidBody.velocity = Vector3.zero;
                buoyancy.rigidBody.angularVelocity = Vector3.zero;

                buoyancy.buoyancyScale = buoyancyScale;
            }

            void FixedUpdate()
            {
                if (UnityEngine.Time.frameCount % waterDetectionRate == 0)
                {
                    if (WaterLevel.Factor(entity.WorldSpaceBounds().ToBounds()) > 0.65f)
                    {
                        try
                        {
                            AddBuoyancyComponent();
                        }
                        finally
                        {
                            Destroy(this);
                        }
                    }
                }
            }
        }

        private void AddFloaterComponent(BaseEntity entity, float buoyancyScale)
        {
            // Bail here so we're not allocating too much trash in the hook.
            if (buoyancyScale < 0)
                return;

            ItemFloater floater = entity.gameObject.AddComponent<ItemFloater>();
            floater.buoyancyScale = buoyancyScale;
            floater.entity = entity;
            floater.waterDetectionRate = config.waterDetectionRate;
        }

        #region Hooks

        void OnItemDropped(Item item, BaseEntity entity)
        {
                if (item?.info == null)
                    return;

                if (entity == null)
                    return;

                object val;
                if (config.ItemBuoyancy.TryGetValue(item.info.shortname.ToLower(), out val) || config.CategoryBuoyancy.TryGetValue(item.info.category.ToString().ToLower(), out val))
                {
                    try
                    {
                        AddFloaterComponent(entity, Convert.ToSingle(val));
                    }
                    catch (FormatException)
                    {
                        PrintWarning($"Invalid configuration for {item.info.shortname}, item buoyancy values must be floats.");
                    }
                }
                else
                {
                    AddFloaterComponent(entity, config.globalBuoyancy);
                }
        }

        #endregion
        #region Configuration

        private class FloatingItemsConfig
        {
            public int waterDetectionRate = 5;
            public float globalBuoyancy = -1f;
            public Dictionary<string, object> ItemBuoyancy = new Dictionary<string, object>
            {
                {"stones",      0f},
                {"crude.oil",   0.6f},
                {"waterjug",    0.6f},
                {"bow.hunting", 0.5f}
            };

            public Dictionary<string, object> CategoryBuoyancy = new Dictionary<string, object>
            {
                {"weapon", 0.8f}
            };

            private FloatingItems plugin;

            public FloatingItemsConfig(FloatingItems plugin)
            {
                this.plugin = plugin;

                GetConfig(ref ItemBuoyancy, "Item Buoyancy");
                GetConfig(ref CategoryBuoyancy, "Category Buoyancy");
                GetConfig(ref globalBuoyancy, "Global Buoyancy");
                GetConfig(ref waterDetectionRate, "Water Detection Rate");
                plugin.SaveConfig();
            }

            private void GetConfig<T>(ref T variable, params string[] path)
            {
                if (path.Length == 0)
                    return;

                if (plugin.Config.Get(path) == null)
                {
                    SetConfig(ref variable, path);
                    plugin.PrintWarning($"Added field to config: {string.Join("/", path)}");
                }

                variable = (T)Convert.ChangeType(plugin.Config.Get(path), typeof(T));
            }

            private void SetConfig<T>(ref T variable, params string[] path) => plugin.Config.Set(path.Concat(new object[] { variable }).ToArray());
        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new configuration file.");

        private FloatingItemsConfig config;

        private void Init()
        {
            config = new FloatingItemsConfig(this);
        }

        #endregion
    }
}


// --- End of file: FloatingItems.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/feed-food ---
// --- Original File Path: F/FeedFood/FeedFood.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Feed Food", "Lorddy", "0.0.1")]
    [Description("Feeds dropped food to players you're looking at")]
    public class FeedFood : RustPlugin
    {
        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Fed"] = "You fed {0} a {1}",
                ["CannotConsume"] = "Feeding target can't consume anymore"

            }, this); ;
        }
        #endregion Localization

        #region Initialization
        private const string PERMISSION_FEEDER = "feedfood.feeder";
        private const string PERMISSION_AFFECT = "feedfood.affect";
        private void Init()
        {
            permission.RegisterPermission(PERMISSION_FEEDER, this);
            permission.RegisterPermission(PERMISSION_AFFECT, this);
        }

        #endregion Initialization

        #region Oxide Hooks
        void OnItemDropped(Item item, BaseEntity entity)
        {
            if (item == null || entity == null) return;
            var player = item.GetOwnerPlayer();
            if (player == null) return;
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_FEEDER)) return;
            BasePlayer target = RelationshipManager.GetLookingAtPlayer(player);
            if (target == null || target.userID == player.userID) return;
            if (target.IsNpc) return;
            if (!permission.UserHasPermission(target.UserIDString, PERMISSION_AFFECT)) return;
            ItemModConsume component = item.info.GetComponent<ItemModConsume>();
            if (!(component == null))
            {
                if(component.CanDoAction(item, target))
                {
                    component.DoAction(item, target);
                    Message(player.IPlayer, "Fed", target.displayName, item.info.displayName.english);
                }
                else
                {
                    Message(player.IPlayer, "CannotConsume");
                }
               
                return;
            }
        }
        #endregion

        #region Core Methods

        #endregion Core Methods

        #region Helpers

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string textOrLang, params object[] args)
        {
            if (player.IsConnected)
            {
                string message = GetLang(textOrLang, player.Id, args);
                player.Reply(message != textOrLang ? message : textOrLang);
            }
        }
        #endregion Helpers
    }
}



// --- End of file: FeedFood.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/fps-override ---
// --- Original File Path: F/FpsOverride/FpsOverride.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Fps Override", "MJSU", "0.0.1")]
    [Description("Overrides the server target fps")]
    internal class FpsOverride : RustPlugin
    {
        #region Class Fields
        private PluginConfig _pluginConfig; //Plugin Config
        #endregion

        #region Setup & Loading
        private void Init()
        {
            ConfigLoad();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        private void ConfigLoad()
        {
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Fps = config.Fps == 0 ? Application.targetFrameRate : config.Fps;
            return config;
        }

        private void OnServerInitialized()
        {
            Application.targetFrameRate = _pluginConfig.Fps;
        }
        #endregion

        #region uMod Hook
        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            string command = $"{arg.cmd.Parent}.{arg.cmd.Name}";
            if (command == "fps.limit" && arg.Args != null && arg.Args.Length != 0)
            {
                int target = arg.GetInt(0);
                if (target > 0)
                {
                    Application.targetFrameRate = target;
                    _pluginConfig.Fps = target;
                    Interface.Oxide.LogInfo($"fps.limit: \"{target}\"");
                    Config.WriteObject(_pluginConfig);
                    return true;
                }
            }
            
            return null;
        }
        #endregion

        #region Classes
        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Server Fps Target")]
            public int Fps { get; set; }
        }
        #endregion
    }
}


// --- End of file: FpsOverride.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/faux-admin ---
// --- Original File Path: F/FauxAdmin/FauxAdmin.cs ---

using Network;
using Facepunch;
using System;
using UnityEngine;
using Newtonsoft.Json;
using System.Collections;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("FauxAdmin", "Colon Blow Modified by Dracconus", "2.0.1")]
    [Description("FauxAdmin")]
    public class FauxAdmin : CovalencePlugin
    {
        // Complete rewrite of plugin
        // Remember, player must disconnect and reconnect for Fauxadmins perms to take effect if they are logged in when granted.
        // And player must disconnect and reconnect if given god mode perms while logged in as well to take effect.
        // added a env.time command for fauxadmins to use if they have perms (not default)
        // and lots more. 
        // 6.12.23 update - added command for chat /noclip
        // 2.15.25 update - Added Carbon Compatibility, and resolved NRE for NoClip functionality.

        #region Loadup

        private const string permAllowed = "fauxadmin.allowed"; // Grants player the FauxAdmin powers, that player must disconnect and reconnect to take effect.
        private const string permBypass = "fauxadmin.bypass"; // Allows specified FauxAdmin and (Blocked)Admins/Mods to noclip thru Non Auth TC's if config is enabled to Disable Globally.
        private const string permBlocked = "fauxadmin.blocked"; // Blocks specified Real Admin or Mod from using a few commands. ie..Noclip..etc.
        private const string permGodMode = "fauxadmin.allowgod"; // Allows specified FauxAdmin, Admin or Mod to Use of GodMode, even if its Disabled Globally in config.
        private const string permGodBlock = "fauxadmin.blockgod"; // Blocks specified FauxAdmin, Admin or Mod to Use of GodMode, even if its Enabled Globally in config.
        private const string permAllowTime = "fauxadmin.allowtime"; // Allows specified FauxAdmin, Admin or Mod to Use of Env.Time commands, even if its not enabled Globally in config.
        private const string permAllowKill = "fauxadmin.allowkill"; // Allows specified FauxAdmin, Admin or Mod to Use of entkill command, even if its not enabled Globally in config.
        private const string permOnlyOwn = "fauxadmin.allowown"; // Allows Fauxadmin to only noclip ONLY under Authorized TC Zones.
        private const string permTerrain = "fauxadmin.allowterrain"; // Allows Fauxadmin to only noclip under Terrain if Disabled Globally in Config.
        private const string permCanLoot = "fauxadmin.canloot"; // Allows Fauxadmin to loot things when Disabled Globally in Config.

        private void Loaded()
        {
            Unsubscribe(nameof(OnStructureDemolish));
            Unsubscribe(nameof(OnStructureRotate));
            Unsubscribe(nameof(OnStructureUpgrade));
            Unsubscribe(nameof(OnUserPermissionGranted));
            Unsubscribe(nameof(OnUserPermissionRevoked));
            Unsubscribe(nameof(CanLootEntity));

            permission.RegisterPermission(permAllowed, this);
            permission.RegisterPermission(permBypass, this);
            permission.RegisterPermission(permBlocked, this);
            permission.RegisterPermission(permGodMode, this);
            permission.RegisterPermission(permGodBlock, this);
            permission.RegisterPermission(permAllowTime, this);
            permission.RegisterPermission(permAllowKill, this);
            permission.RegisterPermission(permOnlyOwn, this);
            permission.RegisterPermission(permTerrain, this);
            permission.RegisterPermission(permCanLoot, this);

            LoadConfig();
        }

        private void OnServerInitialized()
        {
            if (config.fauxAdminSettings.DisableFauxAdminDemolish) Subscribe(nameof(OnStructureDemolish));
            if (config.fauxAdminSettings.DisableFauxAdminRotate) Subscribe(nameof(OnStructureRotate));
            if (config.fauxAdminSettings.DisableFauxAdminUpgrade) Subscribe(nameof(OnStructureUpgrade));
            if (config.fauxAdminSettings.MessageOnFauxAdminGrant) Subscribe(nameof(OnUserPermissionGranted));
            if (config.fauxAdminSettings.KickOnFauxAdminRevoke) Subscribe(nameof(OnUserPermissionRevoked));
            if (config.fauxAdminSettings.DisableLooting) Subscribe(nameof(CanLootEntity));

            ServerMgr.Instance.StartCoroutine(ProcessFuaxAdminControls());
        }

        #endregion

        #region Configuration

        private static PluginConfig config;

        private class PluginConfig
        {
            public FauxAdminSettings fauxAdminSettings { get; set; }

            public class FauxAdminSettings
            {
                [JsonProperty(PropertyName = "GodMode - Disable God Mode use for all Standard FauxAdmins (except those with fauxadmin.allowgod perms) ? (users must disconnect/reconnect to take effect) ")]
                public bool DisableGodMode { get; set; }

                [JsonProperty(PropertyName = "GodMode - Message player to disconnect/reconnect when fauxadmin.allowgod perms are granted and they are in game ? (users must disconnect/reconnect to take effect) ")]
                public bool MessageOnGodGrant { get; set; }

                [JsonProperty(PropertyName = "GodMode - Force Disconnect of player when fauxadmin.allowgod perms are revoked and they are in game ? (users must disconnect/reconnect to take effect) ")]
                public bool KickOnGodRevoke { get; set; }

                [JsonProperty(PropertyName = "Command - Env.Time - Enable Use of Env.Time Admin command to set in game time, for all FauxAdmins ? (default false) ")]
                public bool EnableEnvTime { get; set; }

                [JsonProperty(PropertyName = "Command - EntKill - Enable Simulated Use of Admin Command (ent kill) for all FauxAdmins ? (default true)  ")]
                public bool EnableEntKill { get; set; }

                [JsonProperty(PropertyName = "Command - EntKill - Only Allow FauxAdmins to entkill their OWN stuff (default true) ? ")]
                public bool EntKillOnlyOwn { get; set; }

                [JsonProperty(PropertyName = "Noclip - Disallow FauxAdmins (unless they have the 'fauxadmin.bypass' permission) from using the Noclip (flying) feature in Tool Cupboard (TC) zones where they are not authorized, which are typically owned by other players. ")]
                public bool DisableNoclipOnNoBuild { get; set; }

                [JsonProperty(PropertyName = "Noclip - Allow the FauxAdmins to use the Noclip (flying) feature exclusively within Authorized Tool Cupboard (TC) Zones, thereby preventing them from flying in all other areas. ? ")]
                public bool EnableNoclipOnBuild { get; set; }

                [JsonProperty(PropertyName = "Antihack - Terrain Kill - Allow FauxAdmin to Fly underground without Antihack killing them (if disabled, FauxAdmin must have allowterrain perm or Godmode to fly underground) ?")]
                public bool EnableUnderGround { get; set; }

                [JsonProperty(PropertyName = "Looting - Disable FauxAdmin ability to loot things (boxes, containers, corpses..etc) ?")]
                public bool DisableLooting { get; set; }

                [JsonProperty(PropertyName = "Construction - Disable FauxAdmin Ability to Demolish OTHER players building parts ? ")]
                public bool DisableFauxAdminDemolish { get; set; }

                [JsonProperty(PropertyName = "Construction - Disable FauxAdmin Ability to Rotate OTHER players building parts ? ")]
                public bool DisableFauxAdminRotate { get; set; }

                [JsonProperty(PropertyName = "Construction - Disable FauxAdmin Ability to Upgrade OTHER players building parts ? ")]
                public bool DisableFauxAdminUpgrade { get; set; }

                [JsonProperty(PropertyName = "Permissions - Grant - Message Online Player when Fauxadmin.allowed perms are granted (perms only take effect when disconnect/connect) ? ")]
                public bool MessageOnFauxAdminGrant { get; set; }

                [JsonProperty(PropertyName = "Permissions - Revoke - Disconnect Online Player when Fauxadmin.allowed perms are revoked (perms only take effect when disconnect/connect) ?")]
                public bool KickOnFauxAdminRevoke { get; set; }

                [JsonProperty(PropertyName = "Player Flag - Backend - Use (isAdmin) Instead of (isDeveloper) for FauxAdmin magic (default is dev, better compatibility with other plugins) ? ")]
                public bool UseAdminFlag { get; set; }
            }

            public static PluginConfig DefaultConfig() => new PluginConfig()
            {
                fauxAdminSettings = new PluginConfig.FauxAdminSettings
                {
                    DisableGodMode = false,
                    MessageOnGodGrant = true,
                    KickOnGodRevoke = true,
                    EnableEnvTime = false,
                    EnableEntKill = true,
                    EntKillOnlyOwn = true,
                    DisableNoclipOnNoBuild = true,
                    EnableNoclipOnBuild = false,
                    EnableUnderGround = true,
                    DisableLooting = false,
                    DisableFauxAdminDemolish = true,
                    DisableFauxAdminRotate = true,
                    DisableFauxAdminUpgrade = true,
                    UseAdminFlag = false,
                    MessageOnFauxAdminGrant = true,
                    KickOnFauxAdminRevoke = true,
                }
            };
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("New configuration file created!!");
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            SaveConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["notauthorized"] = "You are not authorized to use that command !!",
                ["disablegod"] = "You are not authorized to use God Mode !!",
                ["disablenoclip"] = "You are not allowed to noclip into an area you do not have TC priv.",
                ["processonconnect"] = "was processed as a FauxAdmin when they connected.",
                ["processonload"] = "was processed as a FauxAdmin when plugin reloaded.",
                ["permgranted"] = "You have been granted Faux Admin, you must disconnect and reconnect to take effect.",
                ["permrevoked"] = "Faux Admin rights removed, You were disconnected.",
                ["godgranted"] = "You have been granted Admin God Mode, you must disconnect and reconnect to take effect.",
                ["godrevoked"] = "God Mode rights removed, You were disconnected.",
                ["noclipactivated"] = "Noclip Activated",
                ["noclipdeactivated"] = "Noclip Deactivated"
            }, this);
        }

        #endregion

        #region Commands

        [Command("fly")]
        private void cmdfly(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            ToggleNoclip(player);
        }

        [Command("noclip")]
        private void cmdNoClip(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            ToggleNoclip(player);
        }

        [Command("entkill")]
        private void cmdEntKill(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            if (player == null) return;

            // Must be a Standard Fauxadmin to continue checking
            if (!player.IPlayer.HasPermission(permAllowed)) return;

            if (config.fauxAdminSettings.EnableEntKill || player.IPlayer.HasPermission(permAllowKill))
            {
                EntKillProcess(player);
            }
            else
            {
                player.IPlayer.Message(lang.GetMessage("notauthorized", this, player.IPlayer.Id));
            }
        }

        #endregion

        #region Hooks

        private object OnClientCommand(Connection connection, string command)
        {
            var player = BasePlayer.FindByID(connection.userid);
            if (player == null) return null;

            if (!player.IPlayer.HasPermission(permAllowed)) return null;

            if (command.Contains("setinfo \"global.god\" \"True\""))
            {
                if (!player.IPlayer.HasPermission(permGodMode))
                {
                    player.IPlayer.Message(lang.GetMessage("disablegod", this, player.IPlayer.Id));
                    return false;
                }
            }
            else if (command.Contains("env.time"))
            {
                if (config.fauxAdminSettings.EnableEnvTime || player.IPlayer.HasPermission(permAllowTime))
                {
                    string[] array = command.Split(' ');

                    if (array.Length > 1)
                    {
                        this.covalence.Server.Command("env.time " + array[1]);
                        Puts($"{player} used the env.time command");
                    }
                    else
                    {
                        player.IPlayer.Message("Current Time is : " + TOD_Sky.Instance.Cycle.Hour.ToString());
                    }
                }
                else
                {
                    player.IPlayer.Message(lang.GetMessage("notauthorized", this, player.IPlayer.Id));
                }
            }

            return null;
        }

        private object CanLootEntity(BasePlayer player, BaseEntity container)
        {
            if (container is DroppedItemContainer || container is LootableCorpse || container is ResourceContainer || container is StorageContainer)
            {
                if (player.IPlayer.HasPermission(permAllowed) && !player.IPlayer.HasPermission(permCanLoot)) return true;
            }
            return null;
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            ProcessPlayer(player);
        }

        private object CanUpdateSign(BasePlayer player, Signage sign)
        {
            if (player.IPlayer.HasPermission(permAllowed) && sign.OwnerID != player.userID)
            {
                return false;
            }
            return null;
        }

        private object OnStructureDemolish(BuildingBlock block, BasePlayer player)
        {
            if (player.IPlayer.HasPermission(permAllowed) && block.OwnerID.IsSteamId() && block.OwnerID != player.userID) return true;
            return null;
        }

        private object OnStructureRotate(BuildingBlock block, BasePlayer player)
        {
            if (player.IPlayer.HasPermission(permAllowed) && block.OwnerID.IsSteamId() && block.OwnerID != player.userID) return true;
            return null;
        }

        private object OnStructureUpgrade(BuildingBlock block, BasePlayer player)
        {
            if (player.IPlayer.HasPermission(permAllowed) && block.OwnerID.IsSteamId() && block.OwnerID != player.userID) return true;
            return null;
        }

        private void OnUserPermissionGranted(string id, string permName)
        {
            ulong playerid = Convert.ToUInt64(id);
            var player = BasePlayer.FindByID(playerid);
            if (player == null) return;

            if (config.fauxAdminSettings.MessageOnFauxAdminGrant && permName == permAllowed)
                player.IPlayer.Message(lang.GetMessage("permgranted", this, player.IPlayer.Id));

            if (config.fauxAdminSettings.MessageOnGodGrant && permName == permGodMode)
                player.IPlayer.Message(lang.GetMessage("godgranted", this, player.IPlayer.Id));
        }

        private void OnUserPermissionRevoked(string id, string permName)
        {
            ulong playerid = Convert.ToUInt64(id);
            var player = BasePlayer.FindByID(playerid);
            if (player == null) return;

            if (config.fauxAdminSettings.KickOnFauxAdminRevoke && permName == permAllowed)
                player.Kick(lang.GetMessage("permrevoked", this, player.IPlayer.Id));

            if (config.fauxAdminSettings.KickOnGodRevoke && permName == permGodMode)
                player.Kick(lang.GetMessage("godrevoked", this, player.IPlayer.Id));
        }

        private object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
        {
            if (type == AntiHackType.FlyHack)
            {
                if (player.IPlayer.HasPermission(permAllowed)) return false;
            }
            if (type == AntiHackType.InsideTerrain)
            {
                if (config.fauxAdminSettings.EnableUnderGround) return false;
                if (player.IPlayer.HasPermission(permTerrain)) return false;
            }
            return null;
        }

        private void Unload()
        {
            DestroyAll<FauxAdminControl>();
        }

        #endregion

        #region Methods

        private void EntKillProcess(BasePlayer player)
        {
            RaycastHit RayHit;
            if (Physics.Raycast(player.eyes.HeadRay(), out RayHit, 10f, LayerMask.GetMask("Construction", "Deployed", "Default", "AI", "Player (Server)")))
            {
                var baseEntity = RayHit.GetEntity();
                if (baseEntity == null) return;
                if (baseEntity is BasePlayer || baseEntity.IsNpc) return;
                if (config.fauxAdminSettings.EntKillOnlyOwn && player.userID != baseEntity.OwnerID) return;
                baseEntity.Kill(BaseNetworkable.DestroyMode.Gib);
            }
        }

        private IEnumerator ProcessFuaxAdminControls()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                var authLevel = player.net?.connection?.authLevel;
                if (authLevel != null && authLevel > 0 && !player.IPlayer.HasPermission(permBlocked)) continue;

                var hasAllowedPermission = player.IPlayer.HasPermission(permAllowed);
                var hasBypassPermission = player.IPlayer.HasPermission(permBypass);
                var hasGodBlockPermission = player.IPlayer.HasPermission(permGodBlock);
                var hasGodModePermission = player.IPlayer.HasPermission(permGodMode);

                if (hasAllowedPermission)
                {
                    if (!hasBypassPermission)
                    {
                        var controls = player.GetComponent<FauxAdminControl>();
                        if (!controls)
                        {
                            var newControls = player.gameObject.AddComponent<FauxAdminControl>();
                            newControls.Initialize(this);
                            Puts($"{player} " + lang.GetMessage("processonload", this, player.IPlayer.Id));
                        }
                    }
                    if (hasGodBlockPermission || (config.fauxAdminSettings.DisableGodMode && !hasGodModePermission))
                    {
                        ConsoleNetwork.SendClientCommand(player.net.connection, "setinfo \"global.god\" \"False\"");
                        Puts($"{player} " + lang.GetMessage("processonload", this, player.IPlayer.Id));
                    }
                }
                yield return new WaitForEndOfFrame();
            }
        }

        private void ProcessPlayer(BasePlayer player)
        {
            if (player.net?.connection?.authLevel > 0)
            {
                if (player.IPlayer.HasPermission(permBlocked))
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper, false);
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                    if (player.IPlayer.HasPermission(permGodBlock) || (config.fauxAdminSettings.DisableGodMode && !player.IPlayer.HasPermission(permGodMode)))
                    {
                        ConsoleNetwork.SendClientCommand(player.net.connection, "setinfo \"global.god\" \"False\"");
                    }
                }
            }
            else if (!player.IPlayer.HasPermission(permAllowed))
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper, false);
            }
            else
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, config.fauxAdminSettings.UseAdminFlag);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper, !config.fauxAdminSettings.UseAdminFlag);
                if (player.IPlayer.HasPermission(permGodBlock) || (config.fauxAdminSettings.DisableGodMode && !player.IPlayer.HasPermission(permGodMode)))
                {
                    ConsoleNetwork.SendClientCommand(player.net.connection, "setinfo \"global.god\" \"False\"");
                }
                if (!player.IPlayer.HasPermission(permBypass))
                {
                    var hasControls = player.GetComponent<FauxAdminControl>();
                    if (hasControls) hasControls.OnDestroy();
                    var addControls = player.gameObject.AddComponent<FauxAdminControl>();
                    addControls.Initialize(this);
                }
            }
            Puts($"{player} " + lang.GetMessage("processonconnect", this, player.IPlayer.Id));
        }

        private static void DestroyAll<T>()
        {
            var objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
        }

        #endregion

        #region FauxAdmin Control

        private class FauxAdminControl : FacepunchBehaviour
        {
            private FauxAdmin instance;
            private BasePlayer player;
            private bool hasFrozenPosition;

            public void Initialize(FauxAdmin pluginInstance)
            {
                instance = pluginInstance;
            }

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                if (player == null) { OnDestroy(); return; }
                hasFrozenPosition = false;
            }

            private void DeactivateNoClip(BasePlayer player)
            {
                if (player == null) return;
                if (hasFrozenPosition) return;
                if (player.IPlayer.HasPermission(permBypass)) return;

                hasFrozenPosition = true;
                ServerMgr.Instance.StartCoroutine(DeactivateAndFreeze(player));
            }

            private IEnumerator DeactivateAndFreeze(BasePlayer player)
            {
                if (player == null) yield break;
                if (instance == null) yield break;

                var pos = player.transform.position;

                ConsoleNetwork.SendClientCommand(player.net.connection, "noclip");
                player.IPlayer.Message(instance.lang.GetMessage("disablenoclip", instance, player.IPlayer.Id));

                // Repeatedly teleport the player to the same position
                for (int i = 0; i < 8; i++)
                {
                    yield return new WaitForSeconds(0.1f);
                    if (player != null) player.Teleport(pos);
                }

                yield return new WaitForSeconds(0.1f);
                hasFrozenPosition = false;
            }

            private bool PlayerIsInOwnTCRange()
            {
                List<BuildingPrivlidge> privList = Pool.GetList<BuildingPrivlidge>();
                Vis.Entities<BuildingPrivlidge>(player.transform.position, 50f, privList);

                foreach (BuildingPrivlidge foundEnt in privList)
                {
                    if (foundEnt.IsAuthed(player))
                    {
                        Pool.FreeList<BuildingPrivlidge>(ref privList);
                        return true;
                    }
                }

                Pool.FreeList<BuildingPrivlidge>(ref privList);
                return false;
            }

            private void FixedUpdate()
            {
                if (player == null) { Destroy(gameObject); return; }

                if (player.IsFlying && !hasFrozenPosition)
                {
                    if (FauxAdmin.config.fauxAdminSettings.EnableNoclipOnBuild || player.IPlayer.HasPermission(permOnlyOwn))
                    {
                        if (!PlayerIsInOwnTCRange()) 
                        {
                            DeactivateNoClip(player);
                        }
                    }
                    else if (FauxAdmin.config.fauxAdminSettings.DisableNoclipOnNoBuild)
                    {
                        if (player.IsBuildingBlocked()) 
                        {
                            DeactivateNoClip(player);
                        }
                    }
                }
            }

            public void OnDestroy()
            {
                GameObject.Destroy(this);
            }
        }

        #endregion

        private void ToggleNoclip(BasePlayer player)
        {
            if (player.IsFlying)
            {
                player.IPlayer.Message(lang.GetMessage("noclipdeactivated", this, player.IPlayer.Id));
            }
            else
            {
                player.IPlayer.Message(lang.GetMessage("noclipactivated", this, player.IPlayer.Id));
            }
            ConsoleNetwork.SendClientCommand(player.net.connection, "noclip");
        }
    }
}

// --- End of file: FauxAdmin.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/fix-shop-front ---
// --- Original File Path: F/FixShopFront/FixShopFront.cs ---

﻿namespace Oxide.Plugins
{
    [Info("Fix Shop Front", "Mevent", "1.0.2")]
    [Description("Fixed a bug with managing other people's weapon modifications when exchanging")]
    public class FixShopFront : CovalencePlugin
    {
        private object OnItemAction(Item item, string action, BasePlayer player)
        {
            if (item == null || player == null || action != "drop") return null;

            var shopFront = item.GetRootContainer()?.entityOwner as ShopFront;
            if (shopFront == null) return null;

            var parentItem = item.parentItem;
            if (parentItem == null) return null;

            if (shopFront.customerInventory.itemList.Contains(parentItem))
            {
                if (shopFront.customerPlayer != player)
                    return true;
            }
            else
            {
                if (shopFront.vendorPlayer != player)
                    return true;
            }

            return null;
        }

        private object CanMoveItem(Item item, PlayerInventory inventory, uint targetContainer, int targetSlot,
            int amount)
        {
            var player = inventory.GetComponent<BasePlayer>();
            if (player == null)
                return null;

            var shopFront = item.GetRootContainer()?.entityOwner as ShopFront;
            if (shopFront != null)
            {
                var parentItem = item.parentItem;
                if (parentItem == null) return null;

                if (shopFront.customerInventory.itemList.Contains(parentItem))
                {
                    if (shopFront.customerPlayer != player)
                        return true;
                }
                else
                {
                    if (shopFront.vendorPlayer != player)
                        return true;
                }

                return null;
            }

            var container = inventory.FindContainer(targetContainer);
            if (container != null)
            {
                var parentItem = container.parent;
                if (parentItem == null) return null;

                var front = parentItem.GetRootContainer().entityOwner as ShopFront;
                if (front == null) return null;

                if (front.customerInventory.itemList.Contains(parentItem))
                {
                    if (front.customerPlayer != player) return true;
                }
                else
                {
                    if (front.vendorPlayer != player)
                        return true;
                }

                return null;
            }

            return null;
        }
    }
}

// --- End of file: FixShopFront.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/fuel-gauge ---
// --- Original File Path: F/FuelGauge/FuelGauge.cs ---

using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Fuel Gauge", "shaigannn", "0.8.2")]
    [Description("HUD for amount of fuel when riding a vehicle")]
    public class FuelGauge : RustPlugin
    {
        #region Fields
        [PluginReference]
        private Plugin ImageLibrary;

        private const string perm = "fuelgauge.allow";
        private List<VehicleCache> vehicles = new List<VehicleCache>();

        ConfigData configData;

        private bool useIcon;
        private string imageURL;
        private string dock;
        private bool onlyDriver;
        private string backgroundColor;
        private float backgroundTransparency;
        private string gaugeType = "bar";

        private readonly List<string> driverSeats = new List<string>()
        {
            "miniheliseat", "modularcardriverseat", "transporthelipilot", "driverseat", "smallboatdriver", "standingdriver", "submarinesolodriverstanding", "submarineduodriverseat"
        };

        public class VehicleCache
        {
            public BaseMountable entity;
            public BasePlayer player;

            public int GetFuelAmount()
            {
                if (entity.GetParentEntity() is Minicopter) // Includes ScrapTransportHelicopter
                {
                    return (entity.GetParentEntity() as Minicopter)?.GetFuelSystem()?.GetFuelAmount() ?? 0;
                }

                if (entity.VehicleParent() as ModularCar)
                {
                    return (entity.VehicleParent() as ModularCar)?.GetFuelSystem()?.GetFuelAmount() ?? 0;
                }

                if (entity.GetParentEntity() is MotorRowboat) // Includes RHIB
                {
                    return (entity.GetParentEntity() as MotorRowboat)?.GetFuelSystem()?.GetFuelAmount() ?? 0;
                }

                if(entity.GetParentEntity() is BaseSubmarine)
                {
                    return (entity.GetParentEntity() as BaseSubmarine)?.GetFuelSystem()?.GetFuelAmount() ?? 0;
                }

                return 0;
            }

            //Checks if a vehicle has fuel system
            public static bool HasFuelSystem(BaseMountable entity)
            {
                if (entity.GetParentEntity() is Minicopter) // Includes ScrapTransportHelicopter
                {
                    return true;
                }

                if (entity.VehicleParent() as ModularCar) //Includes Modular Cars
                {
                    return true;
                }

                if (entity.GetParentEntity() is MotorRowboat) // Includes RHIB
                {
                    return true;
                }

                if (entity.GetParentEntity() is BaseSubmarine) // Includes Base Submarines 
                {
                    return true;
                }

                return false;
            }
        }
        #endregion

        #region Config
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                settings = new Settings
                {
                    Dock = "Left",
                    DriverOnly = true
                },
                display = new Display
                {
                    ImageURL = "https://i.imgur.com/n9Vp4yz.png",
                    BackgroundColor = "#9b9696",
                    Transparency = 0.3f,
                    UseIcon = true
                }
            };

            Config.WriteObject(config, true);
            configData = Config.ReadObject<ConfigData>();
            LoadVariables();
        }

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Settings")]
            public Settings settings { get; set; }
            [JsonProperty(PropertyName = "Display")]
            public Display display { get; set; }
        }

        private class Settings
        {
            [JsonProperty(PropertyName = "Dock")]
            public string Dock { get; set; }
            [JsonProperty(PropertyName = "Only Display to Driver")]
            public bool DriverOnly { get; set; }
        }

        private class Display
        {
            [JsonProperty(PropertyName = "Use Icon")]
            public bool UseIcon { get; set; }
            [JsonProperty(PropertyName = "Image URL")]
            public string ImageURL { get; set; }
            [JsonProperty(PropertyName = "Background Color")]
            public string BackgroundColor { get; set; }
            [JsonProperty(PropertyName = "Background Transparency")]
            public float Transparency { get; set; }
        }

        private void LoadVariables()
        {
            configData = Config.ReadObject<ConfigData>();

            imageURL = configData.display.ImageURL;
            backgroundColor = configData.display.BackgroundColor;
            backgroundTransparency = configData.display.Transparency;
            useIcon = configData.display.UseIcon;

            dock = configData.settings.Dock;
            onlyDriver = configData.settings.DriverOnly;
        }
        #endregion

        #region Hooks
        void Init()
        {
            permission.RegisterPermission(perm, this);
            LoadVariables();
        }

        void OnServerInitialized()
        {
            if (ImageLibrary != null)
            {
                ImageLibrary.Call("AddImage", imageURL, imageURL, 0UL);
            }
            UIManager();
        }

        private void Unload()
        {
            DestoryAllUI();
            vehicles.Clear();
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            if (GetPlayer(player))
            {
                RemoveVehicleByPlayer(player);
            }
        }

        void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (GetPlayer(player))
            {
                RemoveVehicleByPlayer(player);
            }
        }

        void OnEntityMounted(BaseMountable entity, BasePlayer player)
        {

            if(entity == null || player == null)
            {
                return;
            }

            if (!permission.UserHasPermission(player.UserIDString, perm))
            {
                return;
            }

            if (!VehicleCache.HasFuelSystem(entity))
            {
                return;
            }

            if (GetPlayer(player))
            {
                RemoveVehicleByPlayer(player);
            }

            if (onlyDriver)
            {
                if (!(driverSeats.Contains(entity.ShortPrefabName)))
                {
                    return;
                }
            }

            VehicleCache vehicle = new VehicleCache
            {
                player = player,
                entity = entity
            };
            vehicles.Add(vehicle);
            CreateUI(vehicle);
        }

        void OnEntityDismounted(BaseMountable entity, BasePlayer player)
        {
            if (GetPlayer(player))
            {
                RemoveVehicleByPlayer(player);
            }
        }

        void OnEntityKill(BaseNetworkable entity)
        {
            if (entity.GetParentEntity() is Minicopter || entity.GetParentEntity() is MotorRowboat || entity.GetParentEntity() is ModularCar)
            {
                foreach (VehicleCache vehicle in vehicles)
                {
                    if (vehicle.entity == entity)
                    {
                        RemoveVehicleByPlayer(vehicle.player);
                        return;
                    }
                }
            }
        }
        #endregion

        #region UIHelper
        static class UIHelper
        {
            public static CuiElementContainer NewCuiElement(string name, string color, string aMin, string aMax)
            {
                var element = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = { Color = color },
                            RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                            CursorEnabled = false
                        },
                        new CuiElement().Parent = "Overlay",
                        name
                    }
                };
                return element;
            }

            public static void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel, CuiHelper.GetGuid());
            }

            public static void CreateLabel(ref CuiElementContainer container, string panel, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter, string color = null)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel, CuiHelper.GetGuid());
            }

            public static void LoadImage(ref CuiElementContainer container, string panel, string png, string aMin, string aMax)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent { Png = png },
                        new CuiRectTransformComponent { AnchorMin = aMin, AnchorMax = aMax }
                    }
                });
            }

            public static string HexToRGBA(string hex, float alpha)
            {
                if (hex.StartsWith("#"))
                {
                    hex = hex.TrimStart('#');
                }

                int red = int.Parse(hex.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hex.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hex.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }
        #endregion

        #region Methods
        public void CreateUI(VehicleCache vehicle)
        {
            var element = UIHelper.NewCuiElement("SHOWFUEL_UI", UIHelper.HexToRGBA(backgroundColor, backgroundTransparency), GetMinDock(), GetMaxDock());
            if (useIcon && ImageLibrary != null && ImageLibrary.IsLoaded)
            {
                UIHelper.CreatePanel(ref element, "SHOWFUEL_UI", UIHelper.HexToRGBA(backgroundColor, backgroundTransparency), "0.0 0.0", "1.0 1.0");
                string icon = GetImage(imageURL);
                if (!string.IsNullOrEmpty(icon))
                {
                    UIHelper.LoadImage(ref element, "SHOWFUEL_UI", icon, "0.1 0.2", "0.7 0.8");
                }
                UIHelper.CreateLabel(ref element, "SHOWFUEL_UI", "x" + vehicle.GetFuelAmount(), 11, "0.1 0.1", "0.9 0.4", TextAnchor.MiddleRight);
                CuiHelper.AddUi(vehicle.player, element);
            }
            else
            {
                UIHelper.CreatePanel(ref element, "SHOWFUEL_UI", UIHelper.HexToRGBA(backgroundColor, backgroundTransparency), "0.0 0.0", "1.0 1.0");
                UIHelper.CreateLabel(ref element, "SHOWFUEL_UI", "x" + vehicle.GetFuelAmount(), 14, "0.1 0.1", "0.9 0.9");
                CuiHelper.AddUi(vehicle.player, element);
            }
        }

        public void UpdateUI(VehicleCache vehicle)
        {
            CuiHelper.DestroyUi(vehicle.player, "SHOWFUEL_UI");
            CreateUI(vehicle);
        }

        public void UIManager()
        {
            timer.Every(3f, () =>
            {
                if (vehicles.Count != 0)
                {
                    foreach (VehicleCache vehicle in vehicles)
                    {
                        if (GetPlayer(vehicle.player))
                        {
                            UpdateUI(vehicle);
                        }
                    }
                }
            });
        }

        public void DestoryUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "SHOWFUEL_UI");
        }

        public void DestoryAllUI()
        {
            foreach (VehicleCache vehicle in vehicles)
            {
                DestoryUI(vehicle.player);
            }
        }

        public void RemoveVehicleByPlayer(BasePlayer player)
        {
            if (player == null)
            {
                return;
            }

            foreach (VehicleCache v in vehicles)
            {
                if (v.player.userID == player.userID)
                {
                    DestoryUI(player);
                    vehicles.Remove(v);
                    return;
                }
            }
        }

        public bool GetPlayer(BasePlayer player)
        {
            if (player == null)
            {
                return false;
            }

            foreach (VehicleCache vehicle in vehicles)
            {
                if (vehicle.player.userID == player.userID)
                {
                    return true;
                }
            }
            return false;
        }

        private string GetImage(string fileName, ulong skin = 0)
        {
            string imageId = ImageLibrary.Call<string>("GetImage", fileName, skin);
            if (imageId == null)
            {
                return string.Empty;
            }

            return imageId;
        }

        public string GetMinDock()
        {
            if (dock == "Right")
            {
                return "0.65 0.025";
            }
            else if (dock == "Left")
            {
                return "0.30 0.025";
            }

            return "0.65 0.025";
        }

        public string GetMaxDock()
        {
            if (dock == "Right")
            {
                return "0.7 0.085";
            }
            else if (dock == "Left")
            {
                return "0.34 0.082";
            }

            return "0.7 0.085";
        }
        #endregion
    }
}

// --- End of file: FuelGauge.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/free-build ---
// --- Original File Path: F/FreeBuild/FreeBuild.cs ---

﻿using System;
using System.Collections.Generic;

using Oxide.Core.Libraries.Covalence;

using Newtonsoft.Json;

/*
 * Thanks to WhiteThunder for helping with the hidden fake resources
 */

namespace Oxide.Plugins
{
    [Info("Free Build", "0x89A", "2.1.2")]
    [Description("Allows building, upgrading and placing deployables for free")]
    class FreeBuild : CovalencePlugin
    {
        private const string usePerm = "freebuild.allow";

        private const int _itemStartPosition = 24;

        private readonly HashSet<BasePlayer> _activePlayers = new HashSet<BasePlayer>();

        private readonly string[] _resourceItemShortnames =
        {
            "wood",
            "stones",
            "metal.fragments",
            "metal.refined"
        };
        
        private readonly List<Item> _resourceItems = new List<Item>();

        private void Init()
        {
            if (!_config.giveHiddenResources)
            {
                Unsubscribe(nameof(OnInventoryNetworkUpdate));
            }
            
            permission.RegisterPermission(usePerm, this);

            if (_config.requireChat)
            {
                AddCovalenceCommand(_config.chatCommand, nameof(Command), usePerm);
            }
        }

        private void Unload()
        {
            if (!_config.giveHiddenResources)
            {
                return;
            }

            foreach (BasePlayer player in _activePlayers)
            {
                player.inventory.SendUpdatedInventory(PlayerInventory.Type.Main, player.inventory.containerMain);
            }
        }

        #region -Hooks-

        private void OnEntitySaved(BasePlayer player, BaseNetworkable.SaveInfo saveInfo)
        {
            if (!IsAllowed(player))
            {
                return;
            }

            AddItems(saveInfo.msg.basePlayer.inventory.invMain);
        }

        private void OnInventoryNetworkUpdate(PlayerInventory inventory, ItemContainer container, ProtoBuf.UpdateItemContainer updatedItemContainer, PlayerInventory.Type inventoryType, bool sendToEveryone)
        {
            if (inventory != null && inventory.baseEntity != null && !IsAllowed(inventory.baseEntity))
            {
                return;
            }

            if (inventoryType == PlayerInventory.Type.Main)
            {
                AddItems(updatedItemContainer.container[0]);
            }
        }

        private object CanAffordUpgrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum iGrade)
        {
            if (IsAllowed(player))
            {
                return true;
            }
            
            return null;
        }
        
        object CanAffordToPlace(BasePlayer player, Planner planner, Construction construction)
        {
            if (IsAllowed(player))
            {
                return true;
            }
            
            return null;
        }

        object OnPayForPlacement(BasePlayer player, Planner planner, Construction construction)
        {
            if (IsAllowed(player) && DeployableCheck(planner))
            {
                return true;
            }
            
            return null;
        }

        object OnPayForUpgrade(BasePlayer player, BuildingBlock block, ConstructionGrade gradeTarget)
        {
            if (IsAllowed(player))
            {
                return true;
            }
            
            return null;
        }

        #endregion

        #region -Methods-

        private void Command(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;
            if (player == null) return;

            if (_activePlayers.Contains(player))
            {
                _activePlayers.Remove(player);
                player.ChatMessage(lang.GetMessage("Disabled", this, player.UserIDString));
            }
            else
            {
                _activePlayers.Add(player);
                player.ChatMessage(lang.GetMessage("Enabled", this, player.UserIDString));
            }
            
            player.inventory.SendUpdatedInventory(PlayerInventory.Type.Main, player.inventory.containerMain);
        }

        private bool IsAllowed(BasePlayer player)
        {
            return _config.requireChat ? _activePlayers.Contains(player) : permission.UserHasPermission(player.UserIDString, usePerm);
        }

        private bool DeployableCheck(Planner planner)
        {
            return _config.freeDeployables || !planner.isTypeDeployable;
        }
        
        private void AddItems(ProtoBuf.ItemContainer containerData)
        {
            if (containerData == null)
            {
                return;
            }

            List<Item> items = GetItems();
            
            foreach (Item item in items)
            {
                containerData.contents.Add(item.Save());
            }
            
            containerData.slots = _itemStartPosition + items.Count;
        }
        
        private List<Item> GetItems()
        {
            if (_resourceItems.Count > 0)
            {
                return _resourceItems;
            }

            _resourceItems.Clear();
            
            int position = _itemStartPosition;
            foreach (string shortname in _resourceItemShortnames)
            {
                Item item = ItemManager.CreateByName(shortname, 10000);
                if (item == null)
                {
                    continue;
                }

                item.position = position++;
                _resourceItems.Add(item);
            }

            return _resourceItems;
        }

        #endregion

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Enabled"] = "Free build <color=green>enabled</color>",
                ["Disabled"] = "Free build <color=red>disabled</color>",
            }, this);
        }
        
        #region -Configuration-

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty("Chat Command")]
            public string chatCommand = "freebuild";
        
            [JsonProperty("Require Chat Command")]
            public bool requireChat = true;
            
            [JsonProperty("Free Deployables")]
            public bool freeDeployables = true;

            [JsonProperty("Give Player Hidden Resources")]
            public bool giveHiddenResources = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Failed to load config, using default values");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion
    }
}


// --- End of file: FreeBuild.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/farm-tools ---
// --- Original File Path: F/FarmTools/FarmTools.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Farm Tools", "Clearshot", "1.2.2")]
    [Description("Farming made easy. Take control of farming with binds.")]
    class FarmTools : CovalencePlugin
    {
        private PluginConfig _config;
        private Game.Rust.Libraries.Player _rustPlayer = Interface.Oxide.GetLibrary<Game.Rust.Libraries.Player>("Player");
        private List<ulong> _usedCommand = new List<ulong>();
        private Dictionary<ulong, float> _cooldown = new Dictionary<ulong, float>();
        private int _debrisLayerMask = LayerMask.GetMask("Debris");
        private int _deployedLayerMask = LayerMask.GetMask("Deployed");

        private const string PERM_CLONE = "farmtools.clone";
        private const string PERM_CLONE_ALL = "farmtools.clone.all";
        private const string PERM_HARVEST_ALL = "farmtools.harvest.all";
        private const string PERM_PLANT_ALL = "farmtools.plant.all";
        private const string PERM_GENES = "farmtools.genes";

        private void SendChatMsg(BasePlayer pl, string msg, string prefix = null) =>
            _rustPlayer.Message(pl, msg, prefix != null ? prefix : lang.GetMessage("ChatPrefix", this, pl.UserIDString), Convert.ToUInt64(_config.chatIconID), Array.Empty<object>());

        private void Init()
        {
            permission.RegisterPermission(PERM_CLONE, this);
            permission.RegisterPermission(PERM_CLONE_ALL, this);
            permission.RegisterPermission(PERM_HARVEST_ALL, this);
            permission.RegisterPermission(PERM_PLANT_ALL, this);
            permission.RegisterPermission(PERM_GENES, this);
        }

        private void ShowHelp(BasePlayer pl)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine(lang.GetMessage("HelpTitle", this, pl.UserIDString));
            sb.AppendLine(lang.GetMessage("Help", this, pl.UserIDString));
            sb.AppendLine(lang.GetMessage("HelpClone", this, pl.UserIDString));

            if (permission.UserHasPermission(pl.UserIDString, PERM_CLONE_ALL))
                sb.AppendLine(lang.GetMessage("HelpCloneAll", this, pl.UserIDString));

            if (permission.UserHasPermission(pl.UserIDString, PERM_HARVEST_ALL))
                sb.AppendLine(lang.GetMessage("HelpHarvestAll", this, pl.UserIDString));

            if (permission.UserHasPermission(pl.UserIDString, PERM_PLANT_ALL))
                sb.AppendLine(lang.GetMessage("HelpPlantAll", this, pl.UserIDString));

            if (permission.UserHasPermission(pl.UserIDString, PERM_GENES))
                sb.AppendLine(lang.GetMessage("HelpGenes", this, pl.UserIDString));

            SendChatMsg(pl, sb.ToString(), "");
        }

        #region Commands
        [Command("farmtools")]
        private void FarmToolsCommand(IPlayer player, string command, string[] args)
        {
            if (player.IsServer) return;
            BasePlayer pl = player.Object as BasePlayer;
            if (pl == null) return;

            ShowHelp(pl);
        }

        [Command("farmtools.clone", "clone")]
        private void CloneCommand(IPlayer player, string command, string[] args)
        {
            if (player.IsServer) return;
            BasePlayer pl = player.Object as BasePlayer;
            if (pl == null) return;

            if (!player.HasPermission(PERM_CLONE))
            {
                SendChatMsg(pl, string.Format(lang.GetMessage("NoPerms", this, pl.UserIDString), command));
                return;
            }

            if (!_usedCommand.Contains(pl.userID)) _usedCommand.Add(pl.userID);

            RaycastHit hit;
            if (Physics.Raycast(pl.eyes.HeadRay(), out hit, 4f))
            {
                Collider[] hitColliders = new Collider[5];
                int numColliders = Physics.OverlapSphereNonAlloc(hit.point, 0.65f, hitColliders, _debrisLayerMask);
                for (int i = 0; i < numColliders; i++)
                {
                    GrowableEntity growableEntity = hitColliders[i]?.gameObject?.GetComponent<GrowableEntity>();
                    if (growableEntity != null)
                    {
                        growableEntity.TakeClones(pl);
                        break;
                    }
                }
            }
        }

        [Command("farmtools.cloneall", "cloneall")]
        private void CloneAllCommand(IPlayer player, string command, string[] args)
        {
            if (player.IsServer) return;
            BasePlayer pl = player.Object as BasePlayer;
            if (pl == null) return;

            if (!player.HasPermission(PERM_CLONE_ALL))
            {
                SendChatMsg(pl, string.Format(lang.GetMessage("NoPerms", this, pl.UserIDString), command));
                return;
            }

            if (!_usedCommand.Contains(pl.userID)) _usedCommand.Add(pl.userID);

            PlanterBox planter = EyeTraceToEntity(pl, 4f, _deployedLayerMask) as PlanterBox;
            if (planter == null) return;

            foreach (BaseEntity baseEntity in planter.children.ToList())
            {
                if (baseEntity == null) continue;
                GrowableEntity growableEntity = baseEntity as GrowableEntity;
                if (growableEntity == null) continue;
                growableEntity.TakeClones(pl);
            }
        }

        [Command("farmtools.harvestall", "harvestall")]
        private void HarvestAllCommand(IPlayer player, string command, string[] args)
        {
            if (player.IsServer) return;
            BasePlayer pl = player.Object as BasePlayer;
            if (pl == null) return;

            if (!player.HasPermission(PERM_HARVEST_ALL))
            {
                SendChatMsg(pl, string.Format(lang.GetMessage("NoPerms", this, pl.UserIDString), command));
                return;
            }

            if (!_usedCommand.Contains(pl.userID)) _usedCommand.Add(pl.userID);

            PlanterBox planter = EyeTraceToEntity(pl, 4f, _deployedLayerMask) as PlanterBox;
            if (planter == null) return;

            foreach (BaseEntity baseEntity in planter.children.ToList())
            {
                if (baseEntity == null) continue;
                GrowableEntity growableEntity = baseEntity as GrowableEntity;
                if (growableEntity == null) continue;

                if (growableEntity.State == PlantProperties.State.Dying)
                    growableEntity.RemoveDying(pl);
                else
                    growableEntity.PickFruit(pl);
            }
        }

        [Command("farmtools.plantall", "plantall")]
        private void PlantAllCommand(IPlayer player, string command, string[] args)
        {
            if (player.IsServer) return;
            BasePlayer pl = player.Object as BasePlayer;
            if (pl == null) return;

            if (!player.HasPermission(PERM_PLANT_ALL))
            {
                SendChatMsg(pl, string.Format(lang.GetMessage("NoPerms", this, pl.UserIDString), command));
                return;
            }

            if (!_usedCommand.Contains(pl.userID)) _usedCommand.Add(pl.userID);

            Planner planner = pl.GetHeldEntity() as Planner;
            if (planner == null) return;

            PlanterBox planter = EyeTraceToEntity(pl, 4f, _deployedLayerMask) as PlanterBox;
            if (planter == null) return;

            /****************************************************************************
            *                                                                           *
            * Credits to: Auto Plant by rostov114 (https://umod.org/plugins/auto-plant) *
            *                                                                           *
            ****************************************************************************/

            Construction construction = PrefabAttribute.server.Find<Construction>(planner.GetDeployable().prefabID);
            List<Construction.Target> targets = Facepunch.Pool.GetList<Construction.Target>();
            foreach (Socket_Base socket in PrefabAttribute.server.FindAll<Socket_Base>(planter.prefabID).Where(x => x.female))
            {
                Vector3 pos = planter.transform.TransformPoint(socket.worldPosition);
                Construction.Target target = new Construction.Target();

                target.entity = planter;
                target.ray = new Ray(pos + Vector3.up * 1.0f, Vector3.down);
                target.onTerrain = false;
                target.position = pos;
                target.normal = Vector3.up;
                target.rotation = new Vector3();
                target.player = pl;
                target.valid = true;
                target.socket = socket;
                target.inBuildingPrivilege = true;

                Socket_Base maleSocket = construction.allSockets.Where(x => x.male).FirstOrDefault();
                if (maleSocket != null && !maleSocket.CheckSocketMods(maleSocket.DoPlacement(target)))
                    continue;

                targets.Add(target);
            }

            foreach (Construction.Target target in targets)
            {
                planner.DoBuild(target, construction);
            }

            Facepunch.Pool.FreeList(ref targets);
            // end credits
        }

        [Command("farmtools.genes", "genes")]
        private void GenesCommand(IPlayer player, string command, string[] args)
        {
            if (player.IsServer) return;
            BasePlayer pl = player.Object as BasePlayer;
            if (pl == null) return;

            if (!player.HasPermission(PERM_GENES))
            {
                SendChatMsg(pl, string.Format(lang.GetMessage("NoPerms", this, pl.UserIDString), command));
                return;
            }

            if (IsPlayerOnCooldown(pl)) return;
            if (!_usedCommand.Contains(pl.userID)) _usedCommand.Add(pl.userID);

            BaseEntity entity = EyeTraceToEntity(pl, 4f, _deployedLayerMask);
            PlanterBox planter = entity as PlanterBox;
            if (planter != null)
            {
                Dictionary<string, List<string>> genes = new Dictionary<string, List<string>>();
                foreach (BaseEntity baseEntity in planter.children.ToList())
                {
                    if (baseEntity == null) continue;
                    GrowableEntity growableEntity = baseEntity as GrowableEntity;
                    if (growableEntity == null || growableEntity.State == PlantProperties.State.Dying) continue;

                    string g = "";
                    string itemName = growableEntity.SourceItemDef.displayName.english;
                    if (!genes.ContainsKey(itemName))
                    {
                        genes.Add(itemName, new List<string>());
                    }

                    foreach (GrowableGene gene in growableEntity.Genes.Genes)
                    {
                        g += gene.GetDisplayCharacter();
                    }

                    if (!genes[itemName].Contains(g))
                    {
                        genes[itemName].Add(g);
                    }
                }

                GiveGenesNote(pl, genes, lang.GetMessage("PlanterGenes", this, pl.UserIDString));
                return;
            }

            StorageContainer container = entity as StorageContainer;
            if (container != null)
            {
                Dictionary<string, List<string>> genes = new Dictionary<string, List<string>>();
                foreach (Item i in container.inventory.itemList)
                {
                    if (i.info.amountType != ItemDefinition.AmountType.Genetics || i?.instanceData?.dataInt == null) continue;

                    string g = "";
                    string itemName = i.info.displayName.english;
                    if (!genes.ContainsKey(itemName))
                    {
                        genes.Add(itemName, new List<string>());
                    }

                    GrowableGenes growGenes = new GrowableGenes();
                    GrowableGeneEncoding.DecodeIntToGenes(i.instanceData.dataInt, growGenes);
                    foreach (GrowableGene gene in growGenes.Genes)
                    {
                        g += gene.GetDisplayCharacter();
                    }

                    if (!genes[itemName].Contains(g))
                    {
                        genes[itemName].Add(g);
                    }
                }

                GiveGenesNote(pl, genes, lang.GetMessage("ContainerGenes", this, pl.UserIDString));
                return;
            }

            SendChatMsg(pl, lang.GetMessage("InvalidGeneEntity", this, pl.UserIDString));
        }
        #endregion

        #region Hooks
        private void OnUserDisconnected(IPlayer player)
        {
            BasePlayer pl = player.Object as BasePlayer;
            if (pl == null) return;

            _usedCommand.Remove(pl.userID);
            _cooldown.Remove(pl.userID);
        }

        private void CanTakeCutting(BasePlayer pl, GrowableEntity plant)
        {
            if (permission.UserHasPermission(pl.UserIDString, PERM_CLONE) || permission.UserHasPermission(pl.UserIDString, PERM_CLONE_ALL))
            {
                if (!_usedCommand.Contains(pl.userID))
                {
                    ShowHelp(pl);
                    _usedCommand.Add(pl.userID);
                }
            }
        }
        #endregion

        #region Helpers
        public bool IsPlayerOnCooldown(BasePlayer pl)
        {
            if (_cooldown.ContainsKey(pl.userID) && Time.realtimeSinceStartup < _cooldown[pl.userID])
            {
                SendChatMsg(pl, string.Format(lang.GetMessage("CommandCooldown", this, pl.UserIDString), Math.Ceiling(_cooldown[pl.userID] - Time.realtimeSinceStartup)));
                return true;
            }
            return false;
        }

        private void GiveGenesNote(BasePlayer pl, Dictionary<string, List<string>> genes, string title)
        {
            if (genes.Count < 1)
            {
                SendChatMsg(pl, lang.GetMessage("InvalidGeneEntity", this, pl.UserIDString));
                return;
            }

            Item item = ItemManager.CreateByName("note");
            item.text = $"{title}\n\n";
            foreach (KeyValuePair<string, List<string>> i in genes)
            {
                item.text += i.Key + "\n";
                foreach (string gene in i.Value)
                {
                    item.text += gene + "\n";
                }
                item.text += "\n";
            }

            if (_config.printGenesToConsole)
                pl.ConsoleMessage(item.text);

            pl.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
            SendChatMsg(pl, lang.GetMessage("GeneNote", this, pl.UserIDString));
            _cooldown[pl.userID] = Time.realtimeSinceStartup + _config.geneCooldown;
        }

        private BaseEntity EyeTraceToEntity(BasePlayer pl, float distance, int mask = ~0)
        {
            RaycastHit hit;
            return Physics.Raycast(pl.eyes.HeadRay(), out hit, distance, mask) ? hit.GetEntity() : null;
        }
        #endregion

        #region Config
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ChatPrefix"] = $"<color=#00a7fe>[{Title}]</color>",
                ["NoPerms"] = "<size=12>You do not have permission to use <color=#00a7fe>{0}</color>!</size>",
                ["HelpTitle"] = $"<size=16><color=#00a7fe>{Title}</color> Help</size>\n",
                ["Help"] = "<size=12>Bind a key to a FarmTools command using the F1 console</size>\n",
                ["HelpClone"] = "<size=12>Take clone from a single plant\n<color=#00a7fe>bind <key> farmtools.clone</color>\nchat command: <color=#00a7fe>/clone</color></size>",
                ["HelpCloneAll"] = "\n<size=12>Take all clones from a planter\n<color=#00a7fe>bind <key> farmtools.cloneall</color>\nchat command: <color=#00a7fe>/cloneall</color></size>",
                ["HelpHarvestAll"] = "\n<size=12>Harvest all plants or remove dying plants from a planter\n<color=#00a7fe>bind <key> farmtools.harvestall</color>\nchat command: <color=#00a7fe>/harvestall</color></size>",
                ["HelpPlantAll"] = "\n<size=12>Plant all seeds in the target planter\n<color=#00a7fe>bind <key> farmtools.plantall</color>\nchat command: <color=#00a7fe>/plantall</color></size>",
                ["HelpGenes"] = "\n<size=12>Copy genes from a planter box or storage container\n<color=#00a7fe>bind <key> farmtools.genes</color>\nchat command: <color=#00a7fe>/genes</color></size>",
                ["PlanterGenes"] = "][ Planter Genes ][",
                ["ContainerGenes"] = "][ Container Genes ][",
                ["GeneNote"] = "A note with genes has been added to your inventory.\n\nGenes can also be copied from the F1 console with <color=#00a7fe>console.copy</color>.",
                ["InvalidGeneEntity"] = "Unable to find genes! Look at a <color=#00a7fe>Planter Box</color> or <color=#00a7fe>Storage Container</color> and try again.",
                ["CommandCooldown"] = "Please wait <color=#00a7fe>{0}s</color>!"
            }, this);
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();
            Config.WriteObject(_config, true);
        }

        private class PluginConfig
        {
            public string chatIconID = "0";
            public bool printGenesToConsole = true;
            public float geneCooldown = 10;
        }
        #endregion
    }
}

// --- End of file: FarmTools.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/factions-core ---
// --- Original File Path: F/FactionsCore/FactionsCore.cs ---

using System.Collections.Generic;
using System;
using System.Linq;
using UnityEngine;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System.Reflection;
using System.Globalization;

namespace Oxide.Plugins
{
    [Info("FactionsCore", "Absolut & misticos", "1.0.5")]
    [Description("A revamped faction/team system")]
    class FactionsCore : RustPlugin
    {
        #region Fields

        [PluginReference]
        Plugin EventManager, ZoneManager, LustyMap, ZoneDomes, Kits, ImageLibrary, Professions, CustomSets, LastFactionStanding, FactionsTax, Conquest;
        static FieldInfo buildingPrivlidges = typeof(BasePlayer).GetField("buildingPrivilege", BindingFlags.Instance | BindingFlags.NonPublic);
        FactionsData fdata;
        private DynamicConfigFile FDATA;

        string TitleColor = "<color=orange>";
        string MsgColor = "<color=#A9A9A9>";

        bool initialized;
        public HashSet<FactionPlayer> FactionPlayers = new HashSet<FactionPlayer>();
        private List<ulong> InFactionChat = new List<ulong>();
        private List<ulong> MakingFactionAnnouncement = new List<ulong>();
        private List<ulong> AdminView = new List<ulong>();
        private List<ulong> JoinCooldown = new List<ulong>();
        private List<ulong> Passthrough = new List<ulong>();
        private Dictionary<string, List<ulong>> ActiveUniforms = new Dictionary<string, List<ulong>>();
        private Dictionary<ulong, ulong> AssignFaction = new Dictionary<ulong, ulong>();
        private Dictionary<ulong, Dictionary<Item, Slot>> LockedUniform = new Dictionary<ulong, Dictionary<Item, Slot>>();
        private List<Monuments> MonumentLocations = new List<Monuments>();
        class Monuments
        {
            public Vector3 position;
            public float radius;
        }
        private Dictionary<string, Timer> timers = new Dictionary<string, Timer>();
        private Dictionary<ulong, FactionDesigner> FactionDetails = new Dictionary<ulong, FactionDesigner>();
        private Dictionary<ulong, FactionDesigner> FactionEditor = new Dictionary<ulong, FactionDesigner>();
        #endregion

        #region Hooks   

        void Loaded()
        {
            FDATA = Interface.Oxide.DataFileSystem.GetFile("FactionsCore_Data");
            lang.RegisterMessages(messages, this);
        }

        void Unload()
        {
            foreach (var p in FactionPlayers)
                DestroyFactionPlayer(p, true);
            foreach (var entry in timers)
                entry.Value.Destroy();
            timers.Clear();
            DestroyAll<FactionPlayer>();
            FactionPlayers.Clear();
            SaveData();
        }

        private void DestroyAll<T>()
        {
            var objects = UnityEngine.Object.FindObjectsOfType(typeof(T));
            if (objects == null) return;
            foreach (var gameObj in objects)
                UnityEngine.Object.Destroy(gameObj);
        }

        void OnServerInitialized()
        {
            initialized = false;
            try
            {
                ImageLibrary.Call("isLoaded", null);
            }
            catch (Exception)
            {
                PrintWarning("No Image Library.. load ImageLibrary to use this Plugin", Name);
                Interface.Oxide.UnloadPlugin(Name);
                return;
            }
            LoadVariables();
            LoadData();
            permission.RegisterPermission(this.Title + ".admin", this);
            permission.RegisterPermission(this.Title + ".allow", this);
            foreach (BasePlayer p in BasePlayer.activePlayerList)
                OnPlayerConnected(p);
            InitializeStuff();
            CheckFactionStale();
        }

        [ChatCommand("testplayers")]
        void chatTP(BasePlayer player)
        {
            var i = 0;
            while (i < 100)
            {
                ulong FakeID = (ulong)GetRandomNumber();
                if (fdata.Players.ContainsKey(FakeID)) continue;
                fdata.Players.Add(FakeID, new PlayerData { });
                i++;
            }
            SendReply(player, "Fake Players Created!");
            SaveData();
        }


        private void InitializeStuff()
        {
            if (timers.ContainsKey("imageloading"))
            {
                timers["imageloading"].Destroy();
                timers.Remove("imageloading");
            }
            if (!isReady())
            { Puts(GetMSG("WaitingImageLibrary")); timers.Add("imageloading", timer.Once(60, () => InitializeStuff())); return; };
            CreateLoadOrder();
            foreach (var entry in configData.FactionEmblems_URLS)
                AddImage(entry.Value, "Embleem" + entry.Key, (ulong)ResourceId);
            if (CustomSets)
                foreach (var entry in fdata.Factions)
                    if (!string.IsNullOrEmpty(entry.Value.KitorSet))
                        SaveSetContents(entry.Value.KitorSet);
            FindMonuments();
            initialized = true;
            SaveData();
            timers.Add("info", timer.Once(900, () => InfoLoop()));
            timers.Add("save", timer.Once(600, () => SaveLoop()));
            timers.Add("ui", timer.Once(60, () => ReloadPlayerPanel()));
        }

        public void SaveSetContents(string set)
        {
            var contents = CustomSets?.Call("GetSetInfo", set);
            if (contents is bool || contents == null)
            {
                Puts($"Set: {set} is not valid!");
                return;
            }
            JObject kitContents = contents as JObject;
            JArray items = kitContents["belt"] as JArray;
            foreach (var itemEntry in items)
            {
                JObject item = itemEntry as JObject;
                if (!ActiveUniforms.ContainsKey((string)item["shortname"]))
                    ActiveUniforms.Add((string)item["shortname"], new List<ulong>());
                if (!ActiveUniforms[(string)item["shortname"]].Contains((ulong)item["skin"]))
                    ActiveUniforms[(string)item["shortname"]].Add((ulong)item["skin"]);

            }
            items = kitContents["wear"] as JArray;
            foreach (var itemEntry in items)
            {
                JObject item = itemEntry as JObject;
                if (!ActiveUniforms.ContainsKey((string)item["shortname"]))
                    ActiveUniforms.Add((string)item["shortname"], new List<ulong>());
                if (!ActiveUniforms[(string)item["shortname"]].Contains((ulong)item["skin"]))
                    ActiveUniforms[(string)item["shortname"]].Add((ulong)item["skin"]);
            }
            items = kitContents["main"] as JArray;
            foreach (var itemEntry in items)
            {
                JObject item = itemEntry as JObject;
                if (!ActiveUniforms.ContainsKey((string)item["shortname"]))
                    ActiveUniforms.Add((string)item["shortname"], new List<ulong>());
                if (!ActiveUniforms[(string)item["shortname"]].Contains((ulong)item["skin"]))
                    ActiveUniforms[(string)item["shortname"]].Add((ulong)item["skin"]);
            }
        }


        private void CreateLoadOrder()
        {
            Dictionary<string, string> newLoadOrder = new Dictionary<string, string>
            {
            {     "announcementoff", "http://i.imgur.com/JcyGEid.png" },
            {    "announcementon", "http://i.imgur.com/JuHJViL.png"  },
            {    "chatoff", "http://i.imgur.com/ZnXH99w.png"  },
            {    "chaton", "http://i.imgur.com/x80bOhZ.png"  },
            {    "mainmenu", "http://i.imgur.com/6lNt3SU.png"  },
            {    "lightbutton",  "http://i.imgur.com/rUhwglx.jpg" },
            {     "darkbutton", "http://i.imgur.com/91KexGA.jpg" },
            {     "hourglass", "http://i.imgur.com/4ItihIf.png" },
            {     "self", "http://i.imgur.com/w3iZpsl.png" },
            {     "box", "http://i.imgur.com/KWN4edk.png" },
            {     "battle", "http://i.imgur.com/EdiuVTZ.png" },
            {     "safezone", "http://i.imgur.com/v5TPxyv.png" },
            {     "friend", "http://i.imgur.com/FE4fV9O.png" },
            {     "greylongbutton", "http://www.pd4pic.com/images/glass-glossy-gui-shape-element-rectangle-shapes.png" },
            {     "first", "http://cdn.mysitemyway.com/etc-mysitemyway/icons/legacy-previews/icons/simple-black-square-icons-arrows/126517-simple-black-square-icon-arrows-double-arrowhead-left.png" },
            {     "back", "http://i.imgur.com/3iCM9zg.png" },
            {     "next",  "http://i.imgur.com/Dt0XmUP.png"},
            {    "last","http://cdn.mysitemyway.com/etc-mysitemyway/icons/legacy-previews/icons/matte-white-square-icons-arrows/124577-matte-white-square-icon-arrows-double-arrowhead-right.png"   },
            {     "neverdelete", "http://www.intrawallpaper.com/static/images/r4RtXBr.png" },
            { "bluelongbutton",  "https://pixabay.com/static/uploads/photo/2016/01/23/11/41/button-1157299_960_720.png"    },
            {    "redlongbutton", "https://pixabay.com/static/uploads/photo/2016/01/23/11/42/button-1157301_960_720.png"  },
            { "blacklongbutton","https://pixabay.com/static/uploads/photo/2016/01/23/11/26/button-1157269_960_720.png"      },
            {    "greenlongbutton","https://pixabay.com/static/uploads/photo/2015/07/25/08/03/the-button-859349_960_720.png"   },
            {    "purplelongbutton",  "https://pixabay.com/static/uploads/photo/2015/07/25/07/55/the-button-859343_960_720.png" },
            {     "greensquarebutton", "http://www.pd4pic.com/images/libya-flag-country-nationality-square-button.png" },
            {     "redsquarebutton", "https://openclipart.org/image/2400px/svg_to_png/78601/Red-button.png" },
            {    "circleselection", "http://i.imgur.com/mkjxZiu.png" }
            };
            ImageLibrary.Call("ImportImageList", Title, newLoadOrder, (ulong)ResourceId, true);
        }


        void CheckFactionStale()
        {
            if (configData.FactionStaleTime == 0) return;
            List<ushort> StaleFactions = new List<ushort>();
            foreach (var entry in fdata.Factions)
                if (entry.Value.LastMemberLoggedIn != 0)
                    if ((entry.Value.LastMemberLoggedIn + (configData.FactionStaleTime * 86400)) < GrabCurrentTime())
                        StaleFactions.Add(entry.Key);
            foreach (var entry in StaleFactions)
                fdata.Factions.Remove(entry);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player != null)
            {
                if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot) || !initialized)
                {
                    timer.Once(5, () => OnPlayerConnected(player));
                    return;

                }
                if (player.IsSleeping())
                    player.EndSleeping();
                InitializeFactionPlayer(player);
            }
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            DestroyUI(player);
                GiveFactionGear(player);
                PlayerPanel(player);
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (GetFactionPlayer(player) != null)
            {
                if (timers.ContainsKey(player.userID.ToString()))
                    timers.Remove(player.userID.ToString());
                DestroyFactionPlayer(GetFactionPlayer(player));
            }
        }
        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (hitInfo == null || entity == null) return;
            try
            {
                if (configData.Allow_FriendlyFire) return;
                if (entity is BasePlayer && hitInfo.Initiator is BaseTrap)
                    if (fdata.Players[entity.ToPlayer().userID].faction == fdata.Players[hitInfo.Initiator.OwnerID].faction)
                        hitInfo.damageTypes.ScaleAll(configData.FriendlyFire_DamageScale);
                var attacker = hitInfo.Initiator.ToPlayer();
                if (attacker == null || GetFactionPlayer(attacker) == null) return;
                if (entity is BasePlayer)
                {
                    var victim = entity.ToPlayer();
                    if (victim == null) return;
                    if (fdata.Players.ContainsKey(victim.userID))
                        if (fdata.Players[victim.userID].faction == 0)
                            return;
                    if (EventManager)
                    {
                        object isPlaying = EventManager?.Call("isPlaying", new object[] { attacker });
                        if (isPlaying is bool)
                            if ((bool)isPlaying)
                                return;
                    }
                    if (victim != attacker)
                    {
                        if (GetFactionPlayer(attacker).Faction != fdata.Players[victim.userID].faction) return;
                        {
                            hitInfo.damageTypes.ScaleAll(configData.FriendlyFire_DamageScale);
                            if (timers.ContainsKey(attacker.UserIDString + "FF")) return;
                            GetSendMSG(attacker, "FFs", victim.displayName);
                            timers.Add(attacker.UserIDString, timer.Once(60, () => timers.Remove(attacker.UserIDString + "FF")));
                        }
                    }
                }
                else if (entity is BaseEntity)
                {
                    var OwnerID = entity.OwnerID;
                    if (attacker.userID == OwnerID) return;
                    if (GetFactionPlayer(attacker).Faction != fdata.Players[OwnerID].faction) return;
                    if (OwnerID != 0)
                    {
                        if (EventManager)
                        {
                            object isPlaying = EventManager?.Call("isPlaying", new object[] { attacker });
                            if (isPlaying is bool)
                                if ((bool)isPlaying)
                                    return;
                        }
                        if (!AllowedToBuild(attacker))
                        {
                            hitInfo.damageTypes.ScaleAll(0);
                            if (timers.ContainsKey(attacker.UserIDString + "FFB")) return;
                            GetSendMSG(attacker, "FFBuildings", GetDisplayName(OwnerID));
                            timers.Add(attacker.UserIDString, timer.Once(60, () => timers.Remove(attacker.UserIDString + "FFB")));
                        }
                    }
                }
            }
            catch (Exception)
            {
            }
        }

        [ConsoleCommand("UI_DestroyUI")]
        private void cmdUI_DestroyUI(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyUI(player);
        }


        void DestroyFactionPlayer(FactionPlayer player, bool unloading = false)
        {
            if (player.player == null) return;
            if (!string.IsNullOrEmpty(configData.MenuKeyBinding))
                player.player.Command($"bind {configData.MenuKeyBinding} \"\"");
            DestroyUI(player.player, true);
            SaveFactionPlayer(player);
            if(IsFaction(player.Faction))
                fdata.Factions[player.Faction].LastMemberLoggedIn = GrabCurrentTime();
            if (!unloading)
            {
                if (FactionPlayers.Contains(player))
                    FactionPlayers.Remove(player);
                UnityEngine.Object.Destroy(player);
            }
        }

        static double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;


        object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (!initialized) return null;
            var player = arg.Connection?.player as BasePlayer;
            if (player == null || arg.Args == null || arg.Args[0].StartsWith("/") || arg.cmd?.FullName != "chat.say") return null;
            if (FactionDetails.ContainsKey(player.userID))
            {
                FactionCreationChat(player, arg.Args);
                return false;
            }

            if (!configData.Use_FactionAnnouncements && !configData.Use_PrivateFactionChat && !configData.Use_FactionChatControl) return null;
            string message = string.Join(" ", arg.Args);
            if (message.Length == 0)
                return null;
            string color = "";
            if (GetFactionPlayer(player) != null && GetFactionPlayer(player).Faction != 0 && fdata.Factions.ContainsKey(GetFactionPlayer(player).Faction))
            {
                var faction = GetFactionPlayer(player).Faction;
                if (configData.Use_FactionAnnouncements && MakingFactionAnnouncement.Contains(player.userID))
                {
                    fdata.Factions[faction].FactionAnnouncements.Add(fdata.Factions[faction].FactionAnnouncements.Keys.Max() + 1, message);
                    foreach (var fp in FactionPlayers.Where(k => k.Faction == faction && k.open))
                        FactionAnnouncementPanel(fp.player);
                    return false;
                }
                color = "<color=" + fdata.Factions[faction].ChatColor + ">";
                if (configData.Use_FactionTags)
                {
                    color += "[" + fdata.Factions[faction].tag + "] ";
                }
                string formatMsg = "";
                if (configData.Use_PrivateFactionChat && InFactionChat.Contains(player.userID))
                {
                    formatMsg = color + player.displayName + "</color>: " + $"<color={configData.InFactionChat_ChatColor}>" + message + "</color>";
                    BroadcastFaction(player, formatMsg);
                }
                else if (configData.Use_FactionChatControl)
                {
                    formatMsg = color + player.displayName + "</color>: " + message;
                    Broadcast(formatMsg, player.userID.ToString());
                }
                return false;
            }
            return null;
        }


        private void FactionCreationChat(BasePlayer player, string[] Args)
        {
            FactionDesigner Creation = FactionDetails[player.userID];
            if (Args.Contains("quit"))
            {
                QuitFactionCreation(player);
                return;
            }
            if (Args.Contains("save"))
            {
                SaveFaction(player);
                return;
            }
            var args = string.Join(" ", Args);
            if (args.Length == 0) return;
            switch (Creation.stepNum)
            {
                case 1:
                    if (fdata.Factions.Count() > 0)
                    {
                        foreach (var faction in fdata.Factions)
                            if (faction.Value.Name == args)
                            {
                                GetSendMSG(player, "FactionNameExists", args);
                                break;
                            }
                            else
                            {
                                Creation.faction.Name = args;
                                Creation.stepNum = 2;
                                if (Creation.editing)
                                    FactionCreation(player, 20);
                                else FactionCreation(player, 2);
                            }
                    }
                    else
                    {
                        Creation.faction.Name = args;
                        Creation.stepNum = 2;
                        if (Creation.editing)
                            FactionCreation(player, 20);
                        else FactionCreation(player, 2);
                    }
                    return;
                case 2:
                    if (fdata.Factions.Count() > 0)
                    {
                        if (Args[0].Length > 5)
                        {
                            GetSendMSG(player, "FactionTagToLong", Args[0]);
                            return;
                        }
                        foreach (var faction in fdata.Factions)
                            if (faction.Value.tag == Args[0])
                            {
                                GetSendMSG(player, "FactionTagExists", Args[0]);
                            }
                            else
                            {
                                Creation.faction.tag = $"{Args[0]}";
                                Creation.stepNum = 3;
                                if (Creation.editing)
                                    FactionCreation(player, 20);
                                else FactionCreation(player, 3);
                            }
                    }
                    else
                    {
                        Creation.faction.tag = $"[{Args[0]}]";
                        Creation.stepNum = 3;
                        if (Creation.editing)
                            FactionCreation(player, 20);
                        else FactionCreation(player, 3);
                    }
                    return;
                case 3:
                    if (Creation.faction.description == "")
                        Creation.faction.description = args;
                    else Creation.faction.description = Creation.faction.description + " " + args;
                    FactionCreation(player, 6);
                    return;
            }
        }

        #endregion

        #region Functions
        bool isAuth(BasePlayer player)
        {
            if (player.net.connection != null)
                if (player.net.connection.authLevel < 2 && !permission.UserHasPermission(player.UserIDString, "FactionsCore.admin"))
                    return false;
            return true;
        }

        private string TryForImage(string shortname, ulong skin = 99)
        {
            if (shortname.Contains("http")) return shortname;
            if (skin == 99) skin = (ulong)ResourceId;
            return GetImage(shortname, skin, true);
        }

        public string GetImage(string shortname, ulong skin = 0, bool returnUrl = false) => (string)ImageLibrary.Call("GetImage", shortname.ToLower(), skin, returnUrl);
        public bool HasImage(string shortname, ulong skin = 0) => (bool)ImageLibrary.Call("HasImage", shortname.ToLower(), skin);
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname.ToLower(), skin);
        public List<ulong> GetImageList(string shortname) => (List<ulong>)ImageLibrary.Call("GetImageList", shortname.ToLower());
        public bool isReady() => (bool)ImageLibrary?.Call("IsReady");

        public object LFSLocation(ushort ID) => LastFactionStanding?.Call("LFSLocation", ID);
        public object TaxboxLocation(ushort ID) => FactionsTax?.Call("TaxboxLocation", ID);

        public List<string> GetSetContents(string set)
        {
            if (CustomSets?.Call("GetSetContents", set) is bool) return null;
            return (List<string>)CustomSets?.Call("GetSetContents", set);
        }

        private void InitializeFactionPlayer(BasePlayer player)
        {
            if (GetFactionPlayer(player) == null)
            FactionPlayers.Add(player.gameObject.AddComponent<FactionPlayer>());
            FactionPlayer fp = player.GetComponent<FactionPlayer>();
            if (!fdata.Players.ContainsKey(player.userID))
                fdata.Players.Add(player.userID, new PlayerData());
            var data = fdata.Players[player.userID];
            if (fdata.Factions.ContainsKey(data.faction))
            {
                if (fdata.Factions[data.faction].factionPlayers.Contains(player.userID))
                {
                    fp.Faction = data.faction;
                    if (fdata.Factions[data.faction].factionPlayers.Count == 1)
                        fdata.Factions[data.faction].Leader = player.userID;
                    ZoneManager?.Call("AddPlayerToZoneWhitelist", data.faction.ToString(), player);
                    AuthorizePlayerOnTurrets(player);
                }
                else
                {
                    ZoneManager?.Call("RemovePlayerFromZoneWhitelist", data.faction.ToString(), player);
                    UNAuthorizePlayerOnTurrets(player, data.faction);
                    fp.Faction = 0;
                }
            }
            else
                fp.Faction = 0;
            if (fp.Faction != 0)
                AddFactionListLM(player.userID, fdata.Factions[fp.Faction].Name, fdata.Factions[fp.Faction].factionPlayers);
            string key = String.Empty;
            if (!string.IsNullOrEmpty(configData.MenuKeyBinding))
            {
                player.Command($"bind {configData.MenuKeyBinding} \"UI_FC_ToggleMenu\"");
                key = GetMSG("FCAltInfo", player, configData.MenuKeyBinding.ToUpper());
            }
            if (configData.InfoInterval != 0)
                GetSendMSG(player, "FCInfo", key);
            GiveFactionGear(player);
            PlayerPanel(player);
            PrivateCheck(player.userID);
            SaveData();
        }

        private void GiveFactionGear(BasePlayer player)
        {
            if (LockedUniform.ContainsKey(player.userID))
            {
                foreach (var entry in LockedUniform[player.userID])
                {
                    if (!Passthrough.Contains(player.userID)) Passthrough.Add(player.userID);
                    entry.Key.RemoveFromContainer();
                    entry.Key.Remove(0f);
                }
                LockedUniform.Remove(player.userID);
            }
            if (GetFactionPlayer(player) == null || GetFactionPlayer(player).Faction == 0 || string.IsNullOrEmpty(fdata.Factions[GetFactionPlayer(player).Faction].KitorSet)) return;
            if (Kits)
            {
                object isKit = Kits?.Call("isKit", new object[] { fdata.Factions[GetFactionPlayer(player).Faction].KitorSet });
                if (isKit is bool)
                    if ((bool)isKit)
                    {
                        List<Item> current = new List<global::Item>();
                        current = player.inventory.containerWear.itemList.Where(k => k.IsLocked()).Select(k => k).ToList();
                        if (current != null)
                            foreach (var entry in current)
                            {
                                entry.RemoveFromContainer();
                            }
                        if (!Passthrough.Contains(player.userID)) Passthrough.Add(player.userID);
                        Kits?.Call("GiveKit", player, fdata.Factions[GetFactionPlayer(player).Faction].KitorSet);
                        if (Passthrough.Contains(player.userID)) Passthrough.Remove(player.userID);
                        LockedUniform.Add(player.userID, new Dictionary<global::Item, Slot>());
                        foreach (var entry in player.inventory.containerWear.itemList)
                        {
                            if (!ActiveUniforms.ContainsKey(entry.info.shortname))
                                ActiveUniforms.Add(entry.info.shortname, new List<ulong>());
                            if (!ActiveUniforms[entry.info.shortname].Contains(entry.skin))
                                ActiveUniforms[entry.info.shortname].Add(entry.skin);
                            Slot slot;
                            if (ItemSlots.TryGetValue(entry.info.shortname, out slot))
                                LockedUniform[player.userID].Add(entry, slot);
                        }
                        foreach (var entry in current) entry.MoveToContainer(player.inventory.containerWear);
                        return;

                    }
            }
            else if (CustomSets)
            {
                if ((bool)CustomSets?.Call("isSet", fdata.Factions[GetFactionPlayer(player).Faction].KitorSet))
                {
                    List<Item> current = new List<global::Item>();
                    current = player.inventory.containerWear.itemList.Select(k => k).ToList();
                    if (current != null)
                        foreach (var entry in current)
                        {
                            entry.RemoveFromContainer();
                        }
                    if (!Passthrough.Contains(player.userID)) Passthrough.Add(player.userID);
                    CustomSets?.Call("GiveSet", player, fdata.Factions[GetFactionPlayer(player).Faction].KitorSet);
                    if (Passthrough.Contains(player.userID)) Passthrough.Remove(player.userID);
                    LockedUniform.Add(player.userID, new Dictionary<global::Item, Slot>());
                    foreach (var entry in player.inventory.containerWear.itemList)
                    {
                        if (!ActiveUniforms.ContainsKey(entry.info.shortname))
                            ActiveUniforms.Add(entry.info.shortname, new List<ulong>());
                        if (!ActiveUniforms[entry.info.shortname].Contains(entry.skin))
                            ActiveUniforms[entry.info.shortname].Add(entry.skin);
                        Slot slot;
                        if (ItemSlots.TryGetValue(entry.info.shortname, out slot))
                            LockedUniform[player.userID].Add(entry, slot);
                    }
                    foreach (var entry in current)
                    {
                        if (LockedUniform[player.userID].Select(k => k.Key).Where(k => k.info.shortname == entry.info.shortname && k.skin == entry.skin) != null)
                        {
                            entry.Remove(0f);
                        }
                        else
                            entry.MoveToContainer(player.inventory.containerWear);
                    }
                    //player.inventory.containerWear.MarkDirty();
                    return;
                }
            }
        }

        object CanWearItem(PlayerInventory inventory, Item item)
        {
            if (!initialized) return null;
            //Puts($"ITEM: {item.info.displayName.translated}");
            if (!configData.LockFactionKits_and_CustomSets) return null;
            if (inventory.containerWear.playerOwner == null) return null;
            BasePlayer player = inventory.containerBelt.playerOwner;
            if (player == null) return null;
            if (Passthrough.Contains(player.userID))
                return null;
            var fp = GetFactionPlayer(player);
            if (!LockedUniform.ContainsKey(player.userID))
                if (!ActiveUniforms.ContainsKey(item.info.shortname) || !ActiveUniforms[item.info.shortname].Contains(item.skin))
                {
                    //Puts("Not restricted item and player doesnt have locked item");
                    return null;
                }
            if (fp == null || fp.Faction == 0 || !LockedUniform.ContainsKey(player.userID))
            {
                //Puts("Restricted item and player is not in faction or have locked items");
                return false;
            }
            //Puts("Locked Uniform Contains Player - Not passthrough");
            if (LockedUniform[player.userID].ContainsKey(item))
            {
                //Puts("Item is approved for Wear List... allowed through");
                return null;
            }
            //Puts("Locked doesnt contain the item...");
            Slot slot;
            if (ItemSlots.TryGetValue(item.info.shortname, out slot))
            {
                //Puts("ItemSlots has item...");
                if (LockedUniform[player.userID].ContainsValue(slot) || slot == Slot.any)
                {
                    //Puts("Slot is any or the same as a locked item...");
                    return false;
                }
            }
            //Puts("ALLOWED");
            return null;
        }

        object OnItemAction(Item item, string cmd)
        {
            if (!initialized) return null;
            if (item == null || item.parent == null || item.parent.playerOwner == null) return null;
            BasePlayer player = item.parent.playerOwner.GetComponent<PlayerInventory>().containerWear.GetOwnerPlayer();
            if (player == null) return null;
            if (item.parent.playerOwner.inventory.containerWear.itemList.Contains(item) && LockedUniform[player.userID].ContainsKey(item) && cmd == "drop")
                return false;
            return null;
        }

        object CanAcceptItem(ItemContainer container, Item item)
        {
            if (!initialized) return null;
            if (!configData.LockFactionKits_and_CustomSets) return null;
            if (container == null || item == null || item.parent == null || item.parent.playerOwner == null) return null;
            //container.playerOwner == null || container.playerOwner.GetComponent<PlayerInventory>() == null ||
            BasePlayer player = item.parent.playerOwner.GetComponent<PlayerInventory>().containerBelt.GetOwnerPlayer();
            if (Passthrough.Contains(player.userID) || !LockedUniform.ContainsKey(player.userID)) return null;
            //Puts("Locked Uniform Contains Player");
            //if (LockedUniform[player.userID].ContainsKey(item) && container == player.inventory.containerWear)
            //{
            //    Puts("Item is approved for Wear List... allowed through");
            //    return null;
            //}

            if (item.parent.playerOwner.inventory.containerWear.itemList.Contains(item) && LockedUniform[player.userID].ContainsKey(item))
            {
                //Puts("Item is in Wear List and Locked contains the item...");
                return ItemContainer.CanAcceptResult.CannotAccept;
            }
            //Puts("Item is not in Wear List or Locked doesnt contain the item...");
            //Slot slot;
            //if (ItemSlots.TryGetValue(item.info.shortname, out slot))
            //{
            //    Puts("ItemSlots has item...");
            //    if (LockedUniform[player.userID].ContainsValue(slot) || slot == Slot.any)
            //    {
            //        Puts("Slot is any or the same or locked uniforms contains it...");
            //        return ItemContainer.CanAcceptResult.CannotAccept;
            //    }
            //}
            return null;
        }

        private void FindMonuments()
        {
            var allobjects = UnityEngine.Object.FindObjectsOfType<GameObject>();
            foreach (var gobject in allobjects)
                if (gobject.name.Contains("autospawn/monument"))
                    MonumentLocations.Add(new Monuments { position = gobject.transform.position, radius = gobject.transform.GetBounds().max.z });
        }

        //AutoTurrets
        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (!initialized) return;
            if (entity == null) return;
            if (entity as AutoTurret != null && configData.AutoAuthorization)
            {
                var userid = entity.GetComponent<AutoTurret>().OwnerID;
                BasePlayer owner = BasePlayer.FindByID(userid);
                if (owner == null || GetFactionPlayer(owner) == null || GetFactionPlayer(owner).Faction == 0) return;
                AssignTurretAuth(fdata.Factions[GetFactionPlayer(owner).Faction], entity.GetComponent<AutoTurret>());
            }
        }

        object CanUseLockedEntity(BasePlayer player, BaseLock door)
        {
            if (!initialized) return null;
            if (GetFactionPlayer(player) == null || GetFactionPlayer(player).Faction == 0) return null;
            var parent = door.parentEntity.Get(true);
            var prefab = parent.LookupPrefab();
            if (parent.IsOpen()) return true;
            if (configData.AutoAuthorization)
            {
                if (configData.AuthorizeLeadersOnly && fdata.Factions[GetFactionPlayer(player).Faction].Leader != player.userID) return null;
                if (fdata.Factions[GetFactionPlayer(player).Faction].factionPlayers.Contains(parent.OwnerID) && AllowedToBuild(player)) return true;
            }
            return null;
        }

        void AssignTurretAuth(Faction faction, AutoTurret turret)
        {
            if (!configData.AutoAuthorization) return;
            if (configData.AuthorizeLeadersOnly)
            {
                var owner = faction.Leader;
                if (!turret.authorizedPlayers.Contains(new ProtoBuf.PlayerNameID() { userid = owner, username = GetDisplayName(owner) }))
                    turret.authorizedPlayers.Add(new ProtoBuf.PlayerNameID() { userid = owner, username = GetDisplayName(owner) });
                return;
            }
            foreach (var p in faction.factionPlayers)
            {
                if (!fdata.Players.ContainsKey(p)) continue;
                if (!turret.authorizedPlayers.Contains(new ProtoBuf.PlayerNameID() { userid = p, username = GetDisplayName(p) }))
                    turret.authorizedPlayers.Add(new ProtoBuf.PlayerNameID() { userid = p, username = GetDisplayName(p) });
            }
        }

        void AuthorizePlayerOnTurrets(BasePlayer player)
        {
            var faction = fdata.Factions[GetFactionPlayer(player).Faction];
            if (configData.AuthorizeLeadersOnly && faction.Leader != player.userID) return;
            if (configData.AutoAuthorization)
            {
                List<AutoTurret> turrets = new List<AutoTurret>();
                turrets = BaseNetworkable.serverEntities.Where(k => (k as AutoTurret) != null && faction.factionPlayers.Contains((k as AutoTurret).OwnerID)).Select(k => k as AutoTurret).ToList();
                foreach (var entry in turrets)
                {
                    var turret = entry as AutoTurret;
                    if (!turret.authorizedPlayers.Contains(new ProtoBuf.PlayerNameID() { userid = player.userID, username = player.displayName }))
                        turret.authorizedPlayers.Add(new ProtoBuf.PlayerNameID() { userid = player.userID, username = player.displayName });
                }
            }
        }

        void UNAuthorizePlayerOnTurrets(BasePlayer player, ushort oldFaction)
        {
            var faction = fdata.Factions[oldFaction];
            if (configData.AutoAuthorization)
            {
                List<BaseNetworkable> turrets = BaseNetworkable.serverEntities.Where(k => (k as AutoTurret) != null && faction.factionPlayers.Contains((k as AutoTurret).OwnerID)).Select(k => k).ToList();
                {
                    if (turrets != null)
                        foreach (var entry in turrets)
                        {
                            var turret = entry as AutoTurret;
                            if (turret.authorizedPlayers.Contains(new ProtoBuf.PlayerNameID() { userid = player.userID, username = player.displayName }))
                                turret.authorizedPlayers.Remove(new ProtoBuf.PlayerNameID() { userid = player.userID, username = player.displayName });
                        }
                }
            }
        }


        void SaveFactionPlayer(FactionPlayer player)
        {
            if (fdata.Factions.ContainsKey(player.Faction))
                if (!fdata.Factions[player.Faction].factionPlayers.Contains(player.player.userID))
                    fdata.Factions[player.Faction].factionPlayers.Add(player.player.userID);
            if (!fdata.Players.ContainsKey(player.player.userID))
                fdata.Players.Add(player.player.userID, new PlayerData());
            var fp = fdata.Players[player.player.userID];
            fp.faction = player.Faction;
        }

        public FactionPlayer GetFactionPlayer(BasePlayer player)
        {
            if (!player.GetComponent<FactionPlayer>()) return null;
            else return player.GetComponent<FactionPlayer>();
        }

        bool isOwner(BasePlayer player, ushort faction)
        {
            if (fdata.Factions[faction].Leader == player.userID)
                return true;
            return false;
        }

        bool isModerator(BasePlayer player, ushort faction)
        {
            if (fdata.Factions[faction].Moderators.Contains(player.userID))
                return true;
            return false;
        }

        public void Broadcast(string message, string userid = "0") => PrintToChat(message);

        public void BroadcastFaction(BasePlayer source, string message, ushort faction = 0)
        {
            if (faction == 0)
                faction = GetFactionPlayer(source).Faction;
            if (!fdata.Factions.ContainsKey(faction)) return;
            string color = fdata.Factions[faction].ChatColor;
            foreach (var entry in fdata.Factions[faction].factionPlayers)
                try { BasePlayer player = BasePlayer.FindByID(entry); GetSendMSG(player, message); }
                catch { }
        }

        private void BroadcastOnScreenFaction(string message, ushort faction = 0, ushort faction2 = 0)
        {
            if (faction == 0)
            {
                if (fdata.Factions.ContainsKey(faction2))
                    foreach (var player in BasePlayer.activePlayerList.Where(k => GetFactionPlayer(k) != null && GetFactionPlayer(k).Faction != faction2))
                        OnScreen(player, message, fdata.Factions[faction].UIColor);
                else
                    foreach (var player in BasePlayer.activePlayerList.Where(k => GetFactionPlayer(k) != null))
                        OnScreen(player, message);
            }
            else if (fdata.Factions.ContainsKey(faction))
                foreach (var entry in fdata.Factions[faction].factionPlayers)
                {
                    try { BasePlayer player = BasePlayer.FindByID(entry); OnScreen(player, message, fdata.Factions[faction].UIColor); }
                    catch { }
                }
        }

        private void GetSendMSG(BasePlayer player, string message, string arg1 = "", string arg2 = "", string arg3 = "")
        {
            string msg = string.Format(lang.GetMessage(message, this, player.UserIDString), arg1, arg2, arg3);
            SendReply(player, TitleColor + lang.GetMessage("title", this, player.UserIDString) + "</color>" + MsgColor + msg + "</color>");
        }

        private string GetMSG(string message, BasePlayer player = null, string arg1 = "", string arg2 = "", string arg3 = "")
        {
            string p = null;
            if (player != null)
                p = player.UserIDString;
            if (messages.ContainsKey(message))
                return string.Format(lang.GetMessage(message, this, p), arg1, arg2, arg3);
            else return message;
        }

        private void QuitFactionCreation(BasePlayer player)
        {
            if (FactionDetails[player.userID].creating)
            {
                FactionDetails.Remove(player.userID);
                GetSendMSG(player, "QuitFactionCreation");
            }
            else if (FactionEditor[player.userID].editing)
            {
                FactionEditor.Remove(player.userID);
                GetSendMSG(player, "QuitFactionEditing");
            }
            DestroyUI(player);
        }

        private void RemoveFaction(BasePlayer player, ushort ID, bool admin = false)
        {
            var factionname = fdata.Factions[ID].Name;
            fdata.Factions.Remove(ID);
            if (player != null)
            {
                DestroyUI(player);
                Broadcast($"{factionname} {GetMSG("FactionDeleted")}");
            }
            if (admin)
                ReassignPlayers(ID);
            SaveData();
        }

        private void ReassignPlayers(ushort ID)
        {
            foreach (var entry in fdata.Factions[ID].factionPlayers)
            {
                fdata.Players[entry].faction = default(ushort);
                try
                {
                    BasePlayer player = BasePlayer.FindByID(entry);
                    GetSendMSG(player, "FactionDeleted");
                    GetFactionPlayer(player).Panel = "Selection";
                    FactionPanel(player);
                }
                catch { }
            }
        }

        static bool AllowedToBuild(BasePlayer player)
        {
            if (player == null) return false;
            List<BuildingPrivlidge> playerpriv = buildingPrivlidges.GetValue(player) as List<BuildingPrivlidge>;
            if (playerpriv == null || playerpriv.Count == 0)
            {
                return false;
            }
            foreach (BuildingPrivlidge priv in playerpriv.ToArray())
            {
                List<ProtoBuf.PlayerNameID> authorized = priv.authorizedPlayers;
                bool foundplayer = false;
                foreach (ProtoBuf.PlayerNameID pni in authorized.ToArray())
                    if (pni.userid == player.userID)
                        foundplayer = true;
                if (!foundplayer)
                    return false;
            }
            return true;
        }


        private void DestroyUI(BasePlayer player, bool all = false)
        {
            FactionPlayer fp = GetFactionPlayer(player);
            if (fp != null)
            {
                fp.open = false;
                fp.SelectedFaction = new ushort();
                fp.TargetPlayer = new ulong();
                fp.Panel = "HOME";
            }
            if (all) CuiHelper.DestroyUi(player, PanelPlayer);
            CuiHelper.DestroyUi(player, PanelFAnnouncements);
            CuiHelper.DestroyUi(player, PanelStatic);
            CuiHelper.DestroyUi(player, PanelProfile);
            CuiHelper.DestroyUi(player, PanelFactions);
            CuiHelper.DestroyUi(player, PanelOnScreen);
            if (Professions)
                player.SendConsoleCommand("UI_ToggleProfessionsMenu close");
            if (CustomSets)
                player.SendConsoleCommand("ToggleCSUI close");
        }

        #endregion

        #region UI Creation
        private string PanelOnScreen = "OnScreen";
        private string PanelFactions = "FactionsPanel";
        private string PanelPlayer = "PlayerPanel";
        private string PanelStatic = "PanelStatic";
        private string PanelFAnnouncements = "PanelFAnnouncements";
        private string PanelProfile = "PanelProfile";
        public class UI
        {
            static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor = false)
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor
                    },
                    new CuiElement().Parent,
                    panelName
                }
            };
                return NewElement;
            }
            static public CuiElementContainer CreateOverlayContainer(string panelName, string color, string aMin, string aMax, bool cursor = false)
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor
                    },
                    new CuiElement().Parent = "Overlay",
                    panelName
                }
            };
                return NewElement;
            }

            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = 1.0f, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);
            }

            static public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 1.0f },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }

            static public void LoadImage(ref CuiElementContainer container, string panel, string img, string aMin, string aMax)
            {
                if (img.StartsWith("http") || img.StartsWith("www"))
                {
                    container.Add(new CuiElement
                    {
                        Parent = panel,
                        Components =
                    {
                        new CuiRawImageComponent {Url = img, Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                    });
                }
                else
                    container.Add(new CuiElement
                    {
                        Parent = panel,
                        Components =
                    {
                        new CuiRawImageComponent {Png = img, Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                    });
            }

            static public void CreateTextOverlay(ref CuiElementContainer container, string panel, string text, string color, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 1.0f)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = fadein, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);

            }
            static public void CreateTextOutline(ref CuiElementContainer element, string panel, string colorText, string colorOutline, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                element.Add(new CuiElement
                {
                    Parent = panel,
                    Components =
                    {
                        new CuiTextComponent{Color = colorText, FontSize = size, Align = align, Text = text },
                        new CuiOutlineComponent {Distance = "1 1", Color = colorOutline},
                        new CuiRectTransformComponent {AnchorMax = aMax, AnchorMin = aMin }
                    }
                });
            }
        }

        private Dictionary<string, string> UIColors = new Dictionary<string, string>
        {
            {"black", "0 0 0 1.0" },
            {"dark", "0.1 0.1 0.1 0.98" },
            {"header", "1 1 1 0.3" },
            {"light", ".564 .564 .564 1.0" },
            {"grey1", "0.6 0.6 0.6 1.0" },
            {"brown", "0.3 0.16 0.0 1.0" },
            {"yellow", "0.9 0.9 0.0 1.0" },
            {"orange", "1.0 0.65 0.0 1.0" },
            {"limegreen", "0.42 1.0 0 1.0" },
            {"blue", "0.2 0.6 1.0 1.0" },
            {"red", "1.0 0.1 0.1 1.0" },
            {"white", "1 1 1 1" },
            {"green", "0.28 0.82 0.28 1.0" },
            {"grey", "0.85 0.85 0.85 1.0" },
            {"Neutral", "0.9 0.9 0.0 1.0" },
            {"Spectator",  "0.9 0.9 0.0 1.0" },
            {"lightblue", "0.6 0.86 1.0 1.0" },
            {"buttonbg", "0.2 0.2 0.2 0.7" },
            {"buttongreen", "0.133 0.965 0.133 0.9" },
            {"buttonred", "0.964 0.133 0.133 0.9" },
            {"buttongrey", "0.8 0.8 0.8 0.9" },
            {"CSorange", "1.0 0.64 0.10 1.0" }
        };

        private Dictionary<string, string> ChatColor = new Dictionary<string, string>
        {
            {"Blue", "<color=#3366ff>" },
            {"Red", "<color=#e60000>" },
            {"Green", "<color=#29a329>" },
            {"Spectator", "<color=#ffff00>"}
        };

        #endregion

        #region UI Panels

        [ConsoleCommand("UI_FC_ToggleMenu")]
        private void cmdUI_FC_ToggleMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null) return;
            if (configData.DisableMenu && !isAuth(player)) return;
            FactionPlayer fp = GetFactionPlayer(player);
            if (fp == null) { InitializeFactionPlayer(player); return; }
            if (arg.Args != null && arg.Args.Length > 0 && arg.Args[0] == "close")
            {
                DestroyUI(player);
                return;
            }
            if (!fp.open)
            {
                fp.open = true;
                ToggleFCMenu(player);
            }
            else
                DestroyUI(player);
        }

        private void ToggleFCMenu(BasePlayer player)
        {
            FactionPlayer fp = GetFactionPlayer(player);
            if (fp == null) { InitializeFactionPlayer(player); return; }
            fp.open = true;
            FCBackground(player);
        }

        void FCBackground(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelStatic);
            var element = UI.CreateOverlayContainer(PanelStatic, "0 0 0 0", "0.05 .1", ".95 1", true);
            UI.LoadImage(ref element, PanelStatic, TryForImage("MainMenu"), "0 0", "1 1");
            CuiHelper.AddUi(player, element);
            FactionPanel(player);
            PlayerProfilePanel(player);
            FactionAnnouncementPanel(player);
        }


        private void FactionCreation(BasePlayer player, int step = 0)
        {
            FactionDesigner creation = null;
            if (FactionDetails.ContainsKey(player.userID))
                creation = FactionDetails[player.userID];
            var i = 0;
            Vector2 min = new Vector2(0f, 0f);
            Vector2 dimension = new Vector2(.2f, .15f);
            Vector2 offset2 = new Vector2(0.002f, 0.003f);
            var element = UI.CreateElementContainer(PanelFactions, UIColors["dark"], "0.3 0.3", "0.7 0.9");
            UI.CreatePanel(ref element, PanelFactions, UIColors["light"], "0.01 0.02", "0.99 0.98");
            switch (step)
            {
                case 0:
                    CuiHelper.DestroyUi(player, PanelFactions);
                    UI.CreatePanel(ref element, PanelFactions, "0 0 0 0", $".0001 0.0001", $"0.0002 0.0002", true);
                    //UI.CreateLabel(ref element, PanelFactions, UIColors["black"], GetMSG("FactionColor", TextColors["limegreen"], creation.faction.Name), 20, "0.05 0", ".95 1", TextAnchor.MiddleCenter);
                    List<string> UnavailableEmbleems = new List<string>();
                    UnavailableEmbleems = fdata.Factions.Select(k => k.Value.embleem).ToList();
                    foreach (var entry in configData.FactionEmblems_URLS.Where(k => !UnavailableEmbleems.Contains("Embleem" + k.Key)))
                    {
                        var pos = CalcButtonPos(i);
                        UI.LoadImage(ref element, PanelFactions, TryForImage("Embleem" + entry.Key), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                        UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_SelectEmbleem {entry.Key}"); i++;
                        if (i == 30) break;
                    }
                    break;
                case 1:
                    CuiHelper.DestroyUi(player, PanelFactions);
                    UI.CreateLabel(ref element, PanelFactions, UIColors["black"], GetMSG("FactionBegin"), 20, "0.05 0", ".95 1", TextAnchor.MiddleCenter);
                    break;
                case 2:
                    CuiHelper.DestroyUi(player, PanelFactions);
                    UI.CreateLabel(ref element, PanelFactions, UIColors["black"], GetMSG("FactionTag", player, creation.faction.Name), 20, "0.05 0", ".95 1", TextAnchor.MiddleCenter);
                    break;
                case 3:
                    CuiHelper.DestroyUi(player, PanelFactions);
                    UI.CreatePanel(ref element, PanelFactions, "0 0 0 0", $".0001 0.0001", $"0.0002 0.0002", true);
                    UI.CreateTextOutline(ref element, PanelFactions, UIColors["black"], UIColors["white"], GetMSG("FactionColor", player), 20, "0.05 1", ".95 1.1");
                    List<string> UnavailableColors = new List<string>();
                    UnavailableColors = fdata.Factions.Select(k => k.Value.ChatColor).ToList();
                    foreach (var entry in configData.Colors.Where(k => !UnavailableColors.Contains(k)))
                    {
                        var pos = CalcButtonPos(i);
                        UI.CreateButton(ref element, PanelFactions, HexTOUIColor(entry), "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_SelectColor {entry}"); i++;
                    }
                    break;
                case 4:
                    if (!Kits && !CustomSets) { FactionCreation(player, 5); return; }
                    CuiHelper.DestroyUi(player, PanelFactions);
                    UI.CreatePanel(ref element, PanelFactions, "0 0 0 0", $".0001 0.0001", $"0.0002 0.0002", true);
                    UI.CreateTextOutline(ref element, PanelFactions, UIColors["black"], UIColors["white"], GetMSG("FactionKit", player), 20, "0.05 1", ".95 1.1");
                    List<string> UnavailableKits = new List<string>();
                    UnavailableKits = fdata.Factions.Select(k => k.Value.KitorSet).ToList();
                    foreach (var entry in configData.Kits_and_CustomSets.Where(k => !UnavailableKits.Contains(k)))
                    {
                        object isKit = Kits?.Call("isKit", new object[] { entry });
                        if ((!(isKit is bool) || !(bool)isKit) && !(bool)CustomSets?.Call("isSet", entry)) continue;
                        var pos = CalcButtonPos(i);
                        UI.CreateButton(ref element, PanelFactions, UIColors["black"], entry, 12, $"{pos[0]} {pos[1] + .075f}", $"{pos[2]} {pos[3]}", $"UI_SelectKit {entry}");
                        UI.CreateButton(ref element, PanelFactions, UIColors["black"], "ViewKit", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[1] + .065f}", $"UI_ViewKit {entry}");
                        i++;
                    }
                    if (i == 0)
                    {
                        creation.stepNum = 3;
                        FactionCreation(player, 5);
                        return;
                    }
                    break;
                case 5:
                    CuiHelper.DestroyUi(player, PanelFactions);
                    UI.CreateLabel(ref element, PanelFactions, creation.faction.UIColor, GetMSG("FactionDescription", player, creation.faction.Name), 20, "0.05 0", ".95 1", TextAnchor.MiddleCenter);
                    break;
                case 6:
                    CuiHelper.DestroyUi(player, PanelFactions);
                    UI.CreatePanel(ref element, PanelFactions, "0 0 0 0", $".0001 0.0001", $"0.0002 0.0002", true);
                    UI.CreateLabel(ref element, PanelFactions, creation.faction.UIColor, GetMSG("CurrentDescription", player, creation.faction.description), 20, "0.05 0", ".95 1", TextAnchor.MiddleCenter);
                    UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), "0.2 0.05", "0.45 0.15");
                    UI.CreateLabel(ref element, PanelFactions, UIColors["black"], GetMSG("SaveDescription", player), 18, "0.2 0.05", "0.45 0.15");
                    UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 18, "0.2 0.05", "0.45 0.15", $"UI_Description save");
                    UI.LoadImage(ref element, PanelFactions, TryForImage("DarkButton"), "0.55 0.05", "0.8 0.15");
                    UI.CreateLabel(ref element, PanelFactions, UIColors["black"], GetMSG("Continue"), 18, "0.55 0.05", "0.8 0.15");
                    UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 18, "0.55 0.05", "0.8 0.15", $"UI_Description continue");
                    break;
                case 7:
                    CuiHelper.DestroyUi(player, PanelFactions);
                    UI.CreateLabel(ref element, PanelFactions, creation.faction.UIColor, GetMSG("CurrentDescription", player, creation.faction.description), 20, "0.05 0", ".95 1", TextAnchor.MiddleCenter);
                    break;
                default:
                    CuiHelper.DestroyUi(player, PanelFactions);
                    element = UI.CreateElementContainer(PanelFactions, UIColors["dark"], "0.3 0.3", "0.7 0.9", true);
                    UI.CreatePanel(ref element, PanelFactions, UIColors["light"], "0.01 0.02", "0.99 0.98");
                    UI.CreateLabel(ref element, PanelFactions, creation.faction.UIColor, GetMSG("FactionDetails", player), 20, "0 .9", "1 1");
                    UI.CreateLabel(ref element, PanelFactions, creation.faction.UIColor, GetMSG("CreationDetails", player, creation.faction.Name, creation.faction.group), 20, "0.1 0.7", "0.9 0.89", TextAnchor.MiddleLeft);
                    UI.CreateLabel(ref element, PanelFactions, creation.faction.UIColor, creation.faction.description, 20, "0.1 0.1", "0.9 0.65", TextAnchor.UpperLeft);
                    UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), "0.2 0.05", "0.45 0.15");
                    UI.CreateLabel(ref element, PanelFactions, UIColors["black"], GetMSG("SaveFaction", player), 18, "0.2 0.05", "0.45 0.15");
                    UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 18, "0.2 0.05", "0.45 0.15", $"UI_SaveFaction", TextAnchor.MiddleCenter);
                    UI.LoadImage(ref element, PanelFactions, TryForImage("DarkButton"), "0.55 0.05", "0.8 0.15");
                    UI.CreateLabel(ref element, PanelFactions, UIColors["black"], GetMSG("Cancel", player), 18, "0.55 0.05", "0.8 0.15");
                    UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 18, "0.55 0.05", "0.8 0.15", $"UI_ExitFactionCreation");
                    break;
            }
            CuiHelper.AddUi(player, element);
        }

        [ConsoleCommand("UI_ToggleFactionChat")]
        private void cmdUI_ToggleFactionChat(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (GetFactionPlayer(player).Faction == 0)
            {
                GetSendMSG(player, "NotInAFaction");
                return;
            }
            if (InFactionChat.Contains(player.userID))
            {
                InFactionChat.Remove(player.userID);
                GetSendMSG(player, "ExitFactionChat");
            }
            else
            {
                if (MakingFactionAnnouncement.Contains(player.userID))
                    MakingFactionAnnouncement.Remove(player.userID);
                InFactionChat.Add(player.userID);
                GetSendMSG(player, "EnterFactionChat");
            }
            PlayerPanel(player);
        }

        [ConsoleCommand("UI_ToggleFactionAnnouncement")]
        private void cmdUI_ToggleFactionAnnouncement(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (GetFactionPlayer(player).Faction == 0)
            {
                GetSendMSG(player, "NotInAFaction");
                return;
            }
            if (fdata.Factions[GetFactionPlayer(player).Faction].Leader != player.userID) return;
            if (MakingFactionAnnouncement.Contains(player.userID))
            {
                MakingFactionAnnouncement.Remove(player.userID);
                GetSendMSG(player, "ExitFactionAnnouncement");
            }
            else
            {
                if (InFactionChat.Contains(player.userID))
                    InFactionChat.Remove(player.userID);
                MakingFactionAnnouncement.Add(player.userID);
                GetSendMSG(player, "EnterFactionAnnouncement");
            }
            PlayerPanel(player);
        }

        private void ShadeZone(BasePlayer player, string zoneID)
        {
            if (ZoneDomes)
                ZoneDomes.Call("AddNewDome", player, zoneID);
        }

        private void UnShadeZone(BasePlayer player, string zoneID)
        {
            if (ZoneDomes)
                ZoneDomes.Call("RemoveExistingDome", null, zoneID);
        }

        private object GetZoneLocation(string zoneid) => ZoneManager?.Call("GetZoneLocation", zoneid);
        private object VerifyZoneID(string zoneid) => ZoneManager?.Call("CheckZoneID", zoneid);

        void OnScreen(BasePlayer player, string msg, string color = "0 0 0 1", string arg1 = "", string arg2 = "", string arg3 = "")
        {
            if (timers.ContainsKey(player.userID.ToString()))
            {
                timers[player.userID.ToString()].Destroy();
                timers.Remove(player.userID.ToString());
            }
            CuiHelper.DestroyUi(player, PanelOnScreen);
            var element = UI.CreateOverlayContainer(PanelOnScreen, "0.0 0.0 0.0 0.0", "0.55 0.8", "0.95 0.95");
            UI.CreateTextOutline(ref element, PanelOnScreen, UIColors["white"], color, GetMSG(msg, player, arg1, arg2, arg3), 24, "0.0 0.0", "1.0 1.0");
            CuiHelper.AddUi(player, element);
            timers.Add(player.userID.ToString(), timer.Once(6, () => CuiHelper.DestroyUi(player, PanelOnScreen)));
        }

        void PlayerPanel(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelPlayer);
            if (!configData.Use_FactionAnnouncements && !configData.Use_PrivateFactionChat || GetFactionPlayer(player) == null) return;
            var element = UI.CreateElementContainer(PanelPlayer, "0 0 0 0", "0.01 0.02", "0.1 0.08");
            var faction = GetFactionPlayer(player).Faction;
            if (faction != 0)
            {
                if (configData.Use_PrivateFactionChat)
                {
                    if (InFactionChat.Contains(player.userID))
                        UI.LoadImage(ref element, PanelPlayer, TryForImage("ChatOn"), "0 0", ".48 1");
                    else UI.LoadImage(ref element, PanelPlayer, TryForImage("ChatOff"), "0 0", ".48 1");
                    UI.CreateButton(ref element, PanelPlayer, "0 0 0 0", "", 14, "0 0", ".48 1", $"UI_ToggleFactionChat", TextAnchor.MiddleCenter);
                }
                if (configData.Use_FactionAnnouncements && (isOwner(player, faction) || isModerator(player, faction)))
                {
                    if (MakingFactionAnnouncement.Contains(player.userID))
                        UI.LoadImage(ref element, PanelPlayer, TryForImage("AnnouncementOn"), ".52 0", "1 1");
                    else UI.LoadImage(ref element, PanelPlayer, TryForImage("AnnouncementOff"), ".52 0", "1 1");
                    UI.CreateButton(ref element, PanelPlayer, "0 0 0 0", "", 14, ".52 0", "1 1", $"UI_ToggleFactionAnnouncement", TextAnchor.MiddleCenter);
                }
            }
            CuiHelper.AddUi(player, element);
        }


        [ConsoleCommand("UI_SafeZone")]
        private void cmdUI_SafeZone(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null || arg.Args == null || arg.Args.Count() < 1) return;
            var zoneID = GetFactionPlayer(player).Faction.ToString();
            var factionname = fdata.Factions[GetFactionPlayer(player).Faction].Name;
            if (arg.Args[0] == "create")
            {
                string msg = $"{GetMSG("EnterFactionSafeZone", player, factionname)}";
                if (!AllowedToBuild(player)) { OnScreen(player, "SafeZoneWhereTCIS"); return; }
                Vector3 pos = player.transform.localPosition;
                if (!BuildingCheck(player, pos)) { OnScreen(player, "NoSafeZonesNearMonuments"); return; }
                List<string> build = new List<string>();
                build.Add("enter_message");
                build.Add(msg.ToString());
                build.Add("radius");
                build.Add(configData.SafeZones_Radius.ToString());
                string[] zoneArgs = build.ToArray();
                ZoneManager?.Call("CreateOrUpdateZone", zoneID, zoneArgs, pos);
                foreach (var entry in fdata.Factions[GetFactionPlayer(player).Faction].factionPlayers)
                    if (BasePlayer.activePlayerList.Contains(BasePlayer.FindByID(entry)))
                        ZoneManager?.Call("AddPlayerToZoneWhitelist", zoneID, BasePlayer.FindByID(entry));
                ZoneManager?.Call("AddPlayerToZoneWhitelist", zoneID, player);
                build.Clear();
                build.Add("eject");
                build.Add("true");
                zoneArgs = build.ToArray();
                ZoneManager?.Call("CreateOrUpdateZone", zoneID, zoneArgs, pos);
                ShadeZone(player, zoneID);
                FactionPanel(player);
            }
            else if (arg.Args[0] == "delete")
            {
                ZoneManager.Call("EraseZone", zoneID);
                UnShadeZone(player, zoneID);
                timer.Once(1, () => FactionPanel(player));
            }
        }

        private bool BuildingCheck(BasePlayer player, Vector3 pos)
        {
            foreach (var entry in MonumentLocations)
            {
                var distance = Vector3.Distance(pos, entry.position);
                if (distance < entry.radius + configData.SafeZones_Radius)
                    return false;
            }
            return true;
        }

        [ConsoleCommand("RunConsoleCommand")]
        private void cmdRunConsoleCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null || arg.Args == null || arg.Args.Count() < 1) return;
            player.SendConsoleCommand(arg.Args[0]);
        }



        private void ManageFactionMenu(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelFactions);
            var i = 0;
            var element = UI.CreateElementContainer(PanelFactions, UIColors["dark"], "0.35 0.3", "0.65 0.7", true);
            UI.CreatePanel(ref element, PanelFactions, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, PanelFactions, UIColors["header"], GetMSG("AdminMenu"), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);
            if (configData.FactionLimit == 0 || configData.FactionLimit > fdata.Factions.Count())
            { CreateOptionButton(ref element, PanelFactions, "GreenSquareButton", GetMSG("CreateFaction"), $"UI_NewFaction", 0); i++; }
            foreach (var entry in fdata.Factions)
            {
                var pos = CalcButtonPos(i);
                UI.CreateButton(ref element, PanelFactions, entry.Value.UIColor, GetMSG("DeleteFaction", player, entry.Value.Name), 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_DeleteFaction {entry.Key}"); i++;
            }
            CuiHelper.AddUi(player, element);
        }

        private void ConfirmFactionDeletion(BasePlayer player, ushort ID)
        {
            CuiHelper.DestroyUi(player, PanelFactions);
            var FactionName = fdata.Factions[ID].Name;
            var ConfirmDelete = UI.CreateElementContainer(PanelFactions, UIColors["dark"], "0.2 0.4", "0.8 0.8", true);
            UI.CreatePanel(ref ConfirmDelete, PanelFactions, UIColors["light"], "0.01 0.02", "0.99 0.98");
            UI.CreateTextOutline(ref ConfirmDelete, PanelFactions, UIColors["white"], UIColors["black"], GetMSG("ConfirmDelete", player, FactionName), 20, "0.1 0.6", "0.9 0.9");
            UI.CreateButton(ref ConfirmDelete, PanelFactions, UIColors["buttonbg"], "Yes", 18, "0.2 0.2", "0.4 0.3", $"UI_DeleteFaction yes {ID}");
            UI.CreateButton(ref ConfirmDelete, PanelFactions, UIColors["buttonbg"], "No", 18, "0.6 0.2", "0.8 0.3", $"UI_DeleteFaction reject");
            CuiHelper.AddUi(player, ConfirmDelete);
        }

        void FactionAnnouncementPanel(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelFAnnouncements);
            if (!configData.Use_FactionAnnouncements) return;
            FactionPlayer fp = GetFactionPlayer(player);
            var faction = fp.Faction;
            int i = -1;
            int n = 0;
            if (faction != 0)
            {
                int StartingEntry = fdata.Factions[fp.Faction].FactionAnnouncements.Keys.Max() - 4;
                if (StartingEntry < 0) StartingEntry = 0;
                int LastEntry = StartingEntry + 4;
                CuiElementContainer element = UI.CreateOverlayContainer(PanelFAnnouncements, "0 0 0 0", "0.25 .15", "0.76 0.35");
                UI.CreateTextOutline(ref element, PanelFAnnouncements, UIColors["red"], UIColors["white"], GetMSG("FactionAnnouncements", player), 22, "0 1.05", "1 1.4", TextAnchor.LowerCenter);
                foreach (var entry in fdata.Factions[fp.Faction].FactionAnnouncements.OrderBy(k => k.Key))
                {
                    i++;
                    if (i < StartingEntry) continue;
                    if (i >= StartingEntry)
                    {
                        var pos = ItemListPos(n);
                        UI.CreateLabel(ref element, PanelFAnnouncements, UIColors["white"], entry.Value, 20, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                        n++;
                        if (i == LastEntry) break;
                    }
                }
                CuiHelper.AddUi(player, element);
            }
        }

        private float[] ItemListPos(int number)
        {
            Vector2 position = new Vector2(0f, 0.82f);
            Vector2 dimensions = new Vector2(1f, .2f);
            float offsetY = 0;
            float offsetX = 0;
            offsetY = ((-0.01f - dimensions.y) * number);
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private class Games
        {
            [JsonProperty("response")]
            public Content Response;

            public class Content
            {
                [JsonProperty("game_count")]
                public int GameCount;
                [JsonProperty("games")]
                public Game[] Games;

                public class Game
                {
                    [JsonProperty("appid")]
                    public uint AppId;
                    [JsonProperty("playtime_2weeks")]
                    public int PlaytimeTwoWeeks;
                    [JsonProperty("playtime_forever")]
                    public int PlaytimeForever;
                }
            }
        }

        private class Summaries
        {
            [JsonProperty("response")]
            public Content Response;

            public class Content
            {
                [JsonProperty("players")]
                public Player[] Players;

                public class Player
                {
                    [JsonProperty("communityvisibilitystate")]
                    public int CommunityVisibilityState;
                }
            }
        }
        private int GetCommunityVisibilityState(Summaries s) => s.Response.Players[0].CommunityVisibilityState;
        private T Deserialise<T>(string json) => JsonConvert.DeserializeObject<T>(json);

        private void PrivateCheck(ulong ID)
        {
            webrequest.EnqueueGet(string.Format("http://api.steampowered.com/" + "ISteamUser/GetPlayerSummaries/v0002/?key={0}&steamids={1}", "4A395E77EEBB9087580BCC3F967D783E", ID), (code, response) =>
            {
                if (code == 200)
                {
                    var summaries = Deserialise<Summaries>(response);
                    if (GetCommunityVisibilityState(summaries) < 3)
                    {
                        Puts($"{GetDisplayName(ID)} has a private profile.");
                    }
                    else GetRustTime(ID);
                }
            }, this);
        }

        private void GetRustTime(ulong ID)
        {
            webrequest.EnqueueGet(string.Format("http://api.steampowered.com/" + "IPlayerService/GetOwnedGames/v0001/?key={0}&steamid={1}", "4A395E77EEBB9087580BCC3F967D783E", ID), (code, response) =>
            {
                if (code == 200)
                {

                    var games = Deserialise<Games>(response);
                    if (games != null)
                        foreach (var entry in games.Response.Games)
                        {
                            fdata.Players[ID].RustLifeTime = games.Response.Games.Where(k => k.AppId == 252490).Select(k => k.PlaytimeForever).FirstOrDefault() / 60;
                            fdata.Players[ID].RustTwoWeekTime = games.Response.Games.Where(k => k.AppId == 252490).Select(k => k.PlaytimeTwoWeeks).FirstOrDefault() / 60;
                        }
                }
            }, this);
        }

        void PlayerProfilePanel(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelProfile);
            FactionPlayer fp = GetFactionPlayer(player);
            var page = fp.page;
            var panel = fp.Panel;
            CuiElementContainer element = UI.CreateOverlayContainer(PanelProfile, "0 0 0 0", "0.065 .11", ".19 .35");
            ///CREATE USER PROFILE INFO
            UI.LoadImage(ref element, PanelProfile, TryForImage(player.UserIDString, 0), "0 .65", ".35 1");
            UI.CreateLabel(ref element, PanelProfile, UIColors["white"], player.displayName, 16, ".37 .67", "1 1", TextAnchor.LowerLeft);
            UI.LoadImage(ref element, PanelProfile, TryForImage("hourglass"), "0.05 .38", ".3 .62");
            UI.CreateLabel(ref element, PanelProfile, UIColors["white"], GetMSG("PlayTimeMinutes", player, fdata.Players[player.userID].RustLifeTime.ToString(), fdata.Players[player.userID].RustTwoWeekTime.ToString()), 10, ".37 .35", "1 .65", TextAnchor.MiddleLeft);

            if (fp.Faction != 0)
            {
                var faction = fdata.Factions[fp.Faction];
                UI.CreateTextOutline(ref element, PanelProfile, faction.UIColor, UIColors["white"], faction.Name, 16, ".37 0", "1 .35", TextAnchor.MiddleLeft);
                if (!string.IsNullOrEmpty(faction.embleem))
                    UI.LoadImage(ref element, PanelProfile, TryForImage(faction.embleem), "-0.03 0.03", ".33 .3");
            }
            CuiHelper.AddUi(player, element);
        }

        static float mapSize = TerrainMeta.Size.x;
        static float GetPosition(float pos) => (pos + mapSize / 2f) / mapSize;

        void FactionPanel(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelFactions);
            CuiHelper.DestroyUi(player, PanelOnScreen);
            FactionPlayer fp = GetFactionPlayer(player);
            var page = fp.page;
            var panel = fp.Panel;
            var faction = fp.Faction;
            int entriesallowed;
            int remainingentries;
            int count;
            int shownentries;
            int i;
            int n;
            float[] pos;
            CuiElementContainer element = UI.CreateOverlayContainer(PanelFactions, "0 0 0 0", "0.05 .41", ".95 1");
            UI.CreateButton(ref element, PanelFactions, UIColors["red"], "X", 14, "0 .95", ".025 1", $"UI_FC_ToggleMenu close", TextAnchor.MiddleCenter);
            ////LEFT PANEL
            //UI.CreatePanel(ref element, PanelFactions, UIColors["white"], "0.135 0", ".305 .8");

            ////MIDDLE PANEL
            //UI.CreatePanel(ref element, PanelFactions, UIColors["white"], "0.315 0", ".685 .8");

            ////RIGHT PANEL
            //UI.CreatePanel(ref element, PanelFactions, UIColors["white"], "0.695 0", ".865 .8");

            ////
            UI.CreateTextOutline(ref element, PanelFactions, UIColors["white"], UIColors["black"], GetMSG("HOME"), 16, "0.22 0.89", "0.31 .99");
            UI.CreateTextOutline(ref element, PanelFactions, UIColors["white"], UIColors["black"], GetMSG("MAP"), 16, "0.314 0.89", "0.404 .99");
            UI.CreateTextOutline(ref element, PanelFactions, UIColors["white"], UIColors["black"], GetMSG("Faction"), 16, "0.408 0.89", "0.498 .99");
            UI.CreateTextOutline(ref element, PanelFactions, UIColors["white"], UIColors["black"], GetMSG("AllPlayers"), 16, "0.502 0.89", "0.592 .99");
            UI.CreateTextOutline(ref element, PanelFactions, UIColors["white"], UIColors["black"], GetMSG("ScoreBoard"), 16, "0.596 0.89", "0.686 .99");
            UI.CreateTextOutline(ref element, PanelFactions, UIColors["white"], UIColors["black"], GetMSG("Options"), 16, "0.69 0.89", "0.78 .99");
            if (panel != "HOME")
                UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 18, "0.22 0.89", "0.31 .99", $"UI_FC_ChangePanel HOME");
            UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 18, "0.314 0.89", "0.404 .99", $"UI_FC_ChangePanel MAP");
            if (panel != "FLIST")
                UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 18, "0.408 0.89", "0.498 .99", $"UI_FC_ChangePanel FLIST");
            if (panel != "PLIST" && (configData.Use_PlayerListMenu || isAuth(player)))
                UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 18, "0.502 0.89", "0.592 .99", $"UI_FC_ChangePanel PLIST");
            if (panel != "SCOREBOARD")
                UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 18, "0.596 0.89", "0.686 .99", $"UI_FC_ChangePanel SCOREBOARD");
            if (panel != "OPTIONS" && isAuth(player))
                UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 18, "0.69 0.89", "0.78 .99", $"UI_FC_ChangePanel OPTIONS");
            switch (panel)
            {
                case "HOME":
                    if (!string.IsNullOrEmpty(configData.HomePageMessage))
                        UI.CreateTextOutline(ref element, PanelFactions, UIColors["white"], UIColors["black"], configData.HomePageMessage, 16, "0.32 0.02", ".68 .78");
                    i = 0;
                    foreach (var entry in fdata.Players[player.userID].PendingInvites.Where(k => fdata.Factions.ContainsKey(k)))
                    {
                        pos = LeftPanelPos(i);
                        UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                        UI.CreateLabel(ref element, PanelFactions, fdata.Factions[entry].UIColor, GetMSG("FactionInvite", player, fdata.Factions[entry].Name), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                        UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_FC_ChangePanel HOME {entry}");
                        i++;
                        if (i == 7) break;
                    }
                    if (faction == 0)
                    {
                        i = 7;
                        pos = LeftPanelPos(i);
                        if (configData.Use_AllowPlayersToCreateFactions && (configData.FactionLimit == 0 || configData.FactionLimit > fdata.Factions.Count()))
                        {
                            UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                            UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("CreateFaction"), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                            UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 8, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_NewFaction");
                            i++;
                        }
                        pos = LeftPanelPos(i);
                        UI.LoadImage(ref element, PanelFactions, TryForImage("DarkButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                        UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("JoinFaction"), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                        UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_FC_ChangePanel Selection");
                    }
                    else
                    {
                        pos = LeftPanelPos(8);
                        UI.LoadImage(ref element, PanelFactions, TryForImage("DarkButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                        UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("LeaveFaction"), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                        UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_LeaveFaction");
                    }
                    if (fp.SelectedFaction != new ushort())
                    {
                        //UI.CreatePanel(ref element, PanelFactions, UIColors["white"], "0.695 0", ".865 .8");
                        var f = fdata.Factions[fp.SelectedFaction];
                        UI.CreateTextOutline(ref element, PanelFactions, f.UIColor, UIColors["white"], f.Name, 18, "0.7 0.74", ".86 .78", TextAnchor.UpperCenter);
                        if (!string.IsNullOrEmpty(f.embleem))
                            UI.LoadImage(ref element, PanelFactions, TryForImage(f.embleem), "0.73 0.5", ".83 .74");
                        UI.CreateLabel(ref element, PanelFactions, f.UIColor, GetMSG("CreationLeader", player, fdata.Players.ContainsKey(f.Leader) ? GetDisplayName(f.Leader) : "NONE"), 14, "0.7 .44", ".86 .49");
                        UI.CreateLabel(ref element, PanelFactions, f.UIColor, GetMSG("CreationPlayerCount", player, f.factionPlayers.Count().ToString()), 14, "0.7 .39", ".86 .44");
                        UI.CreateLabel(ref element, PanelFactions, f.UIColor, f.description, 10, "0.7 .15", ".86 .39");
                        pos = RightPanelPos(8);
                        UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                        UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("JoinFaction"), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                        UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 8, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_FactionSelection", TextAnchor.MiddleCenter);
                    }
                    break;
                case "MAP":
                    float minx;
                    float miny;
                    float maxx;
                    float maxy;
                    UI.LoadImage(ref element, PanelFactions, TryForImage("worldmap", 0), "0.315 0", ".685 .8");
                    foreach (var entry in fdata.Factions)
                    {
                        object bzone = ZoneManager?.Call("GetZoneLocation", entry.Key.ToString());
                        if (bzone is Vector3)
                        {
                            Vector3 safezone = (Vector3)bzone;
                            if (safezone == new Vector3()) continue;
                            minx = 0.315f + (0.37f * GetPosition(safezone.x)) - .02f;
                            miny = 0f + (0.8f * GetPosition(safezone.z)) - .03f;
                            maxx = minx + .04f;
                            maxy = miny + .06f;
                            if (!string.IsNullOrEmpty(fdata.Factions[entry.Key].embleem))
                                UI.LoadImage(ref element, PanelFactions, TryForImage(entry.Value.embleem), $"{minx} {miny}", $"{maxx} {maxy}");
                            else UI.LoadImage(ref element, PanelFactions, TryForImage("safezone"), $"{minx} {miny}", $"{maxx} {maxy}");
                        }
                    }
                    if (faction != 0)
                    {
                        if (configData.ShowFactionPlayersOnMap)
                            foreach (var entry in FactionPlayers.Where(k => k.Faction == faction && k.player.userID != player.userID))
                            {
                                minx = 0.315f + (0.37f * GetPosition(entry.player.transform.localPosition.x)) - .005f;
                                miny = 0f + (0.8f * GetPosition(entry.player.transform.localPosition.z)) - .007f;
                                maxx = minx + .01f;
                                maxy = miny + .014f;
                                UI.LoadImage(ref element, PanelFactions, TryForImage("Friend"), $"{minx} {miny}", $"{maxx} {maxy}");
                            }
                        if (FactionsTax)
                            if (isOwner(player, faction) || isModerator(player, faction))
                            {
                                var result = TaxboxLocation(faction);
                                if (result is Vector3)
                                {
                                    Vector3 box = (Vector3)result;
                                    minx = 0.315f + (0.37f * GetPosition(box.x)) - .007f;
                                    miny = 0f + (0.8f * GetPosition(box.z)) - .009f;
                                    maxx = minx + .014f;
                                    maxy = miny + .018f;
                                    UI.LoadImage(ref element, PanelFactions, TryForImage("box"), $"{minx} {miny}", $"{maxx} {maxy}");
                                }
                            }
                        if (LastFactionStanding)
                        {
                            var result = LFSLocation(faction);
                            if (result is Vector3)
                            {
                                Vector3 battle = (Vector3)result;
                                minx = 0.315f + (0.37f * GetPosition(battle.x)) - .03f;
                                miny = 0f + (0.8f * GetPosition(battle.z)) - .04f;
                                maxx = minx + .06f;
                                maxy = miny + .08f;
                                UI.LoadImage(ref element, PanelFactions, TryForImage("battle"), $"{minx} {miny}", $"{maxx} {maxy}");
                            }
                        }
                    }

                        minx = 0.315f + (0.37f * GetPosition(player.transform.localPosition.x)) - .005f;
                        miny = 0f + (0.8f * GetPosition(player.transform.localPosition.z)) - .007f;
                        maxx = minx + .01f;
                        maxy = miny + .014f;
                        UI.LoadImage(ref element, PanelFactions, TryForImage("Self"), $"{minx} {miny}", $"{maxx} {maxy}");
                    if (faction != 0)
                        if (isOwner(player, faction) || isModerator(player, faction))
                        {
                            i = 0;
                            pos = LeftPanelPos(i);
                            if (FactionsTax)
                            {
                                UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("SetTaxBox"), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"RunConsoleCommand UI_SetTaxBox");
                                i++;
                            }
                            if (configData.SafeZones_Allow && ZoneManager)
                            {
                                pos = LeftPanelPos(i);
                                object result = ZoneManager?.Call("AddPlayerToZoneWhitelist", GetFactionPlayer(player).Faction.ToString(), player);
                                if (result != null && result is bool && (bool)result)
                                {
                                    UI.LoadImage(ref element, PanelFactions, TryForImage("DarkButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                    UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("DeleteFactionSafeZone"), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                    UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_SafeZone delete");
                                }
                                else
                                {
                                    UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                    UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("CreateFactionSafeZone"), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                    UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_SafeZone create");
                                }
                            }
                        }
                    break;
                case "FLIST":
                    if (faction != 0)
                    {
                        var FactionData = fdata.Factions[faction];
                        if (!string.IsNullOrEmpty(FactionData.embleem))
                            UI.LoadImage(ref element, PanelFactions, TryForImage(FactionData.embleem), "0.37 .1", ".63 .7");
                        i = 0;
                        pos = LeftPanelPos(i);
                        UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                        UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("ToggleOnlineOnly", player), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                        UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 8, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_ToggleOnlineOnly", TextAnchor.MiddleCenter);
                        List<ulong> FactionPlayers = new List<ulong>();
                        if (fp.OnlineOnly)
                        {
                            UI.CreateTextOutline(ref element, PanelFactions, FactionData.UIColor, UIColors["white"], GetMSG("OnlineOnly", player, FactionData.Name), 18, "0.315 0.8", ".685 .85", TextAnchor.UpperCenter);
                            FactionPlayers = BasePlayer.activePlayerList.Where(k => k.userID != player.userID && FactionData.factionPlayers.Contains(k.userID)).Select(k => k.userID).ToList();
                        }
                        else
                        {
                            UI.CreateTextOutline(ref element, PanelFactions, FactionData.UIColor, UIColors["white"], GetMSG("AllMembers", player, FactionData.Name), 18, "0.315 0.8", ".685 .85", TextAnchor.UpperCenter);
                            FactionPlayers = FactionData.factionPlayers.Where(k => k != player.userID).ToList();
                        }
                        count = FactionData.factionPlayers.Where(k => k != player.userID).Count();
                        entriesallowed = 38;
                        remainingentries = count - (page * entriesallowed);
                        if (page > 0)
                        {
                            UI.LoadImage(ref element, PanelFactions, TryForImage("BACK"), "0.56 0.03", "0.61 0.13");
                            UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 18, "0.56 0.03", "0.61 0.13", $"UI_FC_TurnPage {page - 1}");
                        }
                        if (remainingentries > entriesallowed)
                        {

                            UI.LoadImage(ref element, PanelFactions, TryForImage("NEXT"), "0.62 0.03", "0.67 0.13");
                            UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 18, "0.62 0.03", "0.67 0.13", $"UI_FC_TurnPage {page + 1}");
                        }
                        shownentries = page * entriesallowed;
                        i = 0;
                        n = 0;
                        foreach (var entry in FactionPlayers)
                        {
                            i++;
                            if (i < shownentries + 1) continue;
                            else if (i <= shownentries + entriesallowed)
                            {
                                pos = MiddlePanelPos(n);
                                var name = GetDisplayName(entry);
                                UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                UI.CreateLabel(ref element, PanelFactions, UIColors["white"], name, 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_FC_ChangePanel FLIST {entry}");
                                n++;
                            }
                        }
                        if (fp.TargetPlayer != new ulong())
                        {
                            var Playerdata = fdata.Players[fp.TargetPlayer];
                            //UI.CreatePanel(ref element, PanelFactions, UIColors["white"], "0.695 0", ".865 .8");
                            UI.LoadImage(ref element, PanelFactions, TryForImage(fp.TargetPlayer.ToString(), 0), "0.73 0.55", ".83 .79");
                            UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetDisplayName(fp.TargetPlayer), 16, "0.7 0.49", ".86 .55", TextAnchor.UpperCenter);
                            UI.LoadImage(ref element, PanelFactions, TryForImage("hourglass"), "0.73 .41", ".76 .49");
                            UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("PlayTimeMinutes", player, Playerdata.RustLifeTime.ToString(), Playerdata.RustTwoWeekTime.ToString()), 10, "0.77 .39", ".86 .49", TextAnchor.MiddleLeft);
                            UI.CreateLabel(ref element, PanelFactions, UIColors["white"], BasePlayer.activePlayerList.Contains(BasePlayer.FindByID(fp.TargetPlayer)) ? GetMSG("ONLINE") : GetMSG("OFFLINE"), 16, "0.7 .34", ".86 .39");
                            if (isOwner(player, faction) || isModerator(player, faction))
                            {
                                if (FactionData.Leader == player.userID)
                                {
                                    i = 7;
                                    pos = RightPanelPos(i);
                                    if (!FactionData.Moderators.Contains(fp.TargetPlayer))
                                    {
                                        UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                        UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("AddModerator"), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                        UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 8, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_FC_Moderator add", TextAnchor.MiddleCenter);
                                        i++;
                                    }
                                    else
                                    {
                                        UI.LoadImage(ref element, PanelFactions, TryForImage("DarkButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                        UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("RemoveModerator"), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                        UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 8, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_FC_Moderator remove", TextAnchor.MiddleCenter);
                                        i++;
                                    }
                                }
                                i = 8;
                                pos = RightPanelPos(i);
                                if (fdata.Players[fp.TargetPlayer].faction == faction)
                                {
                                    UI.LoadImage(ref element, PanelFactions, TryForImage("DarkButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                    UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("KickFromFaction"), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                    UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 8, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_FC_KickPlayer", TextAnchor.MiddleCenter);
                                }
                            }
                        }
                        if (FactionData.Leader == player.userID || FactionData.Moderators.Contains(player.userID))
                        {
                            i = 7;
                            pos = LeftPanelPos(i);
                            UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                            UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("TogglePrivate", player, FactionData.Private.ToString()), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                            UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_FC_TogglePrivate");
                            i++;
                            pos = LeftPanelPos(i);
                            UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                            UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("InvitePlayers", player), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                            UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_FC_ChangePanel Invite");
                            i++;

                        }
                        pos = LeftPanelPos(8);
                        UI.LoadImage(ref element, PanelFactions, TryForImage("DarkButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                        UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("LeaveFaction"), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                        UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_LeaveFaction");
