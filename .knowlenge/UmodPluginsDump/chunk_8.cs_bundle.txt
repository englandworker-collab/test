                    }
                    else
                    {
                        UI.CreateTextOutline(ref element, PanelFactions, UIColors["white"], UIColors["black"], GetMSG("NotInFaction", player), 36, "0.32 0.02", ".68 .78");
                        i = 7;
                        pos = LeftPanelPos(i);
                        if (configData.Use_AllowPlayersToCreateFactions && (configData.FactionLimit == 0 || configData.FactionLimit > fdata.Factions.Count()))
                        {
                            UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                            UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("CreateFaction"), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                            UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 8, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_NewFaction");
                            i++;
                        }
                        pos = LeftPanelPos(i);
                        UI.LoadImage(ref element, PanelFactions, TryForImage("DarkButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                        UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("JoinFaction"), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                        UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_FC_ChangePanel Selection");
                    }
                    break;
                case "Invite":
                    UI.CreateTextOutline(ref element, PanelFactions, UIColors["white"], UIColors["black"], GetMSG("MoreDetails", player), 18, "0.315 0.8", ".685 .85", TextAnchor.UpperCenter);
                    List<ulong> PlayerList = fdata.Players.Where(k => k.Value.faction == 0 && !k.Value.PendingInvites.Contains(faction)).Select(k => k.Key).ToList();
                    count = PlayerList.Count();
                    entriesallowed = 38;
                    remainingentries = count - (page * entriesallowed);
                    if (page > 0)
                    {
                        UI.LoadImage(ref element, PanelFactions, TryForImage("BACK"), "0.56 0.03", "0.61 0.13");
                        UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 18, "0.56 0.03", "0.61 0.13", $"UI_FC_TurnPage {page - 1}");
                    }
                    if (remainingentries > entriesallowed)
                    {

                        UI.LoadImage(ref element, PanelFactions, TryForImage("NEXT"), "0.62 0.03", "0.67 0.13");
                        UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 18, "0.62 0.03", "0.67 0.13", $"UI_FC_TurnPage {page + 1}");
                    }
                    shownentries = page * entriesallowed;
                    i = 0;
                    n = 0;
                    foreach (var entry in PlayerList)
                    {
                        i++;
                        if (i < shownentries + 1) continue;
                        else if (i <= shownentries + entriesallowed)
                        {
                            pos = MiddlePanelPos(n);
                            var name = GetDisplayName(entry);
                            UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                            UI.CreateLabel(ref element, PanelFactions, UIColors["white"], name, 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                            UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_FC_ChangePanel Invite {entry}");
                            n++;
                        }
                    }
                    if (fp.TargetPlayer != new ulong())
                    {
                        var Playerdata = fdata.Players[fp.TargetPlayer];
                        //UI.CreatePanel(ref element, PanelFactions, UIColors["white"], "0.695 0", ".865 .8");

                        UI.LoadImage(ref element, PanelFactions, TryForImage(fp.TargetPlayer.ToString(), 0), "0.73 0.55", ".83 .79");
                        UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetDisplayName(fp.TargetPlayer), 16, "0.7 0.49", ".86 .55", TextAnchor.UpperCenter);
                        UI.LoadImage(ref element, PanelFactions, TryForImage("hourglass"), "0.73 .41", ".76 .49");
                        UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("PlayTimeMinutes", player, Playerdata.RustLifeTime.ToString(), Playerdata.RustTwoWeekTime.ToString()), 10, "0.77 .39", ".86 .49", TextAnchor.MiddleLeft);
                        UI.CreateLabel(ref element, PanelFactions, UIColors["white"], BasePlayer.activePlayerList.Contains(BasePlayer.FindByID(fp.TargetPlayer)) ? GetMSG("ONLINE") : GetMSG("OFFLINE"), 16, "0.7 .34", ".86 .39");
                        if (isOwner(player, faction) || isModerator(player, faction))
                        {
                            if (fdata.Players[fp.TargetPlayer].faction == 0)
                            {
                                i = 8;
                                pos = RightPanelPos(i);
                                UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                UI.CreateLabel(ref element, PanelFactions, UIColors["black"], GetMSG("InviteToFaction"), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 8, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_FC_SendInvite", TextAnchor.MiddleCenter);
                            }
                        }
                    }
                    break;
                case "Selection":
                    if (fdata.Factions.Count() == 0) { GetSendMSG(player, "NoFactionsToJoin"); return; }
                    if (fp.Faction != 0)
                    {
                        GetSendMSG(player, "InAFaction");
                        return;
                    }
                    CuiHelper.DestroyUi(player, PanelFactions);
                    count = fdata.Factions.Count();
                    UI.CreateTextOutline(ref element, PanelFactions, UIColors["white"], UIColors["black"], GetMSG("FactionSelectionTitle", player), 18, "0.315 0.8", ".685 .85", TextAnchor.UpperCenter);
                    entriesallowed = 38;
                    remainingentries = count - (page * entriesallowed);
                    if (page > 0)
                    {
                        UI.LoadImage(ref element, PanelFactions, TryForImage("BACK"), "0.56 0.03", "0.61 0.13");
                        UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 18, "0.56 0.03", "0.61 0.13", $"UI_FC_TurnPage {page - 1}");
                    }
                    if (remainingentries > entriesallowed)
                    {

                        UI.LoadImage(ref element, PanelFactions, TryForImage("NEXT"), "0.62 0.03", "0.67 0.13");
                        UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 18, "0.62 0.03", "0.67 0.13", $"UI_FC_TurnPage {page + 1}");
                    }
                    shownentries = page * entriesallowed;
                    i = 0;
                    n = 0;
                    foreach (var entry in fdata.Factions.Where(k => !k.Value.BanList.Contains(player.userID) && !k.Value.Private))
                    {
                        i++;
                        if (i < shownentries + 1) continue;
                        else if (i <= shownentries + entriesallowed)
                        {
                            pos = MiddlePanelPos(n);
                            UI.CreateButton(ref element, PanelFactions, entry.Value.UIColor, entry.Value.Name, 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_FactionInfo {entry.Key}"); n++;
                        }
                    }
                    if (fp.SelectedFaction != new ushort())
                    {
                        //UI.CreatePanel(ref element, PanelFactions, UIColors["white"], "0.695 0", ".865 .8");
                        var f = fdata.Factions[fp.SelectedFaction];
                        UI.CreateTextOutline(ref element, PanelFactions, f.UIColor, UIColors["white"], f.Name, 18, "0.7 0.74", ".86 .78", TextAnchor.UpperCenter);
                        if (!string.IsNullOrEmpty(f.embleem))
                            UI.LoadImage(ref element, PanelFactions, TryForImage(f.embleem), "0.73 0.5", ".83 .74");
                        UI.CreateLabel(ref element, PanelFactions, f.UIColor, GetMSG("CreationLeader", player, fdata.Players.ContainsKey(f.Leader) ? GetDisplayName(f.Leader) : "NONE"), 14, "0.7 .44", ".86 .49");
                        UI.CreateLabel(ref element, PanelFactions, f.UIColor, GetMSG("CreationPlayerCount", player, f.factionPlayers.Count().ToString()), 14, "0.7 .39", ".86 .44");
                        UI.CreateLabel(ref element, PanelFactions, f.UIColor, f.description, 10, "0.7 .15", ".86 .39");
                        pos = RightPanelPos(8);
                        UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                        UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("JoinFaction"), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                        UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 8, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_FactionSelection", TextAnchor.MiddleCenter);
                    }
                    break;

                case "PLIST":
                    i = 0;
                    pos = LeftPanelPos(i);
                    UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                    UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("ToggleOnlineOnly", player), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                    UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 8, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_ToggleOnlineOnly", TextAnchor.MiddleCenter);
                    List<ulong> AllPlayers = new List<ulong>();
                    if (fp.OnlineOnly)
                    {
                        UI.CreateTextOutline(ref element, PanelFactions, UIColors["white"], UIColors["black"], GetMSG("MoreDetails-OnlineOnly", player), 18, "0.315 0.8", ".685 .85", TextAnchor.UpperCenter);
                        AllPlayers = BasePlayer.activePlayerList.Where(k => k.userID != player.userID).Select(k => k.userID).ToList();
                    }
                    else
                    {
                        UI.CreateTextOutline(ref element, PanelFactions, UIColors["white"], UIColors["black"], GetMSG("MoreDetails", player), 18, "0.315 0.8", ".685 .85", TextAnchor.UpperCenter);
                        AllPlayers = fdata.Players.Where(k => k.Key != player.userID).Select(k => k.Key).ToList();
                    }
                    count = AllPlayers.Count();
                    entriesallowed = 38;
                    remainingentries = count - (page * entriesallowed);
                    if (page > 0)
                    {
                        UI.LoadImage(ref element, PanelFactions, TryForImage("BACK"), "0.56 0.03", "0.61 0.13");
                        UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 18, "0.56 0.03", "0.61 0.13", $"UI_FC_TurnPage {page - 1}");
                    }
                    if (remainingentries > entriesallowed)
                    {

                        UI.LoadImage(ref element, PanelFactions, TryForImage("NEXT"), "0.62 0.03", "0.67 0.13");
                        UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 18, "0.62 0.03", "0.67 0.13", $"UI_FC_TurnPage {page + 1}");
                    }
                    shownentries = page * entriesallowed;
                    i = 0;
                    n = 0;
                    foreach (var entry in AllPlayers)
                    {
                        i++;
                        if (i < shownentries + 1) continue;
                        else if (i <= shownentries + entriesallowed)
                        {
                            pos = MiddlePanelPos(n);
                            var name = GetDisplayName(entry);
                            UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                            UI.CreateLabel(ref element, PanelFactions, UIColors["white"], name, 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                            UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_FC_ChangePanel PLIST {entry}");
                            n++;
                        }
                    }
                    if (fp.TargetPlayer != new ulong())
                    {
                        var Playerdata = fdata.Players[fp.TargetPlayer];
                        //UI.CreatePanel(ref element, PanelFactions, UIColors["white"], "0.695 0", ".865 .8");

                        UI.LoadImage(ref element, PanelFactions, TryForImage(fp.TargetPlayer.ToString(), 0), "0.73 0.55", ".83 .79");
                        UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetDisplayName(fp.TargetPlayer), 16, "0.7 0.49", ".86 .55", TextAnchor.UpperCenter);
                        UI.LoadImage(ref element, PanelFactions, TryForImage("hourglass"), "0.73 .41", ".76 .49");
                        UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("PlayTimeMinutes", player, Playerdata.RustLifeTime.ToString(), Playerdata.RustTwoWeekTime.ToString()), 10, "0.77 .39", ".86 .49", TextAnchor.MiddleLeft);
                        UI.CreateLabel(ref element, PanelFactions, UIColors["white"], BasePlayer.activePlayerList.Contains(BasePlayer.FindByID(fp.TargetPlayer)) ? GetMSG("ONLINE") : GetMSG("OFFLINE"), 16, "0.7 .34", ".86 .39");
                        if (fdata.Players[fp.TargetPlayer].faction != 0)
                        {
                            var factiondet = fdata.Factions[fdata.Players[fp.TargetPlayer].faction];
                            UI.CreateTextOutline(ref element, PanelFactions, factiondet.UIColor, UIColors["white"], factiondet.Name, 16, ".76 .26", ".86 .36", TextAnchor.MiddleLeft);
                            if (!string.IsNullOrEmpty(factiondet.embleem))
                                UI.LoadImage(ref element, PanelFactions, TryForImage(factiondet.embleem), "0.7 0.26", ".76 .36");
                        }
                        if (isAuth(player) && AdminView.Contains(player.userID))
                        {
                            i = 8;
                            pos = RightPanelPos(i);
                            if (fdata.Players[fp.TargetPlayer].faction != 0)
                            {
                                UI.LoadImage(ref element, PanelFactions, TryForImage("DarkButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("KickFromFaction"), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 8, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_FC_KickPlayer", TextAnchor.MiddleCenter);
                            }
                            else
                            {
                                UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("AssignToFaction"), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 8, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_FC_AssignPlayer", TextAnchor.MiddleCenter);
                            }
                        }
                        else if (faction != 0 && (isOwner(player, faction) || isModerator(player, faction)))
                        {
                            if (fdata.Players[fp.TargetPlayer].faction == faction)
                            {
                                i = 7;
                                pos = RightPanelPos(i);
                                if (!fdata.Factions[faction].Moderators.Contains(fp.TargetPlayer))
                                {
                                    UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                    UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("AddModerator"), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                    UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 8, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_FC_Moderator add", TextAnchor.MiddleCenter);
                                    i++;
                                }
                                else
                                {
                                    UI.LoadImage(ref element, PanelFactions, TryForImage("DarkButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                    UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("RemoveModerator"), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                    UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 8, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_FC_Moderator remove", TextAnchor.MiddleCenter);
                                    i++;
                                }
                                i = 8;
                                pos = RightPanelPos(i);
                                UI.LoadImage(ref element, PanelFactions, TryForImage("DarkButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("KickFromFaction"), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 8, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_FC_KickPlayer", TextAnchor.MiddleCenter);
                            }
                            else if (fdata.Players[fp.TargetPlayer].faction == 0 && !fdata.Players[fp.TargetPlayer].PendingInvites.Contains(faction))
                            {
                                i = 8;
                                pos = RightPanelPos(i);
                                UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("InviteToFaction"), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 8, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_FC_SendInvite", TextAnchor.MiddleCenter);
                            }
                        }
                    }
                    break;

                case "SCOREBOARD":

                    break;
                case "Assign":
                    if (fdata.Factions.Count() == 0) return;
                    count = fdata.Factions.Count();
                    UI.CreateTextOutline(ref element, PanelFactions, UIColors["white"], UIColors["black"], GetMSG("FactionSelectionTitle", player), 18, "0.315 0.8", ".685 .85", TextAnchor.UpperCenter);
                    entriesallowed = 38;
                    remainingentries = count - (page * entriesallowed);
                    if (remainingentries > entriesallowed)
                    {
                        UI.LoadImage(ref element, PanelFactions, TryForImage("NEXT"), "0.54 0.03", "0.59 0.3");
                        UI.CreateButton(ref element, PanelFactions, "0 0 0 0", GetMSG("Next"), 18, "0.54 0.03", "0.59 0.13", $"UI_FC_TurnPage {page + 1}");
                    }
                    if (page > 0)
                    {
                        UI.LoadImage(ref element, PanelFactions, TryForImage("BACK"), "0.61 0.03", "0.66 0.3");
                        UI.CreateButton(ref element, PanelFactions, "0 0 0 0", GetMSG("Back"), 18, "0.61 0.03", "0.66 0.13", $"UI_FC_TurnPage {page - 1}");
                    }
                    shownentries = page * entriesallowed;
                    i = 0;
                    n = 0;
                    foreach (var entry in fdata.Factions)
                    {
                        i++;
                        if (i < shownentries + 1) continue;
                        else if (i <= shownentries + entriesallowed)
                        {
                            pos = MiddlePanelPos(n);
                            UI.CreateButton(ref element, PanelFactions, entry.Value.UIColor, entry.Value.Name, 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_FC_AssignPlayer {entry.Key}"); n++;
                        }
                    }
                    break;
                case "OPTIONS":
                    i = 0;
                    UI.CreateTextOutline(ref element, PanelFactions, UIColors["white"], UIColors["black"], GetMSG("Options", player), 18, "0.315 0.8", ".685 .85", TextAnchor.UpperCenter);
                    var possiblepages = 1;
                    if (possiblepages > 1 && page < possiblepages)

                    {
                        UI.LoadImage(ref element, PanelFactions, TryForImage("NEXT"), "0.54 0.03", "0.59 0.3");
                        UI.CreateButton(ref element, PanelFactions, "0 0 0 0", GetMSG("Next"), 18, "0.54 0.03", "0.59 0.13", $"UI_FC_TurnPage {page + 1}");
                    }
                    if (page > 0)
                    {
                        UI.LoadImage(ref element, PanelFactions, TryForImage("BACK"), "0.61 0.03", "0.66 0.3");
                        UI.CreateButton(ref element, PanelFactions, "0 0 0 0", GetMSG("Back"), 18, "0.61 0.03", "0.66 0.13", $"UI_FC_TurnPage {page - 1}");
                    }
                    var button = string.Empty;
                    if (page == 0)
                    {
                        if (configData.AutoAuthorization) button = "GreenSquareButton";
                        else button = "RedSquareButton";
                        CreateOptionButton(ref element, PanelFactions, button, GetMSG("AutoAuthorizationTitle"), $"UI_ChangeOption UI_AutoAuthorization AutoAuthorizationInfo AutoAuthorizationTitle {configData.AutoAuthorization}", i); i++;

                        if (configData.AuthorizeLeadersOnly) button = "GreenSquareButton";
                        else button = "RedSquareButton";
                        CreateOptionButton(ref element, PanelFactions, button, GetMSG("AuthorizeLeadersOnlyTitle"), $"UI_ChangeOption UI_AuthorizeLeadersOnly AuthorizeLeadersOnlyInfo AuthorizeLeadersOnlyTitle {configData.AuthorizeLeadersOnly}", i); i++;

                        if (configData.SafeZones_Allow) button = "GreenSquareButton";
                        else button = "RedSquareButton";
                        CreateOptionButton(ref element, PanelFactions, button, GetMSG("SafeZones_AllowTitle"), $"UI_ChangeOption UI_SafeZones_Allow SafeZones_AllowInfo SafeZones_AllowTitle {configData.SafeZones_Allow}", i); i++;

                        if (configData.DeleteEmptyFactions) button = "GreenSquareButton";
                        else button = "RedSquareButton";
                        CreateOptionButton(ref element, PanelFactions, button, GetMSG("DeleteEmptyFactionsTitle"), $"UI_ChangeOption UI_DeleteEmptyFactions DeleteEmptyFactionsInfo DeleteEmptyFactionsTitle {configData.DeleteEmptyFactions}", i); i++;

                        if (configData.DisableMenu) button = "GreenSquareButton";
                        else button = "RedSquareButton";
                        CreateOptionButton(ref element, PanelFactions, button, GetMSG("DisableMenuTitle"), $"UI_ChangeOption UI_DisableMenu DisableMenuInfo DisableMenuTitle {configData.DisableMenu}", i); i++;

                        if (configData.Use_FactionAnnouncements) button = "GreenSquareButton";
                        else button = "RedSquareButton";
                        CreateOptionButton(ref element, PanelFactions, button, GetMSG("Use_FactionAnnouncementsTitle"), $"UI_ChangeOption UI_Use_FactionAnnouncements Use_FactionAnnouncementsInfo Use_FactionAnnouncementsTitle {configData.Use_FactionAnnouncements}", i); i++;

                        if (configData.Use_PrivateFactionChat) button = "GreenSquareButton";
                        else button = "RedSquareButton";
                        CreateOptionButton(ref element, PanelFactions, button, GetMSG("Use_PrivateFactionChatTitle"), $"UI_ChangeOption UI_Use_PrivateFactionChat Use_PrivateFactionChatInfo Use_PrivateFactionChatTitle {configData.Use_PrivateFactionChat}", i); i++;

                        if (configData.LockFactionKits_and_CustomSets) button = "GreenSquareButton";
                        else button = "RedSquareButton";
                        CreateOptionButton(ref element, PanelFactions, button, GetMSG("LockFactionKits_and_CustomSetsTitle"), $"UI_ChangeOption UI_LockFactionKits_and_CustomSets LockFactionKits_and_CustomSetsInfo LockFactionKits_and_CustomSetsTitle {configData.LockFactionKits_and_CustomSets}", i); i++;

                        if (configData.Use_FactionChatControl) button = "GreenSquareButton";
                        else button = "RedSquareButton";
                        CreateOptionButton(ref element, PanelFactions, button, GetMSG("ChatControlTitle"), $"UI_ChangeOption UI_Use_FactionChatControl ChatControlInfo ChatControlTitle {configData.Use_FactionChatControl}", i); i++;

                        if (configData.Use_FactionTags) button = "GreenSquareButton";
                        else button = "RedSquareButton";
                        CreateOptionButton(ref element, PanelFactions, button, GetMSG("FactionTagOnChatTitle"), $"UI_ChangeOption UI_Use_FactionTags FactionTagOnChatInfo FactionTagOnChatTitle {configData.Use_FactionTags}", i); i++;

                        if (configData.Use_PlayerListMenu) button = "GreenSquareButton";
                        else button = "RedSquareButton";
                        CreateOptionButton(ref element, PanelFactions, button, GetMSG("Use_PlayerListMenuTitle"), $"UI_ChangeOption UI_Use_PlayerListMenu Use_PlayerListMenuInfo Use_PlayerListMenuTitle {configData.Use_PlayerListMenu}", i); i++;

                        if (configData.Allow_FriendlyFire) button = "GreenSquareButton";
                        else button = "RedSquareButton";
                        CreateOptionButton(ref element, PanelFactions, button, GetMSG("FriendlyFireTitle"), $"UI_ChangeOption UI_FriendlyFire FriendlyFireInfo FriendlyFireTitle {configData.Allow_FriendlyFire}", i); i++;

                        if (configData.Use_AllowPlayersToCreateFactions) button = "GreenSquareButton";
                        else button = "RedSquareButton";
                        CreateOptionButton(ref element, PanelFactions, button, GetMSG("PlayersToCreateFactionsTitle"), $"UI_ChangeOption UI_Use_AllowPlayersToCreateFactionsTitle PlayersToCreateFactionsInfo PlayersToCreateFactionsTitle {configData.Use_AllowPlayersToCreateFactions}", i); i++;

                        if (configData.ShowFactionPlayersOnMap) button = "GreenSquareButton";
                        else button = "RedSquareButton";
                        CreateOptionButton(ref element, PanelFactions, button, GetMSG("ShowFactionPlayersOnMapTitle "), $"UI_ChangeOption UI_Use_ShowFactionPlayersOnMap ShowFactionPlayersOnMapInfo ShowFactionPlayersOnMapTitle  {configData.ShowFactionPlayersOnMap}", i); i++;
                    }
                    if (page == 2)
                    {
                    }

                    if (page == 3)
                    {
                    }
                    pos = LeftPanelPos(7);
                    UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                    UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("CreateFaction"), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                    UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 8, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_NewFaction");
                    pos = LeftPanelPos(8);
                    UI.LoadImage(ref element, PanelFactions, TryForImage("LightButton"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                    UI.CreateLabel(ref element, PanelFactions, UIColors["white"], GetMSG("ToggleAdminView", player), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                    UI.CreateButton(ref element, PanelFactions, "0 0 0 0", "", 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_ToggleAdminView");
                    break;
            }
            CuiHelper.AddUi(player, element);
        }

        private string GetDisplayName(ulong UserID)
        {
            IPlayer player = this.covalence.Players.FindPlayer(UserID.ToString());
            if (player == null) return UserID.ToString();
            return player.Name;
        }

        private float[] LeftPanelPos(int number)
        {
            Vector2 position = new Vector2(0.15f, 0.71f);
            Vector2 dimensions = new Vector2(0.14f, 0.07f);
            float offsetY = 0;
            float offsetX = 0;
            offsetY = (-0.015f - dimensions.y) * number;
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] RightPanelPos(int number)
        {
            Vector2 position = new Vector2(0.71f, 0.71f);
            Vector2 dimensions = new Vector2(0.14f, 0.07f);
            float offsetY = 0;
            float offsetX = 0;
            offsetY = (-0.015f - dimensions.y) * number;
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }


        private float[] MiddlePanelPos(int number)
        {
            Vector2 position = new Vector2(0.325f, 0.68f);
            Vector2 dimensions = new Vector2(0.065f, 0.07f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 5)
            {
                offsetX = (0.005f + dimensions.x) * number;
            }
            if (number > 4 && number < 10)
            {
                offsetX = (0.005f + dimensions.x) * (number - 5);
                offsetY = (-0.02f - dimensions.y) * 1;
            }
            if (number > 9 && number < 15)
            {
                offsetX = (0.005f + dimensions.x) * (number - 10);
                offsetY = (-0.02f - dimensions.y) * 2;
            }
            if (number > 14 && number < 20)
            {
                offsetX = (0.005f + dimensions.x) * (number - 15);
                offsetY = (-0.02f - dimensions.y) * 3;
            }
            if (number > 19 && number < 25)
            {
                offsetX = (0.005f + dimensions.x) * (number - 20);
                offsetY = (-0.02f - dimensions.y) * 4;
            }
            if (number > 24 && number < 30)
            {
                offsetX = (0.005f + dimensions.x) * (number - 25);
                offsetY = (-0.02f - dimensions.y) * 5;
            }
            if (number > 29 && number < 35)
            {
                offsetX = (0.005f + dimensions.x) * (number - 30);
                offsetY = (-0.02f - dimensions.y) * 6;
            }
            if (number > 34 && number < 40)
            {
                offsetX = (0.005f + dimensions.x) * (number - 35);
                offsetY = (-0.02f - dimensions.y) * 7;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] OptionButtonPos(int number)
        {
            Vector2 position = new Vector2(0.325f, 0.66f);
            Vector2 dimensions = new Vector2(0.11f, 0.11f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 3)
            {
                offsetX = (0.005f + dimensions.x) * number;
            }
            if (number > 2 && number < 6)
            {
                offsetX = (0.005f + dimensions.x) * (number - 3);
                offsetY = (-0.02f - dimensions.y) * 1;
            }
            if (number > 5 && number < 9)
            {
                offsetX = (0.005f + dimensions.x) * (number - 6);
                offsetY = (-0.02f - dimensions.y) * 2;
            }
            if (number > 8 && number < 12)
            {
                offsetX = (0.005f + dimensions.x) * (number - 9);
                offsetY = (-0.02f - dimensions.y) * 3;
            }
            if (number > 11 && number < 15)
            {
                offsetX = (0.005f + dimensions.x) * (number - 12);
                offsetY = (-0.02f - dimensions.y) * 4;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }


        private object GetBasePlayer(ulong ID)
        {
            try
            {
                BasePlayer player = BasePlayer.FindByID(ID);
                if (BasePlayer.activePlayerList.Contains(player))
                    return player;
                else return null;
            }
            catch
            {
                return null;
            }
        }

        [ConsoleCommand("UI_FC_TogglePrivate")]
        void cmdUI_FC_TogglePrivate(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            FactionPlayer fp = GetFactionPlayer(player);
            if (fp == null) return;
            if (!isOwner(player, fp.Faction) && !isModerator(player, fp.Faction)) return;
            if (fdata.Factions[fp.Faction].Private)
            {
                fdata.Factions[fp.Faction].Private = false;
                OnScreen(player, "NoLongerPrivate");
            }
            else
            {
                fdata.Factions[fp.Faction].Private = true;
                OnScreen(player, "NowPrivate");
            }
            FactionPanel(player);
        }

        [ConsoleCommand("UI_FC_SendInvite")]
        private void cmdUI_FC_SendInvite(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null) return;
            if (!isOwner(player, GetFactionPlayer(player).Faction)) return;
            var faction = GetFactionPlayer(player).Faction;
            if (GetFactionPlayer(player).TargetPlayer == new ulong()) return;
            if (!fdata.Players[GetFactionPlayer(player).TargetPlayer].PendingInvites.Contains(faction))
                fdata.Players[GetFactionPlayer(player).TargetPlayer].PendingInvites.Add(faction);
            GetFactionPlayer(player).TargetPlayer = new ulong();
            FactionPanel(player);
        }

        [ConsoleCommand("UI_FC_Moderator")]
        private void cmdUI_FC_Moderator(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (!isAuth(player) && !isOwner(player, GetFactionPlayer(player).Faction)) return;
            var faction = fdata.Factions[GetFactionPlayer(player).Faction];
            if (GetFactionPlayer(player).TargetPlayer == new ulong()) return;
            string Action = arg.Args[0];
            ulong target = GetFactionPlayer(player).TargetPlayer;
            if (Action == "add")
            {
                if (faction.factionPlayers.Contains(target) && !faction.Moderators.Contains(target))
                    faction.Moderators.Add(target);
            }
            else if (faction.factionPlayers.Contains(target) && faction.Moderators.Contains(target))
                faction.Moderators.Remove(target);
            FactionPanel(player);
        }


        [ConsoleCommand("UI_FC_KickPlayer")]
        private void cmdUI_FC_KickPlayer(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (!isAuth(player) && !isOwner(player, GetFactionPlayer(player).Faction) && !isModerator(player, GetFactionPlayer(player).Faction)) return;
            if (GetFactionPlayer(player).TargetPlayer == new ulong()) return;
            ulong target = GetFactionPlayer(player).TargetPlayer;
            UnassignPlayerFromFaction(target, true);
            if (!isAuth(player) || !AdminView.Contains(player.userID))
                GetFactionPlayer(player).TargetPlayer = new ulong();
            FactionPanel(player);
        }

        [ConsoleCommand("UI_FC_AssignPlayer")]
        private void cmdUI_AssignPlayer(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (!isAuth(player)) return;
            if (GetFactionPlayer(player).TargetPlayer == new ulong()) return;
            ulong target = GetFactionPlayer(player).TargetPlayer;
            if (arg.Args == null || arg.Args.Count() == 0)
                GetFactionPlayer(player).Panel = "Assign";
            else
            {
                var faction = Convert.ToUInt16(arg.Args[0]);
                BasePlayer Target = BasePlayer.FindByID(target);
                if (Target == null)
                {
                    var PlayerData = fdata.Players[target];
                    PlayerData.faction = faction;
                    PlayerData.PendingInvites.Clear();
                    if (!fdata.Factions[faction].factionPlayers.Contains(target))
                        fdata.Factions[faction].factionPlayers.Add(target);
                    if (fdata.Factions[faction].factionPlayers.Count() <= 1)
                        fdata.Factions[faction].Leader = target;
                    ConsoleSystem.Run(ConsoleSystem.Option.Server, $"usergroup add {target} {fdata.Factions[faction].group}");
                    SaveData();
                    Broadcast($"<color={GetMSG("JoinedFaction", player, fdata.Factions[faction].ChatColor, GetDisplayName(target), fdata.Factions[faction].Name)}</color>");
                }
                else
                {
                    AssignPlayerToFaction(Target, faction);
                }
                GetFactionPlayer(player).SelectedFaction = new ushort();
                GetFactionPlayer(player).Panel = "PLIST";
            }
            FactionPanel(player);
        }

        #endregion

        [ConsoleCommand("UI_ChangeOption")]
        private void cmdChangeOption(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var cmd = arg.Args[0];
            var verbiage = arg.Args[1];
            var optionName = arg.Args[2];
            var status = arg.Args[3];
            ChangeOption(player, cmd, verbiage, optionName, status);
        }

        void ChangeOption(BasePlayer player, string cmd, string verbiage, string optionName, string status)
        {
            CuiHelper.DestroyUi(player, PanelOnScreen);
            string state = "";
            if (status.ToUpper() == "FALSE") state = lang.GetMessage($"FALSE", this);
            if (status.ToUpper() == "TRUE") state = lang.GetMessage($"TRUE", this);
            string title = string.Format(lang.GetMessage($"OptionChangeTitle", this), lang.GetMessage($"{optionName}", this), state);
            string change = "";
            if (status.ToUpper() == "FALSE") change = lang.GetMessage($"TRUE", this);
            else change = lang.GetMessage($"FALSE", this);
            var element = UI.CreateOverlayContainer(PanelOnScreen, UIColors["dark"], "0.3 0.3", "0.7 0.7", true);
            UI.CreatePanel(ref element, PanelOnScreen, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, PanelOnScreen, UIColors["header"], title, 18, "0.03 0.85", "0.97 .95", TextAnchor.UpperCenter);
            UI.CreateLabel(ref element, PanelOnScreen, UIColors["dark"], lang.GetMessage($"{verbiage}", this), 18, "0.03 0.27", "0.97 0.83", TextAnchor.UpperLeft);
            UI.CreateLabel(ref element, PanelOnScreen, UIColors["dark"], string.Format(lang.GetMessage($"OptionChangeMSG", this), change), 18, "0.2 0.18", "0.8 0.26", TextAnchor.MiddleCenter);
            UI.CreateButton(ref element, PanelOnScreen, UIColors["buttonbg"], "Yes", 18, "0.2 0.05", "0.4 0.15", $"{cmd}");
            UI.CreateButton(ref element, PanelOnScreen, UIColors["buttonred"], "No", 16, "0.6 0.05", "0.8 0.15", $"UI_DestroyOnScreenPanel");
            CuiHelper.AddUi(player, element);
        }

        private void CreateOptionButton(ref CuiElementContainer container, string panelName, string button, string name, string cmd, int num)
        {
            var pos = OptionButtonPos(num);
            UI.LoadImage(ref container, panelName, TryForImage(button), $"{ pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
            UI.CreateLabel(ref container, panelName, UIColors["black"], name, 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
            UI.CreateButton(ref container, panelName, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", cmd);
        }


        [ConsoleCommand("UI_DestroyOnScreenPanel")]
        private void cmdUI_DestroyOnScreenPanel(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null) return;
            CuiHelper.DestroyUi(player, PanelOnScreen);
        }

        [ConsoleCommand("UI_AutoAuthorization")]
        private void cmdUI_AutoAuthorization(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.AutoAuthorization == true) configData.AutoAuthorization = false;
            else configData.AutoAuthorization = true;
            FactionPanel(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_AuthorizeLeadersOnly")]
        private void cmdUI_AuthorizeLeadersOnly(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.AuthorizeLeadersOnly == true) configData.AuthorizeLeadersOnly = false;
            else configData.AuthorizeLeadersOnly = true;
            FactionPanel(player);
            SaveConfig(configData);
        }
        [ConsoleCommand("UI_DeleteEmptyFactions")]
        private void cmdUI_DeleteEmptyFactions(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.DeleteEmptyFactions == true) configData.DeleteEmptyFactions = false;
            else configData.DeleteEmptyFactions = true;
            FactionPanel(player);
            SaveConfig(configData);
        }
        [ConsoleCommand("UI_SafeZones_Allow")]
        private void cmdUI_SafeZones_Allow(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.SafeZones_Allow == true) configData.SafeZones_Allow = false;
            else configData.SafeZones_Allow = true;
            FactionPanel(player);
            SaveConfig(configData);
        }
        [ConsoleCommand("UI_DisableMenu")]
        private void cmdUI_DisableMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.DisableMenu == true) configData.DisableMenu = false;
            else configData.DisableMenu = true;
            FactionPanel(player);
            SaveConfig(configData);
        }
        [ConsoleCommand("UI_Use_FactionAnnouncements")]
        private void cmdUI_Use_FactionAnnouncements(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_FactionAnnouncements == true) configData.Use_FactionAnnouncements = false;
            else configData.Use_FactionAnnouncements = true;
            FactionPanel(player);
            SaveConfig(configData);
        }
        [ConsoleCommand("UI_Use_PrivateFactionChat")]
        private void cmdUI_Use_PrivateFactionChat(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_PrivateFactionChat == true) configData.Use_PrivateFactionChat = false;
            else configData.Use_PrivateFactionChat = true;
            FactionPanel(player);
            SaveConfig(configData);
        }
        [ConsoleCommand("UI_Use_ShowFactionPlayersOnMap")]
        private void cmdUI_Use_ShowFactionPlayersOnMap(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.ShowFactionPlayersOnMap == true) configData.ShowFactionPlayersOnMap = false;
            else configData.ShowFactionPlayersOnMap = true;
            FactionPanel(player);
            SaveConfig(configData);
        }
        [ConsoleCommand("UI_LockFactionKits_and_CustomSets")]
        private void cmdUI_LockFactionKits_and_CustomSets(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.LockFactionKits_and_CustomSets == true) configData.LockFactionKits_and_CustomSets = false;
            else configData.LockFactionKits_and_CustomSets = true;
            FactionPanel(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_Use_FactionChatControl")]
        private void cmdFactionChatControl(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_FactionChatControl == true) configData.Use_FactionChatControl = false;
            else configData.Use_FactionChatControl = true;
            FactionPanel(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_Use_FactionTags")]
        private void cmdUI_Use_FactionTags(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_FactionTags == true) configData.Use_FactionTags = false;
            else configData.Use_FactionTags = true;
            FactionPanel(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_Use_AllowPlayersToCreateFactionsTitle")]
        private void cmdUI_Use_AllowPlayersToCreateFactionsTitle(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_AllowPlayersToCreateFactions == true) configData.Use_AllowPlayersToCreateFactions = false;
            else configData.Use_AllowPlayersToCreateFactions = true;
            FactionPanel(player);
            SaveConfig(configData);
        }


        [ConsoleCommand("UI_Use_PlayerListMenu")]
        private void cmdShowOnlinePlayers(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Use_PlayerListMenu == true) configData.Use_PlayerListMenu = false;
            else configData.Use_PlayerListMenu = true;
            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, PanelPlayer);
                PlayerPanel(player);
            }
            FactionPanel(player);
            SaveConfig(configData);
        }

        [ConsoleCommand("UI_FriendlyFire")]
        private void cmdFriendlyFire(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (configData.Allow_FriendlyFire == true) configData.Allow_FriendlyFire = false;
            else configData.Allow_FriendlyFire = true;
            FactionPanel(player);
            SaveConfig(configData);
        }

        #region UI Commands

        private int GetRandomNumber()
        {
            var random = new System.Random();
            int number = random.Next(int.MinValue, int.MaxValue);
            return number;
        }


        [ConsoleCommand("UI_NewFaction")]
        private void cmdNewFaction(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (!isAuth(player) && GetFactionPlayer(player).Faction != 0)
            {
                GetSendMSG(player, "InAFaction");
                return;
            }
            if (FactionDetails.ContainsKey(player.userID))
                FactionDetails.Remove(player.userID);
            ushort index = (ushort)GetRandomNumber();
            while (fdata.Factions.ContainsKey(index))
            {
                index++;
            }
            FactionDetails.Add(player.userID, new FactionDesigner { ID = index, creating = true, faction = new Faction { }, stepNum = 0 });
            DestroyUI(player);
            FactionCreation(player);
        }

        [ConsoleCommand("UI_Description")]
        private void cmdUI_Description(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var type = arg.Args[0];
            if (type == "save")
            {
                FactionCreation(player, 99);
            }
            else if (type == "continue")
            {
                FactionCreation(player, 7);
            }
        }

        [ConsoleCommand("UI_SelectColor")]
        private void cmdSelectColor(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var Color = arg.Args[0];
            FactionDesigner Creator;
            if (FactionDetails.ContainsKey(player.userID))
                Creator = FactionDetails[player.userID];
            else Creator = FactionEditor[player.userID];
            Creator.faction.ChatColor = Color;
            Creator.faction.UIColor = HexTOUIColor(Color);
            Creator.faction.group = Creator.faction.Name;
            DestroyUI(player);
            if (FactionEditor.ContainsKey(player.userID))
            {
                FactionCreation(player, 20);
                return;
            }
            Creator.stepNum = 3;
            FactionCreation(player, 4);
        }

        [ConsoleCommand("UI_SelectKit")]
        private void cmdUI_SelectKit(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var kit = string.Join(" ", arg.Args);
            FactionDesigner Creator;
            if (FactionDetails.ContainsKey(player.userID))
                Creator = FactionDetails[player.userID];
            else Creator = FactionEditor[player.userID];
            Creator.faction.KitorSet = kit;
            DestroyUI(player);
            if (FactionEditor.ContainsKey(player.userID))
            {
                FactionCreation(player, 20);
                return;
            }
            Creator.stepNum = 3;
            FactionCreation(player, 5);
        }


        [ConsoleCommand("UI_ViewKit")]
        private void cmdUI_ViewKit(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var kit = string.Join(" ", arg.Args);
            CuiHelper.DestroyUi(player, PanelOnScreen);
            var i = 0;
            var element = UI.CreateElementContainer(PanelOnScreen, "0 0 0 0", "0.71 0.3", "0.86 0.9");
            UI.CreateLabel(ref element, PanelOnScreen, "1 1 1 1", GetMSG("KitContents", player, kit), 16, "0 0.87", "1 0.97", TextAnchor.MiddleCenter);
            List<string> setcontents = new List<string>();
            setcontents = GetSetContents(kit);
            if (setcontents == null) return;
            foreach (var item in setcontents)
            {
                var name = item.Substring(0, item.IndexOf('_'));
                ulong skin;
                if (!ulong.TryParse(item.Substring(item.IndexOf('_') + 1, item.Length - (item.IndexOf('_') + 5)), out skin)) skin = 0;
                var pos = CalcEquipPos(i);
                UI.LoadImage(ref element, PanelOnScreen, TryForImage(name, skin), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                i++;
            }
            UI.CreateButton(ref element, PanelOnScreen, UIColors["buttonred"], GetMSG("Close", player), 14, "0.67 0.02", "0.97 0.08", $"UI_FC_DestroyOnScreenPanel");
            CuiHelper.AddUi(player, element);
        }


        [ConsoleCommand("UI_FC_DestroyOnScreenPanel")]
        private void cmdUI_FC_DestroyOnScreenPanel(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null) return;
            CuiHelper.DestroyUi(player, PanelOnScreen);
        }

        [ConsoleCommand("UI_SelectEmbleem")]
        private void cmdUI_SelectEmbleem(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int index;
            if (!int.TryParse(arg.Args[0], out index)) return;
            FactionDesigner Creator;
            if (FactionDetails.ContainsKey(player.userID))
                Creator = FactionDetails[player.userID];
            else Creator = FactionEditor[player.userID];
            Creator.faction.embleem = $"Embleem{index}";
            DestroyUI(player);
            if (FactionEditor.ContainsKey(player.userID))
            {
                FactionCreation(player, 20);
                return;
            }
            Creator.stepNum = 1;
            FactionCreation(player, 1);
        }

        [ConsoleCommand("UI_SaveFaction")]
        private void cmdUI_SaveFaction(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (FactionDetails.ContainsKey(player.userID))
                SaveFaction(player);
        }

        [ConsoleCommand("UI_DeleteFaction")]
        private void cmdUI_DeleteFaction(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (!player.IsAdmin) return;
            ushort ID;
            if (!ushort.TryParse(arg.Args[0], out ID))
            {
                if (arg.Args[0] == "yes")
                {
                    ID = Convert.ToUInt16(arg.Args[1]);
                    if (!fdata.Factions.ContainsKey(ID)) return;
                    fdata.Factions.Remove(ID);
                }
                ManageFactionMenu(player);
                return;
            }
            else
            {
                ConfirmFactionDeletion(player, ID);
                return;
            }
        }


        [ConsoleCommand("UI_ExitFactionCreation")]
        private void cmdUI_ExitFactionCreation(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            ExitFactionCreation(player);
        }

        private void ExitFactionCreation(BasePlayer player)
        {
            if (FactionDetails.ContainsKey(player.userID))
                FactionDetails.Remove(player.userID);
            else FactionEditor.Remove(player.userID);
            GetSendMSG(player, "QuitFactionCreation");
            DestroyUI(player);
        }
        private void SaveFaction(BasePlayer player)
        {
            FactionDesigner Creator;
            if (FactionDetails.ContainsKey(player.userID))
            {
                Creator = FactionDetails[player.userID];
                var faction = Creator.ID;
                fdata.Factions.Add(Creator.ID, Creator.faction);
                FactionDetails.Remove(player.userID);
                GetSendMSG(player, "NewFactionCreated", Creator.faction.Name);
                if (GetFactionPlayer(player).Faction == 0 && !AdminView.Contains(player.userID))
                {
                    AssignPlayerToFaction(player, faction);
                }
                ConsoleSystem.Run(ConsoleSystem.Option.Server, $"group add {fdata.Factions[faction].group}");
            }
            else if (FactionEditor.ContainsKey(player.userID))
            {
                Creator = FactionEditor[player.userID];
                fdata.Factions.Remove(Creator.ID);
                fdata.Factions.Add(Creator.ID, Creator.faction);
                FactionEditor.Remove(player.userID);
                GetSendMSG(player, "FactionEdited", Creator.faction.Name);
            }
            DestroyUI(player);
            SaveData();
        }

        [ConsoleCommand("UI_FC_TurnPage")]
        private void cmdUI_ChangePage(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (!GetFactionPlayer(player).open) return;
            int page = Convert.ToInt32(arg.Args[0]);
            GetFactionPlayer(player).page = page;
            FactionPanel(player);
        }

        [ConsoleCommand("UI_FC_ChangePanel")]
        private void cmdUI_FC_ChangePanel(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null) return;
            FactionPlayer fp = GetFactionPlayer(player);
            if (fp == null) { InitializeFactionPlayer(player); return; }
            var panel = arg.Args[0];
            if (panel != fp.Panel)
            {
                if (panel == "MAP" && !configData.Use_Map)
                {
                    GetSendMSG(player, "MapDisabled");
                    return;
                }
                    fp.Panel = panel;
                fp.page = 0;
                fp.TargetPlayer = new ulong();
            }
            if (arg.Args != null && arg.Args.Length > 1)
            {
                ulong id;
                if (ulong.TryParse(arg.Args[1], out id)) fp.TargetPlayer = id;
                ushort Fid;
                if (ushort.TryParse(arg.Args[1], out Fid)) fp.SelectedFaction = Fid;
            }
            if (Professions)
                player.SendConsoleCommand("UI_ToggleProfessionsMenu close");
            if (CustomSets)
                player.SendConsoleCommand("ToggleCSUI close");
            FactionPanel(player);
        }

        [ConsoleCommand("UI_FactionInfo")]
        private void cmdUI_FactionInfo(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            ushort faction = Convert.ToUInt16(arg.Args[0]);
            GetFactionPlayer(player).SelectedFaction = faction;
            FactionPanel(player);
        }



        [ConsoleCommand("UI_ToggleOnlineOnly")]
        private void cmdUI_ToggleOnlineOnly(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (GetFactionPlayer(player).OnlineOnly)
                GetFactionPlayer(player).OnlineOnly = false;
            else
                GetFactionPlayer(player).OnlineOnly = true;
            GetFactionPlayer(player).TargetPlayer = new ulong();
            GetFactionPlayer(player).page = 0;
            FactionPanel(player);
        }

        [ConsoleCommand("UI_ToggleAdminView")]
        private void cmdUI_ToggleAdminView(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (!isAuth(player)) return;
            if (AdminView.Contains(player.userID))
            {
                AdminView.Remove(player.userID);
                OnScreen(player, "ExitAdminView");
            }
            else
            {
                AdminView.Add(player.userID);
                OnScreen(player, "EnterAdminView");
            }
        }

        [ConsoleCommand("UI_FactionSelection")]
        private void cmdFactionSelection(ConsoleSystem.Arg arg)
        {

            var player = arg.Connection.player as BasePlayer;
            if (player == null) return;
            ushort faction = GetFactionPlayer(player).SelectedFaction;
            var selectioncount = fdata.Factions[faction].factionPlayers.Count;
            if (configData.AllowedFactionDifference != 0)
            {
                var max = GetMax();
                var min = GetMin();
                int diff = max - min;
                if (max != 0 && selectioncount == max && diff >= configData.AllowedFactionDifference)
                {
                    GetSendMSG(player, "FactionToFull", fdata.Factions[faction].Name);
                    return;
                }
            }
            if (configData.FactionPlayerLimit != 0 && configData.FactionPlayerLimit <= selectioncount)
            {
                GetSendMSG(player, "FactionAtLimit", fdata.Factions[faction].Name);
                return;
            }
            DestroyUI(player);
            if (JoinCooldown.Contains(player.userID))
            { GetSendMSG(player, "FactionJoinCooldown"); return; }
            AssignPlayerToFaction(player, faction);
        }

        [ConsoleCommand("UI_AssignPlayerFaction")]
        private void cmdUI_AssignPlayerFaction(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            ushort faction = Convert.ToUInt16(arg.Args[0]);
            AssignPlayerToFaction(player, faction);
            CuiHelper.DestroyUi(player, PanelFactions);
        }

        [ConsoleCommand("UI_LeaveFaction")]
        private void cmdUI_LeaveFaction(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var faction = GetFactionPlayer(player).Faction;
            var factionname = fdata.Factions[faction].Name;
            UnassignPlayerFromFaction(player.userID);
            SetJoinCooldown(player);
            PlayerPanel(player);
            FactionPanel(player);
        }

        private int GetMax()
        {
            int max = 0;
            foreach (var entry in fdata.Factions)
                if (entry.Value.factionPlayers.Count > max) max = entry.Value.factionPlayers.Count;
            return max;
        }

        private int GetMin()
        {
            int min = 999999;
            foreach (var entry in fdata.Factions)
                if (entry.Value.factionPlayers.Count < min) min = entry.Value.factionPlayers.Count;
            return min;
        }

        private void SetJoinCooldown(BasePlayer player)
        {
            if (JoinCooldown.Contains(player.userID))
                JoinCooldown.Remove(player.userID);
            else
            {
                JoinCooldown.Add(player.userID);
                timers.Add(player.userID.ToString(), timer.Once(600, () => SetJoinCooldown(player)));
            }
        }


        private void AssignPlayerToFaction(BasePlayer player, ushort faction)
        {
            var p = GetFactionPlayer(player);
            var factionname = fdata.Factions[faction].Name;
            if (p != null)
            {
                if (p.Faction != 0)
                {
                    if (p.Faction == faction)
                        return;
                    else
                    {
                        fdata.Factions[p.Faction].factionPlayers.Remove(player.userID);
                        ConsoleSystem.Run(ConsoleSystem.Option.Server, $"usergroup remove {player.userID} {fdata.Factions[p.Faction].group}");
                    }
                }
                p.Faction = faction;
                p.SelectedFaction = new ushort();
                fdata.Players[player.userID].PendingInvites.Clear();
                fdata.Factions[faction].factionPlayers.Add(player.userID);
                if (fdata.Factions[faction].factionPlayers.Count() <= 1)
                    fdata.Factions[faction].Leader = player.userID;
                foreach (var fp in FactionPlayers.Where(kvp => kvp.Faction == faction && kvp.player.userID != player.userID))
                    UpdateFactionListLM(fp.player.userID, factionname, fdata.Factions[faction].factionPlayers);
                AddFactionListLM(player.userID, factionname, fdata.Factions[faction].factionPlayers);
                ConsoleSystem.Run(ConsoleSystem.Option.Server, $"usergroup add {player.userID} {fdata.Factions[faction].group}");
                SaveData();
                AuthorizePlayerOnTurrets(player);
                GiveFactionGear(p.player);
                Broadcast($"<color={GetMSG("JoinedFaction", player, fdata.Factions[faction].ChatColor, GetDisplayName(player.userID), factionname)}</color>");
            }
            else InitializeFactionPlayer(player);
        }

        private void UnassignPlayerFromFaction(ulong playerID, bool admin = false)
        {
            ushort oldFaction = 0;
            try
            {
                BasePlayer player = BasePlayer.FindByID(playerID);
                if (player != null)
                {
                    if (GetFactionPlayer(player) != null && GetFactionPlayer(player).Faction != 0)
                    {
                        if (LockedUniform.ContainsKey(player.userID))
                        {
                            foreach (var entry in LockedUniform[player.userID])
                            {
                                entry.Key.RemoveFromContainer();
                                entry.Key.Remove(0f);
                            }
                            LockedUniform.Remove(player.userID);
                        }
                        oldFaction = GetFactionPlayer(player).Faction;
                        GetFactionPlayer(player).Faction = 0;
                        fdata.Factions[oldFaction].factionPlayers.Remove(playerID);
                        foreach (var fp in FactionPlayers.Where(kvp => kvp.Faction == oldFaction && kvp.player.userID != player.userID))
                            UpdateFactionListLM(fp.player.userID, fdata.Factions[oldFaction].Name, fdata.Factions[oldFaction].factionPlayers);
                        RemoveFactionListLM(player.userID, fdata.Factions[oldFaction].Name);
                        fdata.Factions[oldFaction].BanList.Add(player.userID);
                        UNAuthorizePlayerOnTurrets(player, oldFaction);
                    }
                }
                if (admin)
                {
                    OnScreen(player, "RemovedFromFaction", fdata.Factions[oldFaction].Name);
                }
            }
            catch
            {
                oldFaction = fdata.Players[playerID].faction;
                fdata.Players[playerID].faction = 0;
                if (fdata.Factions[oldFaction].factionPlayers.Contains(playerID))
                    fdata.Factions[oldFaction].factionPlayers.Remove(playerID);
            }
            BroadcastFaction(null, $"<color={GetMSG("LeftTheFaction", null, fdata.Factions[oldFaction].ChatColor, GetDisplayName(playerID), fdata.Factions[oldFaction].Name)}</color>", oldFaction);
            if (configData.DeleteEmptyFactions)
                if (fdata.Factions[oldFaction].factionPlayers.Count() == 0)
                {
                    ZoneManager.Call("EraseZone", oldFaction.ToString());
                    UnShadeZone(null, oldFaction.ToString());
                    RemoveFaction(null, oldFaction);
                }
            SaveData();
        }


        #endregion

        #region Chat Commands
        [ChatCommand("faction")]
        private void cmdFaction(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if ((configData.DisableMenu || !permission.UserHasPermission(player.UserIDString, this.Title+".allow")) && !isAuth(player)) return;
            if (!initialized)
            {
                GetSendMSG(player, "Factions is still loading images! Try again shortly.");
                return;
            }
            FactionPlayer fp = GetFactionPlayer(player);
            if (fp == null) { InitializeFactionPlayer(player); return; }
            ToggleFCMenu(player);
        }
        #endregion

        #region UI Calculations

        private float[] CalcButtonPos(int number)
        {
            Vector2 position = new Vector2(0.02f, 0.8f);
            Vector2 dimensions = new Vector2(0.15f, 0.15f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 6)
            {
                offsetX = (0.01f + dimensions.x) * number;
            }
            if (number > 5 && number < 12)
            {
                offsetX = (0.01f + dimensions.x) * (number - 6);
                offsetY = (-0.025f - dimensions.y) * 1;
            }
            if (number > 11 && number < 18)
            {
                offsetX = (0.01f + dimensions.x) * (number - 12);
                offsetY = (-0.025f - dimensions.y) * 2;
            }
            if (number > 17 && number < 24)
            {
                offsetX = (0.01f + dimensions.x) * (number - 18);
                offsetY = (-0.025f - dimensions.y) * 3;
            }
            if (number > 23 && number < 30)
            {
                offsetX = (0.01f + dimensions.x) * (number - 24);
                offsetY = (-0.025f - dimensions.y) * 4;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] CalcEquipPos(int number)
        {
            Vector2 position = new Vector2(0f, 0.73f);
            Vector2 dimensions = new Vector2(0.3f, 0.15f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 3)
            {
                offsetX = (0.05f + dimensions.x) * number;
            }
            if (number > 2 && number < 6)
            {
                offsetX = (0.05f + dimensions.x) * (number - 3);
                offsetY = (-0.001f - dimensions.y) * 1;
            }
            if (number > 5 && number < 9)
            {
                offsetX = (0.05f + dimensions.x) * (number - 6);
                offsetY = (-0.001f - dimensions.y) * 2;
            }
            if (number > 8 && number < 12)
            {
                offsetX = (0.05f + dimensions.x) * (number - 9);
                offsetY = (-0.001f - dimensions.y) * 3;
            }
            if (number > 11 && number < 15)
            {
                offsetX = (0.05f + dimensions.x) * (number - 12);
                offsetY = (-0.001f - dimensions.y) * 4;
            }
            if (number > 14 && number < 18)
            {
                offsetX = (0.05f + dimensions.x) * (number - 15);
                offsetY = (-0.001f - dimensions.y) * 5;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] CalcInvItemPos(int number)
        {
            Vector2 position = new Vector2(0.02f, 0.8f);
            Vector2 dimensions = new Vector2(0.16f, 0.16f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 6)
            {
                offsetX = (dimensions.x + .001f) * number;
            }
            if (number > 5 && number < 12)
            {
                offsetX = (dimensions.x + .001f) * (number - 6);
                offsetY = (-0.005f - dimensions.y) * 1;
            }
            if (number > 11 && number < 18)
            {
                offsetX = (dimensions.x + .001f) * (number - 12);
                offsetY = (-0.005f - dimensions.y) * 2;
            }
            if (number > 17 && number < 24)
            {
                offsetX = (dimensions.x + .001f) * (number - 18);
                offsetY = (-0.005f - dimensions.y) * 3;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        //private void CreateFactionDetails(ref CuiElementContainer container, string panelName, string text, int number)
        //{
        //    Vector2 dimensions = new Vector2(0.8f, 0.1f);
        //    Vector2 origin = new Vector2(0.1f, 0.7f);
        //    Vector2 offset = new Vector2(0, (0.01f + dimensions.y) * number);

        //    Vector2 posMin = origin - offset;
        //    Vector2 posMax = posMin + dimensions;
        //    UI.CreateLabel(ref container, panelName, UIColors["buttonbg"], text, 18, $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}");
        //}

        private float[] PlayerEntryPos(int number)
        {
            Vector2 position = new Vector2(0.03f, 0.81f);
            Vector2 dimensions = new Vector2(0.2f, 0.15f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 6)
            {
                offsetY = (-0.005f - dimensions.y) * number;
            }
            if (number > 5 && number < 12)
            {
                offsetX = (0.005f + dimensions.x) * 1;
                offsetY = (-0.005f - dimensions.y) * (number - 6);
            }
            if (number > 11 && number < 18)
            {
                offsetX = (0.005f + dimensions.x) * 2;
                offsetY = (-0.005f - dimensions.y) * (number - 12);
            }
            if (number > 17 && number < 24)
            {
                offsetX = (0.005f + dimensions.x) * 3;
                offsetY = (-0.005f - dimensions.y) * (number - 18);
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        #endregion

        #region External Functions

        [HookMethod("BroadcastOnScreen")]
        void BroadcastOnScreen(string message, ushort Faction, ushort Faction2 = 0)
        {
            BroadcastOnScreenFaction(message, Faction, Faction2);
        }

        [HookMethod("AssignToFaction")]
        bool AssignToFaction(ulong ID, ushort Faction)
        {
            if (!fdata.Players.ContainsKey(ID)) return false;
            BasePlayer Target = BasePlayer.FindByID(ID);
            if (Target == null)
            {
                var PlayerData = fdata.Players[ID];
                PlayerData.faction = Faction;
                PlayerData.PendingInvites.Clear();
                fdata.Factions[Faction].factionPlayers.Add(ID);
                if (fdata.Factions[Faction].factionPlayers.Count() <= 1)
                    fdata.Factions[Faction].Leader = ID;
                ConsoleSystem.Run(ConsoleSystem.Option.Server, $"usergroup add {ID} {fdata.Factions[Faction].group}");
                SaveData();
                Broadcast($"<color={GetMSG("JoinedFaction", null, fdata.Factions[Faction].ChatColor, GetDisplayName(ID), fdata.Factions[Faction].Name)}</color>");
            }
            else
            {
                if (GetFactionPlayer(Target) == null) return false;
                AssignPlayerToFaction(Target, Faction);
            }
            return true;
        }

        [HookMethod("ClearFactionPlayers")]
        void ClearFactionPlayers(ushort ID)
        {
            if (!fdata.Factions.ContainsKey(ID)) return;
            foreach (var player in fdata.Factions[ID].factionPlayers)
            {
                try
                {
                    var fp = GetFactionPlayer(BasePlayer.FindByID(player));
                    if (fp != null)
                        fp.Faction = 0;
                }
                catch
                {
                    if (fdata.Players.ContainsKey(player))
                        fdata.Players[player].faction = 0;
                }
            }
            fdata.Factions[ID].factionPlayers.Clear();
            SaveData();
        }


        [HookMethod("GivePlayerFactionGear")]
        bool GivePlayerFactionGear(BasePlayer player)
        {
            GiveFactionGear(player);
            return true;
        }

        [HookMethod("IsFaction")]
        bool IsFaction(ushort ID)
        {
            if (ID != 0 && fdata.Factions.ContainsKey(ID)) return true;
            return false;
        }

        [HookMethod("GetPlayerFaction")]
        object GetPlayerFaction(ulong ID)
        {
            if (fdata.Players.ContainsKey(ID) && fdata.Players[ID].faction != 0) return fdata.Players[ID].faction;
            return false;
        }

        [HookMethod("GetFactionInfo")]
        object GetFactionInfo(ushort ID, string request)
        {
            if (ID == 0 || !fdata.Factions.ContainsKey(ID)) return false;
            switch (request.ToLower())
            {
                case "name":
                    return fdata.Factions[ID].Name;
                case "tag":
                    return fdata.Factions[ID].tag;
                case "group":
                    return fdata.Factions[ID].group;
                case "embleem":
                    return fdata.Factions[ID].embleem;
                case "description":
                    return fdata.Factions[ID].description;
                case "chatcolor":
                    return fdata.Factions[ID].ChatColor;
                case "uicolor":
                    return fdata.Factions[ID].UIColor;
                case "members":
                    return fdata.Factions[ID].factionPlayers;
                case "owner":
                    return fdata.Factions[ID].Leader;
                case "moderators":
                    return fdata.Factions[ID].Moderators;
                case "playercount":
                    return fdata.Factions[ID].factionPlayers.Count();
                default:
                    return false;
            }
        }

        [HookMethod("GetFactionList")]
        List<ushort> GetFactionList()
        {
            if (fdata.Factions == null || fdata.Factions.Count < 1)
                return null;
            List<ushort> list = new List<ushort>();
            foreach (var entry in fdata.Factions)
                list.Add(entry.Key);
            return list;
        }

        [HookMethod("CheckSameFaction")]
        bool CheckSameFaction(ulong player1ID, ulong player2ID)
        {
            if (!fdata.Players.ContainsKey(player1ID) || !fdata.Players.ContainsKey(player2ID)) return false;
            var player1faction = fdata.Players[player1ID].faction;
            var player2faction = fdata.Players[player2ID].faction;
            if (player1faction == player2faction && player1faction != 0) return true;
            else return false;

        }

        private void AddFactionListLM(ulong playerID, string FactionName, List<ulong> IDs)
        {
            if (!LustyMap) return;
            List<string> stringIDs = new List<string>();
            foreach (var entry in IDs)
                stringIDs.Add(entry.ToString());
            LustyMap?.Call("AddFriendList", playerID.ToString(), FactionName, stringIDs);
        }

        private void RemoveFactionListLM(ulong playerID, string FactionName)
        {
            if (!LustyMap) return;
            LustyMap?.Call("RemoveFriendList", playerID.ToString(), FactionName);

        }

        private void UpdateFactionListLM(ulong playerID, string FactionName, List<ulong> IDs)
        {
            if (!LustyMap) return;
            List<string> stringIDs = new List<string>();
            foreach (var entry in IDs)
                stringIDs.Add(entry.ToString());
            LustyMap?.Call("UpdateFriendList", playerID.ToString(), FactionName, stringIDs);
        }


        private void AddFriendLM(ulong playerID, string Name, ulong friendID)
        {
            if (!LustyMap) return;
            LustyMap?.Call("AddFriend", playerID.ToString(), Name, friendID.ToString());
        }

        private void RemoveFriendLM(ulong playerID, string Name, ulong friendID)
        {
            if (!LustyMap) return;
            LustyMap?.Call("RemoveFriend", playerID.ToString(), Name, friendID.ToString());
        }

        #endregion

        #region Timers

        private void SaveLoop()
        {
            if (timers.ContainsKey("save"))
            {
                timers["save"].Destroy();
                timers.Remove("save");
            }
            SaveData();
            timers.Add("save", timer.Once(600, () => SaveLoop()));
        }

        private void InfoLoop()
        {
            if (timers.ContainsKey("info"))
            {
                timers["info"].Destroy();
                timers.Remove("info");
            }
            if (configData.InfoInterval == 0) return;
            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                string key = String.Empty;
                if (!string.IsNullOrEmpty(configData.MenuKeyBinding))
                    key = GetMSG("FCAltInfo", p, configData.MenuKeyBinding.ToUpper());
                GetSendMSG(p, "FCInfo", key);
            }
            timers.Add("info", timer.Once(configData.InfoInterval * 60, () => InfoLoop()));
        }

        private void ReloadPlayerPanel()
        {
            if (timers.ContainsKey("ui"))
            {
                timers["ui"].Destroy();
                timers.Remove("ui");
            }
            foreach (var player in FactionPlayers)
                PlayerPanel(player.player);
            timers.Add("ui", timer.Once(60, () => ReloadPlayerPanel()));
        }

        private static readonly DateTime Epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTotalMinutes() => DateTime.UtcNow.Subtract(Epoch).TotalMinutes;
        #endregion

        #region Classes
        [Serializable]
        public class FactionPlayer : MonoBehaviour
        {
            public BasePlayer player;
            public ushort Faction;
            public string Panel = "HOME";
            public int page;
            public bool open;
            public bool admin;
            public bool OnlineOnly;
            public ushort SelectedFaction;
            public ulong TargetPlayer;
            void Awake()
            {
                enabled = false;
                player = GetComponent<BasePlayer>();
            }
        }

        public class FactionsData
        {
            public Dictionary<ulong, PlayerData> Players = new Dictionary<ulong, PlayerData>();
            public Dictionary<ushort, Faction> Factions = new Dictionary<ushort, Faction>();
        }

        public class Faction
        {
            public string Name;
            public string tag;
            public ulong Leader = 0L;
            public List<ulong> Moderators = new List<ulong>();
            public Dictionary<int, string> FactionAnnouncements = new Dictionary<int, string> { { 0, "Welcome to the Faction!" } };
            public bool Private;
            public string UIColor;
            public string ChatColor;
            public string KitorSet;
            public string group;
            public string description;
            public string embleem;
            public List<ulong> BanList = new List<ulong>();
            public List<ulong> factionPlayers = new List<ulong>();
            public double LastMemberLoggedIn;
            public bool AutoAuthorization;
        }

        public class PlayerData
        {
            public ushort faction = 0;
            public List<ushort> PendingInvites = new List<ushort>();
            public int RustLifeTime;
            public int RustTwoWeekTime;
        }

        class FactionDesigner
        {
            public ushort ID;
            public bool creating;
            public bool editing;
            public Faction faction;
            public int stepNum = 0;
        }
        #endregion

        #region Data Management

        void SaveData()
        {
            if (initialized)
            {
                foreach (var entry in FactionPlayers)
                    SaveFactionPlayer(entry);
                FDATA.WriteObject(fdata);
            }
        }

        void LoadData()
        {
            try
            {
                fdata = FDATA.ReadObject<FactionsData>();
                if (fdata == null || fdata.Players == null)
                    fdata = new FactionsData();
            }
            catch
            {

                Puts("Couldn't load Factions Core Data, creating new datafile");
                fdata = new FactionsData();
            }
            if (fdata.Factions == null || fdata.Factions.Count == 0)
                fdata.Factions = DefaultFactions;
            if (fdata.Players == null)
                fdata.Players = new Dictionary<ulong, PlayerData>();
        }

        private Dictionary<string, Slot> ItemSlots = new Dictionary<string, Slot>
        {
            {"tshirt", Slot.chest },
            {"tshirt.long", Slot.chest },
            {"shirt.collared", Slot.chest },
            {"shirt.tanktop", Slot.chest },
            {"jacket", Slot.chest },
            {"jacket.snow", Slot.chest },
            {"hoodie", Slot.chest },
            {"burlap.shirt", Slot.chest },
            {"hazmat.jacket", Slot.chest },

            /////
            {"wood.armor.jacket", Slot.chest2 },
            {"roadsign.jacket", Slot.chest2 },
            {"metal.plate.torso", Slot.chest2 },
            {"bone.armor.suit", Slot.chest2 },
            {"attire.hide.vest", Slot.chest2 },
            {"attire.hide.poncho", Slot.chest2 },
            {"attire.hide.helterneck", Slot.chest2 },

            /////
            {"pants", Slot.legs },
            {"pants.shorts", Slot.legs },
            {"hazmat.pants", Slot.legs },
            {"burlap.trousers", Slot.legs },
            {"attire.hide.pants", Slot.legs },
            {"attire.hide.skirt", Slot.legs },
            /////
            {"wood.armor.pants", Slot.legs2 },
            {"roadsign.kilt", Slot.legs2 },

            /////
            {"shoes.boots", Slot.feet },
            {"hazmat.boots", Slot.feet },
            {"burlap.shoes", Slot.feet },
            {"attire.hide.boots", Slot.feet },

            /////
            {"burlap.gloves", Slot.hands },
            {"hazmat.gloves", Slot.hands },

            /////
            {"mask.bandana",Slot.head },
            {"mask.balaclava",Slot.head },
            {"hat.cap",Slot.head },
            {"hat.beenie",Slot.head },
            {"bucket.helmet",Slot.head },
            {"hat.boonie",Slot.head },
            {"santahat",Slot.head },
            {"riot.helmet",Slot.head },
            {"metal.facemask",Slot.head },
            {"hazmat.helmet",Slot.head },
            {"hat.miner",Slot.head },
            {"hat.candle",Slot.head },
            {"coffeecan.helmet",Slot.head },
            {"burlap.headwrap",Slot.head },

            /////
            {"hazmatsuit", Slot.any },
        };

        enum Slot
        {
            any,
            head,
            chest,
            chest2,
            legs,
            legs2,
            feet,
            hands,
        }

        private Dictionary<int, string> DefaultEmblems = new Dictionary<int, string>
        {
            {0, "http://i.imgur.com/avnIndo.png" },
            {1, "http://i.imgur.com/bDNy4nh.png" },
            {2, "http://i.imgur.com/iwzGH4W.png" },
            {3, "http://i.imgur.com/WAnPTiw.png" },
            {4, "http://i.imgur.com/8d78Qnu.png" },
            {5, "http://i.imgur.com/gAxeMvK.png" },
            {6, "http://i.imgur.com/dNpKRwg.png" },
            {7, "http://i.imgur.com/Qu4SNm8.png" },
            {8, "http://i.imgur.com/w2IH1Eo.png" },
             {9, "http://i.imgur.com/Qzxv1zv.png" },
            {10, "http://i.imgur.com/MDi4aEn.png" },
            {11, "http://i.imgur.com/4DbaDNJ.png" },
            {12, "http://i.imgur.com/yzShlSM.png" },
            {13, "http://i.imgur.com/3HppE22.png" },
            {14, "http://i.imgur.com/Xs6QN2s.png" },
            {15, "http://i.imgur.com/NHGRtgx.png" },
            {16, "http://i.imgur.com/PeSghTc.png" },
            {17, "http://i.imgur.com/y8wo92P.png" },
            {18, "http://i.imgur.com/OhGqJbe.png" },
            {19, "http://i.imgur.com/FZk4S8s.png" },
            {20, "http://i.imgur.com/V41i65b.png" },
            {21, "http://i.imgur.com/XTwyNKE.png" },
            {22, "http://i.imgur.com/vyI8Dh0.png" },
            {23, "http://i.imgur.com/Lwpo4Uk.png" },
            {24, "http://i.imgur.com/iKs1J4i.png" },
            {25, "http://i.imgur.com/syl5cba.png" },
            {26, "http://i.imgur.com/h5fPxsP.png" },
            {27, "http://i.imgur.com/ONs75vx.png" },
            {28, "http://i.imgur.com/73UHzgO.png" },
            {29, "http://i.imgur.com/g35lupC.png" },
            {30, "http://i.imgur.com/V6x5DEd.png" },
            {31, "http://i.imgur.com/whcI2My.png" },
            {32, "http://i.imgur.com/3q7CHvO.png" },
            {33, "http://i.imgur.com/vqJIHFk.png" },
            {34, "http://i.imgur.com/wUoKvyO.png" },
            {35, "http://i.imgur.com/Oy7ZY0o.png" },
            {36, "http://i.imgur.com/SwCMLVl.png" },
            {37, "http://i.imgur.com/FpBbyJd.png" },
            {38, "http://i.imgur.com/LkOu53F.png" },
            {39, "http://i.imgur.com/NdGUphU.png" },
            {40, "http://i.imgur.com/f9iakjZ.png" },
            {41, "http://i.imgur.com/e9J33lR.png" },
            {42, "http://i.imgur.com/oK8gp0b.png" },
            {43, "http://i.imgur.com/cQ0hj5s.png" },
            {44, "http://i.imgur.com/S9iwCq8.png" },
            {45, "http://i.imgur.com/FLPXWvG.png" },
            {46, "http://i.imgur.com/uaZoI9g.png" },
            {47, "http://i.imgur.com/5mboBg8.png" },
            {48, "http://i.imgur.com/41uR2X6.png" },
            {49, "http://i.imgur.com/LhyPd3c.png" },
            {50, "http://i.imgur.com/hrw1Ti9.png" },
            {51, "http://i.imgur.com/yclMvuL.png" },
            {52, "http://i.imgur.com/ozBS4Kx.png" },
            {53, "http://i.imgur.com/lpzn12Y.png" },
            {54, "http://i.imgur.com/439Qhnh.png" },
            {55, "http://i.imgur.com/NkhVOqe.png" },
            {56, "http://i.imgur.com/zc4Pqlm.png" },
            {57, "http://i.imgur.com/JiIgA1i.png" },
            {58, "http://i.imgur.com/dzLQYMu.png" },
            {59, "http://i.imgur.com/J5eyqmq.png" },
};

        public static string HexTOUIColor(string hexColor)
        {
            if (hexColor.IndexOf('#') != -1)
                hexColor = hexColor.Replace("#", "");

            int red = 0;
            int green = 0;
            int blue = 0;
            int trans = 255;

            if (hexColor.Length == 8)
            {
                trans = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                red = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                green = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                blue = int.Parse(hexColor.Substring(6, 2), NumberStyles.AllowHexSpecifier);
            }

            if (hexColor.Length == 6)
            {
                red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
            }
            else if (hexColor.Length == 3)
            {
                red = int.Parse(hexColor[0].ToString() + hexColor[0].ToString(), NumberStyles.AllowHexSpecifier);
                green = int.Parse(hexColor[1].ToString() + hexColor[1].ToString(), NumberStyles.AllowHexSpecifier);
                blue = int.Parse(hexColor[2].ToString() + hexColor[2].ToString(), NumberStyles.AllowHexSpecifier);
            }
            return $"{((float)red) / 255f} {((float)green) / 255f} {((float)blue) / 255f} {((float)trans) / 255f}";
        }

        private List<string> DefaultColors = new List<string>
                {
                    "#e60000",
                    "#3366ff",
                    "#29a329",
                    "#ffff00",
                    "#ff9933",
                    "#7300e6",
                    "#A93226",
                    "#4A235A",
                    "#1F618D",
                    "#117864",
                    "#D35400",
                    "#626567",
                    "#34495E",
                    "#FA0091",
                    "#3EFF00",
                    "#00E0B8",
                    "#4D8B98",
                    "#9FB1B4",
                    "#9569A8",
                    "#76125B",
                    "#161419",
                    "#3A2C09",
                    "#9ACD32",
                    "#009A9A",
                    "#523b2f",
                    "#743d1b",
                    "#d9dee2",
                    "#676862",
                    "#273a29",
        };

        private Dictionary<ushort, Faction> DefaultFactions = new Dictionary<ushort, Faction>
                {
                    {1254, new Faction
                    {
                    Name = "Faction A",
                    ChatColor = "#7300e6",
                    UIColor = "0.45 0.0 0.9 1.0",
                    group = "FactionA",
                    tag = "A",
                    embleem = "Embleem2",
                    description = "A Basic Faction Created by Default.",
                    }
                    },

                    { 1241, new Faction
                    {
                    Name = "Faction B",
                    ChatColor = "#ff9933",
                    UIColor = "1.0 0.51 0.2 1.0",
                    group = "FactionB",
                    tag = "B",
                    embleem = "Embleem9",
                    description = "A Basic Faction Created by Default.",
                    }
                    },

                    { 1287, new Faction
                    {
                    Name = "Faction C",
                    ChatColor = "#29a329",
                    UIColor = "0.16 0.63 0.16 1.0",
                    group = "FactionC",
                    tag = "C",
                    embleem = "Embleem11",
                    description = "A Basic Faction Created by Default.",
                    }
                    }
        };

        #endregion

        #region Config        
        private ConfigData configData;
        class ConfigData
        {
            public int InfoInterval { get; set; }
            public string MenuKeyBinding { get; set; }
            public bool DisableMenu { get; set; }
            public bool Use_FactionAnnouncements { get; set; }
            public bool Use_PrivateFactionChat { get; set; }
            public bool Use_FactionChatControl { get; set; }
            public bool Use_FactionTags { get; set; }
            public bool Use_PlayerListMenu { get; set; }
            public bool Use_Map { get; set; }
            public bool LockFactionKits_and_CustomSets { get; set; }
            public bool ShowFactionPlayersOnMap { get; set; }
            public int FactionLimit { get; set; }
            public int FactionPlayerLimit { get; set; }
            public int AllowedFactionDifference { get; set; }
            public bool Use_AllowPlayersToCreateFactions { get; set; }
            public bool Allow_FriendlyFire { get; set; }
            public float FriendlyFire_DamageScale { get; set; }
            public string HomePageMessage { get; set; }
            public int FactionStaleTime { get; set; }
            public bool AutoAuthorization { get; set; }
            public bool AuthorizeLeadersOnly { get; set; }
            public bool SafeZones_Allow { get; set; }
            public bool DeleteEmptyFactions { get; set; }
            public float SafeZones_Radius { get; set; }
            public string InFactionChat_ChatColor { get; set; }
            public Dictionary<int, string> FactionEmblems_URLS { get; set; }
            public List<string> Colors { get; set; }
            public List<string> Kits_and_CustomSets { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            if (configData == null)
                LoadDefaultConfig();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                MenuKeyBinding = string.Empty,
                InfoInterval = 15,
                Use_AllowPlayersToCreateFactions = true,
                HomePageMessage = "Welcome to the server! This plugin is called <color=red>FactionsCore</color> and it is written by <color=red>AbsolutRust</color> Enjoy!",
                Use_FactionChatControl = true,
                Use_PrivateFactionChat = true,
                Use_FactionAnnouncements = true,
                Use_FactionTags = true,
                Use_Map = true,
                LockFactionKits_and_CustomSets = false,
                ShowFactionPlayersOnMap = true,
                Use_PlayerListMenu = true,
                AllowedFactionDifference = 5,
                Allow_FriendlyFire = false,
                FriendlyFire_DamageScale = 0.0f,
                FactionLimit = 0,
                FactionPlayerLimit = 0,
                FactionStaleTime = 0,
                AutoAuthorization = true,
                InFactionChat_ChatColor = "#93FF7F",
                SafeZones_Allow = true,
                DeleteEmptyFactions = false,
                SafeZones_Radius = 40f,
                AuthorizeLeadersOnly = false,
                FactionEmblems_URLS = DefaultEmblems,
                DisableMenu = false,
                Colors = DefaultColors,
                Kits_and_CustomSets = new List<string> { "faction0", "faction1", "faction2", "faction3" },
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Messages
        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"title", "Factions: " },
            {"FCInfo", "This server is running Factions. Type '/faction'{0} to open the menu."},
            {"FCAltInfo", " or press '{0}'" },
            {"FFBuildings", "This is a friendly structure owned by {0}! You must be authorized on a nearby Tool Cupboard to damage it!"},
            {"FFs", "{0} is on your faction!"},
            {"FactionPlayerInfo", "{1} {0}"},
            {"AdminOptions", "Admin Menu" },
            {"ToggleProxmity", "Proximity" },
            {"OnlineList", "Online Players" },
            {"Faction", "Faction" },
            {"PlayerData", "PlayerData Info" },
            {"PlayerHealth", "Health: {0}%" },
            {"PlayerHydration", "Hydration: {0}%" },
            {"PlayerCalories", "Calories: {0}%" },
            {"CurrentLevel", "Exp Level: {0}" },
            {"FactionBegin", "To begin creating a new faction type a name for the Faction. To quit at any time simply type 'quit' or press 'n'" },
            {"FactionTag", "Please type a Faction Tag" },
            {"FactionColor", "Select a Color" },
            {"FactionShirt", "Please Select a Faction Shirt" },
            {"FactionSkin", "Please Select a Skin" },
            {"NewShirt", "Start New Shirt Selection" },
            {"FactionDescription", "Please provide a description of {0}" },
            {"CurrentDescription", "{0}..." },
            {"CreationLeader", "Leader: {0}" },
            {"CreationPlayerCount", "Player Count: {0}" },
            {"CreationDescription", "Description: {0}" },
            {"Back", "Back" },
            {"JoinFaction", "Join Faction?" },
            {"CreateFaction", "Create A Faction?" },
            {"EnterFactionChat", "You have entered Faction Chat. All message will be sent only to Faction Members." },
            {"ExitFactionChat", "You have left Faction Chat. Messages will be seen by everyone on the server." },
            {"EnterFactionAnnouncement", "You have entered Faction Announcement Mode. All message will be saved as Announcements." },
            {"ExitFactionAnnouncement", "You have left Faction Announcement Mode. Chat will work as normal" },
            {"EnterAdminView", "You have entered Admin View. Controls will now show for you as an Admin." },
            {"ExitAdminView", "You have exited Admin View. Controls will now show based on your player." },
            {"FactionOf", "Faction: {0}" },
            {"ItemCondition", "Condition: {0}%" },
            {"Magazine", "Magazine Capacity: {0}%" },
            {"CurrentWeapons", "Current Weapons" },
            {"CurrentAttire", "Current Attire" },
            {"Kills", "Kills: {0}" },
            {"Deaths", "Deaths: {0}" },
            {"FactionListEntry", "{0}\n{1}" },
            {"ONLINE", "Status: <color=#44ff44>Online</color>"},
            {"OFFLINE", "Status: <color=#ff4444>Offline</color>"},
            {"SLEEPING", "Sleeping" },
            {"NewPlayerWelcome", "{0} has joined the fight!" },
            {"PlayerReturns","{0} has returned!"},
            {"PlayerLeft", "{0} has left!" },
            {"LeftTheFaction", "{0}>{1} left {2}" },
            {"NewFactionCreated", "You have created {0}." },
            {"CreationDetails","Name:{0}\nOxide Group:{1}" },
            {"FactionDetails", "Faction Details" },
            {"SaveDescription", "Save Description?"},
            {"Continue", "Type More Description?" },
            {"SaveFaction", "Save Faction?" },
            {"LeaveFaction", "Leave Faction?" },
            {"FactionChat", "Faction Chat" },
            {"FactionJoinCooldown", "You are currently on a Faction Join Cooldown. Try again in a few minutes." },
            {"DoNotJoin", "Do Not Join" },
            {"TogglePrivate", "Private: {0}" },
            {"NoLongerPrivate", "Your Faction is no longer Private." },
            {"NowPrivate", "Your Faction is now Private." },
            {"Private", "Make Private?" },
            {"PrivateFaction", "This Faction is Private. Request an invite from {0} to join." },
            {"RemovedFromFaction", "You have been removed from {0}."},
            {"KickedPlayer", "You have removed {0} from the Faction!" },
            {"InviteMessage", "You have been invited to join the Faction: {0}. Click 'Accept' or 'Decline'" },
            {"Accept", "Accept" },
            {"Decline", "Decline" },
            {"RejectedInvite", "You have rejected the invite to join {0}" },
            {"RejectedInviteToLeader", "{0} has rejected your Faction Invite" },
            {"JoinedFaction", "{0}>{1} has joined the {2} Faction!" },
            {"Restricted", "Restricted" },
            {"AdminMenu", "Admin Menu" },
            {"NoFaction", "No Faction" },
            {"ToggleAdminView", "Admin View" },
            {"FactionTagExists", "The Faction Tag: {0} already exists. Type a different one to continue or quit to end creation" },
            {"FactionNameExists", "The Faction Name: {0} already exists. Type a different one to continue or quit to end creation" },
            {"NotAuth", "You are not authroized" },
            {"InAFaction", "You are already in a Faction." },
            {"NotALeader", "You are not a Faction Leader." },
            {"NotInAFaction", "You are not in a Faction." },
            {"SpawnCooldown", "You are on a Spawn Cooldown" },
            {"FactionSelectionTitle", "Select a Faction" },
            {"QuitFactionCreation", "You have successfully quit Faction Creation" },
            {"FactionTagToLong", "The Faction Tag:{0} is to long... must be no more then 5 characters." },
            {"ManagePlayers", "Manage Players" },
            {"ManageFactions", "Manage Factions" },
            {"DeleteFactionSafeZone", "Delete Safe Zone" },
            {"CreateFactionSafeZone", "Create Safe Zone" },
            {"InviteToFaction", "Invite To Faction" },
            {"KickFromFaction", "Kick From Faction" },
            {"AssignToFaction", "Assign To Faction" },
            {"ConfirmDelete", "Are you sure you want to delete: {0}" },
            {"DeleteFaction", "Delete: {0}" },
            {"FactionAtLimit", "{0} is at the Admin set limit of players. Choose a different Faction" },
            {"FactionToFull", "{0} has to many players. Select a different Faction" },
            {"EnterFactionSafeZone", "You have entered the {0} Safe Zone" },
            {"NoSafeZonesNearMonuments", "You can not make a Safe Zone this close to a Monument!" },
            {"SafeZoneWhereTCIS", "You can only make a Safe Zone where you have an Authorized Tool Cupboard" },
            {"FactionAnnouncements", "FACTION ANNOUNCEMENTS" },
            {"PlayTimeMinutes", "Play Time (Minutes)\nTotal: {0}\n2 Weeks: {1}" },
            {"NoPerm", "You do not have permission to use this command!" },
            {"AddModerator", "Add Moderator" },
            {"RemoveModerator", "Remove Moderator" },
            {"FactionInvite", "Invite From: {0}" },
            {"AllPlayers", "All Players" },
            {"ScoreBoard", "Scoreboard" },
            {"NotInFaction", "You are not in a faction" },
            {"WaitingImageLibrary", "Waiting on Image Library to initialize. Trying again in 60 Seconds" },
            {"MoreDetails", "Select A Player For More Details" },
            {"MoreDetails-OnlineOnly", "Select A Player For More Details - Showing Online Only" },
            {"ToggleOnlineOnly", "Toggle Online/All" },
            {"InvitePlayers", "Invite Players" },
            {"SetTaxBox", "Set Tax Box" },
            {"KitContents", "{0} Kit Contents" },
            {"OnlineOnly", "{0} - Online Only" },
            {"AllMembers", "{0} - All Members" },
            ///OPTIONS MESSAGES
            {"OptionChangeMSG", "Do you want to change this setting to: {0}" },
            {"OptionChangeTitle", "{0} is currently set to: {1}" },
            {"TRUE", "<color=#005800>TRUE</color>" },
            {"FALSE", "<color=#FF0000>FALSE</color>" },
            {"ChatControlTitle", "Factions Chat Control" },
            {"ChatControlInfo", "This setting controls the use of Faction colors and attributes when players send a message. This setting has no impact on the ability to Toggle Faction Chat for private internal faction communication." },
            {"FactionTagOnChatTitle", "Faction Tag" },
            {"FactionTagOnChatInfo", "This setting controls the addition of the Faction Tag on Faction Member chat messages. For Example: [TAG]PLAYERNAME: MSG… If this setting is set to ‘TRUE’ it will automatically set Faction Chat Control to ‘TRUE’ as it is a requirement. This can also be used with ChatTitles." },
            {"FriendlyFireTitle", "Friendly Fire" },
            {"FriendlyFireInfo", "This setting controls whether Faction Members and Faction Member Buildings can be damaged by Friendly Fire. If this setting is set to ‘FALSE’ players within Factions will not be able to damage eachother or structures (unless Authorized on a ToolCupboard). ‘FriendlyFire_DamageScale’ can be changed in the Config File to determine how much damage is done even if Friendly Fire Protection is set to ‘FALSE’. The default setting for ‘FriendlyFire_DamageScale’ is ‘0’. " },
            {"AutoAuthorizationInfo", "This setting controls whether players within a faction are authorized on Turrets and Doors automatically. If set as ‘true’ whenever a turret is made all faction players will be authorized on it automatically. Additionally, if a player tries to open a faction member door and is authorized on a nearby turret they will be able to open the door without a key or key code." },
            {"AutoAuthorizationTitle", "Authorization" },
            {"AuthorizeLeadersOnlyInfo", "This setting modifies the default Authorization settings to only include the leader of each faction instead of all faction members." },
            {"AuthorizeLeadersOnlyTitle", "Authorize Leaders Only" },
            {"SafeZones_AllowInfo", "This setting controls whether leaders and moderators of a faction can create a Safe Zone. Only members of the faction can enter the safe zone. There is a Safe Zone radius setting in the config file to modify how big the zone will be. Additionally, if you have the plugin ZoneDomes loaded it will shade the zone with a dome." },
            {"SafeZones_AllowTitle", "Safe Zones" },
            {"DeleteEmptyFactionsInfo", "Controls whether a faction with no players will automatically be deleted. The check for empty factions happens when a player leaves the faction." },
            {"DeleteEmptyFactionsTitle", "Delete Empty Factions" },
            {"DisableMenuInfo", "Controls whether the UI menu is usable by players. Disabling the menu will still allow it to be used by players with Auth2 or with the FactionsCore.admin permission." },
            {"DisableMenuTitle", "Disable UI Menu" },
            {"Use_FactionAnnouncementsInfo", "This setting controls whether faction leaders and moderators can make Faction Announcements. These announcements are shown in the UI Menu for faction members. This also enables/disables the Faction Announcement toggle button below the chat menu." },
            {"Use_FactionAnnouncementsTitle", "Faction Announcements" },
            {"Use_PrivateFactionChatInfo", "This setting controls whether factions can use the Private Chat function which allows players to chat in a private conversation with only members of the faction. This also enables/disables the Faction Chat toggle button below the chat menu." },
            {"Use_PrivateFactionChatTitle", "Private Chat" },
            {"LockFactionKits_and_CustomSetsInfo", "This setting controls whether faction provided kits and Custom Sets are locked to the player. If set to ‘true’ players will not be able to remove any item given to them through the kit or set." },
            {"LockFactionKits_and_CustomSetsTitle", "Lock Faction Gear" },
            {"Use_PlayerListMenuInfo", "This setting controls whether players can use the ‘All Players’ tab in the UI Menu." },
            {"Use_PlayerListMenuTitle", "Player List" },
            {"ShowFactionPlayersOnMapInfo", "This setting controls whether players can see faction members on the built in UI Map." },
            {"ShowFactionPlayersOnMapTitle", "Show Players on Map" },
            {"PlayersToCreateFactionsInfo", "This setting controls whether players can create their own factions." },
            {"PlayersToCreateFactionsTitle", "Player Faction Creation" },
            {"MapDisabled", "The Map is disabled!" },
        };
        #endregion
    }
}

// --- End of file: FactionsCore.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/fort-wars ---
// --- Original File Path: F/FortWars/FortWars.cs ---

using System.Collections.Generic;
using System;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UI = Oxide.Plugins.FortWarsUI.UIMethods;
using Rgba = Oxide.Plugins.FortWarsUI.Rgba;
using Anchor = Oxide.Plugins.FortWarsUI.Anchor;

// TODO: Add QuickSmelt functionality
// TODO: Add quicksmelt configuration options

namespace Oxide.Plugins
{
    [Info("Fort Wars", "Ryan", "2.0.01")]
    [Description("Custom gamemode that changes values of gathering/smelting/crafting based on a current phase.")]
    public class FortWars : RustPlugin
    {
        #region Declaration

        // Config, Data
        private static ConfigFile CFile;
        private static DataFile DFile;
        
        // Permissions
        private const string AdminPerm = "fortwars.admin";

        // Timers
        private Timer UiTimer;
        private Timer HeliTimer;
        private Timer DropTimer;

        // Temp storage
        private Dictionary<string, float> DefaultBlueprints = new Dictionary<string, float>();

        // UI stuff
        private const string MainContainer = "Main.Container";
        private const string CountdownContainer = "Countdown.Container";
        private const string CountdownTimer = "Countdown.Timer";
        private const string PhaseContainer = "Phase.Container";
        private const string PhaseContent = "Phase.Content";
        private CuiElementContainer CachedContainer;
        private Dictionary<ulong, BasePlayer> UiPlayers = new Dictionary<ulong, BasePlayer>();
        private List<uint> PluginEntities = new List<uint>();

        #endregion

        #region Configuration

        private class ConfigFile
        {
            public HelicopterSettings HelicopterSettings;

            public AirdropSettings AirdropSettings;

            public CraftSettings CraftSettings;

            public GatherSettings GatherSettings;

            public TimeSettings TimeSettings;

            public UiSettings UiSettings;

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    HelicopterSettings = new HelicopterSettings(),
                    AirdropSettings = new AirdropSettings(),
                    CraftSettings = new CraftSettings(),
                    GatherSettings = new GatherSettings(),
                    TimeSettings = new TimeSettings(),
                    UiSettings = new UiSettings()
                };
            }
        }

        // TODO finish this
        private class SmeltSettings
        {
            public Multiplier MultiplierSettings { get; set; }

            public SmeltSettings()
            {
                MultiplierSettings = new Multiplier(1, 2);
            }
        }

        private class UiSettings
        {
            public bool Enabled { get; set; }
            public Rgba PrimaryColor { get; set; }
            public Rgba SecondaryColor { get; set; }
            public ConfigAnchor CountdownAnchor { get; set; }
            public ConfigAnchor PhaseAnchor { get; set; }

            public UiSettings()
            {
                Enabled = true;
                PrimaryColor = new Rgba(0, 0, 0, 0.3f);
                SecondaryColor = new Rgba(255, 255, 255, 255);
                CountdownAnchor = new ConfigAnchor(new Anchor(0.01f, 0.93f), new Anchor(0.1f, 0.99f));
                PhaseAnchor = new ConfigAnchor(new Anchor(0.01f, 0.88f), new Anchor(0.1f, 0.92f));
            }
        }

        private class ConfigAnchor
        {
            public Anchor Min { get; set; }
            public Anchor Max { get; set; }

            public ConfigAnchor()
            {
            }

            public ConfigAnchor(Anchor min, Anchor max)
            {
                Min = min;
                Max = max;
            }
        }

        private class HelicopterSettings
        {
            public float Health;
            public Rotor RotorHealth;
            public float Speed;
            public float BulletDamage;
            public int MaxCrates;

            public HelicopterSettings()
            {
                Health = 200;
                RotorHealth = new Rotor();
                Speed = 110;
                BulletDamage = 10;
                MaxCrates = 3;
            }
        }

        private class AirdropSettings
        {
            public Multiplier AirdropAmounts;

            public AirdropSettings()
            {
                AirdropAmounts = new Multiplier(3, 1);
            }
        }

        private class CraftSettings
        {
            public Multiplier MultiplierSettings;

            public CraftSettings()
            {
                MultiplierSettings = new Multiplier(1, 5);
            }
        }

        private class GatherSettings
        {
            public Multiplier MultiplierSettings;

            public GatherSettings()
            {
                MultiplierSettings = new Multiplier(1, 5);
            }
        }

        private class TimeSettings
        {
            [JsonProperty("Build phase length (minutes)")]
            public float Build;

            [JsonProperty("Fight phrase length (minutes)")]
            public float Fight;

            [JsonProperty("Helicopter frequency (seconds)")]
            public float Heli;

            [JsonProperty("Airdrop Frequency (seconds)")]
            public Multiplier Airdrop;

            public TimeSettings()
            {
                Build = 60;
                Fight = 30;
                Heli = 120;
                Airdrop = new Multiplier(120, 300);
            }
        }

        private class Multiplier
        {
            public float Fight;
            public float Build;

            public Multiplier()
            {
                Fight = 2;
                Build = 1;
            }

            public Multiplier(float fight, float build)
            {
                Fight = fight;
                Build = build;
            }
        }

        private class Rotor
        {
            public float MainHealth;
            public float TailHealth;

            public Rotor()
            {
                MainHealth = 75;
                TailHealth = 100;
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating default configuration file...");
            CFile = ConfigFile.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                CFile = Config.ReadObject<ConfigFile>();
                if (CFile == null) Regenerate();
            }
            catch { Regenerate(); }
        }

        protected override void SaveConfig() => Config.WriteObject(CFile);

        private void Regenerate()
        {
            PrintWarning($"Configuration file at 'oxide/config/{Name}.json' seems to be corrupt! Regenerating...");
            CFile = ConfigFile.DefaultConfig();
            SaveConfig();
        }

        #endregion

        #region Data

        private class DataFile
        {
            public PhaseInfo PhaseInfo = new PhaseInfo();
        }

        private class PhaseInfo
        {
            public bool BuildPhase;
            public bool FightPhase;
            public DateTime StartTime;

            public bool FortWarActive { get { return BuildPhase || FightPhase; } }

            public PhaseInfo()
            {
                BuildPhase = false;
                StartTime = DateTime.MinValue;
            }

            public bool ShouldEnd(float period) => StartTime.AddMinutes(period) < DateTime.UtcNow;

            public double GetSeconds(float period) => (StartTime.AddMinutes(period) - DateTime.UtcNow).TotalSeconds;
        }

        #endregion

        #region Lang

        private struct Msg
        {
            public const string TimeLeft = "TimeLeft";
            public const string BuildPhase = "BuildPhase";
            public const string FightPhase = "FightPhase";
            public const string BuildPhaseStart = "BuildPhaseStart";
            public const string BuildPhaseEnd = "BuildPhaseEnd";
            public const string FightPhaseStart = "FightPhaseStart";
            public const string FightPhaseEnd = "FightPhaseEnd";
            public const string NoPerm = "NoPerm";
            public const string NoFortWarActive = "NoFortWarActive";
            public const string HellStarted = "HellStarted";
            public const string HellInvalidArgs = "HellInvalidArgs";
            public const string HellNoInt = "HellNoInt";
            public const string InfoCraft = "InfoCraft";
            public const string InfoSmelt = "InfoSmelt";
            public const string InfoGather = "InfoGather";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["DayFormat"] = "{0}D {1}H",
                ["DaysFormat"] = "{0}D {1}H",
                ["HourFormat"] = "{0}H {1}M",
                ["HoursFormat"] = "{0}H {1}M",
                ["MinFormat"] = "{0}M {1}S",
                ["MinsFormat"] = "{0}M {1}S",
                ["SecsFormat"] = "{0}S",
                [Msg.TimeLeft] = "TIME LEFT",
                [Msg.BuildPhase] = "BUILD PHASE",
                [Msg.FightPhase] = "FIGHT PHASE",
                [Msg.BuildPhaseStart] = "A build phase has begun, use <color=orange>/phase</color> for gather/crafting/smelting rates!",
                [Msg.BuildPhaseEnd] = "A build phase has ended!",
                [Msg.FightPhaseStart] = "A fight phase has begun, use <color=orange>/phase</color> for gather/crafting/smelting rates!",
                [Msg.FightPhaseEnd] = "A fight phase has ended!",
                [Msg.NoPerm] = "You don't have permission to use that command",
                [Msg.NoFortWarActive] = "There's currently no fortwar active to make hell!",
                [Msg.HellStarted] = "It's turned to hell, {0} helicopters and {1} airdrops incoming!",
                [Msg.HellInvalidArgs] = "Invalid arguments. Usage: /hell <amount>",
                [Msg.HellNoInt] = "The input '<color=orange>{0}</color>' doesn't seem to be a valid integer",
                [Msg.InfoCraft] = "<color=orange>Crafting rate</color> - {0}x",
                [Msg.InfoSmelt] = "<color=orange>Smelting rate</color> - {0}x",
                [Msg.InfoGather] = "<color=orange>Gathering rate</color> - {0}x",
            }, this);
        }

        #endregion

        #region Methods

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private void DestroyTimers()
        {
            UiTimer?.Destroy();
            HeliTimer?.Destroy();
            DropTimer?.Destroy();
        }

        private void UnsubHooks()
        {
            Unsubscribe(nameof(OnDispenserGather));
            Unsubscribe(nameof(OnCollectiblePickup));
            Unsubscribe(nameof(OnDispenserBonus));
            //Unsubscribe(nameof(OnConsumeFuel)); //TODO Finish this
        }

        private void SubHooks()
        {
            Subscribe(nameof(OnDispenserGather));
            Subscribe(nameof(OnCollectiblePickup));
            Subscribe(nameof(OnDispenserBonus));
            //Subscribe(nameof(OnConsumeFuel)); //TODO Finish this
        }

        private void InitializeBuildPhase(DateTime? startTime = null)
        {
            DestroyTimers();

            SubHooks();

            DFile.PhaseInfo.StartTime = startTime ?? DateTime.UtcNow;
            DFile.PhaseInfo.BuildPhase = true;

            UpdateCraftTimes();

            foreach (var player in BasePlayer.activePlayerList)
                PrintToChat(player, Lang(Msg.BuildPhaseStart, player.UserIDString));

            Interface.Call("OnBuildPhaseInitiated");

            if (CFile.UiSettings.Enabled)
            {
                InitializeUi();
                UiTimer = timer.Every(1f, RefreshTimer);
            }
            DropTimer = timer.Every(CFile.TimeSettings.Airdrop.Build, () =>
            {
                for (var i = 0; i < CFile.AirdropSettings.AirdropAmounts.Build; i++)
                    CallDrop();
            });
            HeliTimer = timer.Every(CFile.TimeSettings.Heli, CallHeli);
        }

        private void EndBuildPhase()
        {
            DestroyTimers();

            UnsubHooks();

            DFile.PhaseInfo.StartTime = DateTime.MinValue;
            DFile.PhaseInfo.BuildPhase = false;

            UpdateCraftTimes();

            foreach (var player in BasePlayer.activePlayerList)
                PrintToChat(player, Lang(Msg.BuildPhaseEnd, player.UserIDString));

            Interface.Call("OnBuildPhaseEnded");

            DestroyUi();
        }

        private void InitializeFightPhase(DateTime? startTime = null)
        {
            DestroyTimers();

            SubHooks();

            DFile.PhaseInfo.StartTime = startTime ?? DateTime.UtcNow;
            DFile.PhaseInfo.FightPhase = true;

            UpdateCraftTimes();

            foreach (var player in BasePlayer.activePlayerList)
                PrintToChat(player, Lang(Msg.FightPhaseStart, player.UserIDString));

            Interface.Call("OnFightPhaseInitiated");

            if (CFile.UiSettings.Enabled)
            {
                InitializeUi();
                UiTimer = timer.Every(1f, RefreshTimer);
            }

            DropTimer = timer.Every(CFile.TimeSettings.Airdrop.Fight, () =>
            {
                for (var i = 0; i < CFile.AirdropSettings.AirdropAmounts.Fight; i++)
                    CallDrop();
            });
            HeliTimer = timer.Every(CFile.TimeSettings.Heli, CallHeli);
        }

        private void EndFightPhase()
        {
            DestroyTimers();

            UnsubHooks();

            DFile.PhaseInfo.StartTime = DateTime.MinValue;
            DFile.PhaseInfo.FightPhase = false;

            UpdateCraftTimes();

            foreach (var player in BasePlayer.activePlayerList)
                PrintToChat(player, Lang(Msg.FightPhaseEnd, player.UserIDString));

            Interface.Call("OnFightPhaseEnded");

            DestroyUi();
        }

        private void CallHeli()
        {
            var heli = GameManager.server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab");
            if (heli != null && heli.GetComponent<PatrolHelicopterAI>())
            {
                var patrolHeli = heli.GetComponent<PatrolHelicopterAI>();
                var baseHeli = heli.GetComponent<BaseHelicopter>();
                baseHeli.startHealth = CFile.HelicopterSettings.Health;
                baseHeli.maxCratesToSpawn = CFile.HelicopterSettings.MaxCrates;
                baseHeli.bulletDamage = CFile.HelicopterSettings.BulletDamage;
                baseHeli.weakspots[0].health = CFile.HelicopterSettings.RotorHealth.MainHealth;
                baseHeli.weakspots[1].health = CFile.HelicopterSettings.RotorHealth.TailHealth;
                baseHeli.weakspots[0].maxHealth = CFile.HelicopterSettings.RotorHealth.MainHealth;
                baseHeli.weakspots[1].maxHealth = CFile.HelicopterSettings.RotorHealth.TailHealth;
                patrolHeli.maxSpeed = CFile.HelicopterSettings.Speed;
                heli.Spawn();
                PluginEntities.Add(heli.net.ID);
            }
        }

        private void CallDrop()
        {
            var plane = GameManager.server.CreateEntity("assets/prefabs/npc/cargo plane/cargo_plane.prefab");
            if (plane != null && plane.GetComponent<CargoPlane>())
            {
                var cargoPlane = plane.GetComponent<CargoPlane>();
                cargoPlane.InitDropPosition(cargoPlane.RandomDropPosition());
                plane.Spawn();
                PluginEntities.Add(plane.net.ID);
            }
        }

        private void CheckPhase()
        {
            if (DFile.PhaseInfo.FortWarActive)
            {
                if (DFile.PhaseInfo.BuildPhase && DFile.PhaseInfo.ShouldEnd(CFile.TimeSettings.Build))
                {
                    EndBuildPhase();
                    InitializeFightPhase();
                }
                if (DFile.PhaseInfo.FightPhase && DFile.PhaseInfo.ShouldEnd(CFile.TimeSettings.Fight))
                    EndFightPhase();
            }
        }

        #region UI Methods

        private void InitializeUi()
        {
            foreach (var player in BasePlayer.activePlayerList)
                AddUi(player);
        }

        private void AddUi(BasePlayer player)
        {
            if(!UiPlayers.ContainsKey(player.userID))
                UiPlayers.Add(player.userID, player);
            CuiHelper.DestroyUi(player, MainContainer);
            CuiHelper.AddUi(player, CachedContainer);
            RefreshTimer();
            RefreshPhase();
        }

        private void DestroyUi()
        {
            foreach (var player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, MainContainer);
        }

        private void ConstructUi()
        {
            CachedContainer = UI.Container(MainContainer, "0 0 0 0", new Anchor(0, 0), new Anchor(1, 1), "Under");
            UI.Element(CountdownContainer, MainContainer, ref CachedContainer, CFile.UiSettings.CountdownAnchor.Min, CFile.UiSettings.CountdownAnchor.Max, CFile.UiSettings.PrimaryColor.Format());
            UI.Border(new Anchor(0.01f, 0.93f), new Anchor(0.1f, 0.99f), ref CachedContainer, 0.0001f, CFile.UiSettings.SecondaryColor.Format(), MainContainer);
            UI.Text("", CountdownContainer, ref CachedContainer, TextAnchor.UpperCenter, CFile.UiSettings.SecondaryColor.Format(), 13, Lang(Msg.TimeLeft),
                new Anchor(0.1f, 0.5f), new Anchor(0.9f, 0.85f));

            UI.Element(PhaseContainer, MainContainer, ref CachedContainer, CFile.UiSettings.PhaseAnchor.Min, CFile.UiSettings.PhaseAnchor.Max, CFile.UiSettings.PrimaryColor.Format());
            UI.Border(CFile.UiSettings.PhaseAnchor.Min, CFile.UiSettings.PhaseAnchor.Max, ref CachedContainer, 0.0001f, CFile.UiSettings.SecondaryColor.Format(), MainContainer);
        }

        private void RefreshTimer()
        {
            var period = DFile.PhaseInfo.FortWarActive ? (DFile.PhaseInfo.BuildPhase ? CFile.TimeSettings.Build : CFile.TimeSettings.Fight) : 1;
            if (string.IsNullOrEmpty(GetFormattedTime(DFile.PhaseInfo.GetSeconds(period))))
            {
                CheckPhase();
                return;
            }
            var container = DrawTimer();
            foreach (var player in UiPlayers)
            {
                CuiHelper.DestroyUi(player.Value, CountdownTimer);
                CuiHelper.AddUi(player.Value, container);
            }
        }

        private CuiElementContainer DrawTimer()
        {
            var period = DFile.PhaseInfo.FortWarActive ? (DFile.PhaseInfo.BuildPhase ? CFile.TimeSettings.Build : CFile.TimeSettings.Fight) : 1;
            var container = UI.Container(CountdownTimer, "0 0 0 0", new Anchor(0.1f, 0.15f), new Anchor(0.9f, 0.5f), CountdownContainer);
            UI.Text("", CountdownTimer, ref container, TextAnchor.LowerCenter, CFile.UiSettings.SecondaryColor.Format(), 11, GetFormattedTime(DFile.PhaseInfo.GetSeconds(period)), 
                new Anchor(0, 0), new Anchor(1, 1));
            return container;
        }

        private void RefreshPhase()
        {
            var container = DrawPhase();
            foreach (var player in UiPlayers)
            {
                CuiHelper.DestroyUi(player.Value, PhaseContent);
                CuiHelper.AddUi(player.Value, container);
            }
        }

        private CuiElementContainer DrawPhase()
        {
            var phase = DFile.PhaseInfo.FortWarActive ? (DFile.PhaseInfo.BuildPhase ? Lang(Msg.BuildPhase) : Lang(Msg.FightPhase)) : "N/A";
            var container = UI.Container(PhaseContent, "0 0 0 0", new Anchor(0, 0), new Anchor(1, 1), PhaseContainer);
            UI.Text("", PhaseContent, ref container, TextAnchor.MiddleCenter, CFile.UiSettings.SecondaryColor.Format(), 12, phase, new Anchor(0, 0), new Anchor(1, 1));
            return container;
        }

        #endregion

        private string GetFormattedTime(double time)
        {
            TimeSpan timeSpan = TimeSpan.FromSeconds(time);
            if (timeSpan.TotalSeconds < 1) return null;

            if (Math.Floor(timeSpan.TotalDays) >= 1)
                return string.Format(timeSpan.Days > 1 ? Lang("DaysFormat", null, timeSpan.Days, timeSpan.Hours) : Lang("DayFormat", null, timeSpan.Days, timeSpan.Hours));
            if (Math.Floor(timeSpan.TotalMinutes) >= 60)
                return string.Format(timeSpan.Hours > 1 ? Lang("HoursFormat", null, timeSpan.Hours, timeSpan.Minutes) : Lang("HourFormat", null, timeSpan.Hours, timeSpan.Minutes));
            if (Math.Floor(timeSpan.TotalSeconds) >= 60)
                return string.Format(timeSpan.Minutes > 1 ? Lang("MinsFormat", null, timeSpan.Minutes, timeSpan.Seconds) : Lang("MinFormat", null, timeSpan.Minutes, timeSpan.Seconds));
            return Lang("SecsFormat", null, timeSpan.Seconds);
        }

        private float GetMultiplier(Multiplier mult)
        {
            if (DFile.PhaseInfo.FortWarActive)
            {
                if (DFile.PhaseInfo.BuildPhase) return mult.Build;
                if (DFile.PhaseInfo.FightPhase) return mult.Fight;
            }
            return 1;
        }

        private void UpdateCraftTimes()
        {
            foreach (var bp in ItemManager.bpList)
                bp.time = DefaultBlueprints[bp.targetItem.shortname] * GetMultiplier(CFile.CraftSettings.MultiplierSettings);
        }

        #endregion

        #region Hooks

        private void Init()
        {
            DFile = Interface.Oxide.DataFileSystem.ReadObject<DataFile>(Name);
            permission.RegisterPermission(AdminPerm, this);
        } 

        private void OnServerInitialized()
        {
            ConstructUi();
            UnsubHooks();
            foreach (var defaultBlueprint in ItemManager.bpList)
            {
                if(!DefaultBlueprints.ContainsKey(defaultBlueprint.targetItem.shortname))
                    DefaultBlueprints.Add(defaultBlueprint.targetItem.shortname, defaultBlueprint.time);
            }
            if (DFile.PhaseInfo.FortWarActive)
            {
                if(DFile.PhaseInfo.BuildPhase)
                    InitializeBuildPhase(DFile.PhaseInfo.StartTime);
                if(DFile.PhaseInfo.FightPhase)
                    InitializeFightPhase(DFile.PhaseInfo.StartTime);
            }
        }

        private void OnServerSave() => Interface.Oxide.DataFileSystem.WriteObject(Name, DFile);

        private void Unload()
        {
            DestroyTimers();
            foreach(var player in BasePlayer.activePlayerList)
                OnPlayerDisconnect(player);
            foreach (var bp in ItemManager.bpList)
                bp.time = DefaultBlueprints[bp.targetItem.shortname];
            var count = 0;
            foreach (var pluginEnt in PluginEntities)
            {
                var ent = BaseNetworkable.serverEntities.Find(pluginEnt) as BaseEntity;
                if (ent != null)
                {
                    count++;
                    ent.Kill();
                }
            }
            if(count > 0) Puts($"Destroyed {count} plugin spawned entities");
        }

        private void OnEntityDeath(BaseCombatEntity entity)
        {
            var netId = entity.net.ID;
            if (PluginEntities.Contains(netId))
                PluginEntities.Remove(netId);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (CFile.UiSettings.Enabled && DFile.PhaseInfo.FortWarActive)
                timer.Once(3f, () => AddUi(player));
        }

        private void OnPlayerDisconnect(BasePlayer player)
        {
            if (UiPlayers.ContainsKey(player.userID))
                UiPlayers.Remove(player.userID);
            CuiHelper.DestroyUi(player, MainContainer);
        } 

        private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item) => item.amount = (int)(item.amount * GetMultiplier(CFile.GatherSettings.MultiplierSettings));

        private void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item) => OnDispenserGather(dispenser, player, item);

        private void OnCollectiblePickup(Item item, BasePlayer player) => item.amount = (int)(item.amount * GetMultiplier(CFile.GatherSettings.MultiplierSettings));

        //TODO finish this
        //private void OnConsumeFuel(BaseOven oven, Item fuel, ItemModBurnable burnable)
        //{
            
        //}

        #endregion

        #region Commands

        [ConsoleCommand("fortwars.start")]
        private void StartCommand(ConsoleSystem.Arg arg)
        {
            var userId = arg.Connection?.userid ?? 0;
            if (userId.IsSteamId() && !permission.UserHasPermission(userId.ToString(), AdminPerm))
            {
                arg.ReplyWith("You don't have permission to use that command");
                return;
            }
            if (DFile.PhaseInfo.FortWarActive)
            {
                arg.ReplyWith("You can't start a fortwar when there's already one active!");
                return;
            }
            arg.ReplyWith("You've started a fort war!");
            InitializeBuildPhase();
        }

        [ConsoleCommand("fortwars.end")]
        private void EndCommand(ConsoleSystem.Arg arg)
        {
            var userId = arg.Connection?.userid ?? 0;
            if (userId.IsSteamId() && !permission.UserHasPermission(userId.ToString(), AdminPerm))
            {
                arg.ReplyWith("You don't have permission to use that command");
                return;
            }
            if (!DFile.PhaseInfo.FortWarActive)
            {
                arg.ReplyWith("You can't end a fortwar when there's not one active!");
                return;
            }
            arg.ReplyWith("You've ended the fortwar!");
            if(DFile.PhaseInfo.BuildPhase)
                EndBuildPhase();
            if(DFile.PhaseInfo.FightPhase)
                EndFightPhase();
        }

        [ConsoleCommand("fortwars.build")]
        private void BuildPhaseCommand(ConsoleSystem.Arg arg)
        {
            var userId = arg.Connection?.userid ?? 0;
            if (userId.IsSteamId() && !permission.UserHasPermission(userId.ToString(), AdminPerm))
            {
                arg.ReplyWith("You don't have permission to use that command");
                return;
            }
            if (DFile.PhaseInfo.FortWarActive && DFile.PhaseInfo.BuildPhase)
            {
                arg.ReplyWith("You can't start a build phase when there's already one active!");
                return;
            }
            arg.ReplyWith("You've started a build phase!");
            InitializeBuildPhase();
        }

        [ConsoleCommand("fortwars.fight")]
        private void FightPhaseCommand(ConsoleSystem.Arg arg)
        {
            var userId = arg.Connection?.userid ?? 0;
            if (userId.IsSteamId() && !permission.UserHasPermission(userId.ToString(), AdminPerm))
            {
                arg.ReplyWith("You don't have permission to use that command");
                return;
            }
            if (DFile.PhaseInfo.FortWarActive && DFile.PhaseInfo.FightPhase)
            {
                arg.ReplyWith("You can't start a fight phase when there's already one active!");
                return;
            }
            arg.ReplyWith("You've started a fight phase!");
            InitializeFightPhase();
        }

        [ChatCommand("phase")]
        private void PhaseCommand(BasePlayer player, string command, string[] args)
        {
            if (!DFile.PhaseInfo.FortWarActive)
            {
                PrintToChat(player, Lang(Msg.NoFortWarActive, player.UserIDString));
                return;
            }
            var messages = new List<string>();
            messages.Add(Lang(Msg.InfoGather, player.UserIDString, GetMultiplier(CFile.GatherSettings.MultiplierSettings)));
            messages.Add(Lang(Msg.InfoCraft, player.UserIDString, GetMultiplier(CFile.CraftSettings.MultiplierSettings)));
            //messages.Add(Lang(Msg.InfoSmelt, player.UserIDString, GetMultiplier(CFile.GatherSettings.MultiplierSettings))); //TODO finish this
            PrintToChat(player, string.Join("\n", messages.ToArray()));
        }

        [ChatCommand("hell")]
        private void HellCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, AdminPerm))
            {
                PrintToChat(player, Lang(Msg.NoPerm, player.UserIDString));
                return;
            }
            if (args.Length < 1)
            {
                PrintToChat(player, Lang(Msg.HellInvalidArgs, player.UserIDString));
                return;
            }
            if (!DFile.PhaseInfo.FortWarActive)
            {
                PrintToChat(player, Lang(Msg.NoFortWarActive, player.UserIDString));
                return;
            }
            var number = 0;
            if (!int.TryParse(args[0], out number))
            {
                PrintToChat(player, Lang(Msg.HellNoInt, player.UserIDString));
                return;
            }
            foreach(var loopPlayer in BasePlayer.activePlayerList)
                PrintToChat(loopPlayer, Lang(Msg.HellStarted, player.UserIDString, number, number));
            for (var i = 0; i < number; i++)
            {
                CallDrop();
                CallHeli();
            }
        }

        #endregion

    }
}

namespace Oxide.Plugins.FortWarsUI
{
    public class UIMethods
    {
        public static CuiElementContainer Container(string name, string bgColor, Anchor Min, Anchor Max,
            string parent = "Overlay", float fadeOut = 0f, float fadeIn = 0f)
        {
            var newElement = new CuiElementContainer()
            {
                new CuiElement()
                {
                    Name = name,
                    Parent = parent,
                    FadeOut = fadeOut,
                    Components =
                    {
                        new CuiImageComponent()
                        {
                            Color = bgColor,
                            FadeIn = fadeIn
                        },
                        new CuiRectTransformComponent()
                        {
                            AnchorMin = $"{Min.X} {Min.Y}",
                            AnchorMax = $"{Max.X} {Max.Y}"
                        }
                    }
                },
            };
            return newElement;
        }

        public static void Panel(string name, string parent, ref CuiElementContainer container, string bgColor,
            Anchor Min, Anchor Max, bool cursor = false)
        {
            container.Add(new CuiPanel()
            {
                Image =
                {
                    Color = bgColor
                },
                CursorEnabled = cursor,
                RectTransform =
                {
                    AnchorMin = $"{Min.X} {Min.Y}",
                    AnchorMax = $"{Max.X} {Max.Y}"
                }
            }, parent, name);
        }

        public static void Label(string name, string parent, ref CuiElementContainer container, Anchor Min, Anchor Max,
            string text, string color = "1 1 1 1", int fontSize = 15, TextAnchor textAnchor = TextAnchor.MiddleCenter,
            string font = "robotocondensed-bold.ttf")
        {
            container.Add(new CuiLabel()
            {
                Text =
                {
                    Align = textAnchor,
                    Color = color,
                    Font = font,
                    FontSize = fontSize
                },
                RectTransform =
                {
                    AnchorMin = $"{Min.X} {Min.Y}",
                    AnchorMax = $"{Max.X} {Max.Y}"
                }
            }, parent, name);
        }

        public static void Button(string name, string parent, ref CuiElementContainer container, Anchor Min,
            Anchor Max, string command, string text, string textColor,
            int fontSize, string color = "1 1 1 1", TextAnchor anchor = TextAnchor.MiddleCenter, float fadeOut = 0f,
            float fadeIn = 0f, string font = "robotocondensed-bold.ttf")
        {
            container.Add(new CuiButton()
            {
                FadeOut = fadeOut,
                Button =
                {
                    Color = color,
                    Command = command,
                },
                RectTransform =
                {
                    AnchorMin = $"{Min.X} {Min.Y}",
                    AnchorMax = $"{Max.X} {Max.Y}"
                },
                Text =
                {
                    Text = text,
                    Color = textColor,
                    Align = anchor,
                    Font = font,
                    FontSize = fontSize,
                    FadeIn = fadeIn
                }
            }, parent, name);
        }

        public static void Text(string name, string parent, ref CuiElementContainer container, TextAnchor anchor,
            string color, int fontSize, string text,
            Anchor Min, Anchor Max, string font = "robotocondensed-bold.ttf", float fadeOut = 0f,
            float fadeIn = 0f)
        {
            container.Add(new CuiElement()
            {
                Name = name,
                Parent = parent,
                FadeOut = fadeOut,
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = text,
                        Align = anchor,
                        FontSize = fontSize,
                        Font = font,
                        FadeIn = fadeIn,
                        Color = color
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = $"{Min.X} {Min.Y}",
                        AnchorMax = $"{Max.X} {Max.Y}"
                    }
                }
            });
        }

        public static void Element(string name, string parent, ref CuiElementContainer container, Anchor Min, Anchor Max,
            string bgColor, string material = "", float fadeOut = 0f, float fadeIn = 0f)
        {
            container.Add(new CuiElement()
            {
                Name = name,
                Parent = parent,
                FadeOut = fadeOut,
                Components =
                {
                    new CuiImageComponent()
                    {
                        Color = bgColor,
                        FadeIn = fadeIn
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = $"{Min.X} {Min.Y}",
                        AnchorMax = $"{Max.X} {Max.Y}"
                    }
                }
            });
        }

        public static void Border(Anchor posMin, Anchor posMax, ref CuiElementContainer container, float borderSize = 0.001f, string color = "1 1 1 1", string parent = "Overlay")
        {
            Element("", parent, ref container, posMin, new Anchor(posMax.X, posMin.Y + (borderSize * 2)), "1 1 1 1");
            Element("", parent, ref container, new Anchor(posMin.X, posMax.Y - (borderSize * 2)), posMax, "1 1 1 1");
            Element("", parent, ref container, posMin, new Anchor(posMin.X + borderSize, posMax.Y), "1 1 1 1");
            Element("", parent, ref container, new Anchor(posMax.X, posMin.Y), new Anchor(posMax.X + borderSize, posMax.Y), "1 1 1 1");
        }
    }

    public class Anchor
    {
        public float X { get; set; }
        public float Y { get; set; }

        public Anchor()
        {
        }

        public Anchor(float x, float y)
        {
            X = x;
            Y = y;
        }

        public static Anchor operator +(Anchor first, Anchor second)
        {
            return new Anchor(first.X + second.X, first.Y + second.Y);
        }

        public static Anchor operator -(Anchor first, Anchor second)
        {
            return new Anchor(first.X - second.X, first.Y - second.Y);
        }
    }

    public class Rgba
    {
        public float R { get; set; }
        public float G { get; set; }
        public float B { get; set; }
        public float A { get; set; }

        public Rgba()
        {
        }

        public Rgba(float r, float g, float b, float a)
        {
            R = r;
            G = g;
            B = b;
            A = a;
        }

        public string Format()
        {
            return $"{R / 255} {G / 255} {B / 255} {A}";
        }
    }
}

// --- End of file: FortWars.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/freeze-arrows ---
// --- Original File Path: F/FreezeArrows/FreezeArrows.cs ---

using Facepunch;
using Oxide.Core;
using System;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("FreezeArrows", "Colon Blow", "1.1.2")]
    class FreezeArrows : RustPlugin
    {
        // fix for 5/4 Rust update.

        #region Loadup

        List<ulong> FrozenEntityList = new List<ulong>();
        Dictionary<ulong, string> GuiInfo = new Dictionary<ulong, string>();
        Dictionary<ulong, ShotArrowData> loadArrow = new Dictionary<ulong, ShotArrowData>();

        class ShotArrowData
        {
            public BasePlayer player;
            public int arrows;
            public bool arrowenabled;
        }

        void Loaded()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!loadArrow.ContainsKey(player.userID))
                {
                    loadArrow.Add(player.userID, new ShotArrowData
                    {
                        player = player,
                        arrows = config.FreezeArrowConfig.StartingArrowCount,
                        arrowenabled = false
                    });
                }
            }
            lang.RegisterMessages(Messages, this);
            permission.RegisterPermission("freezearrows.allowed", this);
            permission.RegisterPermission("freezearrows.unlimited", this);
        }

        #endregion

        #region Configuration

        private static PluginConfig config;

        private class PluginConfig
        {
            public GlobalArrowSettings FreezeArrowConfig { get; set; }

            public class GlobalArrowSettings
            {
                [JsonProperty(PropertyName = "Time - How long player is frozen when hit.")] public float FreezeTime { get; set; }
                [JsonProperty(PropertyName = "Time - Cooldown for freezing same player again.")] public float ReFreezeCooldown { get; set; }
                [JsonProperty(PropertyName = "Radius - The distance from impact players are effeted.")] public float FreezeRadius { get; set; }
                [JsonProperty(PropertyName = "Overlay - How long frozen overlay is shown when player is frozen")] public float FreezeOverlayTime { get; set; }
                [JsonProperty(PropertyName = "Arrows - Number of arrows on startup per player.")] public int StartingArrowCount { get; set; }
                [JsonProperty(PropertyName = "Arrows - Automatically reload another freeze arrow if player has them? (false will toggle freeze arrow off after shooting one) ")] public bool toggleFreezeReload { get; set; }
                [JsonProperty(PropertyName = "Overlay - Show freeze overlay when player is frozen ")] public bool useFreezeOverlay { get; set; }
                [JsonProperty(PropertyName = "Effects - Show hit explosion effect ?")] public bool showHitExplosionFX { get; set; }
                [JsonProperty(PropertyName = "Targets - Arrows will freeze players ?")] public bool freezePlayers { get; set; }
                [JsonProperty(PropertyName = "Targets - Arrows will freeze NPCs ?")] public bool freezeNPCs { get; set; }
                [JsonProperty(PropertyName = "Targets - Arrows will freeze Ridable Horses ?")] public bool freezeRideHorses { get; set; }
            }

            public static PluginConfig DefaultConfig() => new PluginConfig()
            {
                FreezeArrowConfig = new PluginConfig.GlobalArrowSettings
                {
                    FreezeTime = 10f,
                    ReFreezeCooldown = 120f,
                    FreezeRadius = 5,
                    FreezeOverlayTime = 10f,
                    StartingArrowCount = 1,
                    useFreezeOverlay = true,
                    showHitExplosionFX = true,
                    freezePlayers = true,
                    freezeNPCs = true,
                    freezeRideHorses = true,
                }
            };
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("New configuration file created!!");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            SaveConfig();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Localization

        string msg(string key, string playerId = null) => lang.GetMessage(key, this, playerId);

        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["onnextshottxt"] = "Your next shot will be a Freeze Arrow",
            ["arrowsleft"] = "Arrows remaining : ",
            ["arrowadded"] = "You have added a freeze arrow to your quiver.",
            ["offnextshottxt"] = "Your next shot will a Normal Arrow",
            ["yourfrozetxt"] = "You are frozen in place....",
            ["nofreezearrows"] = "You have no freeze arrows left",
            ["unlimitedfreezearrows"] = "You have unlimited freeze arrows.. have fun :)",
            ["notoggle"] = "You have not toggled Freeze Arrows ye",
            ["unfrozetxt"] = "You are now unfrozen.... "
        };

        #endregion

        #region Commands

        [ChatCommand("freezearrow")]
        void cmdChatfreezearrow(BasePlayer player, string command, string[] args, int arrows, bool arrowenabled)
        {
            if (!HasPermission(player, "freezearrows.allowed")) return;

            if (!loadArrow.ContainsKey(player.userID))
            {
                loadArrow.Add(player.userID, new ShotArrowData
                {
                    player = player,
                    arrows = config.FreezeArrowConfig.StartingArrowCount,
                    arrowenabled = true
                });
                SendReply(player, msg("onnextshottxt", player.UserIDString));
                if (HasPermission(player, "freezearrows.unlimited")) return;
                SendReply(player, msg("arrowsleft", player.UserIDString) + (loadArrow[player.userID].arrows));
                return;
            }
            if (loadArrow[player.userID].arrowenabled)
            {
                loadArrow[player.userID].arrowenabled = false;
                SendReply(player, msg("offnextshottxt", player.UserIDString));
                return;
            }

            if (HasPermission(player, "freezearrows.unlimited"))
            {
                loadArrow[player.userID].arrowenabled = true;
                SendReply(player, msg("onnextshottxt", player.UserIDString));
                return;
            }
            if (loadArrow[player.userID].arrows <= 0)
            {
                SendReply(player, msg("nofreezearrows", player.UserIDString));
                return;
            }
            if (loadArrow[player.userID].arrows >= 1)
            {
                loadArrow[player.userID].arrowenabled = true;
                SendReply(player, msg("onnextshottxt", player.UserIDString));
                if (HasPermission(player, "freezearrows.unlimited")) return;
                SendReply(player, msg("arrowsleft", player.UserIDString) + (loadArrow[player.userID].arrows));
                return;
            }
            return;
        }

        [ChatCommand("freezecount")]
        void cmdChatfreezecount(BasePlayer player, string command, string[] args, int arrows)
        {
            if (!HasPermission(player, "freezearrows.allowed")) return;
            if (HasPermission(player, "freezearrows.unlimited"))
            {
                SendReply(player, msg("unlimitedfreezearrows", player.UserIDString));
                return;
            }
            if (!loadArrow.ContainsKey(player.userID))
            {
                SendReply(player, msg("notoggle", player.UserIDString));
                return;
            }
            if (loadArrow[player.userID].arrows <= 0)
            {
                SendReply(player, msg("nofreezearrows", player.UserIDString));
                return;
            }
            if (loadArrow[player.userID].arrows >= 1)
            {
                SendReply(player, msg("arrowsleft", player.UserIDString) + (loadArrow[player.userID].arrows));
                return;
            }
            return;
        }

        #endregion

        #region Freeze Overlay

        void FrozenGui(BasePlayer player)
        {
            string guiInfo;
            if (GuiInfo.TryGetValue(player.userID, out guiInfo)) CuiHelper.DestroyUi(player, guiInfo);

            var elements = new CuiElementContainer();
            GuiInfo[player.userID] = CuiHelper.GetGuid();

            elements.Add(new CuiElement
            {
                Name = GuiInfo[player.userID],
                Parent = "Overlay",
                Components =
                    {
                        new CuiRawImageComponent { Sprite = "assets/content/ui/overlay_freezing.png" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
            });

            CuiHelper.AddUi(player, elements);
        }

        #endregion

        #region Hooks

        void OnPlayerAttack(BasePlayer player, HitInfo hitInfo)
        {
            if (!HasPermission(player, "freezearrows.allowed")) return;
            if (!loadArrow[player.userID].arrowenabled) return;

            if (usingCorrectWeapon(player))
            {
                if (hitInfo.ProjectilePrefab.ToString().Contains("arrow_"))
                {
                    if (loadArrow[player.userID].arrows <= 0)
                    {
                        SendReply(player, msg("nofreezearrows", player.UserIDString));
                        return;
                    }
                    findTarget(player, hitInfo);
                    if (config.FreezeArrowConfig.showHitExplosionFX)
                    {
                        Effect.server.Run("assets/bundled/prefabs/fx/explosions/explosion_03.prefab", hitInfo.HitPositionWorld);
                    }
                    if (!config.FreezeArrowConfig.toggleFreezeReload) loadArrow[player.userID].arrowenabled = !loadArrow[player.userID].arrowenabled;
                    if (HasPermission(player, "freezearrows.unlimited")) return;
                    loadArrow[player.userID].arrows = loadArrow[player.userID].arrows - 1;
                }
            }
            return;
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo, int arrows)
        {
            if (hitInfo == null) return;
            if (!(hitInfo.Initiator is BasePlayer)) return;
            if (entity is BaseNpc || entity is BasePlayer)
            {
                var player = (BasePlayer)hitInfo.Initiator;

                if (!HasPermission(player, "freezearrows.allowed")) return;
                if (!loadArrow.ContainsKey(player.userID)) return;
                if (HasPermission(player, "freezearrows.unlimited")) return;

                loadArrow[player.userID].arrows = loadArrow[player.userID].arrows + 1;
                SendReply(player, msg("arrowadded", player.UserIDString));
                SendReply(player, msg("arrowsleft", player.UserIDString) + (loadArrow[player.userID].arrows));
            }
            return;
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                FrozenEntityList.Remove(player.userID);
                string guiInfo;
                if (GuiInfo.TryGetValue(player.userID, out guiInfo)) CuiHelper.DestroyUi(player, guiInfo);
            }
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!loadArrow.ContainsKey(player.userID))
            {
                loadArrow.Add(player.userID, new ShotArrowData
                {
                    player = player,
                    arrows = config.FreezeArrowConfig.StartingArrowCount,
                    arrowenabled = false
                });
            }
            DestroyCui(player);
            FrozenEntityList.Remove(player.userID);
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            DestroyCui(player);
            FrozenEntityList.Remove(player.userID);
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            DestroyCui(player);
            FrozenEntityList.Remove(player.userID);
        }

        #endregion

        #region Helpers

        bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

        bool usingCorrectWeapon(BasePlayer player)
        {
            Item activeItem = player.GetActiveItem();
            if (activeItem != null && activeItem.info.shortname == "crossbow") return true;
            if (activeItem != null && activeItem.info.shortname == "bow.hunting") return true;
            if (activeItem != null && activeItem.info.shortname == "bow.compound") return true;
            return false;
        }

        public void findTarget(BasePlayer player, HitInfo hitInfo)
        {
            var hitPoint = hitInfo.HitPositionWorld;
            List<BaseEntity> plist = Pool.GetList<BaseEntity>();
            Vis.Entities<BaseEntity>(hitPoint, config.FreezeArrowConfig.FreezeRadius, plist);
            foreach (BaseEntity foundEntity in plist)
            {
                var currentpos = foundEntity.transform.position;
                if (config.FreezeArrowConfig.freezePlayers)
                {
                    var isPlayer = foundEntity.GetComponent<BasePlayer>();
                    if (isPlayer && !FrozenEntityList.Contains(isPlayer.userID) && isPlayer != player)
                    {
                        if (config.FreezeArrowConfig.useFreezeOverlay) FrozenGui(isPlayer);
                        timer.Once(config.FreezeArrowConfig.FreezeOverlayTime, () => DestroyCui(isPlayer));
                        timer.Repeat(0.1f, Convert.ToInt32(config.FreezeArrowConfig.FreezeTime) * 10, () => freezeposition(isPlayer, currentpos));
                        FrozenEntityList.Add(isPlayer.userID);
                        timer.Once(config.FreezeArrowConfig.ReFreezeCooldown, () => FrozenEntityList.Remove(player.userID));
                    }
                }
                if (config.FreezeArrowConfig.freezeNPCs)
                {
                    var isBNPC = foundEntity.GetComponent<BaseNpc>();
                    if (isBNPC) timer.Repeat(0.1f, Convert.ToInt32(config.FreezeArrowConfig.FreezeTime) * 10, () => StopNPCMovement(isBNPC));
                }
                if (config.FreezeArrowConfig.freezeRideHorses)
                {
                    var isRideHorse = foundEntity.GetComponent<BaseRidableAnimal>();
                    if (isRideHorse) timer.Repeat(0.1f, Convert.ToInt32(config.FreezeArrowConfig.FreezeTime) * 10, () => isRideHorse.currentRunState = BaseRidableAnimal.RunState.stopped);
                }
            }
            Pool.FreeList<BaseEntity>(ref plist);
        }

        void StopNPCMovement(BaseNpc npc)
        {
            if (npc == null) return;
            npc.StopMoving();
        }

        void freezeposition(BasePlayer player, Vector3 newPos)
        {
            if (player == null) return;
            newPos = player.transform.position;
            ForcePlayerPosition(player, newPos);
        }

        void DestroyCui(BasePlayer player)
        {
            string guiInfo;
            if (GuiInfo.TryGetValue(player.userID, out guiInfo)) CuiHelper.DestroyUi(player, guiInfo);
        }

        #endregion

    }

}

// --- End of file: FreezeArrows.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/free-light-string ---
// --- Original File Path: F/FreeLightString/FreeLightString.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Free Light String", "mspeedie", "0.1.2")]
    [Description("Allows lightstrings to operate without electricity.")]
    
    class FreeLightString : RustPlugin
    {
        #region Initialization
        void OnServerInitialized()
        {
            ChangePower(999999);
        }
        #endregion
        
        #region lightstring
        void OnEntitySpawned(AdvancedChristmasLights lightstring)
        {
            lightstring.UpdateHasPower(999999, 1);
            lightstring.SendNetworkUpdateImmediate();
        }
         
        void ChangePower(int amt)
        {
            foreach (var lightstring in UnityEngine.Object.FindObjectsOfType<AdvancedChristmasLights>())
            {
                lightstring.UpdateHasPower(amt, 1);
				lightstring.SendNetworkUpdateImmediate();
            }
        }
        void Unload()
        {
            ChangePower(0);
        }
        #endregion
    }
}

// --- End of file: FreeLightString.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/free-research ---
// --- Original File Path: F/FreeResearch/FreeResearch.cs ---

﻿using System.Linq;						// Where

namespace Oxide.Plugins
{
	[Info("Free Research", "Zugzwang", "1.0.11")]
	[Description("Free blueprint unlocking from research tables and workbench tech trees.")]		

	class FreeResearch : RustPlugin
	{
		const int ScrapID = -932201673;
		const int MaxResearchScrap = 500;
		
		#region Startup and Unload

		// Load scrap in ResearchTables and enable instant results.
		void OnEntitySpawned(ResearchTable entity)
		{
			entity.pickup.requireEmptyInv = false;
			entity.researchDuration = 0;
			
			Item i = entity.inventory.FindItemByItemID(ScrapID);
			if (i != null)
			{
				i.amount = MaxResearchScrap;
			}
			else
			{
				i = ItemManager.CreateByItemID(ScrapID, MaxResearchScrap);
				if (i != null && !i.MoveToContainer(entity.inventory, 1))
				{
					i.Remove();
				}
			}
		}
		
		// Setup all ResearchTables on Load.
		void OnServerInitialized()
		{
			foreach (ResearchTable entity in BaseNetworkable.serverEntities.Where(x => x is ResearchTable))
			{
				OnEntitySpawned(entity);
			}
		}
		
		// Revert all ResearchTables on Unload.
		void Unload()
		{
			foreach (ResearchTable entity in BaseNetworkable.serverEntities.Where(x => x is ResearchTable))
			{
				entity.pickup.requireEmptyInv = true;
				entity.researchDuration = 10f;
				entity.inventory.Remove(entity.inventory.GetSlot(1));
			}
		}
		
      #endregion Startup and Unload		

		#region Cost Control and TechTree Override
		
		// Allow unlocking all TechTree items unconditionally.
		object CanUnlockTechTreeNode(BasePlayer player, TechTreeData.NodeInstance node, TechTreeData techTree)
		{
			return true;
		}
		
		// Set research cost to zero.
		object OnResearchCostDetermine()
      {
			return (int)0;
		}
		
		#endregion Cost Control and TechTree Override

		#region ResearchTable Inventory Control
		
		// Prevent player from adding more scrap to a ResearchTable.
		object CanAcceptItem(ItemContainer container, Item item, int targetPos)
		{
			if (	container?.entityOwner is not ResearchTable ||
					item?.info?.itemid != ScrapID ||
					targetPos != 1 ||
					container.GetSlot(targetPos) == null
				) return null;
				
			return ItemContainer.CanAcceptResult.CannotAccept;
		}		
		
		// Prevent player from moving scrap in or out of a ResearchTable.
		object CanMoveItem(Item item, PlayerInventory playerLoot, ItemContainerId targetContainerId, int targetSlot, int num, bool flag)
		{
			if (item?.info?.itemid != ScrapID) return null;
			if (item?.parent?.entityOwner is ResearchTable) return false;
			if (playerLoot?.FindContainer(targetContainerId)?.entityOwner is ResearchTable) return false;
			return null;
		}
		
		// Prevent player from stealing scrap by throwing the whole stack on the ground.
		void OnItemRemovedFromContainer(ItemContainer container, Item item)
		{
			if (item?.info?.itemid == ScrapID && container?.entityOwner is ResearchTable)
			{
				NextFrame(() => { item.MoveToContainer(container, 1, true); });
			}
		}		

		// Prevent player from stealing scrap by throwing a partial stack on the ground.		
		Item OnItemSplit(Item item, int amount)
		{
			if (item?.parent?.entityOwner is ResearchTable && item.position == 1) return item;
			return null;
		}		
		
		#endregion ResearchTable Inventory Control
		
		#region ResearchTable Pickup

		// Prevent player from stealing scrap when picking up a ResearchTable.
		object CanPickupEntity(BasePlayer player, ResearchTable entity)
		{
			if (player.CanBuild() && player.IsHoldingEntity<Hammer>())
			{
				Item i = entity.inventory.GetSlot(0);
				if (i != null && !i.MoveToContainer(player.inventory.containerMain))
				{
					i.Drop(player.inventory.containerMain.dropPosition, player.inventory.containerMain.dropVelocity, new UnityEngine.Quaternion());
				}
				entity.inventory.Clear();
				return true;
			}
			return null;
		}	
		
		#endregion ResearchTable Pickup 		
		
	}
}

// --- End of file: FreeResearch.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/free-driving-vehicles ---
// --- Original File Path: F/FreeDrivingVehicles/FreeDrivingVehicles.cs ---

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Free Driving Vehicles", "MON@H", "1.1.4")]
    [Description("Allows player to drive vehicles without fuel.")]
    public class FreeDrivingVehicles : RustPlugin
    {
        #region Variables

        private const string PermissionAll = "freedrivingvehicles.all";
        private const string PermissionRHIB = "freedrivingvehicles.rhib";
        private const string PermissionRowboat = "freedrivingvehicles.rowboat";
        private const string PermissionWorkcart = "freedrivingvehicles.workcart";
        private const string PermissionModularCar = "freedrivingvehicles.modularcar";
        private const string PermissionMiniCopter = "freedrivingvehicles.minicopter";
        private const string PermissionSnowmobile = "freedrivingvehicles.snowmobile";
        private const string PermissionScrapCopter = "freedrivingvehicles.scrapcopter";
        private const string PermissionSubmarineDuo = "freedrivingvehicles.submarineduo";
        private const string PermissionSubmarineSolo = "freedrivingvehicles.submarinesolo";

        private readonly Hash<uint, string> _prefabPermissions = new Hash<uint, string>();

        #endregion Variables

        #region Initialization

        private void Init()
        {
            Unsubscribe(nameof(OnFuelCheck));

            permission.RegisterPermission(PermissionAll, this);
            permission.RegisterPermission(PermissionRHIB, this);
            permission.RegisterPermission(PermissionRowboat, this);
            permission.RegisterPermission(PermissionWorkcart, this);
            permission.RegisterPermission(PermissionModularCar, this);
            permission.RegisterPermission(PermissionMiniCopter, this);
            permission.RegisterPermission(PermissionScrapCopter, this);
            permission.RegisterPermission(PermissionSubmarineDuo, this);
            permission.RegisterPermission(PermissionSubmarineSolo, this);
        }

        private void OnServerInitialized()
        {
            CreateCache();

            Subscribe(nameof(OnFuelCheck));
        }

        #endregion Initialization

        #region Configuration

        private ConfigData _configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Free driving HotAirBalloons for ALL players")]
            public bool HotAirBalloonAllowed = false;

            [JsonProperty(PropertyName = "Only authorized players can drive vehicles")]
            public bool AuthorizedOnlyAllowed = false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _configData = Config.ReadObject<ConfigData>();
                if (_configData == null)
                {
                    LoadDefaultConfig();
                    SaveConfig();
                }
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
                SaveConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(_configData);

        #endregion Configuration

        #region OxideHooks

        private object OnFuelCheck(EntityFuelSystem fuelSystem)
        {
            if (fuelSystem == null)
            {
                return null;
            }

            if (_configData.HotAirBalloonAllowed)
            {
                HotAirBalloon hotAirBalloon = fuelSystem.fuelStorageInstance.Get(true)?.parentEntity.Get(true) as HotAirBalloon;

                if (hotAirBalloon != null)
                {
                    CacheHasFuel(fuelSystem);
                    return true;
                }
            }

            BaseVehicle baseVehicle = fuelSystem.fuelStorageInstance.Get(true)?.parentEntity.Get(true) as BaseVehicle;

            if (baseVehicle != null)
            {
                BasePlayer player = baseVehicle.GetDriver();

                if (player != null)
                {
                    if (permission.UserHasPermission(player.UserIDString, PermissionAll))
                    {
                        CacheHasFuel(fuelSystem);
                        return true;
                    }

                    return HandleFreeDriving(fuelSystem, baseVehicle.GetEntity().prefabID, player.UserIDString);
                }
            }

            return null;
        }

        #endregion OxideHooks

        #region Core

        private void CreateCache()
        {
            _prefabPermissions[StringPool.Get("assets/content/vehicles/boats/rhib/rhib.prefab")] = PermissionRHIB;
            _prefabPermissions[StringPool.Get("assets/content/vehicles/boats/rowboat/rowboat.prefab")] = PermissionRowboat;
            _prefabPermissions[StringPool.Get("assets/content/vehicles/minicopter/minicopter.entity.prefab")] = PermissionMiniCopter;
            _prefabPermissions[StringPool.Get("assets/content/vehicles/modularcar/2module_car_spawned.entity.prefab")] = PermissionModularCar;
            _prefabPermissions[StringPool.Get("assets/content/vehicles/modularcar/3module_car_spawned.entity.prefab")] = PermissionModularCar;
            _prefabPermissions[StringPool.Get("assets/content/vehicles/modularcar/4module_car_spawned.entity.prefab")] = PermissionModularCar;
            _prefabPermissions[StringPool.Get("assets/content/vehicles/modularcar/car_chassis_2module.entity.prefab")] = PermissionModularCar;
            _prefabPermissions[StringPool.Get("assets/content/vehicles/modularcar/car_chassis_3module.entity.prefab")] = PermissionModularCar;
            _prefabPermissions[StringPool.Get("assets/content/vehicles/modularcar/car_chassis_4module.entity.prefab")] = PermissionModularCar;
            _prefabPermissions[StringPool.Get("assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab")] = PermissionScrapCopter;
            _prefabPermissions[StringPool.Get("assets/content/vehicles/snowmobiles/snowmobile.prefab")] = PermissionSnowmobile;
            _prefabPermissions[StringPool.Get("assets/content/vehicles/submarine/submarineduo.entity.prefab")] = PermissionSubmarineDuo;
            _prefabPermissions[StringPool.Get("assets/content/vehicles/submarine/submarinesolo.entity.prefab")] = PermissionSubmarineSolo;
            _prefabPermissions[StringPool.Get("assets/content/vehicles/workcart/workcart.entity.prefab")] = PermissionWorkcart;
        }

        private object HandleFreeDriving(EntityFuelSystem fuelSystem, uint prefabID, string userIDString)
        {
            string prefabPermission = _prefabPermissions[prefabID];

            if (!string.IsNullOrEmpty(prefabPermission) && permission.UserHasPermission(userIDString, prefabPermission))
            {
                CacheHasFuel(fuelSystem);
                return true;
            }
            
            if (_configData.AuthorizedOnlyAllowed)
            {
                return false;
            }

            return null;
        }

        private void CacheHasFuel(EntityFuelSystem fuelSystem)
        {
            fuelSystem.cachedHasFuel = true;
            fuelSystem.nextFuelCheckTime = UnityEngine.Time.time + UnityEngine.Random.Range(10f, 20f);
        }

        #endregion Core
    }
}

// --- End of file: FreeDrivingVehicles.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/fuel-alarm ---
// --- Original File Path: F/FuelAlarm/FuelAlarm.cs ---

using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Fuel Alarm", "Oryx", "1.0.3")]
    [Description("Trigger alarm sound when fuel is below a certin level.")]

    class FuelAlarm : RustPlugin
    {
        #region Fields

        private string perm = "fuelalarm.allow";
        private string prefabSound;
        private int threshold;
        private bool usePerm;
        private float timeInterval;

        private List<VehicleCache> cacheList = new List<VehicleCache>();
        private List<ulong> disabledList;

        ConfigData configData;

        public class VehicleCache
        {
            public List<BasePlayer> playerlist = new List<BasePlayer>();
            public BaseMountable entity;

            public int getFuel()
            {
                return (entity.GetParentEntity() as MotorRowboat).GetFuelSystem()?.GetFuelAmount() ?? 0;
            }
        }
        #endregion

        #region Config
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                settings = new Settings
                {
                    threshold = 20,
                    prefabsound = "assets/bundled/prefabs/fx/invite_notice.prefab",
                    timeinterval = 3f
                },
                permissionSettings = new PermissonSettings
                {
                    useperm = false
                }
            };

            Config.WriteObject(config, true);
            configData = Config.ReadObject<ConfigData>();
            loadVariables();
        }

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Settings")]
            public Settings settings { get; set; }
            [JsonProperty(PropertyName = "Permission Settings")]
            public PermissonSettings permissionSettings { get; set; }
        }

        private class Settings
        {
            [JsonProperty(PropertyName = "Perfab Sound")]
            public string prefabsound { get; set; }
            [JsonProperty(PropertyName = "Threshold")]
            public int threshold { get; set; }
            [JsonProperty(PropertyName = "TimeInterval")]
            public float timeinterval { get; set; }
        }

        private class PermissonSettings
        {
            [JsonProperty(PropertyName = "Use Permission")]
            public bool useperm { get; set; }
        }

        private void loadVariables()
        {
            configData = Config.ReadObject<ConfigData>();

            threshold = configData.settings.threshold;
            prefabSound = configData.settings.prefabsound;
            timeInterval = configData.settings.timeinterval;

            usePerm = configData.permissionSettings.useperm;
        }
        #endregion

        #region Hooks
        void OnEntityMounted(BaseMountable entity, BasePlayer player)
        {
            if (entity == null | player == null) { return; }

            if (!(entity.GetParentEntity() as MotorRowboat || entity.GetParentEntity() as MiniCopter)) { return; }

            if ((!permission.UserHasPermission(player.UserIDString, perm)) && usePerm) { return; }

            if (GetVehcileCache(entity) != null)
            {
                AddPlayer(entity, player);
            }
            else
            {
                VehicleCache vehicleCache = new VehicleCache();
                vehicleCache.entity = entity;
                cacheList.Add(vehicleCache);

                AddPlayer(entity, player);
            }
        }

        void OnEntityDismounted(BaseMountable entity, BasePlayer player)
        {
            if (IsVehicleInCache(entity))
            {
                RemovePlayer(entity, player);

                if (GetVehcileCache(entity).playerlist.Count == 0)
                {
                    RemoveVehicleFromCache(entity);
                }

            }
        }

        void OnServerInitialized()
        {
            AlarmManager();
        }

        private void Init()
        {
            permission.RegisterPermission(perm, this);
            ReadData();
            loadVariables();
            cmd.AddChatCommand("fuelalarm", this, nameof(CmdFuelAlarm));
        }

        void Unload()
        {
            SaveData();
        }

        object OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            foreach (VehicleCache vehicle in cacheList)
            {
                foreach (BasePlayer p in vehicle.playerlist)
                {
                    if (p == player)
                    {
                        RemovePlayer(vehicle.entity, player);
                        return null;
                    }
                }
            }

            return null;
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            VehicleCache vehicle = IsPlayerInCache(player);

            if(vehicle != null)
            {
                RemovePlayer(vehicle.entity, player);
            }
        }

        void OnEntityKill(BaseNetworkable entity)
        {
            if (entity.GetParentEntity() as MotorRowboat || entity.GetParentEntity() as MiniCopter)
            {
                if (GetVehcileCache(entity as BaseMountable) != null)
                {
                    RemoveVehicleFromCache(entity as BaseMountable);
                }
            }
        }
        #endregion

        #region Methods
        public VehicleCache GetVehcileCache(BaseMountable entity)
        {
            return cacheList.Find(x => x.entity = entity);
        }

        public bool IsVehicleInCache(BaseMountable entity)
        {
            if (entity == null) { return false; }

            VehicleCache vehicle = GetVehcileCache(entity);

            return (cacheList.Contains(vehicle));
        }

        public VehicleCache IsPlayerInCache(BasePlayer player)
        {
            foreach(VehicleCache vehicle in cacheList)
            {
                bool isPlayer = vehicle.playerlist.Any(x => x = player);

                if (isPlayer)
                {
                    return vehicle;
                }
            }
            return null;
        }

        public void RemovePlayer(BaseMountable entity, BasePlayer player)
        {
            if (player == null) { return; }

            GetVehcileCache(entity).playerlist.Remove(player);
        }

        public void RemoveVehicleFromCache(BaseMountable entity)
        {
            if(entity == null) { return; }
            cacheList.Remove(cacheList.Find(x => x.entity = entity));
        }

        public void AddPlayer(BaseMountable entity, BasePlayer player)
        {

            if (entity == null) { return; }
            if (player == null) { return; }

            GetVehcileCache(entity).playerlist.Add(player);
        }

        public void AlarmManager()
        {
            timer.Every(timeInterval, () =>
            {
                foreach (VehicleCache vehicle in cacheList)
                {
                    BasePlayer player = vehicle.playerlist[0];

                    if (usePerm)
                    {
                        if (permission.UserHasPermission(player.UserIDString, perm))
                        {
                            if (vehicle.getFuel() <= threshold)
                            {
                                bool isDisabled = disabledList.Contains(player.userID);
                                if (!isDisabled)
                                {
                                    Effect.server.Run(prefabSound, vehicle.playerlist[0].transform.position);
                                }

                            }
                        }
                    }
                    else
                    {
                        if (vehicle.getFuel() <= threshold)
                        {
                            bool isDisabled = disabledList.Contains(player.userID);
                            if (!isDisabled)
                            {
                                Effect.server.Run(prefabSound, vehicle.playerlist[0].transform.position);
                            }

                        }
                    }
                }
            });
        }
        #endregion

        #region Command
        private void CmdFuelAlarm(BasePlayer player, string command, string[] args)
        {
            bool isDisabled = disabledList.Any(x => x == player.userID);

            if (isDisabled)
            {
                disabledList.Remove(player.userID);
                Send(player, "Enabled");

            }
            else
            {
                disabledList.Add(player.userID);
                Send(player, "Disabled");
            }

            SaveData();
        }
        #endregion

        #region Data Methods
        public void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, disabledList);
        }

        public void ReadData()
        {
            try
            {
                disabledList = Interface.Oxide.DataFileSystem.ReadObject<List<ulong>>("FuelAlarm");
            }
            catch
            {
                disabledList = new List<ulong>();
            }

        }
        #endregion

        #region Localization
        public void Send(BasePlayer player, string key)
        {
            SendReply(player, lang.GetMessage(key, this, player.UserIDString));
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Enabled"] = "Alarm is now enabled",
                ["Disabled"] = "Alarm is now disabled"
            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Enabled"] = "Тревога включена",
                ["Disabled"] = "Тревога отключена"
            }, this, "ru");
        }
        #endregion
    }
}

// --- End of file: FuelAlarm.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/fancy-drop ---
// --- Original File Path: F/FancyDrop/FancyDrop.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;
using Oxide.Core;
using Oxide.Core.Plugins;
using IEnumerator = System.Collections.IEnumerator;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("FancyDrop", "FastBurst", "3.2.6")]
    [Description("The Next Level of a fancy airdrop-toolset")]
    class FancyDrop : RustPlugin
    {
        [PluginReference]
        Plugin AlphaLoot, GUIAnnouncements, MagicLoot;

        #region Vars
        private static FancyDrop Instance = null;
        bool Changed = false;
        bool initialized = false;
        Vector3 lastDropPos;
        float lastDropRadius = 0;
        Vector3 lastLootPos;
        int lastMinute;
        double lastHour;

        string msgConsoleDropSpawn;
        static string msgConsoleDropLanded;
        Timer _aidropTimer;
        Timer _massDropTimer;

        private const string SMOKE_EFFECT = "assets/bundled/prefabs/fx/smoke_signal_full.prefab";
        private const string SIRENLIGHT_EFFECT = "assets/prefabs/io/electric/lights/sirenlightorange.prefab";
        private const string SIRENALARM_EFFECT = "assets/prefabs/deployable/playerioents/alarms/audioalarm.prefab";
        private const string PLANE_PREFAB = "assets/prefabs/npc/cargo plane/cargo_plane.prefab";
        private const string SUPPLY_PREFAB = "assets/prefabs/misc/supply drop/supply_drop.prefab";
        private const string HELIBURST_PREFAB = "assets/prefabs/npc/patrol helicopter/rocket_heli_airburst.prefab";
        private const string ROCKETSMOKE_PREFAB = "assets/prefabs/ammo/rocket/rocket_smoke.prefab";
        private const string EXPLOSION_PREFAB = "assets/bundled/prefabs/fx/survey_explosion.prefab";
        private const string HELIEXPLOSION_EFFECT = "assets/prefabs/npc/patrol helicopter/effects/heli_explosion.prefab";
        private const string BRADLEY_CANNON_EFFECT = "assets/prefabs/npc/m2bradley/effects/maincannonattack.prefab";
        private const string PARACHUTE_PREFAB = "assets/prefabs/misc/parachute/parachute.prefab";

        private static RaycastHit rayCastHit;
        private const int CAST_LAYERS = 1 << 0 | 1 << 4 | 1 << 8 | 1 << 10 | 1 << 16 | 1 << 21 | 1 << 23 | 1 << 25 | 1 << 26;

        List<CargoPlane> CargoPlanes = new List<CargoPlane>();
        List<SupplyDrop> SupplyDrops = new List<SupplyDrop>();
        private bool IsFancySupplyDrop(SupplyDrop drop) => SupplyDrops.Contains(drop);
        List<SupplyDrop> LootedDrops = new List<SupplyDrop>();
        List<BaseEntity> activeSignals = new List<BaseEntity>();
        Dictionary<BasePlayer, Timer> timers = new Dictionary<BasePlayer, Timer>();
        private Dictionary<string, int> itemNameToId = new Dictionary<string, int>();
        private ConfigData.StaticOptions.LootOptions lootTable;
        #endregion        

        #region Oxide Hooks
        private void Init()
        {
            Instance = this;
            initialized = false;
            msgConsoleDropSpawn = msg("msgConsoleDropSpawn");
            msgConsoleDropLanded = msg("msgConsoleDropLanded");

            Interface.CallHook("OnFancyDropTypes", configData.DropSettings.setupDropTypes);
        }

        private void Unload()
        {
            airdropTimerStop();

            foreach (var obj in UnityEngine.Object.FindObjectsOfType<ColliderCheck>().ToList())
                GameObject.Destroy(obj);

            foreach (var obj in UnityEngine.Object.FindObjectsOfType<DropTiming>().ToList())
                GameObject.Destroy(obj);

            if (_massDropTimer != null && !_massDropTimer.Destroyed)
                _massDropTimer.Destroy();

            var drops = UnityEngine.Object.FindObjectsOfType<SupplyDrop>().ToList();
            foreach (var drop in drops)
                drop.Kill();

            CargoPlanes.Clear();
            SupplyDrops.Clear();
            LootedDrops.Clear();
            ItemManager.DoRemoves();

            Instance = null;
        }

        private void OnServerInitialized()
        {
            Puts($"Map Highest Point: ({TerrainMeta.HighestPoint.y}m) | Plane flying height: (~{TerrainMeta.HighestPoint.y * configData.AirdropSettings.planeOffSetYMultiply}m)");
            if (configData.TimerSettings.airdropTimerEnabled)
                Puts($"Timed Airdrop activated with '{configData.TimerSettings.airdropTimerMinPlayers}' players between '{configData.TimerSettings.airdropTimerWaitMinutesMin}' and '{configData.TimerSettings.airdropTimerWaitMinutesMax}' minutes");
            if ((configData.TimerSettings.airdropCleanupAtStart && UnityEngine.Time.realtimeSinceStartup < 60) || BasePlayer.activePlayerList.Count == 1)
                airdropCleanUp();
            if (configData.TimerSettings.airdropRemoveInBuilt)
                removeBuiltInAirdrop();
            if (configData.TimerSettings.airdropTimerEnabled)
                airdropTimerNext();

            object value;
            var checkdefaults = defaultDrop();
            foreach (var pair in checkdefaults)
                if (!setupDropDefault.TryGetValue(pair.Key, out value))
                    setupDropDefault.Add(pair.Key, checkdefaults[pair.Key]);

            lang.RegisterMessages(Messages, this);
            initialized = true;
        }

        private void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            NextTick(() =>
            {
                if (!initialized || entity == null || !(entity is SupplySignal))
                    return;

                if (entity.net == null)
                    entity.net = Network.Net.sv.CreateNetworkable();

                if (Interface.CallHook("ShouldFancyDrop", entity.net.ID) != null)
                    return;

                if (activeSignals.Contains(entity))
                    return;

                activeSignals.Add(entity);
                SupplyThrown(player, entity);
            });
        }

        private void OnExplosiveDropped(BasePlayer player, BaseEntity entity, ThrownWeapon thrown)
        {
            NextTick(() =>
            {
                if (!initialized || entity == null || !(entity is SupplySignal))
                    return;

                if (Interface.CallHook("ShouldFancyDrop", entity.net.ID) != null)
                    return;

                if (activeSignals.Contains(entity))
                    return;

                activeSignals.Add(entity);
                SupplyThrown(player, entity);
            });
        }

        private void SupplyThrown(BasePlayer player, BaseEntity entity)
        {
            Vector3 playerposition = player.transform.position;

            timer.Once(3.0f, () => {
                if (entity == null)
                {
                    activeSignals.Remove(entity);
                    return;
                }
                InvokeHandler.CancelInvoke(entity.GetComponent<MonoBehaviour>(), new Action((entity as SupplySignal).Explode));
            });
            timer.Once(3.3f, () => {
                if (entity == null) return;
                activeSignals.Remove(entity);

                Vector3 position = new Vector3();
                string gridPos = GetGridString(position);

                if (!configData.AirdropSettings.disableRandomSupplyPos)
                    position = entity.transform.position + new Vector3(UnityEngine.Random.Range(-20f, 20f), 0f, UnityEngine.Random.Range(-20f, 20f));
                else
                    position = entity.transform.position;
                InvokeHandler.Invoke(entity.GetComponent<MonoBehaviour>(), new Action((entity as SupplySignal).FinishUp), configData.GenericSettings.supplySignalSmokeTime);
                entity.SetFlag(BaseEntity.Flags.On, true, false);
                entity.SendNetworkUpdateImmediate(false);

                if (configData.GenericSettings.lockSignalDrop)
                    startCargoPlane(position, false, null, "supplysignal", "", true, player.userID);
                else
                    startCargoPlane(position, false, null, "supplysignal");

                if (configData.Notifications.notifyDropConsoleSignal)
                    Puts($"SupplySignal thrown by '{player.displayName}' at: {playerposition}");

                if (configData.Notifications.notifyDropAdminSignal)
                {
                    foreach (var admin in BasePlayer.activePlayerList.Where(p => p.IsAdmin).ToList())
                        SendReply(admin, $"<color={configData.GenericSettings.colorAdmMsg}>" + string.Format(msg("msgDropSignalAdmin", player.UserIDString), player.displayName, playerposition) + "</color>");
                }

                if (configData.Notifications.notifyDropSignalByPlayer)
                    if (configData.Notifications.notifyDropSignalByPlayerCoords)
                        PrintToChat(string.Format(configData.GenericSettings.Format, configData.GenericSettings.Color, configData.GenericSettings.Prefix) + $"<color={configData.GenericSettings.colorTextMsg}>" + string.Format(msg("msgDropSignalByPlayerCoords", player.UserIDString), player.displayName, position.x.ToString("0"), position.z.ToString("0")) + "</color>");
                    else if (configData.Notifications.notifyDropSignalByPlayerGrid)
                        PrintToChat(string.Format(configData.GenericSettings.Format, configData.GenericSettings.Color, configData.GenericSettings.Prefix) + $"<color={configData.GenericSettings.colorTextMsg}>" + string.Format(msg("msgDropSignalByPlayerGrid", player.UserIDString), player.displayName, gridPos) + "</color>");
                    else
                        PrintToChat(string.Format(configData.GenericSettings.Format, configData.GenericSettings.Color, configData.GenericSettings.Prefix) + $"<color={configData.GenericSettings.colorTextMsg}>" + string.Format(msg("msgDropSignalByPlayer", player.UserIDString), player.displayName) + "</color>");
            });
        }

        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (!initialized || entity == null || !(entity is SupplyDrop) || LootedDrops.Contains(entity as SupplyDrop))
                return;

            if ((configData.GenericSettings.lockSignalDrop || configData.GenericSettings.lockDirectDrop) && entity.OwnerID != 0uL && entity.OwnerID != player.userID)
            {
                NextTick(() => player.EndLooting());
                MessageToPlayer(player, msg("msgCrateLocked", player.UserIDString));
                if (configData.DebugSettings.useDebug)
                    Puts($"Drop is locked to {entity.OwnerID.ToString()}");
                return;
            }

            if (entity.OwnerID == player.userID)
            {
                string gridPos = GetGridString(entity.transform.position);
                if (configData.Notifications.notifyDropConsoleLooted)
                    Puts($"{player.displayName} ({player.UserIDString}) looted his Drop at: {entity.transform.position.ToString("0")} grid area: {gridPos}");

                if (!configData.GenericSettings.unlockDropAfterLoot)
                {
                    entity.OwnerID = 0uL;
                    LootedDrops.Add(entity as SupplyDrop);
                }
                return;
            }

            if (Vector3.Distance(lastLootPos, entity.transform.position) > ((lastDropRadius * 2) * 1.2))
            {
                string gridPos = GetGridString(entity.transform.position);

                if (configData.Notifications.notifyDropServerLooted)
                    NotifyOnDropLooted(entity, player);
                if (configData.Notifications.notifyDropConsoleLooted)
                    Puts($"{player.displayName} ({player.UserIDString}) looted the Drop at: {entity.transform.position.ToString("0")} grid area: {gridPos}");
                LootedDrops.Add(entity as SupplyDrop);
                lastLootPos = entity.transform.position;
                return;
            }
        }

        private object getFancyDropTypes()
        {
            if (setupDropTypes != null)
                return setupDropTypes;
            else
                return null;
        }

        private void OnTick()
        {
            if (configData.TimersSettings.useRealtimeTimers)
                OnTickReal();
            if (configData.TimersSettings.useGametimeTimers)
                OnTickServer();
        }

        private void OnTickReal()
        {
            if (lastMinute == DateTime.UtcNow.Minute)
                return;

            lastMinute = DateTime.UtcNow.Minute;
            if (BasePlayer.activePlayerList.Count >= configData.TimersSettings.timersMinPlayers && configData.TimersSettings.realTimers.ContainsKey(DateTime.Now.ToString("HH:mm")))
            {
                string runCmd = (string)configData.TimersSettings.realTimers[DateTime.Now.ToString("HH:mm")];
                if (configData.TimersSettings.logTimersToConsole)
                    Puts($"Run real timer: ({DateTime.Now.ToString("HH:mm")}) {runCmd}");
                ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), "ad." + runCmd);
            }
        }

        private void OnTickServer()
        {
            if (lastHour == Math.Floor(TOD_Sky.Instance.Cycle.Hour))
                return;

            lastHour = Math.Floor(TOD_Sky.Instance.Cycle.Hour);
            if (BasePlayer.activePlayerList.Count >= configData.TimersSettings.timersMinPlayers && configData.TimersSettings.serverTimers.ContainsKey(lastHour.ToString()))
            {
                string runCmd = (string)configData.TimersSettings.serverTimers[lastHour.ToString()];
                if (configData.TimersSettings.logTimersToConsole)
                    Puts($"Run server timer: ({lastHour}) {runCmd}");
                ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), "ad." + runCmd);
            }
        }
        #endregion Oxide Hooks

        #region Plugin Hooks
        private bool IsFancyDrop(CargoPlane plane) => plane == null ? false : plane.GetComponent<DropTiming>();

        private object IsFancyDropType(CargoPlane plane)
        {
            if (plane == null || !plane.GetComponent<DropTiming>())
                return false;
            return (string)plane.GetComponent<DropTiming>().dropsettings["droptype"];
        }

        private void OverrideDropTime(CargoPlane plane, float seconds)
        {
            var dropTiming = plane.GetComponent<DropTiming>();
            if (dropTiming != null)
            {
                dropTiming.TimeOverride(seconds);
            }
        }
        #endregion

        #region ColliderCheck
        // Removing from being active until proper fix 
        //private void OnEntityTakeDamage(SupplyDrop entity, HitInfo info)
        //{
        //    if (!configData.DamageSettings.shootDownDrops || info == null)
        //        return;

        //    if (entity is SupplyDrop)
        //    {
        //        var drop = entity as SupplyDrop;
        //        if (drop == null || drop.IsDestroyed)
        //            return;

        //        BaseEntity parachute = _parachute.GetValue(drop) as BaseEntity;
        //        if (parachute == null || parachute.IsDestroyed)
        //            return;

        //        var col = drop.GetComponent<ColliderCheck>();
        //        if (col == null)
        //            return;

        //        if (col.hitCounter < configData.DamageSettings.shootDownCount)
        //        {
        //            col.hitCounter++;
        //            return;
        //        }
        //        parachute.Kill();
        //        parachute = null;
        //        drop.GetComponent<Rigidbody>().drag = configData.DamageSettings.dropDragsetting;
        //        drop.GetComponent<Rigidbody>().mass = configData.DamageSettings.dropMassSetting;
        //        drop.GetComponent<Rigidbody>().useGravity = true;
        //        drop.GetComponent<Rigidbody>().isKinematic = false;
        //        drop.GetComponent<Rigidbody>().interpolation = RigidbodyInterpolation.Interpolate;
        //        drop.GetComponent<Rigidbody>().angularDrag = configData.DamageSettings.dropAngularDragSetting;
        //        drop.GetComponent<Rigidbody>().collisionDetectionMode = CollisionDetectionMode.Continuous;
        //        col.wasHit = true;
        //    }
        //}

        sealed class ColliderCheck : FacepunchBehaviour
        {
            public bool notifyEnabled = true;
            public bool notifyConsole;
            public Dictionary<string, object> cratesettings;
            public bool landed = false;
            public int hitCounter = 0;
            public bool wasHit;
            public string dropType;
            private BaseEntity parachute;

            private void Awake()
            {
                Instance.NextTick(() =>
                {
                    if (dropType != null)
                    {
                        if (Convert.ToBoolean(cratesettings["useCustomLootTable"]))
                            Instance.SetupContainer(GetComponent<StorageContainer>(), dropType, true);
                        else
                            Instance.SetupContainer(GetComponent<StorageContainer>(), dropType);
                    }
                    else
                        Awake();
                });
            }

            private void PlayerStoppedLooting(BasePlayer player)
            {
                if (!configData.GenericSettings.unlockDropAfterLoot || GetComponent<BaseEntity>().OwnerID == 0uL || player.userID != GetComponent<BaseEntity>().OwnerID)
                    return;

                GetComponent<BaseEntity>().OwnerID = 0uL;
                Instance.LootedDrops.Add(GetComponent<BaseEntity>() as SupplyDrop);
            }

            private void OnCollisionEnter(Collision col)
            {
                if (!landed)
                {
                    landed = true;
                    if (wasHit)
                    {
                        if (configData.AirdropSettings.EffectsSettings.useSupplyDropEffectLanded)
                            Effect.server.Run(EXPLOSION_PREFAB, GetComponent<BaseEntity>().transform.position);

                        if (configData.DamageSettings.explodeImpact)
                        {
                            if (UnityEngine.Random.Range(0, 100) <= configData.DamageSettings.explodeChance)
                            {
                                StartCoroutine(HitRemove(true));
                                return;
                            }
                        }
                        else
                        {
                            StartCoroutine(DeSpawn());
                            return;
                        }
                    }

                    if (configData.AirdropSettings.EffectsSettings.useSupplyDropRocket)
                        Instance.CreateRocket(GetComponent<BaseEntity>().transform.position);

                    if (notifyEnabled && configData.Notifications.notifyDropPlayersOnLanded && dropType != "dropdirect" && (((Instance.lastDropRadius * 2) * 1.2) - Vector3.Distance(Instance.lastDropPos, GetComponent<BaseEntity>().transform.position) <= 0 && !(UnityEngine.CollisionEx.GetEntity(col) is SupplyDrop)))
                        Instance.NotifyOnDropLanded(GetComponent<BaseEntity>());

                    Instance.lastDropPos = GetComponent<BaseEntity>().transform.position;

                    StartCoroutine(DeSpawn());

                    if (configData.DebugSettings.useDebug)
                        Instance.Puts("Debug Info: Drop has landed on the ground.");

                    if (configData.AirdropSettings.EffectsSettings.useSupplyDropEffectLanded)
                        Effect.server.Run(EXPLOSION_PREFAB, GetComponent<BaseEntity>().transform.position);

                    if (notifyConsole && configData.Notifications.notifyDropConsoleOnLanded)
                        Instance.Puts(string.Format(Instance.lang.GetMessage(msgConsoleDropLanded, Instance), GetComponent<BaseEntity>().transform.position.x.ToString("0"), GetComponent<BaseEntity>().transform.position.y.ToString("0"), GetComponent<BaseEntity>().transform.position.z.ToString("0")));
                }
            }

            private IEnumerator HitRemove(bool explode)
            {
                if (explode)
                {
                    yield return new WaitForEndOfFrame();
                    Effect.server.Run("assets/bundled/prefabs/fx/item_break.prefab", GetComponent<BaseEntity>().transform.position);
                    (GetComponent<BaseEntity>() as StorageContainer).DropItems();
                    Instance.SupplyDrops.Remove(GetComponent<SupplyDrop>());
                    cratesettings.Clear();
                    GetComponent<BaseEntity>().Kill();
                }
                else
                {
                    yield return new WaitForEndOfFrame();
                    Instance.SupplyDrops.Remove(GetComponent<SupplyDrop>());
                }
            }

            private IEnumerator DeSpawn()
            {
                yield return new WaitForSeconds(Convert.ToSingle(cratesettings["despawnMinutes"]) * 60.0f);
                yield return new WaitWhile(() => GetComponent<BaseEntity>().IsOpen());
                cratesettings.Clear();
                GetComponent<BaseEntity>().Kill();
            }

            private void OnDestroy()
            {
                cratesettings.Clear();
                //Instance.SupplyDrops.Remove(GetComponent<SupplyDrop>());
                //Instance.LootedDrops.Remove(GetComponent<SupplyDrop>());
            }

            internal void OnGroundCollision()
            {
                parachute.Kill(BaseNetworkable.DestroyMode.None);
            }
            public ColliderCheck() { }
        }
        #endregion ColliderCheck

        #region Drop Timing
        class DropTiming : FacepunchBehaviour
        {
            private int dropCount;
            private float updatedTime;
            public Vector3 startPos;
            public Vector3 endPos;
            public bool notify = true;
            private bool notifyConsole = true;
            private int cratesToDrop;
            public string dropType;
            public Dictionary<string, object> dropsettings;
            public ulong userID;

            private float gapTimeToTake = 0f;
            private float halfTimeToTake = 0f;
            private float offsetTimeToTake = 0f;

            private void Awake()
            {
                dropCount = 0;
                notifyConsole = true;
            }

            public void GetSettings(Dictionary<string, object> drop, Vector3 start, Vector3 end, float seconds)
            {
                dropsettings = new Dictionary<string, object>(drop);
                startPos = start;
                endPos = end;
                gapTimeToTake = Convert.ToSingle(dropsettings["cratesGap"]) / Convert.ToSingle(dropsettings["planeSpeed"]);
                halfTimeToTake = seconds / 2;
                offsetTimeToTake = gapTimeToTake / 2;
                cratesToDrop = Mathf.RoundToInt(UnityEngine.Random.Range(Convert.ToSingle(dropsettings["minCrates"]) * 100f, Convert.ToSingle(dropsettings["maxCrates"]) * 100f) / 100f);

                if ((cratesToDrop % 2) == 0)
                    updatedTime = halfTimeToTake - offsetTimeToTake - ((cratesToDrop - 1) / 2 * gapTimeToTake);
                else
                    updatedTime = halfTimeToTake - ((cratesToDrop - 1) / 2 * gapTimeToTake);

                if (userID != 0ul)
                    userID = Convert.ToUInt64(dropsettings["userID"]);
            }
            public void TimeOverride(float seconds)
            {
                halfTimeToTake = seconds / 2;
                offsetTimeToTake = gapTimeToTake / 2;
                cratesToDrop = Mathf.RoundToInt(UnityEngine.Random.Range(Convert.ToSingle(dropsettings["minCrates"]) * 100f, Convert.ToSingle(dropsettings["maxCrates"]) * 100f) / 100f);

                if ((cratesToDrop % 2) == 0)
                    updatedTime = halfTimeToTake - offsetTimeToTake - ((cratesToDrop - 1) / 2 * gapTimeToTake);
                else
                    updatedTime = halfTimeToTake - ((cratesToDrop - 1) / 2 * gapTimeToTake);
            }
            private void Update()
            {
                if ((float)Instance.dropPlanesecondsTaken.GetValue(GetComponent<CargoPlane>()) > updatedTime && dropCount < cratesToDrop)
                {
                    dropsettings = new Dictionary<string, object>();
                    dropsettings = getObjects(dropType);
                    updatedTime += gapTimeToTake;
                    dropCount++;
                    //Instance.Puts("We Got a UserID? " + dropsettings["userID"].ToString());
                    Instance.createSupplyDrop(GetComponent<CargoPlane>().transform.position, dropsettings, notify, notifyConsole, startPos, endPos, dropType, userID);
                    if (configData.Notifications.notifyDropConsoleSpawned && notifyConsole)
                        Instance.Puts(string.Format(Instance.lang.GetMessage(Instance.msgConsoleDropSpawn, Instance), GetComponent<BaseEntity>().transform.position.x.ToString("0"), GetComponent<BaseEntity>().transform.position.y.ToString("0"), GetComponent<BaseEntity>().transform.position.z.ToString("0")));
                }

                if (dropCount == 1 && notify)
                    notify = false;

                if (dropCount == 1 && configData.Notifications.notifyDropConsoleFirstOnly)
                    notifyConsole = false;
            }

            private void OnDestroy()
            {
                dropsettings.Clear();
                Instance.CargoPlanes.Remove(GetComponent<CargoPlane>());
                Destroy(this);
            }

            public DropTiming() { }
        }
        #endregion Drop Timing

        #region Objects Creation
        CargoPlane createCargoPlane(Vector3 pos = new Vector3()) => (CargoPlane)GameManager.server.CreateEntity(PLANE_PREFAB, new Vector3(), new Quaternion(), true);

        private static void RunEffect(string name, BaseEntity entity = null, Vector3 position = new Vector3(), Vector3 offset = new Vector3())
        {
            if (entity != null)
                Effect.server.Run(name, entity, 0, offset, position, null, true);
            else
                Effect.server.Run(name, position, Vector3.up, null, true);
        }

        private static void CreateSirenLights(BaseEntity entity)
        {
            var SirenLight = GameManager.server.CreateEntity(SIRENLIGHT_EFFECT, default(Vector3), default(Quaternion), true);

            SirenLight.gameObject.Identity();
            SirenLight.SetParent(entity as LootContainer, "parachute_attach");
            SirenLight.Spawn();
            SirenLight.SetFlag(BaseEntity.Flags.Reserved8, true);
        }

        private static void CreateSirenAlarms(BaseEntity entity)
        {
            var SirenAlarm = GameManager.server.CreateEntity(SIRENALARM_EFFECT, new Vector3(0f, 0f, 0f), default(Quaternion), true);

            SirenAlarm.gameObject.Identity();
            SirenAlarm.SetParent(entity);
            SirenAlarm.Spawn();
            SirenAlarm.SetFlag(BaseEntity.Flags.Reserved8, true);
        }

        private void CreateDropEffects(BaseEntity entity)
        {
            if (entity == null)
                return;

            if (configData.AirdropSettings.EffectsSettings.useSirenAlarmOnDrop && configData.AirdropSettings.EffectsSettings.useSirenAlarmAtNightOnly && TOD_Sky.Instance.IsNight)
                CreateSirenAlarms(entity);
            else if (configData.AirdropSettings.EffectsSettings.useSirenAlarmAtNightOnly && TOD_Sky.Instance.IsNight)
                CreateSirenAlarms(entity);
            else if (configData.AirdropSettings.EffectsSettings.useSirenAlarmOnDrop)
                CreateSirenAlarms(entity);
            else
                return;

            if (configData.AirdropSettings.EffectsSettings.useSirenLightOnDrop && configData.AirdropSettings.EffectsSettings.useSirenLightAtNightOnly && TOD_Sky.Instance.IsNight)
                CreateSirenLights(entity);
            else if (configData.AirdropSettings.EffectsSettings.useSirenLightAtNightOnly && TOD_Sky.Instance.IsNight)
                CreateSirenLights(entity);
            else if (configData.AirdropSettings.EffectsSettings.useSirenLightOnDrop)
                CreateSirenLights(entity);
            else
                return;
        }

        private void createSupplyDrop(Vector3 pos, Dictionary<string, object> cratesettings, bool notify = true, bool notifyConsole = true, Vector3 start = new Vector3(), Vector3 end = new Vector3(), string dropType = "regular", ulong userID = 0uL)
        {
            SupplyDrop newDrop;
            object value;
            if (configData.DropSettings.setupDropTypes.ContainsKey(dropType))
            {
                cratesettings = getObjects(dropType);

                if (configData.DebugSettings.useDebug)
                    Puts("Debug Info: Yes we have current settings");
            }
            else
            {
                cratesettings = new Dictionary<string, object>((Dictionary<string, object>)setupDropDefault);

                if (configData.DebugSettings.useDebug)
                    Puts("Debug Info: We are using new settings");
            }

            if (userID != 0uL)
            {
                if (configData.DebugSettings.useDebug)
                    Puts("Debug Info: We got userID and set and locked to " + userID.ToString());

                newDrop = GameManager.server.CreateEntity(SUPPLY_PREFAB, pos, new Quaternion(), true) as SupplyDrop;
                (newDrop as BaseEntity).OwnerID = userID;
            }
            else
            {
                newDrop = GameManager.server.CreateEntity(SUPPLY_PREFAB, pos, Quaternion.LookRotation(end - start), true) as SupplyDrop;
                if (configData.DebugSettings.useDebug)
                    Puts("Debug Info: Drop is currently not locked to any players");
            }

            (newDrop as BaseNetworkable).gameObject.AddComponent<ColliderCheck>();
            newDrop.GetComponent<ColliderCheck>().cratesettings = cratesettings;
            newDrop.GetComponent<ColliderCheck>().notifyEnabled = notify;
            newDrop.GetComponent<ColliderCheck>().notifyConsole = notifyConsole;
            newDrop.GetComponent<ColliderCheck>().dropType = dropType;
            newDrop.GetComponent<Rigidbody>().drag = Convert.ToSingle(cratesettings["crateAirResistance"]);

            if (configData.DebugSettings.useDebug)
            {
                Puts("Debug Info: Supply Drop (after spawning) Resistance Now " + Convert.ToDouble(cratesettings["crateAirResistance"]).ToString());
                Puts("Debug Info: Supply Drop (after spawning) Despawn Time " + cratesettings["despawnMinutes"].ToString());
            }

            newDrop.Spawn();

            int slots = 36;
            newDrop.inventory.capacity = 36;
            newDrop.panelName = "generic";
            newDrop.inventory.ServerInitialize(null, slots);
            newDrop.inventory.MarkDirty();

            //Interface.CallHook("OnLootSpawn", new object[] { newDrop.GetComponent<LootContainer>() });
            SupplyDrops.Add(newDrop);

            if (configData.AirdropSettings.EffectsSettings.useSmokeEffectOnDrop)
                RunEffect(SMOKE_EFFECT, newDrop);

            if (configData.AirdropSettings.EffectsSettings.useSirenAlarmOnDrop || configData.AirdropSettings.EffectsSettings.useSirenLightOnDrop && newDrop != null)
            {
                if (newDrop == null)
                    return;

                CreateDropEffects(newDrop);
            }
        }

        private void createSupplyDropSpace(Vector3 pos, Dictionary<string, object> cratesettings, bool notify = true, bool notifyConsole = true, Vector3 start = new Vector3(), Vector3 end = new Vector3(), string dropType = "regular", ulong userID = 0uL)
        {
            SupplyDrop newDrop;
            object value;
            pos.y = 350f;

            if (configData.DropSettings.setupDropTypes.ContainsKey(dropType))
            {
                cratesettings = getObjects(dropType);
                if (configData.DebugSettings.useDebug)
                    Puts("Debug Info: Yes we have current settings");
            }
            else
            {
                cratesettings = new Dictionary<string, object>((Dictionary<string, object>)setupDropDefault);
                if (configData.DebugSettings.useDebug)
                    Puts("Debug Info: We are using new settings");
            }

            if (userID != 0uL)
            {
                if (configData.DebugSettings.useDebug)
                    Puts("Debug Info: We got userID and set and locked to " + userID.ToString());

                newDrop = GameManager.server.CreateEntity(SUPPLY_PREFAB, pos, new Quaternion(), true) as SupplyDrop;
                (newDrop as BaseEntity).OwnerID = userID;
            }
            else
            {
                newDrop = GameManager.server.CreateEntity(SUPPLY_PREFAB, pos, Quaternion.LookRotation(end - start), true) as SupplyDrop;
                if (configData.DebugSettings.useDebug)
                    Puts("Debug Info: Drop is currently not locked to any players");
            }

            (newDrop as BaseNetworkable).gameObject.AddComponent<ColliderCheck>();
            newDrop.GetComponent<ColliderCheck>().cratesettings = cratesettings;
            newDrop.GetComponent<ColliderCheck>().notifyEnabled = notify;
            newDrop.GetComponent<ColliderCheck>().notifyConsole = notifyConsole;
            newDrop.GetComponent<ColliderCheck>().dropType = dropType;
            (newDrop as BaseNetworkable).gameObject.AddComponent<DropBehaviour>();

            Effect.server.Run(BRADLEY_CANNON_EFFECT, newDrop.transform.position, Vector3.zero, null, true);
            newDrop.Invoke(() => Effect.server.Run(HELIEXPLOSION_EFFECT, newDrop.transform.position, Vector3.zero, null, true), 0.5f);
            newDrop.Invoke(() => Effect.server.Run(HELIEXPLOSION_EFFECT, newDrop.transform.position, Vector3.zero, null, true), 0.6f);

            if (configData.DebugSettings.useDebug)
            {
                Puts("Debug Info: Supply Drop (after spawning) Resistance Now " + Convert.ToDouble(cratesettings["crateAirResistance"]).ToString());
                Puts("Debug Info: Supply Drop (after spawning) Despawn Time " + cratesettings["despawnMinutes"].ToString());
            }

            newDrop.Spawn();

            int slots = 36;
            newDrop.inventory.capacity = 36;
            newDrop.panelName = "generic";
            newDrop.inventory.ServerInitialize(null, slots);
            newDrop.inventory.MarkDirty();

            //Interface.CallHook("OnLootSpawn", new object[] { newDrop.GetComponent<LootContainer>() });
            SupplyDrops.Add(newDrop);

            if (configData.AirdropSettings.EffectsSettings.useSmokeEffectOnDrop)
                RunEffect(SMOKE_EFFECT, newDrop);

            if (configData.AirdropSettings.EffectsSettings.useSirenAlarmOnDrop || configData.AirdropSettings.EffectsSettings.useSirenLightOnDrop && newDrop != null)
            {
                if (newDrop == null)
                    return;

                CreateDropEffects(newDrop);
            }
        }

        private void SpawnNetworkable(BaseNetworkable ent)
        {
            if (ent.GetComponent<UnityEngine.Component>().transform.root != ent.GetComponent<UnityEngine.Component>().transform)
                ent.GetComponent<UnityEngine.Component>().transform.parent = null;

            Rust.Registry.Entity.Register(ent.GetComponent<UnityEngine.Component>().gameObject, ent);

            if (ent.net == null)
                ent.net = Network.Net.sv.CreateNetworkable();

            ent.net.handler = ent;
            _creationFrame.SetValue(ent, Time.frameCount);
            ent.PreInitShared();
            ent.InitShared();
            ent.ServerInit();
            ent.PostInitShared();
            ent.UpdateNetworkGroup();
            _isSpawned.SetValue(ent, true);
            Interface.CallHook("OnEntitySpawned", ent);
            ent.SendNetworkUpdateImmediate(true);
        }

        private void CreateRocket(Vector3 startPoint)
        {
            BaseEntity entity = null;
            if (TOD_Sky.Instance.IsNight)
                entity = GameManager.server.CreateEntity(HELIBURST_PREFAB, startPoint + new Vector3(0, 10, 0), new Quaternion(), true);
            else
                entity = GameManager.server.CreateEntity(ROCKETSMOKE_PREFAB, startPoint + new Vector3(0, 10, 0), new Quaternion(), true);

            entity.GetComponent<TimedExplosive>().timerAmountMin = configData.AirdropSettings.EffectsSettings.signalRocketExplosionTime;
            entity.GetComponent<TimedExplosive>().timerAmountMax = configData.AirdropSettings.EffectsSettings.signalRocketExplosionTime;
            entity.GetComponent<ServerProjectile>().gravityModifier = 0f;
            entity.GetComponent<ServerProjectile>().speed = configData.AirdropSettings.EffectsSettings.signalRocketSpeed;
            for (int i = 0; i < entity.GetComponent<TimedExplosive>().damageTypes.Count; i++)
            {
                entity.GetComponent<TimedExplosive>().damageTypes[i].amount *= 0f;
            }
            entity.SendMessage("InitializeVelocity", Vector3.up * 2f);
            entity.Spawn();
        }

        private static Dictionary<string, object> getObjects(string name)
        {
            Dictionary<string, object> dropsettings = new Dictionary<string, object>();
            if (configData.DropSettings.setupDropTypes.ContainsKey(name))
            {
                var json = JsonConvert.SerializeObject(configData.DropSettings.setupDropTypes[name]);
                dropsettings = JsonConvert.DeserializeObject<Dictionary<string, object>>(json) as Dictionary<string, object>;
            }
            return dropsettings;
        }

        public static Dictionary<string, TValue> ToDictionary<TValue>(object obj)
        {
            var json = JsonConvert.SerializeObject(obj);
            var dictionary = JsonConvert.DeserializeObject<Dictionary<string, TValue>>(json);
            return dictionary;
        }

        private void startCargoPlane(Vector3 dropToPos = new Vector3(), bool randomDrop = true, CargoPlane plane = null, string dropType = "regular", string staticList = "", bool showinfo = true, ulong userID = 0uL)
        {
            Dictionary<string, object> dropsettings = new Dictionary<string, object>();
            int speed = 35;
            int additionalheight = 0;
            if (configData.DropSettings.setupDropTypes.ContainsKey(dropType))
            {
                dropsettings = getObjects(dropType);
            }
            else
                dropsettings = new Dictionary<string, object>((Dictionary<string, object>)setupDropDefault);

            if (userID != 0uL)
            {
                if (configData.DebugSettings.useDebug)
                    Puts("Debug Info: UserID received and set as " + userID.ToString());
                dropsettings.Add("userID", userID);
            }

            if (!dropsettings.ContainsKey("droptype"))
                dropsettings.Add("droptype", dropType);

            if (staticList != "")
                dropsettings["CustomLootListName"] = staticList;
            if (Convert.ToInt32(dropsettings["planeSpeed"]) < 20)
                dropsettings["planeSpeed"] = 20;
            if (Convert.ToSingle(dropsettings["crateAirResistance"]) < 0.6)
                dropsettings["crateAirResistance"] = 0.6;
            if (Convert.ToInt32(dropsettings["despawnMinutes"]) < 1)
                dropsettings["despawnMinutes"] = 1;
            if (Convert.ToInt32(dropsettings["cratesGap"]) < 5)
                dropsettings["cratesGap"] = 5;
            if (Convert.ToInt32(dropsettings["minCrates"]) < 1)
                dropsettings["minCrates"] = 1;
            if (Convert.ToInt32(dropsettings["maxCrates"]) < 1)
                dropsettings["maxCrates"] = 1;

            speed = Convert.ToInt32(dropsettings["planeSpeed"]);
            additionalheight = Convert.ToInt32(dropsettings["additionalheight"]);

            object isSupplyDropActive = Interface.Oxide.CallHook("isSupplyDropActive");
            if (dropsettings.ContainsKey("betterloot"))
                dropsettings["betterloot"] = isSupplyDropActive != null && (bool)isSupplyDropActive ? true : false;
            string notificationInfo = "";

            if (dropsettings.ContainsKey("notificationInfo"))
                notificationInfo = (string)dropsettings["notificationInfo"];
            if (plane == null)
                plane = createCargoPlane();
            if (randomDrop)
                dropToPos = plane.RandomDropPosition();

            float x = TerrainMeta.Size.x;
            float y;
            y = (TerrainMeta.HighestPoint.y * configData.AirdropSettings.planeOffSetYMultiply) + additionalheight;
            Vector3 startPos = Vector3Ex.Range(-1f, 1f);
            startPos.y = 0f;
            startPos.Normalize();
            startPos *= x * configData.AirdropSettings.planeOffSetXMultiply;
            startPos.y = y;
            Vector3 endPos = startPos * -1f;
            endPos.y = startPos.y;
            startPos += dropToPos;
            endPos += dropToPos;
            float secondsToTake = Vector3.Distance(startPos, endPos) / speed;
            plane.gameObject.AddComponent<DropTiming>();
            plane.GetComponent<DropTiming>().dropType = dropType;
            plane.GetComponent<DropTiming>().userID = userID;
            plane.GetComponent<DropTiming>().GetSettings(dropsettings, startPos, endPos, secondsToTake);

            if (configData.DebugSettings.useDebug)
            {
                Puts("Debug Info: Plane Height Setting " + dropsettings["additionalheight"].ToString());
                Puts("Debug Info: Plane Speed Setting " + dropsettings["planeSpeed"].ToString());
                Puts("Debug Info: Supply Drop Despawn Setting " + dropsettings["despawnMinutes"].ToString());
                Puts("Debug Info: Supply Drop Resistance Setting " + dropsettings["crateAirResistance"].ToString());
                Puts("Debug Info: Notification Info " + notificationInfo);
                if (userID != 0uL)
                    Puts("Debug Info: UserID Set to " + dropsettings["userID"].ToString());
            }

            dropsettings.Clear();
            dropPlanedropped.SetValue(plane, true);
            plane.InitDropPosition(dropToPos);

            if (!CargoPlanes.Contains(plane))
            {
                if ((plane as BaseNetworkable).net == null)
                    (plane as BaseNetworkable).net = Network.Net.sv.CreateNetworkable();
                CargoPlanes.Add(plane);
            }

            (plane as BaseNetworkable).limitNetworking = true;

            if ((int)_creationFrame.GetValue(plane) == 0)
                plane.Spawn();

            plane.transform.position = startPos;
            plane.transform.rotation = Quaternion.LookRotation(endPos - startPos);
            dropPlanestartPos.SetValue(plane, startPos);
            dropPlaneendPos.SetValue(plane, endPos);
            dropPlanesecondsToTake.SetValue(plane, secondsToTake);
            (plane as BaseNetworkable).limitNetworking = false;

            if (showinfo)
                DropNotifier(dropToPos, dropType, staticList, notificationInfo);
        }

        private static string GetGridString(Vector3 position) => MapHelper.PositionToString(position);

        private void DropNotifier(Vector3 dropToPos, string dropType, string staticList, string notificationInfo)
        {
            string gridPos = GetGridString(dropToPos);

            if (dropType == "dropdirect")
                return;

            else if (dropType == "supplysignal")
            {
                if (configData.Notifications.notifyDropServerSignal)
                    if (configData.Notifications.notifyDropGUI && configData.UISettings.SimpleUI_Enable)
                        if (configData.Notifications.notifyDropServerSignalCoords)
                            foreach (var player in BasePlayer.activePlayerList)
                                MessageToPlayerUI(player, string.Format(msg("msgDropSignalCoords", player.UserIDString), dropToPos.x.ToString("0"), dropToPos.z.ToString("0")));
                        else if (configData.Notifications.notifyDropServerSignalGrid)
                            foreach (var player in BasePlayer.activePlayerList)
                                MessageToPlayerUI(player, string.Format(msg("msgDropSignalGrid", player.UserIDString), gridPos));
                        else
                            foreach (var player in BasePlayer.activePlayerList)
                                MessageToPlayerUI(player, string.Format(msg("msgDropSignal", player.UserIDString)));
                    else if (configData.Notifications.notifyDropGUI && GUIAnnouncements)
                        if (configData.Notifications.notifyDropServerSignalCoords)
                            MessageToAllGui(string.Format(msg("msgDropSignalCoords"), dropToPos.x.ToString("0"), dropToPos.z.ToString("0")));
                        else if (configData.Notifications.notifyDropServerSignalGrid)
                            MessageToAllGui(string.Format(msg("msgDropSignalGrid"), gridPos));
                        else
                            MessageToAllGui(msg("msgDropSignal"));
                    else
                        if (configData.Notifications.notifyDropServerSignalCoords)
                        foreach (var player in BasePlayer.activePlayerList)
                            MessageToPlayer(player, string.Format(msg("msgDropSignalCoords", player.UserIDString), dropToPos.x.ToString("0"), dropToPos.z.ToString("0")));
                    else if (configData.Notifications.notifyDropServerSignalGrid)
                        foreach (var player in BasePlayer.activePlayerList)
                            MessageToPlayer(player, string.Format(msg("msgDropSignalGrid", player.UserIDString), gridPos));
                    else
                        foreach (var player in BasePlayer.activePlayerList)
                            MessageToPlayer(player, msg("msgDropSignal", player.UserIDString));
                return;
            }
            else if (dropType == "regular")
            {
                if (configData.Notifications.notifyDropServerRegular)
                    if (configData.Notifications.notifyDropGUI && configData.UISettings.SimpleUI_Enable)
                        if (configData.Notifications.notifyDropServerRegularCoords)
                            foreach (var player in BasePlayer.activePlayerList)
                                MessageToPlayerUI(player, string.Format(msg("msgDropRegularCoords", player.UserIDString), dropToPos.x.ToString("0"), dropToPos.z.ToString("0")));
                        else if (configData.Notifications.notifyDropServerRegularGrid)
                            foreach (var player in BasePlayer.activePlayerList)
                                MessageToPlayerUI(player, string.Format(msg("msgDropRegularGrid", player.UserIDString), gridPos));
                        else
                            foreach (var player in BasePlayer.activePlayerList)
                                MessageToPlayerUI(player, msg("msgDropRegular", player.UserIDString));
                    else if (configData.Notifications.notifyDropGUI && GUIAnnouncements)
                        if (configData.Notifications.notifyDropServerRegularCoords)
                            MessageToAllGui(string.Format(msg("msgDropRegularCoords"), dropToPos.x.ToString("0"), dropToPos.z.ToString("0")));
                        else if (configData.Notifications.notifyDropServerRegularGrid)
                            MessageToAllGui(string.Format(msg("msgDropRegularGrid"), gridPos));
                        else
                            MessageToAllGui(msg("msgDropRegular"));
                    else
                        if (configData.Notifications.notifyDropServerRegularCoords)
                        foreach (var player in BasePlayer.activePlayerList)
                            MessageToPlayer(player, string.Format(msg("msgDropRegularCoords", player.UserIDString), dropToPos.x.ToString("0"), dropToPos.z.ToString("0")));
                    else if (configData.Notifications.notifyDropServerRegularGrid)
                        foreach (var player in BasePlayer.activePlayerList)
                            MessageToPlayer(player, string.Format(msg("msgDropRegularGrid", player.UserIDString), gridPos));
                    else
                        foreach (var player in BasePlayer.activePlayerList)
                            MessageToPlayer(player, msg("msgDropRegular", player.UserIDString));
                return;
            }
            else if (dropType == "massdrop")
            {
                if (configData.Notifications.notifyDropServerMass)
                    if (configData.Notifications.notifyDropGUI && configData.UISettings.SimpleUI_Enable)
                        foreach (var player in BasePlayer.activePlayerList)
                            MessageToPlayerUI(player, msg("msgDropMass", player.UserIDString));
                    else if (configData.Notifications.notifyDropGUI && GUIAnnouncements)
                        MessageToAllGui(msg("msgDropMass"));
                    else
                        foreach (var player in BasePlayer.activePlayerList)
                            MessageToPlayer(player, msg("msgDropMass", player.UserIDString));
                return;
            }
            else
            {
                if (configData.Notifications.notifyDropServerCustom)
                    if (configData.Notifications.notifyDropGUI && configData.UISettings.SimpleUI_Enable)
                        if (configData.Notifications.notifyDropServerCustomCoords && _massDropTimer != null && _massDropTimer.Repetitions == 0)
                            foreach (var player in BasePlayer.activePlayerList)
                                MessageToPlayerUI(player, string.Format(msg("msgDropCustomCoords", player.UserIDString), notificationInfo, dropToPos.x.ToString("0"), dropToPos.z.ToString("0")));
                        else if (configData.Notifications.notifyDropServerCustomGrid && _massDropTimer != null && _massDropTimer.Repetitions == 0)
                            foreach (var player in BasePlayer.activePlayerList)
                                MessageToPlayerUI(player, string.Format(msg("msgDropCustomGrid", player.UserIDString), notificationInfo, gridPos));
                        else
                            foreach (var player in BasePlayer.activePlayerList)
                                MessageToPlayerUI(player, string.Format(msg("msgDropCustom", player.UserIDString), notificationInfo));
                    else if (configData.Notifications.notifyDropGUI && GUIAnnouncements)
                        if (configData.Notifications.notifyDropServerCustomCoords && _massDropTimer != null && _massDropTimer.Repetitions == 0)
                            MessageToAllGui(string.Format(msg("msgDropCustomCoords"), notificationInfo, dropToPos.x.ToString("0"), dropToPos.z.ToString("0")));
                        else if (configData.Notifications.notifyDropServerCustomGrid && _massDropTimer != null && _massDropTimer.Repetitions == 0)
                            MessageToAllGui(string.Format(msg("msgDropCustoGrid"), notificationInfo, gridPos));
                        else
                            MessageToAllGui(string.Format(msg("msgDropCustom"), notificationInfo));
                    else
                        if (configData.Notifications.notifyDropServerCustomCoords && _massDropTimer != null && _massDropTimer.Repetitions == 0)
                        foreach (var player in BasePlayer.activePlayerList)
                            MessageToPlayer(player, string.Format(msg("msgDropCustomCoords", player.UserIDString), notificationInfo, dropToPos.x.ToString("0"), dropToPos.z.ToString("0")));
                    else if (configData.Notifications.notifyDropServerCustomGrid && _massDropTimer != null && _massDropTimer.Repetitions == 0)
                        foreach (var player in BasePlayer.activePlayerList)
                            MessageToPlayer(player, string.Format(msg("msgDropCustomGrid", player.UserIDString), notificationInfo, gridPos));
                    else
                        foreach (var player in BasePlayer.activePlayerList)
                            MessageToPlayer(player, string.Format(msg("msgDropCustom", player.UserIDString), notificationInfo));
            }
        }
        #endregion ObjectsCreation        

        #region Airdrop Timers
        private void airdropTimerNext(int custom = 0)
        {
            if (configData.TimerSettings.airdropTimerEnabled)
            {
                int delay;
                airdropTimerStop();
                if (custom == 0)
                    delay = UnityEngine.Random.Range(configData.TimerSettings.airdropTimerWaitMinutesMin, configData.TimerSettings.airdropTimerWaitMinutesMax);
                else
                    delay = custom;
                _aidropTimer = timer.Once(delay * 60, airdropTimerRun);
                if (configData.Notifications.notifyDropConsoleRegular)
                    Puts($"Next timed Airdrop in {delay.ToString()} minutes");
            }
        }

        private void airdropTimerRun()
        {
            var playerCount = BasePlayer.activePlayerList.Count;
            if (playerCount >= configData.TimerSettings.airdropTimerMinPlayers)
            {
                ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), "ad." + configData.TimerSettings.airdropTimerCmd.Replace("ad.", ""));
                if (configData.Notifications.notifyDropConsoleRegular)
                    Puts($"Timed Airdrop initiated with command '{"ad." + configData.TimerSettings.airdropTimerCmd.Replace("ad.", "")}'");
            }
            else
            {
                if (configData.Notifications.notifyDropConsoleRegular)
                    Puts("Timed Airdrop skipped, not enough Players");
            }
            airdropTimerNext();
        }

        private void airdropTimerStop()
        {
            if (_aidropTimer == null || _aidropTimer.Destroyed)
                return;

            _aidropTimer.Destroy();
            _aidropTimer = null;
        }

        private void removeBuiltInAirdrop()
        {
            var triggeredEvents = UnityEngine.Object.FindObjectsOfType<TriggeredEventPrefab>();
            var planePrefab = triggeredEvents.Where(e => e.targetPrefab != null && e.targetPrefab.guid.Equals("8429b072581d64747bfe17eab7852b42")).ToList();
            foreach (var prefab in planePrefab)
            {
                Puts("Builtin Airdrop removed");
                UnityEngine.Object.Destroy(prefab);
            }
        }
        #endregion Airdrop Timers

        #region FindPlayer
        private static BasePlayer FindPlayerByName(string name)
        {
            BasePlayer result = null;
            foreach (BasePlayer current in BasePlayer.activePlayerList)
            {
                if (current.displayName.Equals(name, StringComparison.OrdinalIgnoreCase))
                {
                    BasePlayer result2 = current;
                    return result2;
                }

                if (current.UserIDString.Contains(name, CompareOptions.OrdinalIgnoreCase))
                {
                    BasePlayer result2 = current;
                    return result2;
                }

                if (current.displayName.Contains(name, CompareOptions.OrdinalIgnoreCase))
                {
                    result = current;
                }
            }
            return result;
        }
        #endregion FindPlayer        

        #region Setup Loot
        private void ClearContainer(ItemContainer itemContainer)
        {
            if (itemContainer == null || itemContainer.itemList == null)
                return;

            while (itemContainer.itemList.Count > 0)
            {
                var item = itemContainer.itemList[0];
                item.RemoveFromContainer();
                item.Remove(0f);
                item.DoRemove();
            }
            Puts("Cleared Container");
        }

        private void FillLootContainer(BaseEntity Container, string dropType)
        {
            if (Container == null)
                return;

            ItemContainer itemContainer = Container.GetComponent<StorageContainer>()?.inventory;
            if (itemContainer == null)
                return;

            bool exitloop = false;
            foreach (var dtn in configData.StaticItems.LootSettings)
            {
                switch (dtn.DropTypeName)
                {
                    case "regular":
                    case "massdrop":
                    case "dropdirect":
                    case "supplysignal":
                    case "custom_event":
                        if (dtn.DropTypeName == dropType)
                        {

                            int count = UnityEngine.Random.Range(dtn.MinimumItems, dtn.MaximumItems);

                            if (itemContainer.capacity < count)
                                itemContainer.capacity = count;

                            List<ConfigData.StaticOptions.LootOptions.LootItem> Items = new List<ConfigData.StaticOptions.LootOptions.LootItem>(dtn.Items);
                            for (int i = 0; i < count; i++)
                            {
                                if (Items.Count == 0)
                                    Items = new List<ConfigData.StaticOptions.LootOptions.LootItem>(dtn.Items);

                                ConfigData.StaticOptions.LootOptions.LootItem lootItem = Items.GetRandom();
                                if (lootItem == null)
                                {
                                    count--;
                                    continue;
                                }

                                Item item = null;
                                item = ItemManager.CreateByName(lootItem.Name, 1, lootItem.Skin);

                                if (item != null)
                                {
                                    item.amount = UnityEngine.Random.Range(lootItem.Minimum, lootItem.Maximum);
                                    item.MarkDirty();
                                    if (lootItem.DisplayName != null)
                                        item.name = lootItem.DisplayName;

                                    item.MoveToContainer(itemContainer, -1, false);
                                }
                                Items.Remove(lootItem);
                            }
                            exitloop = true;
                        }
                        break;
                    default:
                        break;
                }
                if (exitloop) break;
            }
        }

        //private void SetupContainer(StorageContainer drop, Dictionary<string, object> setup)
        private void SetupContainer(StorageContainer drop, string dropType, bool CustomLoot = false)
        {
            ItemContainer itemContainer = drop.GetComponent<StorageContainer>()?.inventory;

            if (Instance.AlphaLoot != null && Instance.AlphaLoot.Call("WantsToHandleFancyDropLoot") != null)
                return;

            if (Instance.MagicLoot != null && Instance.MagicLoot.CallHook("OnLootSpawn", new object[] { drop.GetComponent<LootContainer>() }) != null)
                return;

            if (dropType != null && CustomLoot)
            {
                ClearContainer(itemContainer);
                FillLootContainer(drop, dropType);
                return;
            }
        }
        #endregion Setup Loot

        #region SimpleUI
        private class UIColor
        {
            string color;

            public UIColor(double red, double green, double blue, double alpha)
            {
                color = $"{red} {green} {blue} {alpha}";
            }

            public override string ToString() => color;
        }

        private class UIObject
        {
            List<object> ui = new List<object>();
            List<string> objectList = new List<string>();

            public UIObject()
            {
            }

            public void Draw(BasePlayer player)
            {
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "AddUI", JsonConvert.SerializeObject(ui).Replace("{NEWLINE}", Environment.NewLine));
            }

            public void Destroy(BasePlayer player)
            {
                foreach (string uiName in objectList)
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "DestroyUI", uiName);
            }

            public string AddText(string name, double left, double top, double width, double height, string color, string text, int textsize = 15, string parent = "Hud", int alignmode = 0, float fadeIn = 0f, float fadeOut = 0f)
            {
                text = text.Replace("\n", "{NEWLINE}");
                string align = "";

                switch (alignmode)
                {
                    case 0: { align = "LowerCenter"; break; };
                    case 1: { align = "LowerLeft"; break; };
                    case 2: { align = "LowerRight"; break; };
                    case 3: { align = "MiddleCenter"; break; };
                    case 4: { align = "MiddleLeft"; break; };
                    case 5: { align = "MiddleRight"; break; };
                    case 6: { align = "UpperCenter"; break; };
                    case 7: { align = "UpperLeft"; break; };
                    case 8: { align = "UpperRight"; break; };
                }

                ui.Add(new Dictionary<string, object> {
                    {"name", name},
                    {"parent", parent},
                    {"fadeOut", fadeOut.ToString()},
                    {"components",
                        new List<object> {
                            new Dictionary<string, string> {
                                {"type", "UnityEngine.UI.Text"},
                                {"text", text},
                                {"fontSize", textsize.ToString()},
                                {"color", color.ToString()},
                                {"align", align},
                                {"fadeIn", fadeIn.ToString()}
                            },
                            new Dictionary<string, string> {
                                {"type", "RectTransform"},
                                {"anchormin", $"{left} {((1 - top) - height)}"},
                                {"anchormax", $"{(left + width)} {(1 - top)}"}
                            }
                        }
                    }
                });

                objectList.Add(name);
                return name;
            }
        }

        private void UIMessage(BasePlayer player, string message)
        {
            bool replaced = false;
            float fadeIn = 0.2f;
            Timer playerTimer;

            timers.TryGetValue(player, out playerTimer);
            if (playerTimer != null && !playerTimer.Destroyed)
            {
                playerTimer.Destroy();
                fadeIn = 0.1f;
                replaced = true;
            }

            UIObject ui = new UIObject();

            ui.AddText("Notice_DropShadow", configData.UISettings.SimpleUI_Left + 0.002, configData.UISettings.SimpleUI_Top + 0.002, configData.UISettings.SimpleUI_MaxWidth, configData.UISettings.SimpleUI_MaxHeight, configData.UISettings.SimpleUI_ShadowColor, StripTags(message), configData.UISettings.SimpleUI_FontSize, "Hud", 3, fadeIn, 0.2f);
            ui.AddText("Notice", configData.UISettings.SimpleUI_Left, configData.UISettings.SimpleUI_Top, configData.UISettings.SimpleUI_MaxWidth, configData.UISettings.SimpleUI_MaxHeight, configData.UISettings.SimpleUI_NoticeColor, message, configData.UISettings.SimpleUI_FontSize, "Hud", 3, fadeIn, 0.2f);

            ui.Destroy(player);

            if (replaced)
            {
                timer.Once(0.1f, () =>
                {
                    ui.Draw(player);
                    timers[player] = timer.Once(configData.UISettings.SimpleUI_HideTimer, () => ui.Destroy(player));
                });
            }
            else
            {
                ui.Draw(player);
                timers[player] = timer.Once(configData.UISettings.SimpleUI_HideTimer, () => ui.Destroy(player));
            }
        }

        private string StripTags(string original)
        {
            foreach (string tag in tags)
                original = original.Replace(tag, "");

            foreach (Regex regexTag in regexTags)
                original = regexTag.Replace(original, "");

            return original;
        }
        #endregion SimpleUI

        #region Space Drop Component
        private class DropBehaviour : MonoBehaviour
        {
            private SupplyDrop sDrop;
            private Rigidbody rBody;
            private Transform transForm;

            private float heightAtPos;
            private float distToTarget;
            private bool DeployedChute = false;

            private BaseEntity parachute;
            private Vector3 velocityDrop;

            private void Awake()
            {
                sDrop = GetComponent<SupplyDrop>();
                rBody = GetComponent<Rigidbody>();
                transForm = sDrop.transform;
            }

            private void Start()
            {
                sDrop.RemoveParachute();

                rBody.isKinematic = false;
                rBody.useGravity = true;
                rBody.mass = 1.25f;
                rBody.interpolation = RigidbodyInterpolation.Interpolate;
                rBody.drag = 0.1f;
                rBody.angularDrag = 0.1f;
                rBody.AddForce(Vector3.down * configData.AirdropSettings.SpaceSettings.dropVelocity, ForceMode.Impulse);

                if (Physics.Raycast(transForm.position + Vector3.down, Vector3.down, out rayCastHit, 500f, CAST_LAYERS, QueryTriggerInteraction.Collide))
                    heightAtPos = rayCastHit.point.y;
                else
                    heightAtPos = TerrainMeta.HeightMap.GetHeight(transForm.position);
            }

            private void Update()
            {
                distToTarget = transForm.position.y - heightAtPos;

                if (distToTarget < configData.AirdropSettings.SpaceSettings.dropGroundDistance && distToTarget > 2f)
                {
                    if (!DeployedChute)
                    {
                        parachute = GameManager.server.CreateEntity(PARACHUTE_PREFAB, transForm.position, Quaternion.identity);
                        parachute.SetParent(sDrop, "parachute_attach", false, false);
                        parachute.transform.localPosition = Vector3.zero;
                        parachute.transform.localRotation = Quaternion.identity;
                        parachute.enableSaving = false;
                        parachute.Spawn();

                        velocityDrop = rBody.velocity;

                        DeployedChute = true;
                    }

                    rBody.velocity = Vector3.Lerp(velocityDrop, Vector3.zero, 1f - Mathf.InverseLerp(0f, configData.AirdropSettings.SpaceSettings.dropGroundDistance, distToTarget));
                }

                if (distToTarget < 1f)
                {
                    if (DeployedChute)
                    {
                        sDrop.RemoveParachute();
                        parachute.Kill(BaseNetworkable.DestroyMode.None);
                    }
                    DeployedChute = false;
                    return;
                }
            }

            private void OnGroundCollision()
            {
                sDrop.RemoveParachute();
                parachute.Kill(BaseNetworkable.DestroyMode.None);
                Destroy(this);
            }
        }
        #endregion

        #region Commands

        #region Console Commands
        [ConsoleCommand("ad.random")]
        private void dropRandom(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < configData.GenericSettings.neededAuthLvl) return;
            var plane = createCargoPlane();
            Vector3 newpos = plane.RandomDropPosition();
            newpos.y += TerrainMeta.HeightMap.GetHeight(newpos);
            string gridPos = GetGridString(newpos);
            string type = "regular";
            if (arg.Args != null && arg.Args.Length > 0)
                if (configData.DropSettings.setupDropTypes.ContainsKey(arg.Args[0]))
                    type = arg.Args[0];
                else
                {
                    SendReply(arg, "Droptype not found");
                    return;
                }
            string list = "";
            if (arg.Args != null && arg.Args.Length > 1)
            {
                bool exitloop = false;
                foreach (var dtn in configData.StaticItems.LootSettings)
                {
                    switch (dtn.DropTypeName)
                    {
                        case "regular":
                        case "massdrop":
                        case "dropdirect":
                        case "supplysignal":
                        case "custom_event":
                            if (dtn.DropTypeName == arg.Args[1])
                            {
                                list = arg.Args[1];
                                if (configData.DebugSettings.useDebug) Puts("List " + arg.Args[1].ToString());
                                exitloop = true;
                            }
                            else
                            {
                                SendReply(arg, string.Format("Static itemlist not found"));
                                exitloop = true;
                                return;
                            }
                            break;
                        default:
                            break;
                    }
                    if (exitloop) break;
                }
            }
            startCargoPlane(newpos, false, plane, type, list);
            if (list == "")
                SendReply(arg, $"Random Airdrop of type '{type}' incoming at: {newpos.ToString("0")} grid area: {gridPos}");
            else
                SendReply(arg, $"Random Airdrop of type '{type}|{list}' incoming at: {newpos.ToString("0")} grid area: {gridPos}");
            if (configData.TimerSettings.airdropTimerEnabled && configData.TimerSettings.airdropTimerResetAfterRandom)
                airdropTimerNext();
        }

        [ConsoleCommand("ad.topos")]
        private void dropToPos(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < configData.GenericSettings.neededAuthLvl) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Please specity location with X and Z coordinates as integer");
                return;
            }
            string type = "regular";
            if (arg.Args != null && arg.Args.Length > 2)
                if (configData.DropSettings.setupDropTypes.ContainsKey(arg.Args[2]))
                    type = arg.Args[2];
                else
                {
                    SendReply(arg, "Droptype not found");
                    return;
                }
            string list = "";
            if (arg.Args != null && arg.Args.Length > 3)
            {
                bool exitloop = false;
                foreach (var dtn in configData.StaticItems.LootSettings)
                {
                    switch (dtn.DropTypeName)
                    {
                        case "regular":
                        case "massdrop":
                        case "dropdirect":
                        case "supplysignal":
                        case "custom_event":
                            if (dtn.DropTypeName == arg.Args[3])
                            {
                                list = arg.Args[3];
                                if (configData.DebugSettings.useDebug) Puts("List " + arg.Args[3].ToString());
                                exitloop = true;
                            }
                            else
                            {
                                SendReply(arg, string.Format("Cusatom Loot list not found"));
                                exitloop = true;
                                return;
                            }
                            break;
                        default:
                            break;
                    }
                    if (exitloop) break;
                }
            }
            Vector3 newpos = new Vector3(Convert.ToInt32(arg.Args[0]), 0, Convert.ToInt32(arg.Args[1]));
            newpos.y += TerrainMeta.HeightMap.GetHeight(newpos);
            string gridPos = GetGridString(newpos);
            startCargoPlane(newpos, false, null, type, list);
            if (list == "")
                SendReply(arg, $"Airdrop of type '{type}' started to: {newpos.ToString("0")} grid area: {gridPos}");
            else
                SendReply(arg, $"Airdrop of type '{type}|{list}' started to: {newpos.ToString("0")} grid area: {gridPos}");
        }

        [ConsoleCommand("ad.massdrop")]
        private void dropMass(ConsoleSystem.Arg arg)
        {
            int drops = 0;
            if (arg.Connection != null && arg.Connection.authLevel < configData.GenericSettings.neededAuthLvl) return;
            if (arg.Args == null)
                drops = configData.AirdropSettings.airdropMassdropDefault;
            else if (arg.Args != null && arg.Args.Length >= 1)
            {
                int.TryParse(arg.Args[0], out drops);
                if (drops == 0)
                {
                    SendReply(arg, "Massdrop value has to be an integer number");
                    return;
                }
            }
            string type = "massdrop";
            if (arg.Args != null && arg.Args.Length > 1)
                if (configData.DropSettings.setupDropTypes.ContainsKey(arg.Args[1]))
                    type = arg.Args[1];
                else
                {
                    SendReply(arg, string.Format("Droptype not found"));
                    return;
                }
            string list = "";
            if (arg.Args != null && arg.Args.Length > 2)
            {
                bool exitloop = false;
                foreach (var dtn in configData.StaticItems.LootSettings)
                {
                    switch (dtn.DropTypeName)
                    {
                        case "regular":
                        case "massdrop":
                        case "dropdirect":
                        case "supplysignal":
                        case "custom_event":
                            if (dtn.DropTypeName == arg.Args[2])
                            {
                                list = arg.Args[2];
                                if (configData.DebugSettings.useDebug) Puts("List " + arg.Args[2].ToString());
                                exitloop = true;
                            }
                            else
                            {
                                SendReply(arg, string.Format("Custom Loot list not found"));
                                exitloop = true;
                                return;
                            }
                            break;
                        default:
                            break;
                    }
                    if (exitloop) break;
                }
            }
            if (list == "")
                SendReply(arg, $"Massdrop started with {drops.ToString()} Drops of type '{type}'");
            else
                SendReply(arg, $"Massdrop started with {drops.ToString()} Drops of type '{type}|{list}'");
            if (_massDropTimer != null && !_massDropTimer.Destroyed)
                _massDropTimer.Destroy();
            bool showinfo = true;
            _massDropTimer = timer.Repeat(configData.AirdropSettings.airdropMassdropDelay, drops + 1, () => {
                if (_massDropTimer == null || _massDropTimer.Destroyed) return;
                startCargoPlane(Vector3.zero, true, null, type, list, showinfo);
                if (_massDropTimer.Repetitions == drops) showinfo = false;
            });
        }

        [ConsoleCommand("ad.massdropto")]
        private void dropMassTo(ConsoleSystem.Arg arg)
        {
            int drops = configData.AirdropSettings.airdropMassdropDefault;
            float x = -99999;
            float z = -99999;
            float radius = configData.AirdropSettings.airdropMassdropRadiusDefault;
            if ((arg.Connection != null && arg.Connection.authLevel < configData.GenericSettings.neededAuthLvl) || arg.Args == null) return;
            if (arg.Args.Length < 2)
            {
                SendReply(arg, "Specify at minumum (X) and (Z)");
                return;
            }
            if (arg.Args.Length >= 3) int.TryParse(arg.Args[2], out drops);

            if (!float.TryParse(arg.Args[0], out x) || !float.TryParse(arg.Args[1], out z))
            {
                SendReply(arg, "Specify at minumum (X) (Z) or with '0 0' for random position | and opt:drop-count and opt:radius )");
                return;
            }
            Vector3 newpos = new Vector3();
            if (x == 0 || z == 0)
            {
                newpos = referencePlane.RandomDropPosition();
                x = newpos.x;
                z = newpos.z;
            }
            if (arg.Args.Length > 3) float.TryParse(arg.Args[3], out radius);
            lastDropRadius = radius;
            string type = "massdrop";
            if (arg.Args != null && arg.Args.Length > 4)
                if (configData.DropSettings.setupDropTypes.ContainsKey(arg.Args[4]))
                    type = arg.Args[4];
                else
                {
                    SendReply(arg, string.Format("Droptype not found"));
                    return;
                }
            string list = "";
            if (arg.Args != null && arg.Args.Length > 5)
            {
                bool exitloop = false;
                foreach (var dtn in configData.StaticItems.LootSettings)
                {
                    switch (dtn.DropTypeName)
                    {
                        case "regular":
                        case "massdrop":
                        case "dropdirect":
                        case "supplysignal":
                        case "custom_event":
                            if (dtn.DropTypeName == arg.Args[5])
                            {
                                list = arg.Args[5];
                                if (configData.DebugSettings.useDebug) Puts("List " + arg.Args[5].ToString());
                                exitloop = true;
                            }
                            else
                            {
                                SendReply(arg, string.Format("Custom Loot list not found"));
                                exitloop = true;
                                return;
                            }
                            break;
                    }
                    if (exitloop) break;
                }
            }
            if (list == "")
                SendReply(arg, string.Format($"Massdrop  of type '{type}' to (X:{x.ToString("0")} Z:{z.ToString("0")}) started with {drops.ToString()} Drops( {radius}m Radius)"));
            else
                SendReply(arg, string.Format($"Massdrop  of type '{type}|{list}' to (X:{x.ToString("0")} Z:{z.ToString("0")}) started with {drops.ToString()} Drops( {radius}m Radius)"));
            if (_massDropTimer != null && !_massDropTimer.Destroyed)
                _massDropTimer.Destroy();
            bool showinfo = true;
            _massDropTimer = timer.Repeat(configData.AirdropSettings.airdropMassdropDelay, drops + 1, () => {
                if (_massDropTimer == null || _massDropTimer.Destroyed) return;
                newpos.x = UnityEngine.Random.Range(x - radius, x + radius);
                newpos.z = UnityEngine.Random.Range(z - radius, z + radius);
                //newpos.y -= TerrainMeta.HeightMap.GetHeight(newpos);
                startCargoPlane(newpos, false, null, type, list, showinfo);
                if (_massDropTimer.Repetitions == drops) showinfo = false;
            });
        }

        [ConsoleCommand("ad.toplayer")]
        private void dropToPlayer(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < configData.GenericSettings.neededAuthLvl) return;
            if (arg.Args == null)
            {
                SendReply(arg, string.Format("Please specify a target playername"));
                return;
            }
            if (arg.Args[0] == "*")
            {
                foreach (BasePlayer target in BasePlayer.activePlayerList)
                {
                    if (target.IsAdmin) continue;
                    NextTick(() => {
                        var newpos = new Vector3();
                        newpos = target.transform.position;
                        startCargoPlane(newpos, false, null, "dropdirect");
                        if (configData.Notifications.notifyDropPlayer)
                            MessageToPlayer(target, msg("msgDropPlayer", target.UserIDString));
                    });
                }
                SendReply(arg, string.Format($"Started Airdrop to each active player"));
            }
            else
            {
                BasePlayer target = FindPlayerByName(arg.Args[0]);
                if (target == null)
                {
                    SendReply(arg, string.Format($"Player '{arg.Args[0]}' not found"));
                    return;
                }
                var newpos = new Vector3();
                newpos = target.transform.position;
                string gridPos = GetGridString(newpos);
                startCargoPlane(newpos, false, null, "dropdirect");
                SendReply(arg, string.Format($"Starting Airdrop to Player '{target.displayName}' at: {newpos.ToString("0")} grid area: {gridPos}"));
                if (configData.Notifications.notifyDropPlayer)
                    MessageToPlayer(target, msg("msgDropPlayer", target.UserIDString));
            }
        }

        [ConsoleCommand("ad.dropplayer")]
        private void dropDropOnly(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < configData.GenericSettings.neededAuthLvl) return;
            if (arg.Args == null)
            {
                SendReply(arg, string.Format("Please specify a target playername"));
                return;
            }
            BasePlayer target = FindPlayerByName(arg.Args[0]);
            if (target == null)
            {
                SendReply(arg, string.Format($"Player '{arg.Args[0]}' not found"));
                return;
            }
            var newpos = new Vector3();
            newpos = target.transform.position;
            newpos.y += 100;
            string gridPos = GetGridString(newpos);
            Dictionary<string, object> setting;
            if (setupDropTypes.ContainsKey("dropdirect"))
            {
                setting = new Dictionary<string, object>((Dictionary<string, object>)setupDropTypes["dropdirect"]);
                object value;
                foreach (var pair in setupDropDefault)
                    if (!setting.TryGetValue(pair.Key, out value))
                        setting.Add(pair.Key, setupDropDefault[pair.Key]);
            }
            else
                setting = new Dictionary<string, object>((Dictionary<string, object>)setupDropDefault);
            setting.Add("userID", target.userID);
            object isSupplyDropActive = Interface.Oxide.CallHook("isSupplyDropActive");
            setting.Add("betterloot", isSupplyDropActive != null && (bool)isSupplyDropActive ? true : false);
            setting["droptype"] = "dropdirect";
            createSupplyDrop(newpos, new Dictionary<string, object>(setting), false, false, new Vector3(), new Vector3(), "dropdirect", target.userID);
            setting.Clear();
            SendReply(arg, string.Format($"Direct Drop to Player '{target.displayName}' at: {target.transform.position.ToString("0")} grid area: {gridPos}"));
            if (configData.Notifications.notifyDropDirect)
                MessageToPlayer(target, msg("msgDropDirect", target.UserIDString));

        }

        [ConsoleCommand("ad.dropspace")]
        private void dropDropSpaceOnly(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < configData.GenericSettings.neededAuthLvl) return;
            if (arg.Args == null)
            {
                SendReply(arg, string.Format("Please specify a target playername"));
                return;
            }
            BasePlayer target = FindPlayerByName(arg.Args[0]);
            if (target == null)
            {
                SendReply(arg, string.Format($"Player '{arg.Args[0]}' not found"));
                return;
            }
            var newpos = new Vector3();
            newpos = target.transform.position;
            newpos.y += 100;
            string gridPos = GetGridString(newpos);
            Dictionary<string, object> setting;
            if (setupDropTypes.ContainsKey("dropdirect"))
            {
                setting = new Dictionary<string, object>((Dictionary<string, object>)setupDropTypes["dropdirect"]);
                object value;
                foreach (var pair in setupDropDefault)
                    if (!setting.TryGetValue(pair.Key, out value))
                        setting.Add(pair.Key, setupDropDefault[pair.Key]);
            }
            else
                setting = new Dictionary<string, object>((Dictionary<string, object>)setupDropDefault);
            setting.Add("userID", target.userID);
            object isSupplyDropActive = Interface.Oxide.CallHook("isSupplyDropActive");
            setting.Add("betterloot", isSupplyDropActive != null && (bool)isSupplyDropActive ? true : false);
            setting["droptype"] = "dropdirect";
            createSupplyDropSpace(newpos, new Dictionary<string, object>(setting), false, false, new Vector3(), new Vector3(), "dropdirect", target.userID);
            setting.Clear();
            SendReply(arg, string.Format($"Space Drop to Player '{target.displayName}' at: {target.transform.position.ToString("0")} grid area: {gridPos}"));
            if (configData.Notifications.notifyDropDirect)
                MessageToPlayer(target, msg("msgDropDirectSpace", target.UserIDString));

        }

        [ConsoleCommand("ad.timer")]
        private void dropReloadTimer(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < configData.GenericSettings.neededAuthLvl) return;
            if (arg.Args != null && arg.Args.Length > 0)
            {
                try
                {
                    airdropTimerNext(Convert.ToInt32(arg.Args[0]));
                    return;
                }
                catch
                {
                    SendReply(arg, string.Format("Custom Timer value has to be an integer number."));
                    return;
                }
            }
            airdropTimerNext();
        }

        [ConsoleCommand("ad.cleanup")]
        private void dropCleanUp(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < configData.GenericSettings.neededAuthLvl) return;
            if (_massDropTimer != null && !_massDropTimer.Destroyed)
                _massDropTimer.Destroy();
            var planes = UnityEngine.Object.FindObjectsOfType<CargoPlane>().ToList();
            SendReply(arg, $"...killing {planes.Count} Planes");
            foreach (var plane in planes)
                plane.Kill();
            var drops = UnityEngine.Object.FindObjectsOfType<SupplyDrop>().ToList();
            SendReply(arg, $"...killing {drops.Count} SupplyDrops");
            foreach (var drop in drops)
                drop.Kill();
            CargoPlanes.Clear();
            SupplyDrops.Clear();
            LootedDrops.Clear();
            ItemManager.DoRemoves();
        }

        private void airdropCleanUp()
        {
            var drops = UnityEngine.Object.FindObjectsOfType<SupplyDrop>().ToList();
            Puts($"...killing {drops.Count} SupplyDrops");
            foreach (var drop in drops)
                drop.KillMessage();
        }

        [ConsoleCommand("ad.lootreload")]
        private void dropLootReload(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < configData.GenericSettings.neededAuthLvl) return;
            SendReply(arg, "Custom loot reloading...");
            //SetupLoot();
        }
        #endregion Console Commands

        #region Chat Commands
        [ChatCommand("droprandom")]
        private void cdropRandom(BasePlayer player, string command)
        {
            if (player.net.connection.authLevel < configData.GenericSettings.neededAuthLvl)
            {
                SendReply(player, string.Format(configData.GenericSettings.Format, configData.GenericSettings.Color, configData.GenericSettings.Prefix) + "You are not allowed to use this command");
                return;
            }
            var plane = createCargoPlane();
            Vector3 newpos = plane.RandomDropPosition();
            string gridPos = GetGridString(newpos);
            newpos.y += TerrainMeta.HeightMap.GetHeight(newpos);
            startCargoPlane(newpos, false, plane, "regular");
            SendReply(player, $"<color={configData.GenericSettings.colorAdmMsg}>Random Airdrop incoming at: {newpos.ToString("0")} grid area: {gridPos}</color>");
            if (configData.TimerSettings.airdropTimerEnabled && configData.TimerSettings.airdropTimerResetAfterRandom)
                airdropTimerNext();
        }

        [ChatCommand("droptopos")]
        private void cdropToPos(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < configData.GenericSettings.neededAuthLvl)
            {
                SendReply(player, string.Format(configData.GenericSettings.Format, configData.GenericSettings.Color, configData.GenericSettings.Prefix) + "You are not allowed to use this command");
                return;
            }
            if (args == null || args.Length != 2)
            {
                SendReply(player, $"<color={configData.GenericSettings.colorAdmMsg}>Please specity location with X and Z coordinates only</color>");
                return;
            }
            Vector3 newpos = new Vector3(Convert.ToInt32(args[0]), 0, Convert.ToInt32(args[1]));
            string gridPos = GetGridString(newpos);
            newpos.y += TerrainMeta.HeightMap.GetHeight(newpos);
            startCargoPlane(newpos, false, null, "regular");
            if (configData.GenericSettings.notifyByChatAdminCalls)
                SendReply(player, $"<color={configData.GenericSettings.colorAdmMsg}>Airdrop called to position: {newpos.ToString("0")} grid area: {gridPos}</color>");
        }

        [ChatCommand("droptoplayer")]
        private void cdropToPlayer(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < configData.GenericSettings.neededAuthLvl)
            {
                SendReply(player, string.Format(configData.GenericSettings.Format, configData.GenericSettings.Color, configData.GenericSettings.Prefix) + msg("msgNoAccess"));
                return;
            }
            if (args.Length < 1)
            {
                SendReply(player, $"<color={configData.GenericSettings.colorAdmMsg}>Please specify a target playername</color>");
                return;
            }
            if (args[0] == "*")
            {
                foreach (BasePlayer target in BasePlayer.activePlayerList)
                {
                    if (target.IsAdmin) continue;
                    NextTick(() => {
                        var newpos = new Vector3();
                        newpos = target.transform.position;
                        startCargoPlane(newpos, false, null, "dropdirect");
                        if (configData.Notifications.notifyDropPlayer)
                            MessageToPlayer(target, msg("msgDropPlayer", target.UserIDString));
                    });
                }
                if (configData.GenericSettings.notifyByChatAdminCalls)
                    SendReply(player, $"<color={configData.GenericSettings.colorAdmMsg}>Started Airdrop to each active player</color>");
            }
            else
            {
                BasePlayer target = FindPlayerByName(args[0]);
                if (target == null)
                {
                    SendReply(player, $"<color={configData.GenericSettings.colorAdmMsg}>Player '{args[0]}' not found</color>");
                    return;
                }
                var newpos = new Vector3();
                newpos = target.transform.position;
                string gridPos = GetGridString(newpos);
                startCargoPlane(newpos, false, null, "dropdirect");
                if (configData.GenericSettings.notifyByChatAdminCalls)
                    SendReply(player, $"<color={configData.GenericSettings.colorAdmMsg}>Airdrop called to player '{target.displayName}' at: {newpos.ToString("0")} grid area: {gridPos}</color>");
                if (configData.Notifications.notifyDropPlayer)
                    MessageToPlayer(target, msg("msgDropPlayer", target.UserIDString));
            }
        }

        [ChatCommand("dropdirect")]
        private void cdropDirect(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < configData.GenericSettings.neededAuthLvl)
            {
                SendReply(player, string.Format(configData.GenericSettings.Format, configData.GenericSettings.Color, configData.GenericSettings.Prefix) + msg("msgNoAccess"));
                return;
            }
            if (args.Length < 1)
            {
                SendReply(player, $"<color={configData.GenericSettings.colorAdmMsg}>Please specify a target playername</color>");
                return;
            }
            BasePlayer target = FindPlayerByName(args[0]);
            if (target == null)
            {
                SendReply(player, $"<color={configData.GenericSettings.colorAdmMsg}>Player '{args[0]}' not found</color>");
                return;
            }
            var newpos = new Vector3();
            newpos = target.transform.position;
            newpos.y += 100;

            Dictionary<string, object> setting;
            if (setupDropTypes.ContainsKey("dropdirect"))
            {
                setting = new Dictionary<string, object>((Dictionary<string, object>)setupDropTypes["dropdirect"]);
                object value;
                foreach (var pair in setupDropDefault)
                    if (!setting.TryGetValue(pair.Key, out value))
                        setting.Add(pair.Key, setupDropDefault[pair.Key]);
            }
            else
                setting = new Dictionary<string, object>((Dictionary<string, object>)setupDropDefault);
            setting.Add("userID", target.userID);
            object isSupplyDropActive = Interface.Oxide.CallHook("isSupplyDropActive");
            setting.Add("betterloot", isSupplyDropActive != null && (bool)isSupplyDropActive ? true : false);
            setting["droptype"] = "dropdirect";
            createSupplyDrop(newpos, new Dictionary<string, object>(setting), false, false, new Vector3(), new Vector3(), "dropdirect", target.userID);
            setting.Clear();
            if (configData.GenericSettings.notifyByChatAdminCalls)
                SendReply(player, $"<color={configData.GenericSettings.colorAdmMsg}>Direct Drop to Player '{target.displayName}' at: {target.transform.position.ToString("0")}</color>");
            if (configData.Notifications.notifyDropDirect)
                MessageToPlayer(target, msg("msgDropDirect", target.UserIDString));
        }

        [ChatCommand("dropspace")]
        private void cdropDirectSpace(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < configData.GenericSettings.neededAuthLvl)
            {
                SendReply(player, string.Format(configData.GenericSettings.Format, configData.GenericSettings.Color, configData.GenericSettings.Prefix) + msg("msgNoAccess"));
                return;
            }
            if (args.Length < 1)
            {
                SendReply(player, $"<color={configData.GenericSettings.colorAdmMsg}>Please specify a target playername</color>");
                return;
            }
            BasePlayer target = FindPlayerByName(args[0]);
            if (target == null)
            {
                SendReply(player, $"<color={configData.GenericSettings.colorAdmMsg}>Player '{args[0]}' not found</color>");
                return;
            }
            var newpos = new Vector3();
            newpos = target.transform.position;
            newpos.y += 100;

            Dictionary<string, object> setting;
            if (setupDropTypes.ContainsKey("dropdirect"))
            {
                setting = new Dictionary<string, object>((Dictionary<string, object>)setupDropTypes["dropdirect"]);
                object value;
                foreach (var pair in setupDropDefault)
                    if (!setting.TryGetValue(pair.Key, out value))
                        setting.Add(pair.Key, setupDropDefault[pair.Key]);
            }
            else
                setting = new Dictionary<string, object>((Dictionary<string, object>)setupDropDefault);
            setting.Add("userID", target.userID);
            object isSupplyDropActive = Interface.Oxide.CallHook("isSupplyDropActive");
            setting.Add("betterloot", isSupplyDropActive != null && (bool)isSupplyDropActive ? true : false);
            setting["droptype"] = "dropdirect";

            createSupplyDropSpace(newpos, new Dictionary<string, object>(setting), false, false, new Vector3(), new Vector3(), "dropdirect", target.userID);

            setting.Clear();
            if (configData.GenericSettings.notifyByChatAdminCalls)
                SendReply(player, $"<color={configData.GenericSettings.colorAdmMsg}>Space Drop to Player '{target.displayName}' at: {target.transform.position.ToString("0")}</color>");
            if (configData.Notifications.notifyDropDirect)
                MessageToPlayer(target, msg("msgDropDirectSpace", target.UserIDString));
        }

        [ChatCommand("dropmass")]
        private void cdropMass(BasePlayer player, string command, string[] args)
        {
            int drops = 0;
            if (player.net.connection.authLevel < configData.GenericSettings.neededAuthLvl)
            {
                SendReply(player, string.Format(configData.GenericSettings.Format, configData.GenericSettings.Color, configData.GenericSettings.Prefix) + msg("msgNoAccess"));
                return;
            }
            if (args.Length < 1)
                drops = configData.AirdropSettings.airdropMassdropDefault;
            else
                try { drops = Convert.ToInt32(args[0]); }
                catch
                {
                    SendReply(player, $"<color={configData.GenericSettings.colorAdmMsg}>Massdrop value has to be an integer number</color>");
                    return;
                }
            if (configData.GenericSettings.notifyByChatAdminCalls)
                SendReply(player, $"<color={configData.GenericSettings.colorAdmMsg}>Massdrop started with {drops.ToString()} Drops</color>");

            if (_massDropTimer != null && !_massDropTimer.Destroyed)
                _massDropTimer.Destroy();

            bool showinfo = true;
            _massDropTimer = timer.Repeat(configData.AirdropSettings.airdropMassdropDelay, drops + 1, () => {
                if (_massDropTimer == null || _massDropTimer.Destroyed) return;
                startCargoPlane(Vector3.zero, true, null, "massdrop", "", showinfo);
                if (_massDropTimer.Repetitions == drops) showinfo = false;
            });
        }

        [ChatCommand("droptomass")]
        private void cdropToMass(BasePlayer player, string command, string[] args)
        {
            int drops = configData.AirdropSettings.airdropMassdropDefault;
            float x = -99999;
            float z = -99999;
            float radius = configData.AirdropSettings.airdropMassdropRadiusDefault;
            if (player.net.connection.authLevel < configData.GenericSettings.neededAuthLvl)
            {
                SendReply(player, string.Format(configData.GenericSettings.Format, configData.GenericSettings.Color, configData.GenericSettings.Prefix) + msg("msgNoAccess"));
                return;
            }
            if (args.Length < 2)
            {
                SendReply(player, $"<color={configData.GenericSettings.colorAdmMsg}>Specify at minumum (X) and (Z)</color>");
                return;
            }
            if (args.Length >= 3) int.TryParse(args[2], out drops);

            if (!float.TryParse(args[0], out x) || !float.TryParse(args[1], out z))
            {
                SendReply(player, $"<color={configData.GenericSettings.colorAdmMsg}>Specify at minumum (X) (Z) or with '0 0' for random position | and opt:drop-count and opt:radius )</color>");
                return;
            }
            Vector3 newpos = new Vector3();
            if (x == 0 || z == 0)
            {
                var plane = createCargoPlane();
                newpos = plane.RandomDropPosition();
                x = newpos.x;
                z = newpos.z;
                plane.Kill();
            }

            if (args.Length > 3) float.TryParse(args[3], out radius);
            lastDropRadius = radius;
            if (configData.GenericSettings.notifyByChatAdminCalls)
                SendReply(player, $"<color={configData.GenericSettings.colorAdmMsg}>Massdrop to (X:{x.ToString("0")} Z:{z.ToString("0")}) started with {drops.ToString()} Drops( {radius}m Radius)</color>");

            if (_massDropTimer != null && !_massDropTimer.Destroyed)
                _massDropTimer.Destroy();

            bool showinfo = true;
            _massDropTimer = timer.Repeat(configData.AirdropSettings.airdropMassdropDelay, drops + 1, () => {
                if (_massDropTimer == null || _massDropTimer.Destroyed) return;
                newpos.x = UnityEngine.Random.Range(x - radius, x + radius);
                newpos.z = UnityEngine.Random.Range(z - radius, z + radius);
                newpos.y += TerrainMeta.HeightMap.GetHeight(newpos);
                startCargoPlane(newpos, false, null, "massdrop", "", showinfo);
                if (_massDropTimer.Repetitions == drops) showinfo = false;
            });
        }
        #endregion Chat Commands

        #endregion Commands

        #region Dictionary & Lists
        static Dictionary<string, object> defaultRealTimers()
        {
            var dp = new Dictionary<string, object>();
            dp.Add("16:00", "ad.massdrop 3");
            dp.Add("18:00", "ad.toplayer *");
            return dp;
        }

        static Dictionary<string, object> defaultServerTimers()
        {
            var dp = new Dictionary<string, object>();
            dp.Add("6", "ad.massdrop 3");
            dp.Add("18", "ad.massdropto 0 0 5 100");
            return dp;
        }

        static Dictionary<string, object> defaultDrop()
        {
            var dp = new Dictionary<string, object>();
            dp.Add("minCrates", 1);
            dp.Add("maxCrates", 1);
            dp.Add("cratesGap", 50);
            dp.Add("despawnMinutes", 15);
            dp.Add("crateAirResistance", 2.0); ;
            dp.Add("useCustomLootTable", false);
            dp.Add("CustomLootListName", "regular");
            dp.Add("planeSpeed", 35);
            dp.Add("additionalheight", 0);
            return dp;
        }

        static Dictionary<string, object> defaultDropTypes()
        {
            var dp = new Dictionary<string, object>();

            var dp0 = new Dictionary<string, object>();
            dp0.Add("minCrates", 1);
            dp0.Add("maxCrates", 1);
            dp0.Add("cratesGap", 50);
            dp0.Add("despawnMinutes", 15);
            dp0.Add("crateAirResistance", 2.0);
            dp0.Add("useCustomLootTable", false);
            dp0.Add("CustomLootListName", "regular");
            dp0.Add("planeSpeed", 35);
            dp0.Add("additionalheight", 0);
            dp.Add("regular", dp0);

            var dp1 = new Dictionary<string, object>();
            dp1.Add("minCrates", 1);
            dp1.Add("maxCrates", 1);
            dp1.Add("cratesGap", 50);
            dp1.Add("despawnMinutes", 15);
            dp1.Add("crateAirResistance", 2.0);
            dp1.Add("useCustomLootTable", false);
            dp1.Add("CustomLootListName", "supplysignal");
            dp1.Add("planeSpeed", 35);
            dp1.Add("additionalheight", 0);
            dp.Add("supplysignal", dp1);

            var dp2 = new Dictionary<string, object>();
            dp2.Add("minCrates", 1);
            dp2.Add("maxCrates", 1);
            dp2.Add("cratesGap", 50);
            dp2.Add("despawnMinutes", 15);
            dp2.Add("crateAirResistance", 2.0);
            dp2.Add("useCustomLootTable", false);
            dp2.Add("CustomLootListName", "massdrop");
            dp2.Add("planeSpeed", 45);
            dp2.Add("additionalheight", 0);
            dp.Add("massdrop", dp2);

            var dp3 = new Dictionary<string, object>();
            dp3.Add("minCrates", 1);
            dp3.Add("maxCrates", 1);
            dp3.Add("cratesGap", 50);
            dp3.Add("despawnMinutes", 15);
            dp3.Add("crateAirResistance", 2.0);
            dp3.Add("useCustomLootTable", false);
            dp3.Add("CustomLootListName", "dropdirect");
            dp3.Add("planeSpeed", 65);
            dp3.Add("additionalheight", 0);
            dp.Add("dropdirect", dp3);

            var dp4 = new Dictionary<string, object>();
            dp4.Add("minCrates", 1);
            dp4.Add("maxCrates", 1);
            dp4.Add("cratesGap", 50);
            dp4.Add("despawnMinutes", 15);
            dp4.Add("crateAirResistance", 2.0);
            dp4.Add("useCustomLootTable", false);
            dp4.Add("CustomLootListName", "custom_event");
            dp4.Add("planeSpeed", 95);
            dp4.Add("additionalheight", 0);
            dp4.Add("notificationInfo", "Custom Stuff");
            dp.Add("custom_event", dp4);

            return dp;
        }

        static Dictionary<string, object> defaultItemList()
        {
            var dp0_0 = new Dictionary<string, object>();
            dp0_0.Add("targeting.computer", 2);
            dp0_0.Add("cctv.camera", 2);
            var dp0 = new Dictionary<string, object>();
            dp0.Add("itemList", dp0_0);
            dp0.Add("itemDivider", 2);

            var dp1_0 = new Dictionary<string, object>();
            dp1_0.Add("explosive.timed", 4);
            dp1_0.Add("metal.refined", 100);
            var dp1 = new Dictionary<string, object>();
            dp1.Add("itemList", dp1_0);
            dp1.Add("itemDivider", 2);

            var dp2_0 = new Dictionary<string, object>();
            dp2_0.Add("explosive.timed", 4);
            dp2_0.Add("grenade.f1", 10);
            var dp2 = new Dictionary<string, object>();
            dp2.Add("itemList", dp2_0);
            dp2.Add("itemDivider", 2);

            var dp3_0 = new Dictionary<string, object>();
            dp3_0.Add("explosive.timed", 4);
            dp3_0.Add("surveycharge", 10);
            var dp3 = new Dictionary<string, object>();
            dp3.Add("itemList", dp3_0);
            dp3.Add("itemDivider", 2);

            var dp4_0 = new Dictionary<string, object>();
            dp4_0.Add("explosive.timed", 10);
            dp4_0.Add("grenade.f1", 10);
            var dp4 = new Dictionary<string, object>();
            dp4.Add("itemList", dp4_0);
            dp4.Add("itemDivider", 2);

            var dp = new Dictionary<string, object>();
            dp.Add("regular", dp0);
            dp.Add("supplysignal", dp1);
            dp.Add("massdrop", dp2);
            dp.Add("dropdirect", dp3);
            dp.Add("custom_event", dp4);

            return dp;
        }

        FieldInfo dropPlanestartPos = typeof(CargoPlane).GetField("startPos", (BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public));
        FieldInfo dropPlaneendPos = typeof(CargoPlane).GetField("endPos", (BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public));
        FieldInfo dropPlanesecondsToTake = typeof(CargoPlane).GetField("secondsToTake", (BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public));
        FieldInfo dropPlanesecondsTaken = typeof(CargoPlane).GetField("secondsTaken", (BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public));
        FieldInfo dropPlanedropped = typeof(CargoPlane).GetField("dropped", (BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public));
        FieldInfo _isSpawned = typeof(BaseNetworkable).GetField("isSpawned", (BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public));
        FieldInfo _creationFrame = typeof(BaseNetworkable).GetField("creationFrame", (BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public));
        static FieldInfo _parachute = typeof(SupplyDrop).GetField("parachute", (BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public));

        CargoPlane referencePlane = GameManager.server.FindPrefab(PLANE_PREFAB).GetComponent<CargoPlane>();
        SpawnFilter spawnFilter = GameManager.server.FindPrefab(PLANE_PREFAB).GetComponent<CargoPlane>().filter;

        List<Regex> regexTags = new List<Regex>
        {
            new Regex(@"<color=.+?>", RegexOptions.Compiled),
            new Regex(@"<size=.+?>", RegexOptions.Compiled)
        };

        List<string> tags = new List<string>
        {
            "</color>",
            "</size>",
            "<i>",
            "</i>",
            "<b>",
            "</b>"
        };
        #endregion

        #region Configuration
        Dictionary<string, object> setupDropTypes = new Dictionary<string, object>();
        Dictionary<string, object> setupDropDefault = new Dictionary<string, object>();
        //Dictionary<string, object> setupItemList = new Dictionary<string, object>();
        Dictionary<string, object> realTimers = new Dictionary<string, object>();
        Dictionary<string, object> serverTimers = new Dictionary<string, object>();

        private static ConfigData configData;
        class ConfigData
        {
            [JsonProperty(PropertyName = "Debug")]
            public DebugOptions DebugSettings { get; set; }
            [JsonProperty(PropertyName = "General Settings")]
            public GenericOptions GenericSettings { get; set; }
            [JsonProperty(PropertyName = "Airdrop & General Plane Settings")]
            public AirdropOptions AirdropSettings { get; set; }
            [JsonProperty(PropertyName = "Allow Damage Airdrop Settings")]
            public DamageOptions DamageSettings { get; set; }
            [JsonProperty(PropertyName = "Notification Settings")]
            public NotificationOptions Notifications { get; set; }
            [JsonProperty(PropertyName = "SimpleUI")]
            public UIOptions UISettings { get; set; }
            [JsonProperty(PropertyName = "Timer - Random Event")]
            public TimerOptions TimerSettings { get; set; }
            [JsonProperty(PropertyName = "Timers- System Timers")]
            public TimersOptions TimersSettings { get; set; }
            [JsonProperty(PropertyName = "Drop Settings")]
            public DropOptions DropSettings { get; set; }
            [JsonProperty(PropertyName = "Custom Loot Items")]
            public StaticOptions StaticItems { get; set; }

            public class DebugOptions
            {
                [JsonProperty(PropertyName = "Enable Debugging to Console")]
                public bool useDebug { get; set; }
            }

            public class GenericOptions
            {
                [JsonProperty(PropertyName = "Admin messages color")]
                public string colorAdmMsg { get; set; }
                [JsonProperty(PropertyName = "AuthLevel needed for console commands")]
                public int neededAuthLvl { get; set; }
                [JsonProperty(PropertyName = "Broadcast messages color")]
                public string colorTextMsg { get; set; }
                [JsonProperty(PropertyName = "Chat/Message prefix")]
                public string Prefix { get; set; }
                [JsonProperty(PropertyName = "Prefix color")]
                public string Color { get; set; }
                [JsonProperty(PropertyName = "Prefix format")]
                public string Format { get; set; }
                [JsonProperty(PropertyName = "GUI Announce command")]
                public string guiCommand { get; set; }
                [JsonProperty(PropertyName = "Show message to admin after command usage")]
                public bool notifyByChatAdminCalls { get; set; }
                [JsonProperty(PropertyName = "Time for active smoke of SupplySignal (default is 210)")]
                public float supplySignalSmokeTime { get; set; }
                [JsonProperty(PropertyName = "Lock DirectDrop to be looted only by target player")]
                public bool lockDirectDrop { get; set; }
                [JsonProperty(PropertyName = "Lock SignalDrop to be looted only by target player")]
                public bool lockSignalDrop { get; set; }
                [JsonProperty(PropertyName = "Unlock crates only after player stopped looting")]
                public bool unlockDropAfterLoot { get; set; }
            }

            public class AirdropOptions
            {
                [JsonProperty(PropertyName = "Default radius for location based massdrop")]
                public float airdropMassdropRadiusDefault { get; set; }
                [JsonProperty(PropertyName = "Delay between Massdrop plane spawns")]
                public float airdropMassdropDelay { get; set; }
                [JsonProperty(PropertyName = "Massdrop default plane amount")]
                public int airdropMassdropDefault { get; set; }
                [JsonProperty(PropertyName = "Multiplier for (plane height * highest point on Map); Default 1.0")]
                public float planeOffSetYMultiply { get; set; }
                [JsonProperty(PropertyName = "Multiplier for overall flight distance; lower means faster at map")]
                public float planeOffSetXMultiply { get; set; }
                [JsonProperty(PropertyName = "Disable SupplySignal randomization")]
                public bool disableRandomSupplyPos { get; set; }
                [JsonProperty(PropertyName = "Visual & Sound Effects Settings")]
                public EffectsOptions EffectsSettings { get; set; }
                [JsonProperty(PropertyName = "Space Delivery Drop Settings")]
                public SpaceOptions SpaceSettings { get; set; }

                public class EffectsOptions
                {
                    [JsonProperty(PropertyName = "Use Explosion Sound Effect when hits ground position")]
                    public bool useSupplyDropEffectLanded { get; set; }
                    [JsonProperty(PropertyName = "Deploy Smoke on drop as it falls")]
                    public bool useSmokeEffectOnDrop { get; set; }
                    [JsonProperty(PropertyName = "Deploy with Audio Alarm on drop")]
                    public bool useSirenAlarmOnDrop { get; set; }
                    [JsonProperty(PropertyName = "Deploy with Audio Alarms on drop only during the night")]
                    public bool useSirenAlarmAtNightOnly { get; set; }
                    [JsonProperty(PropertyName = "Deploy with Spinning Siren Light on drop")]
                    public bool useSirenLightOnDrop { get; set; }
                    [JsonProperty(PropertyName = "Deploy with Spinning Siren Light on drop only during the night")]
                    public bool useSirenLightAtNightOnly { get; set; }
                    [JsonProperty(PropertyName = "Enable Rocket Signal upon Supply Drop Landing")]
                    public bool useSupplyDropRocket { get; set; }
                    [JsonProperty(PropertyName = "Signal rocket speed")]
                    public float signalRocketSpeed { get; set; }
                    [JsonProperty(PropertyName = "Signal rocket explosion timer")]
                    public float signalRocketExplosionTime { get; set; }
                }

                public class SpaceOptions
                {
                    [JsonProperty(PropertyName = "Incoming Space Delivery Supply Drop velocity")]
                    public float dropVelocity { get; set; }
                    [JsonProperty(PropertyName = "Parachute deploy distance from ground")]
                    public float dropGroundDistance { get; set; }
                }

            }

            public class DamageOptions
            {
                [JsonProperty(PropertyName = "Players can shoot down the drop")]
                public bool shootDownDrops { get; set; }
                [JsonProperty(PropertyName = "Players can shoot down the drop - needed hits")]
                public int shootDownCount { get; set; }
                [JsonProperty(PropertyName = "Set Angular Drag for drop")]
                public float dropAngularDragSetting { get; set; }
                [JsonProperty(PropertyName = "Set Drag for drop (drop resistance)")]
                public float dropDragsetting { get; set; }
                [JsonProperty(PropertyName = "Set drop allow to explode on impact")]
                public bool explodeImpact { get; set; }
                [JsonProperty(PropertyName = "Set drop chance exploding on impact (x out of 100)")]
                public int explodeChance { get; set; }
                [JsonProperty(PropertyName = "Set Mass weight for drop")]
                public float dropMassSetting { get; set; }
            }

            public class NotificationOptions
            {
                [JsonProperty(PropertyName = "Maximum distance in meters to get notified about landed Drop")]
                public float supplyDropNotifyDistance { get; set; }
                [JsonProperty(PropertyName = "Maximum distance in meters to get notified about looted Drop")]
                public float supplyLootNotifyDistance { get; set; }
                [JsonProperty(PropertyName = "Notify a player about incoming Drop to his location")]
                public bool notifyDropPlayer { get; set; }
                [JsonProperty(PropertyName = "Notify a player about spawned Drop at his location")]
                public bool notifyDropDirect { get; set; }
                [JsonProperty(PropertyName = "Notify a player about Space Delivery Drop at his location")]
                public bool notifyDropDirectSpace { get; set; }
                [JsonProperty(PropertyName = "Notify admins per chat about player who has thrown SupplySignal")]
                public bool notifyDropAdminSignal { get; set; }
                [JsonProperty(PropertyName = "Notify console at Drop by SupplySignal")]
                public bool notifyDropConsoleSignal { get; set; }
                [JsonProperty(PropertyName = "Notify console at timed-regular Drop")]
                public bool notifyDropConsoleRegular { get; set; }
                [JsonProperty(PropertyName = "Notify console when a Drop is being looted")]
                public bool notifyDropConsoleLooted { get; set; }
                [JsonProperty(PropertyName = "Notify console when Drop is landed")]
                public bool notifyDropConsoleOnLanded { get; set; }
                [JsonProperty(PropertyName = "Notify console when Drop is spawned")]
                public bool notifyDropConsoleSpawned { get; set; }
                [JsonProperty(PropertyName = "Notify console when Drop landed/spawned only at the first")]
                public bool notifyDropConsoleFirstOnly { get; set; }
                [JsonProperty(PropertyName = "Notify players at custom/event Drop")]
                public bool notifyDropServerCustom { get; set; }
                [JsonProperty(PropertyName = "Notify players at custom/event Drop including Coords")]
                public bool notifyDropServerCustomCoords { get; set; }
                [JsonProperty(PropertyName = "Notify players at custom/event Drop including Grid Area")]
                public bool notifyDropServerCustomGrid { get; set; }
                [JsonProperty(PropertyName = "Notify players at Drop by SupplySignal")]
                public bool notifyDropServerSignal { get; set; }
                [JsonProperty(PropertyName = "Notify players at Drop by SupplySignal including Coords")]
                public bool notifyDropServerSignalCoords { get; set; }
                [JsonProperty(PropertyName = "Notify players at Drop by SupplySignal including Grid Area")]
                public bool notifyDropServerSignalGrid { get; set; }
                [JsonProperty(PropertyName = "Notify players at Massdrop")]
                public bool notifyDropServerMass { get; set; }
                [JsonProperty(PropertyName = "Notify players at Random/Timed Drop")]
                public bool notifyDropServerRegular { get; set; }
                [JsonProperty(PropertyName = "Notify players at Random/Timed Drop including Coords")]
                public bool notifyDropServerRegularCoords { get; set; }
                [JsonProperty(PropertyName = "Notify players at Random/Timed Drop including Grid Area")]
                public bool notifyDropServerRegularGrid { get; set; }
                [JsonProperty(PropertyName = "Notify players when a Drop is being looted")]
                public bool notifyDropServerLooted { get; set; }
                [JsonProperty(PropertyName = "Notify players when a Drop is being looted including coords")]
                public bool notifyDropServerLootedCoords { get; set; }
                [JsonProperty(PropertyName = "Notify players when a Drop is being looted including Grid Area")]
                public bool notifyDropServerLootedGrid { get; set; }
                [JsonProperty(PropertyName = "Notify players when Drop is landed about distance")]
                public bool notifyDropPlayersOnLanded { get; set; }
                [JsonProperty(PropertyName = "Notify Players who has thrown a SupplySignal")]
                public bool notifyDropSignalByPlayer { get; set; }
                [JsonProperty(PropertyName = "Notify Players who has thrown a SupplySignal including coords")]
                public bool notifyDropSignalByPlayerCoords { get; set; }
                [JsonProperty(PropertyName = "Notify Players who has thrown a SupplySignal including Grid Area")]
                public bool notifyDropSignalByPlayerGrid { get; set; }
                [JsonProperty(PropertyName = "Use GUI Announcements for any Drop notification")]
                public bool notifyDropGUI { get; set; }
            }

            public class UIOptions
            {
                [JsonProperty(PropertyName = "SimpleUI_Enable")]
                public bool SimpleUI_Enable { get; set; }
                [JsonProperty(PropertyName = "SimpleUI_FontSize")]
                public int SimpleUI_FontSize { get; set; }
                [JsonProperty(PropertyName = "SimpleUI_HideTimer")]
                public float SimpleUI_HideTimer { get; set; }
                [JsonProperty(PropertyName = "SimpleUI_NoticeColor")]
                public string SimpleUI_NoticeColor { get; set; }
                [JsonProperty(PropertyName = "SimpleUI_ShadowColor")]
                public string SimpleUI_ShadowColor { get; set; }
                [JsonProperty(PropertyName = "SimpleUI_Top")]
                public float SimpleUI_Top { get; set; }
                [JsonProperty(PropertyName = "SimpleUI_Left")]
                public float SimpleUI_Left { get; set; }
                [JsonProperty(PropertyName = "SimpleUI_MaxWidth")]
                public float SimpleUI_MaxWidth { get; set; }
                [JsonProperty(PropertyName = "SimpleUI_MaxHeight")]
                public float SimpleUI_MaxHeight { get; set; }
            }

            public class TimerOptions
            {
                [JsonProperty(PropertyName = "Use Airdrop timer")]
                public bool airdropTimerEnabled { get; set; }
                [JsonProperty(PropertyName = "Used Airdrop timer command")]
                public string airdropTimerCmd { get; set; }
                [JsonProperty(PropertyName = "Minimum players for timed Drop")]
                public int airdropTimerMinPlayers { get; set; }
                [JsonProperty(PropertyName = "Minimum minutes for random timer delay")]
                public int airdropTimerWaitMinutesMin { get; set; }
                [JsonProperty(PropertyName = "Maximum minutes for random timer delay")]
                public int airdropTimerWaitMinutesMax { get; set; }
                [JsonProperty(PropertyName = "Reset Timer after manual random drop")]
                public bool airdropTimerResetAfterRandom { get; set; }
                [JsonProperty(PropertyName = "Remove builtIn Airdrop")]
                public bool airdropRemoveInBuilt { get; set; }
                [JsonProperty(PropertyName = "Cleanup old Drops at serverstart")]
                public bool airdropCleanupAtStart { get; set; }
            }

            public class TimersOptions
            {
                [JsonProperty(PropertyName = "Log to console")]
                public bool logTimersToConsole { get; set; }
                [JsonProperty(PropertyName = "Minimum players for running Timers")]
                public int timersMinPlayers { get; set; }
                [JsonProperty(PropertyName = "Use RealTime")]
                public bool useRealtimeTimers { get; set; }
                [JsonProperty(PropertyName = "RealTime")]
                public Dictionary<string, object> realTimers { get; set; }
                [JsonProperty(PropertyName = "Use ServerTime")]
                public bool useGametimeTimers { get; set; }
                [JsonProperty(PropertyName = "ServerTime")]
                public Dictionary<string, object> serverTimers { get; set; }
            }

            public class DropOptions
            {
                [JsonProperty(PropertyName = "DropDefault")]
                public Dictionary<string, object> setupDropDefault { get; set; }
                [JsonProperty(PropertyName = "DropTypes")]
                public Dictionary<string, object> setupDropTypes { get; set; }
            }

            public class StaticOptions
            {
                [JsonProperty(PropertyName = "DropTypes")]
                public List<LootOptions> LootSettings { get; set; }

                public class LootOptions
                {
                    [JsonProperty(PropertyName = "DropType Name")]
                    public string DropTypeName { get; set; }
                    [JsonProperty(PropertyName = "Minimum amount of items to spawn")]
                    public int MinimumItems { get; set; }
                    [JsonProperty(PropertyName = "Maximum amount of items to spawn")]
                    public int MaximumItems { get; set; }
                    [JsonProperty(PropertyName = "Custom Loot Contents")]
                    public List<LootItem> Items { get; set; }

                    public class LootItem
                    {
                        [JsonProperty(PropertyName = "Shortname")]
                        public string Name { get; set; }
                        [JsonProperty(PropertyName = "Minimum amount of item")]
                        public int Minimum { get; set; }
                        [JsonProperty(PropertyName = "Maximum amount of item")]
                        public int Maximum { get; set; }
                        [JsonProperty(PropertyName = "Skin ID")]
                        public ulong Skin { get; set; }
                        [JsonProperty(PropertyName = "Display Name")]
                        public string DisplayName { get; set; }
                    }
                }
            }
            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                DebugSettings = new ConfigData.DebugOptions
                {
                    useDebug = false
                },
                GenericSettings = new ConfigData.GenericOptions
                {
                    Prefix = "[ZTL Drop Services]",
                    Color = "#00ffff",
                    Format = "<size=12><color={0}>{1}</color>: ",
                    guiCommand = "announce",
                    neededAuthLvl = 1,
                    supplySignalSmokeTime = 210.0f,
                    colorAdmMsg = "#c0c0c0",
                    notifyByChatAdminCalls = true,
                    colorTextMsg = "#ffffff",
                    lockDirectDrop = true,
                    lockSignalDrop = false,
                    unlockDropAfterLoot = false,
                },
                AirdropSettings = new ConfigData.AirdropOptions
                {
                    airdropMassdropDefault = 5,
                    airdropMassdropDelay = 0.66f,
                    airdropMassdropRadiusDefault = 100,
                    planeOffSetXMultiply = 1.25f,
                    planeOffSetYMultiply = 1.0f,
                    disableRandomSupplyPos = false,
                    EffectsSettings = new ConfigData.AirdropOptions.EffectsOptions
                    {
                        useSupplyDropEffectLanded = false,
                        signalRocketSpeed = 15,
                        signalRocketExplosionTime = 15,
                        useSmokeEffectOnDrop = false,
                        useSirenAlarmOnDrop = false,
                        useSirenAlarmAtNightOnly = false,
                        useSirenLightOnDrop = false,
                        useSirenLightAtNightOnly = false,
                        useSupplyDropRocket = false
                    },
                    SpaceSettings = new ConfigData.AirdropOptions.SpaceOptions
                    {
                        dropVelocity = 120.0f,
                        dropGroundDistance = 50.0f
                    }
                },
                DamageSettings = new ConfigData.DamageOptions
                {
                    shootDownDrops = true,
                    shootDownCount = 3,
                    dropDragsetting = 0.3f,
                    dropMassSetting = 0.75f,
                    dropAngularDragSetting = 0.1f,
                    explodeImpact = true,
                    explodeChance = 25
                },
                Notifications = new ConfigData.NotificationOptions
                {
                    supplyDropNotifyDistance = 1000,
                    supplyLootNotifyDistance = 1000,
                    notifyDropGUI = false,
                    notifyDropServerSignal = false,
                    notifyDropServerSignalCoords = false,
                    notifyDropServerSignalGrid = false,
                    notifyDropConsoleSignal = true,
                    notifyDropConsoleRegular = true,
                    notifyDropConsoleOnLanded = false,
                    notifyDropConsoleSpawned = false,
                    notifyDropConsoleFirstOnly = true,
                    notifyDropConsoleLooted = true,
                    notifyDropServerRegular = true,
                    notifyDropServerRegularCoords = false,
                    notifyDropServerRegularGrid = false,
                    notifyDropServerCustom = true,
                    notifyDropServerCustomCoords = false,
                    notifyDropServerCustomGrid = false,
                    notifyDropServerMass = true,
                    notifyDropPlayer = true,
                    notifyDropDirect = true,
                    notifyDropDirectSpace = true,
                    notifyDropPlayersOnLanded = false,
                    notifyDropServerLooted = false,
                    notifyDropServerLootedCoords = false,
                    notifyDropServerLootedGrid = false,
                    notifyDropSignalByPlayer = false,
                    notifyDropSignalByPlayerCoords = false,
                    notifyDropSignalByPlayerGrid = false,
                    notifyDropAdminSignal = false
                },
                UISettings = new ConfigData.UIOptions
                {
                    SimpleUI_Enable = false,
                    SimpleUI_FontSize = 25,
                    SimpleUI_Top = 0.05f,
                    SimpleUI_Left = 0.1f,
                    SimpleUI_MaxWidth = 0.8f,
                    SimpleUI_MaxHeight = 0.1f,
                    SimpleUI_HideTimer = 10,
                    SimpleUI_NoticeColor = "1 1 1 0.9",
                    SimpleUI_ShadowColor = "0.1 0.1 0.1 0.5"
                },
                TimerSettings = new ConfigData.TimerOptions
                {
                    airdropTimerEnabled = true,
                    airdropTimerCmd = "random",
                    airdropRemoveInBuilt = true,
                    airdropCleanupAtStart = true,
                    airdropTimerMinPlayers = 1,
                    airdropTimerWaitMinutesMin = 30,
                    airdropTimerWaitMinutesMax = 60,
                    airdropTimerResetAfterRandom = false
                },
                TimersSettings = new ConfigData.TimersOptions
                {
                    useRealtimeTimers = false,
                    useGametimeTimers = false,
                    logTimersToConsole = true,
                    realTimers = defaultRealTimers(),
                    serverTimers = defaultServerTimers(),
                    timersMinPlayers = 0
                },
                DropSettings = new ConfigData.DropOptions
                {
                    setupDropTypes = defaultDropTypes(),
                    setupDropDefault = defaultDrop()
                },
                StaticItems = new ConfigData.StaticOptions
                {
                    LootSettings = new List<ConfigData.StaticOptions.LootOptions>
                    {
                        new ConfigData.StaticOptions.LootOptions
                        {
                            DropTypeName = "regular",
                            MaximumItems = 6,
                            MinimumItems = 2,
                            Items = new List<ConfigData.StaticOptions.LootOptions.LootItem>
                            {
                                new ConfigData.StaticOptions.LootOptions.LootItem {Name = "metalspring", Maximum = 6, Minimum = 2, Skin =0, DisplayName = null },
                                new ConfigData.StaticOptions.LootOptions.LootItem {Name = "mining.quarry", Maximum = 2, Minimum = 1, Skin =0, DisplayName = null }
                            }
                        },
                        new ConfigData.StaticOptions.LootOptions
                        {
                            DropTypeName = "massdrop",
                            MaximumItems = 6,
                            MinimumItems = 2,
                            Items = new List<ConfigData.StaticOptions.LootOptions.LootItem>
                            {
                                new ConfigData.StaticOptions.LootOptions.LootItem {Name = "metalpipe", Maximum = 2, Minimum = 1, Skin =0, DisplayName = null },
                                new ConfigData.StaticOptions.LootOptions.LootItem {Name = "pistol.revolver", Maximum = 1, Minimum = 1, Skin =0, DisplayName = null }
                            }
                        },
                        new ConfigData.StaticOptions.LootOptions
                        {
                            DropTypeName = "dropdirect",
                            MaximumItems = 6,
                            MinimumItems = 2,
                            Items = new List<ConfigData.StaticOptions.LootOptions.LootItem>
                            {
                                new ConfigData.StaticOptions.LootOptions.LootItem {Name = "syringe.medical", Maximum = 6, Minimum = 2, Skin =0, DisplayName = null },
                                new ConfigData.StaticOptions.LootOptions.LootItem {Name = "largemedkit", Maximum = 2, Minimum = 1, Skin =0, DisplayName = null }
                            }
                        },
                        new ConfigData.StaticOptions.LootOptions
                        {
                            DropTypeName = "supplysignal",
                            MaximumItems = 6,
                            MinimumItems = 2,
                            Items = new List<ConfigData.StaticOptions.LootOptions.LootItem>
                            {
                                new ConfigData.StaticOptions.LootOptions.LootItem {Name = "metal.fragments", Maximum = 4, Minimum = 1, Skin =0, DisplayName = null },
                                new ConfigData.StaticOptions.LootOptions.LootItem {Name = "metal.facemask", Maximum = 1, Minimum = 1, Skin =0, DisplayName = null }
                            }
                        },
                        new ConfigData.StaticOptions.LootOptions
                        {
                            DropTypeName = "custom_event",
                            MaximumItems = 6,
                            MinimumItems = 2,
                            Items = new List<ConfigData.StaticOptions.LootOptions.LootItem>
                            {
                                new ConfigData.StaticOptions.LootOptions.LootItem {Name = "fish.cooked", Maximum = 6, Minimum = 2, Skin =0, DisplayName = null },
                                new ConfigData.StaticOptions.LootOptions.LootItem {Name = "metal.plate.torso", Maximum = 1, Minimum = 1, Skin =0, DisplayName = null }
                            }
                        }
                    }
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new Core.VersionNumber(3, 1, 5))
                configData = baseConfig;

            if (configData.Version < new Core.VersionNumber(3, 1, 6))
            {
                configData.DropSettings.setupDropTypes = defaultDropTypes();
                configData.DropSettings.setupDropDefault = defaultDrop();
            }

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion Config

        #region Messaging
        private void MessageToAllGui(string message)
        {
            var msg = string.Format(configData.GenericSettings.Format, configData.GenericSettings.Color, configData.GenericSettings.Prefix) + message;
            rust.RunServerCommand(configData.GenericSettings.guiCommand + " " + msg.Quote());
        }

        private void MessageToPlayerUI(BasePlayer player, string message)
        {
            UIMessage(player, string.Format(configData.GenericSettings.Format, configData.GenericSettings.Color, configData.GenericSettings.Prefix) + message);
        }

        private void MessageToPlayer(BasePlayer player, string message)
        {
            PrintToChat(player, string.Format(configData.GenericSettings.Format, configData.GenericSettings.Color, configData.GenericSettings.Prefix) + $"<color={configData.GenericSettings.colorTextMsg}>" + message + "</color>");
        }

        private string GetDirectionAngle(float angle, string UserIDString)
        {
            if (angle > 337.5 || angle < 22.5)
                return msg("msgNorth", UserIDString);
            else if (angle > 22.5 && angle < 67.5)
                return msg("msgNorthEast", UserIDString);
            else if (angle > 67.5 && angle < 112.5)
                return msg("msgEast", UserIDString);
            else if (angle > 112.5 && angle < 157.5)
                return msg("msgSouthEast", UserIDString);
            else if (angle > 157.5 && angle < 202.5)
                return msg("msgSouth", UserIDString);
            else if (angle > 202.5 && angle < 247.5)
                return msg("msgSouthWest", UserIDString);
            else if (angle > 247.5 && angle < 292.5)
                return msg("msgWest", UserIDString);
            else if (angle > 292.5 && angle < 337.5)
                return msg("msgNorthWest", UserIDString);
            return "";
        }

        private void NotifyOnDropLanded(BaseEntity drop)
        {
            foreach (var player in BasePlayer.activePlayerList.Where(p => Vector3.Distance(p.transform.position, drop.transform.position) < configData.Notifications.supplyDropNotifyDistance).ToList())
            {
                var message = string.Format(msg("msgDropLanded", player.UserIDString), Vector3.Distance(player.transform.position, drop.transform.position), GetDirectionAngle(Quaternion.LookRotation((drop.transform.position - player.eyes.position).normalized).eulerAngles.y, player.UserIDString));
                MessageToPlayer(player, message);
            }
        }

        private void NotifyOnDropLooted(BaseEntity drop, BasePlayer looter)
        {
            string gridPos = GetGridString(drop.transform.position);

            foreach (var player in BasePlayer.activePlayerList.Where(p => Vector3.Distance(p.transform.position, drop.transform.position) < configData.Notifications.supplyLootNotifyDistance).ToList())
                if (configData.Notifications.notifyDropServerLootedCoords)
                    MessageToPlayer(player, string.Format(msg("msgDropLootetCoords", player.UserIDString), looter.displayName, drop.transform.position.x.ToString("0"), drop.transform.position.z.ToString("0")));
                else if (configData.Notifications.notifyDropServerLootedGrid)
                    MessageToPlayer(player, string.Format(msg("msgDropLootetGrid", player.UserIDString), looter.displayName, gridPos));
                else
                    MessageToPlayer(player, string.Format(msg("msgDropLootet", player.UserIDString), looter.displayName));
        }
        #endregion Messaging

        #region Localization
        private static void SendChatMessage(string key, params object[] args)
        {
            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                BasePlayer player = BasePlayer.activePlayerList[i];
                player.ChatMessage(args != null ? string.Format(msg(key, player.UserIDString), args) : msg(key, player.UserIDString));
            }
        }

        private static string msg(string key, string playerId = "") => Instance.lang.GetMessage(key, Instance, playerId);

        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["msgDropSignal"] = "<size=12>Someone ordered an Air Drop</size>",
            ["msgDropSignalCoords"] = "<size=12>Someone ordered an Air Drop to position <color=#ffff00>X:{0} Z:{1}</color></size>",
            ["msgDropSignalAdmin"] = "<size=12>Supply Signal thrown by '{0}' at: {1}</size>",
            ["msgDropSignalByPlayer"] = "<size=12>Supply Signal thrown by <color=#ffff00>{0}</color></size>",
            ["msgDropSignalByPlayerCoords"] = "<size=12>Supply Signal thrown by <color=#ffff00>{0}</color> at position <color=#ffff00>X:{1} Z:{2}</color></size>",
            ["msgDropRegular"] = "<size=12>A Cargo Plane will deliver the daily Air Drop in a few moments</size>",
            ["msgDropRegularCoords"] = "<size=12>A Cargo Plane will deliver the daily Air Drop at <color=#ffff00>X:{0} | Z:{1}</color> in a few moments</size>",
            ["msgDropMass"] = "<size=12>Mass Air Drop incoming</size>",
            ["msgDropCustom"] = "<size=12>Eventdrop <color=#ffa500>{0}</color> is on the way</size>",
            ["msgDropCustomCoords"] = "<size=12>Eventdrop <color=#ffa500>{0}</color> is on the way to <color=#ffff00>X:{1} | Z:{2}</color></size>",
            ["msgDropPlayer"] = "<size=12><color=#ffff00>Incoming Supply Drop</color> to your current location</size>",
            ["msgDropDirect"] = "<size=12><color=#ffff00>A Supply Drop</color> spawned above your <color=#ffff00>current</color> location</size>",
            ["msgDropLanded"] = "<size=12>A Supply Drop has landed <color=#ffff00>{0:F0}m</color> away from you at direction <color=#ffff00>{1}</color></size>",
            ["msgDropLootet"] = "<size=12><color=#0099CC>Someone is looting the Supply Drop</color></size>",
            ["msgDropLootetCoords"] = "<size=12><color=#ffff00>{0}</color> was looting the Supply Drop at (<color=#ffff00>X:{1} | Z:{2}</color>)</size>",
            ["msgNoAccess"] = "<size=12>You are not allowed to use this command</size>",
            ["msgConsoleDropSpawn"] = "<size=12>Supply Drop spawned at (X:{0} Y:{1} Z:{2})</size>",
            ["msgConsoleDropLanded"] = "<size=12>Supply Drop landed at (X:{0} Y:{1} Z:{2})</size>",
            ["msgCrateLocked"] = "<size=12>This crate is locked until it is being looted by the owner</size>",
            ["msgNorth"] = "<size=12>North</size>",
            ["msgNorthEast"] = "<size=12>NorthEast</size>",
            ["msgEast"] = "<size=12>East</size>",
            ["msgSouthEast"] = "<size=12>SouthEast</size>",
            ["msgSouth"] = "<size=12>South</size>",
            ["msgSouthWest"] = "<size=12>SouthWest</size>",
            ["msgWest"] = "<size=12>West</size>",
            ["msgNorthWest"] = "<size=12>NorthWest</size>",
            ["msgDropSignalGrid"] = "Someone ordered an Airdrop to grid area <color=#ffff00>{0}</color></size>",
            ["msgDropSignalByPlayerGrid"] = "Signal thrown by <color=#ffff00>{0}</color> at grid area <color=#ffff00>{1}</color></size>",
            ["msgDropRegularGrid"] = "Cargoplane will deliver the daily AirDrop in grid area <color=#ffff00>{0}</color> in a few moments</size>",
            ["msgDropCustomGrid"] = "Eventdrop <color=#ffa500>{0}</color> is on his way to grid area <color=#ffff00>{1}</color></size>",
            ["msgDropLootetGrid"] = "<color=#ffff00>{0}</color> was looting the AirDrop located grid area (<color=#ffff00>{1}</color>)</size>",
            ["msgDropDirectSpace"] = "A <color=#ffff00>Space Supply Drop</color> is being deployed to your <color=#ffff00>current</color> location</size>"
        };
        #endregion
    }
}


// --- End of file: FancyDrop.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/file-indexer ---
// --- Original File Path: F/FileIndexer/FileIndexer.cs ---

using System;
using System.IO;
using System.Collections.Generic;
using System.Globalization;

using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
  [Info("FileIndexer", "ImagicTheCat", "1.0.0")]

  public class FileIndexer : CovalencePlugin{
    [Flags]
    public enum Search{
      File = 1,
      Directory = 2,
      Recursive = 4
    }
    
    public class Index{
      public Dictionary<string, Index> idxs;

      public Index()
      {
        idxs = new Dictionary<string, Index>();
      }

      //index a path 
      public void IndexFile(List<string> path, int shift = 0)
      {
        if(path != null && shift < path.Count){
          Index idx;
          if(!idxs.TryGetValue(path[shift],out idx)){ //get existing index or create it
            idx = new Index();
            idxs.Add(path[shift],idx);
          }

          idx.IndexFile(path,shift+1); //recursive index creation
        }
      }

      //get a child index
      public Index GetIndex(List<string> path, int shift = 0)
      {
        if(path != null){ //recursive search
          if(shift < path.Count){ 
            Index idx;
            if(idxs.TryGetValue(path[shift],out idx)) //recursive search
              return idx.GetIndex(path, shift+1);
            else 
              return null;
          }
          else
            return this;
        }
        else
          return null;
      }

      //check if this index is a file (no children)
      public bool IsFile()
      {
        return (idxs.Count == 0);
      }

      //list directories/files in this index (fullpaths)
      public List<string> List(Search search)
      {
        List<string> paths = new List<string>();
        _List(search, paths, "");

        return paths;
      }

      private void _List(Search search, List<string> outpaths, string path)
      {
        foreach(var e in idxs){
          if(e.Value.IsFile()){ //file
            if((search & Search.File) != 0) outpaths.Add(path+e.Key);
          }
          else{ //directory
            if((search & Search.Directory) != 0) outpaths.Add(path+e.Key+"/");

            if((search & Search.Recursive) != 0)
              e.Value._List(search, outpaths, path+e.Key+"/");
          }
        }
      }

      public void Cleanup(string path)
      {
        if(path != null){
          List<string> toremove = new List<string>();

          foreach(var e in idxs){
            if(e.Value.IsFile()){ //file
              if(!Interface.Oxide.DataFileSystem.ExistsDatafile(path+e.Key)) //file don't exist, remove entry
                toremove.Add(e.Key);
            }
            else{ //directory
              e.Value.Cleanup(path+e.Key+"/");             
              if(e.Value.IsFile()) //directory cleaned-up his own content, delete it
                toremove.Add(e.Key);
            }
          }

          foreach(var e in toremove)
            idxs.Remove(e);
        }
      }
    }   

    public class Indexer{
      public Index root;
      private string filepath;

      public Indexer(string filepath)
      {
        this.filepath = filepath;
        Load();
      }

      //index a file (autosave if save not specified)
      public void IndexFile(string filepath, bool save = true)
      {
        bool is_file;
        List<string> list = ParsePath(filepath, out is_file);

        if(is_file){
          root.IndexFile(list);
          if(save)
            Save();
        }
      }

      //list files/directories
      public List<string> List(string path = "", Search search = Search.File | Search.Recursive)
      {
        if(path != null){
          //find index by path
          string[] patharray = path.Split(new string[]{"/"}, StringSplitOptions.RemoveEmptyEntries);
          Index idx = root.GetIndex(new List<string>(patharray)); 

          //list indexes from this index
          if(idx != null)
            return idx.List(search);
        }

        return new List<string>();
      }

      public void Load()
      {
        root = Interface.Oxide.DataFileSystem.ReadObject<Index>(filepath);
        if(root == null)
          root = new Index();
      }

      public void Save()
      {
        Interface.Oxide.DataFileSystem.WriteObject(filepath, root);
      }

      //perform a cleanup of the indexes, checking if a file exists in the root directory
      //rootpath must be like this: my_directory/other/, not my_directory/other
      //don't save the indexer, you must use Save() yourself
      //IndexFile with default parameters will also save the changes.
      public void Cleanup(string rootpath)
      {
        if(rootpath != null)
          root.Cleanup(rootpath);
      }

      public static List<string> ParsePath(string path, out bool is_file)
      {
        List<string> list = new List<string>();
        is_file = false;

        if(path != null){
          string[] res = path.Split(new string[]{"/"}, StringSplitOptions.None);
          for(int i = 0; i < res.Length; i++){
            if(res[i].Length > 0){
              list.Add(res[i]);
              if(i == res.Length-1)
                is_file = true;
            }
          }
        }

        return list;
      }
    }
  }
}

// --- End of file: FileIndexer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/furnace-stopper ---
// --- Original File Path: F/FurnaceStopper/FurnaceStopper.cs ---

using System.Linq;
using UnityEngine;
using VLB;

namespace Oxide.Plugins
{
    [Info("Furnace Stopper", "Orange", "1.0.7")]
    [Description("Stops smelting in furnaces if there are nothing to smelt")]
    public class FurnaceStopper : RustPlugin
    {
        #region Vars

        private const float checkRate = 3f;
        private const string permUse = "furnacestopper.use";

        #endregion

        #region Oxide Hooks

        private void Init()
        {
            permission.RegisterPermission(permUse, this);
        }

        private void Unload()
        {
            foreach (var obj in UnityEngine.Object.FindObjectsOfType<StopperScript>())
            {
                UnityEngine.Object.Destroy(obj);
            }
        }

        private void OnOvenToggle(BaseOven entity, BasePlayer player)
        {
            if (permission.UserHasPermission(entity.OwnerID.ToString(), permUse) == true)
            {
                if (entity.inventory.itemList.Any(x => x.info.GetComponent<ItemModCookable>() != null) == true)
                {
                    NextTick(() =>
                    {
                        if (entity.IsValid() == false)
                        {
                            return;
                        }

                        var component = entity.GetOrAddComponent<StopperScript>();
                        component.StateChanged();
                    });
                }
            }
        }

        #endregion

        #region Scripts

        private class StopperScript : MonoBehaviour
        {
            private BaseOven oven;

            private void Awake()
            {
                oven = GetComponent<BaseOven>();
            }

            public void StateChanged()
            {
                if (oven.IsOn() == true)
                {
                    if (IsInvoking(nameof(Check)) == false)
                    {
                        InvokeRepeating(nameof(Check), checkRate, checkRate);
                    }
                }
                else
                {
                    CancelInvoke(nameof(Check));
                }
            }

            private void Check()
            {
                if (oven.IsOn() == false)
                {
                    CancelInvoke(nameof(Check));
                    return;
                }

                if (oven.inventory.itemList.Any(x => x.info.GetComponent<ItemModCookable>() != null) == false)
                {
                    CancelInvoke(nameof(Check));
                    oven.StopCooking();
                }
            }
        }

        #endregion
    }
}

// --- End of file: FurnaceStopper.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/fog-voting ---
// --- Original File Path: F/FogVoting/FogVoting.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Fog Voting", "Ultra", "1.2.21")]
    [Description("Initializes voting to remove fog from the environment")]

    class FogVoting : RustPlugin
    {
        #region Fields

        bool isVotingOpen = false;
        Timer fogCheckTimer;
        Timer votingTimer;
        Timer votingPanelRefreshTimer;
        DateTime votingStart;
        List<string> usersVotingNo = new List<string>();

        // CUI panels
        static CuiPanel votingPanel;
        string votingPanelName = "votingPanelName";
        string fogYesPanelName = "fogYesPanelName";
        string fogNoPanelName = "fogNoPanelName";
        string votingScorePanelName = "votingScorePanelName";


        #endregion

        #region Oxide Hooks

        void OnServerInitialized()
        {
            InitCUI();
            CheckCurrentFog();
        }

        void Unload()
        {
            DestroyVotingPanel();

            DestroyTimer(fogCheckTimer);
            DestroyTimer(votingTimer);
            DestroyTimer(votingPanelRefreshTimer);
        }

        #endregion

        #region Chat Commands

        [ChatCommand("nofog")]
        void FogNo(BasePlayer player)
        {
            if (!isVotingOpen)
            {
                SendReply(player, "Fog voting is not open now");
            }

            if (!usersVotingNo.Contains(player.UserIDString))
            {
                usersVotingNo.Add(player.UserIDString);
                CheckVoting();
            }
        }

        [ChatCommand("setfog")]
        void SetFog(BasePlayer player, string command, string[] args)
        {
            if (player.IsAdmin)
            {
                float fogValue = 0;
                if (args.Length == 1 && float.TryParse(args[0], out fogValue))
                {
                    if (fogValue >= 0F && fogValue <= 1F)
                    {
                        ConsoleSystem.Run(ConsoleSystem.Option.Server, $"weather.fog {fogValue}");
                    }
                }
            }
        }

        [ChatCommand("checkfog")]
        void CheckFog(BasePlayer player, string command, string[] args)
        {
            if (isVotingOpen) return;
            if (player.IsAdmin)
            {
                CheckCurrentFog();
            }
        }

        #endregion

        #region Core

        void CheckCurrentFog()
        {
            DestroyTimer(fogCheckTimer);

            foreach (var player in BasePlayer.activePlayerList)
            {
                if (Climate.GetFog(player.transform.position) > configData.FogLimit)
                {
                    OpenVoting();
                    return;
                }
            }

            fogCheckTimer = timer.Once(configData.FogCheckInterval, () => CheckCurrentFog());
        }

        void OpenVoting()
        {
            isVotingOpen = true;
            usersVotingNo = new List<string>();
            votingStart = DateTime.UtcNow;
            ShowVotingPanel();
            votingTimer = timer.Once(configData.VotingDuration, () => CloseVoting(intervalMultiplier: 5));

            PrintToChat($"<color=#89b38a>FOG VOTING:</color>: vote <color=#89b38a>/nofog</color> to remove fog");
        }

        void CheckVoting()
        {
            float requiredVotes = BasePlayer.activePlayerList.Count * (configData.VotePercentage / 100);
            if (requiredVotes < 1) requiredVotes = 1;

            if (usersVotingNo.Count >= requiredVotes)
            {
                ConsoleSystem.Run(ConsoleSystem.Option.Server, "weather.fog 0");
                PrintToChat($"<color=#89b38a>FOG VOTING:</color>: Fog has been <color=#89b38a>removed</color>");
                CloseVoting();
            }
        }

        void CloseVoting(float intervalMultiplier = 1)
        {
            isVotingOpen = false;
            DestroyTimer(votingTimer);
            DestroyVotingPanel();
            fogCheckTimer = timer.Once(configData.FogCheckInterval * intervalMultiplier, () => CheckCurrentFog());
        }

        void DestroyTimer(Timer timer)
        {
            timer?.DestroyToPool();
            timer = null;
        }

        void DestroyVotingPanel()
        {
            DestroyTimer(votingPanelRefreshTimer);

            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, votingPanelName);
            }
        }

        #endregion

        #region Config

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Fog value to start voting 0.0 - 1.0")]
            public float FogLimit;

            [JsonProperty(PropertyName = "Interval to check the current fog (seconds)")]
            public float FogCheckInterval;

            [JsonProperty(PropertyName = "Voting duration (seconds)")]
            public float VotingDuration;

            [JsonProperty(PropertyName = "Required vote percentage")]
            public float VotePercentage;
        }

        protected override void LoadConfig()
        {
            try
            {
                base.LoadConfig();
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }

            if (configData.FogLimit < 0 || configData.FogLimit > 1) configData.FogLimit = 0.1F;
            if (configData.FogCheckInterval < 1) configData.FogCheckInterval = 60;
            if (configData.VotingDuration < 10) configData.VotingDuration = 30;
            if (configData.VotePercentage <= 0 || configData.VotePercentage > 100) configData.VotePercentage = 40;

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            configData = new ConfigData()
            {
                FogLimit = 0.3F,
                FogCheckInterval = 60,
                VotingDuration = 30
            };
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(configData, true);
            base.SaveConfig();
        }

        #endregion

        #region CUI

        void InitCUI()
        {
            votingPanel = new CuiPanel
            {
                CursorEnabled = false,
                RectTransform =
                    {
                        AnchorMin = $"0.4 0.74",
                        AnchorMax = $"0.6 0.81"
                    },
                Image =
                 { Color = "0 0 0 0.8" }
            };
        }

        void ShowVotingPanel() {
            /**
             * Moved the below equations out of the loop, to improve performance. 
             */
            float requiredVotes = BasePlayer.activePlayerList.Count * (configData.VotePercentage / 100);
            float progress = (float)(DateTime.UtcNow - votingStart).TotalSeconds / configData.VotingDuration;
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, votingPanelName);

                if (isVotingOpen)
                {
                    var container = new CuiElementContainer();
                    container.Add(votingPanel, name: votingPanelName);

                    if (requiredVotes < 1) requiredVotes = 1;

                    // progress bar
                    container.Add(GetPanel(anchorMin: "0 0", anchorMax: $"{progress} 0.1", color: "1 1 1 0.4"), votingPanelName, name: fogNoPanelName);

                    // voting score 
                    container.Add(GetPanel(anchorMin: "0 0.1", anchorMax: "1 0.6"), votingPanelName, name: votingScorePanelName);
                    container.Add(GetLabel($"{usersVotingNo.Count}/{BasePlayer.activePlayerList.Count}", align: TextAnchor.MiddleCenter, size: 12), votingScorePanelName);

                    // voting info 
                    container.Add(GetPanel(anchorMin: "0 0.6", anchorMax: "1 1"), votingPanelName, name: fogNoPanelName);
                    container.Add(GetLabel($"Vote <color=#89b38a>/nofog</color> to remove fog - {requiredVotes} vote(s) required", align: TextAnchor.MiddleCenter, size: 12), fogNoPanelName);


                    CuiHelper.AddUi(player, container);
                }
            }

            if (isVotingOpen) votingPanelRefreshTimer = timer.Once(2F, () => ShowVotingPanel());
        }

        CuiPanel GetPanel(string anchorMin = "0 0", string anchorMax = "1 1", string color = "0.1 0.1 0.1 0", bool cursorEnabled = false)
        {
            return new CuiPanel
            {
                CursorEnabled = cursorEnabled,
                RectTransform =
                {
                    AnchorMin = anchorMin,
                    AnchorMax = anchorMax
                },
                Image = { Color = color }
            };
        }

        CuiLabel GetLabel(string text, int size = 14, string anchorMin = "0.05 0.02", string anchorMax = "0.98 0.9", TextAnchor align = TextAnchor.MiddleCenter, string color = "1 1 1 1", string font = "robotocondensed-regular.ttf")
        {
            return new CuiLabel
            {
                Text =
                    {
                        Text = text,
                        FontSize = size,
                        Align = align,
                        Color = color,
                        Font = font
                    },
                RectTransform =
                    {
                        AnchorMin = anchorMin,
                        AnchorMax = anchorMax
                    },
            };
        }

        #endregion
    }
}

// --- End of file: FogVoting.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/friendly-fire ---
// --- Original File Path: F/FriendlyFire/FriendlyFire.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Friendly Fire", "collect_vood", "1.1.2")]
    [Description("Gives you the ability to enable or disable friendly fire player based")]
    class FriendlyFire : CovalencePlugin
    {
        [PluginReference]
        private Plugin Friends, Clans;

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                { "NoFriendlyFire", "You cannot damage your friends! (<color=#7FFF00>/ff on</color>)" },
                { "OtherNoFriendlyFire", "{0} has friendly fire disabled!" },
                { "FriendAttack", "Your friend {0} tried to attack you!"},
                { "FFOn", "Friendly Fire turned <color=#7FFF00>on</color>!" },
                { "FFOff", "Friendly Fire turned <color=#FF0000>off</color>!" },
                { "AlreadyStateOn", "Friendly Fire is already turned <color=#7FFF00>on</color>!" },
                { "AlreadyStateOff", "Friendly Fire is already turned <color=#FF0000>off</color>!" },
                { "FFHelp", "Friendly Fire:\n/ff on - to turn on friendly fire\n/ff off - to turn off friendly fire" },
                { "CommandArguments", "You have to use <color=#7FFF00>on</color> or <color=#FF0000>off</color> as arguments!" },
                { "NoPermission", "You don't have access to use this command"}
            }, this);
        }
        #endregion

        #region Config       
        private Configuration config;
        private class Configuration
        {
            [JsonProperty(PropertyName = "Command")]
            public string Command = "ff";
            [JsonProperty(PropertyName = "Player Default Settings", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, bool> PlayerDefaultSettings = new Dictionary<string, bool>
            {
                { "Friendly Fire", false }
            };
            [JsonProperty(PropertyName = "Change friendly fire state permission")]
            public string ChangeStatePermission = "friendlyfire.changestate";
            [JsonProperty(PropertyName = "Send friendly fire messages")]
            public bool SendMessages = true;
            [JsonProperty(PropertyName = "Include check if friend")]
            public bool isFriendCheck = true;
            [JsonProperty(PropertyName = "Include check if team member")]
            public bool isTeamMemberCheck = true;
            [JsonProperty(PropertyName = "Include check if clan member")]
            public bool isClanMemberCheck = true;
        }
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            config = new Configuration();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<Configuration>();
            SaveConfig();
        }
        protected override void SaveConfig() => Config.WriteObject(config);        
        #endregion

        #region Data
        private StoredData storedData;
        private Dictionary<string, PlayerSettings> allPlayerSettings => storedData.AllPlayerSettings;

        private class PlayerSettings
        {
            public bool ff;
        }
        private class StoredData
        {
            public Dictionary<string, PlayerSettings> AllPlayerSettings { get; private set; } = new Dictionary<string, PlayerSettings>();
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        private void OnServerSave() => SaveData();
        private void Unload() => SaveData();

        private void CreatePlayerSettings(IPlayer player)
        {
            if (!allPlayerSettings.ContainsKey(player.Id))
            {
                allPlayerSettings[player.Id] = new PlayerSettings
                {
                    ff = config.PlayerDefaultSettings["Friendly Fire"],
                };
            }
        }
        #endregion

        #region Hooks
        private void Init()
        {
            permission.RegisterPermission(config.ChangeStatePermission, this);
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            AddCovalenceCommand(config.Command, nameof(CommandFriendlyFire));        
        }
        private void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList)
                CreatePlayerSettings(player.IPlayer);
            SaveData();
        }
        object OnPlayerAttack(BasePlayer player, HitInfo info)
        {
            if (info?.HitEntity == null || player == null)
                return null;
            IPlayer attacker = player.IPlayer;
            if (!(info.HitEntity is BasePlayer))
                return null;
            BasePlayer victimBP = info.HitEntity as BasePlayer;
            IPlayer victim = victimBP.IPlayer;
            if (attacker == null || victim == null || attacker.Id == victim.Id)
                return null;
            CreatePlayerSettings(attacker);
            CreatePlayerSettings(victim);
            if (!allPlayerSettings[attacker.Id].ff || !allPlayerSettings[victim.Id].ff)
            {
                if ((config.isTeamMemberCheck && IsTeamMember(player, victimBP)) || (config.isFriendCheck && (Friends?.Call<bool>("AreFriends", attacker.Id, victim.Id) ?? false)) || (config.isClanMemberCheck && IsClanMember(player, victimBP)))
                {
                    if (config.SendMessages)
                    {
                        if (!allPlayerSettings[attacker.Id].ff)
                        {
                            attacker.Reply(GetMessage("NoFriendlyFire", attacker));
                        }
                        else
                        {
                            attacker.Reply(GetMessage("OtherNoFriendlyFire", attacker, victim.Name));
                        }
                        victim.Reply(GetMessage("FriendAttack", victim, attacker.Name));
                    }
                    Interface.Oxide.CallHook("OnFriendAttacked", attacker, victim, info);
                    return true;
                }
            }
            return null;
        }
        private void OnUserConnected(IPlayer player) { CreatePlayerSettings(player); }
        #endregion

        #region Command
        private void CommandFriendlyFire(IPlayer player, string command, string[] args)
        {
            if (!HasPermission(player))
            {
                player.Reply(GetMessage("NoPermission", player));
                return;
            }
            CreatePlayerSettings(player);
            if (args.Length <= 0)
            {
                if (allPlayerSettings[player.Id].ff == true)
                {
                    allPlayerSettings[player.Id].ff = false;
                    player.Reply(GetMessage("FFOff", player));
                }
                else
                {
                    allPlayerSettings[player.Id].ff = true;
                    player.Reply(GetMessage("FFOn", player));
                }
                return;
            }
            switch (args[0].ToLower())
            {
                case "on":
                    if (allPlayerSettings[player.Id].ff == true)
                    {
                        player.Reply(GetMessage("AlreadyStateOn", player));
                        break;
                    }
                    allPlayerSettings[player.Id].ff = true;
                    player.Reply(GetMessage("FFOn", player));
                    break;
                case "off":
                    if (allPlayerSettings[player.Id].ff == false)
                    {
                        player.Reply(GetMessage("AlreadyStateOff", player));
                        break;
                    }
                    allPlayerSettings[player.Id].ff = false;
                    player.Reply(GetMessage("FFOff", player));
                    break;
                case "help":
                    player.Reply(GetMessage("FFHelp", player));
                    break;
                default:
                    player.Reply(GetMessage("CommandArguments", player));
                    break;
            }
        }
        #endregion

        #region Helpers
        string GetMessage(string key, IPlayer player, params string[] args) => String.Format(lang.GetMessage(key, this, player.Id), args);
        bool HasPermission(IPlayer player) => permission.UserHasPermission(player.Id, config.ChangeStatePermission);
        bool IsTeamMember(BasePlayer player, BasePlayer possibleMember)
        {
            if (player.currentTeam == 0 || possibleMember.currentTeam == 0)
                return false;
            return player.currentTeam == possibleMember.currentTeam;
        }
        bool IsClanMember(BasePlayer player, BasePlayer possibleMember)
        {
            if (Clans == null || !Clans.IsLoaded)
                return false;

            var playerClan = Clans.Call<string>("GetClanOf", player);
            var otherPlayerClan = Clans.Call<string>("GetClanOf", possibleMember);
            if (String.IsNullOrEmpty(otherPlayerClan) || String.IsNullOrEmpty(playerClan))
            {
                return false;
            }
            return playerClan == otherPlayerClan;
        }
        #endregion
    }
}


// --- End of file: FriendlyFire.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/fetch ---
// --- Original File Path: F/Fetch/Fetch.cs ---

﻿using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Fetch", "CatMeat", "1.0.2")]
    [Description("Download JSON file from URI and store in a DATA subfolder")]

    class Fetch : CovalencePlugin
    {
        // Filename obtained from command parameters arg[0] (.json automatically added)
        // URI obtained from command parameters arg[1]
        // Destination directory obtained from config file or `fetch` if not defined
        // tested with dropbox link, must replace ?dl=0 with ?dl=1
        // originally intended to upload fortify files to a server running copypaste, hence the default sub-folder.

        private const string FetchUse = "fetch.use";
        private const string FetchOverwrite = "fetch.overwrite";
        private PluginConfig config;

        #region Init
        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();
            permission.RegisterPermission(FetchUse, this);
            permission.RegisterPermission(FetchOverwrite, this);
        }

        protected override void LoadDefaultConfig()
        {
            Puts(Lang("FetchConfig"));
            Config.WriteObject(GetDefaultConfig(), true);
        }
        #endregion Init

        #region Lang
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["FetchConfig"] = "Creating config file.",
                ["FetchSyntax"] = "Syntax: /fetch savefilename url", 
                ["FetchExists"] = "{0} already exists! Choose another name.", 
                ["FetchInvalid"] = "Not a valid URL", 
                ["FetchErrCode"] = "Error: {0} - Could not download",
                ["FetchSaveFail"] = "Error: Failed to save {0}",
                ["FetchSaveFailLog"] = "Error: Failed to save {0} - {1} for user {2}",
                ["FetchSaved"] = "Successfully saved {0}.json" 
            }, this);
        }

        private string Lang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }
        #endregion lang

        #region Config
        private class PluginConfig
        {
            public bool AllowOverwrite;
            public string SubFolder;
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                AllowOverwrite = false,
                SubFolder = "copypaste"
            };
        }
        #endregion Config

        #region Command
        [Command("fetch")]
        private void GetRequest(IPlayer player, string command, string[] args)
        {
            if (player.HasPermission(FetchUse))
            {
                // Example: /fetch test https://www.dropbox.com/s/qh5emmd9clss069/2x2fortify.json?dl=1

                if (String.IsNullOrEmpty(config.SubFolder))
                {
                    config.SubFolder = Name.ToLower(); 
                }

                if (args.Length != 2 || String.IsNullOrEmpty(args[0]) || String.IsNullOrEmpty(args[1]))
                {
                    player.Reply(Lang("FetchSyntax", player.Id));
                    return;
                }

                string savefilename = args[0]; 
                string uri = args[1];

                if (Interface.Oxide.DataFileSystem.ExistsDatafile($"{Interface.Oxide.DataDirectory}\\{config.SubFolder}\\{savefilename}"))
                {
                    if (!config.AllowOverwrite || !player.HasPermission(FetchOverwrite))
                    {
                        player.Reply(Lang("FetchExists", player.Id, savefilename));
                        return;
                    }
                }

                Uri uriResult;
                bool uriTest = Uri.TryCreate(uri, UriKind.Absolute, out uriResult)
                    && (uriResult.Scheme == Uri.UriSchemeHttp || uriResult.Scheme == Uri.UriSchemeHttps);

                if (uriTest)
                {
                    try
                    {
                        webrequest.Enqueue(uri, null, (code, response) =>
                          GetCallback(code, response, uri, savefilename, player), this);
                    }
                    catch
                    {
                        player.Reply(Lang("FetchInvalid", player.Id, uri));
                        return;
                    }
                }
                else
                {
                    player.Reply(Lang("FetchInvalid", player.Id, uri));
                    return;
                }
            }
        }

        private void GetCallback(int code, string response, string uri, string savefilename, IPlayer player)
        {
            if (response == null || code != 200)
            {
                player.Reply(Lang("FetchErrCode", player.Id, code));
                return;
            }

            string SaveFilePath = String.Format($"{Interface.Oxide.DataDirectory}\\{config.SubFolder}\\{savefilename}");

            try
            {
                var json = JObject.Parse(response);
                Interface.Oxide.DataFileSystem.WriteObject(SaveFilePath, json);
            }
            catch
            {
                if (!player.IsServer)
                {
                    Puts(Lang("FetchSaveFailLog", player.Id, savefilename, SaveFilePath, player.Name));
                }

                player.Reply(Lang("FetchSaveFail", player.Id, savefilename));
                return;
            }

            player.Reply(Lang("FetchSaved", player.Id, savefilename));
        }
        #endregion Command
    }
}


// --- End of file: Fetch.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/foundation-limit ---
// --- Original File Path: F/FoundationLimit/FoundationLimit.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Foundation Limit", "noname", "1.4.2")]
    [Description("Limits the number of foundations allowed")]
    class FoundationLimit : CovalencePlugin
    {
        public static FoundationLimit Plugin;
        private int MaskInt = LayerMask.GetMask("Construction");
        private const string foundationlimit_admin_Perm = "foundationlimit.admin";
        private const string foundationlimit_bypass_Perm = "foundationlimit.bypass";

        private uint FoundationPrefabID;
        private uint TriangleFoundationPrefabID;

        #region Hooks

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");

            Config.WriteObject(GetDefaultConfig(), true);
        }

        private void OnServerInitialized()
        {
            Plugin = this;
            LoadConfig();
            RegisterPermissions();

            FoundationPrefabID = StringPool.toNumber["assets/prefabs/building core/foundation/foundation.prefab"];
            TriangleFoundationPrefabID = StringPool.toNumber["assets/prefabs/building core/foundation.triangle/foundation.triangle.prefab"];
        }

        private void Unload()
        {
            Plugin = null;
        }

        #endregion

        #region PluginIO

        #region ConfigManage

        private PluginConfig config;

        private void LoadConfig()
        {
            config = Config.ReadObject<PluginConfig>();

            if (config == null)
                config = GetDefaultConfig();
        }

        private class PluginConfig
        {
            public int SearchRange;
            public bool UseFoundationClassification;
            public int DefaultFoundationLimit;
            public int DefaultTriangleFoundationLimit;
            public int MinFoundationsBeforeMsgShowsUp;
            public List<PermissionItem> permissionItems;

            public PluginConfig()
            {
                permissionItems = new List<PermissionItem>();
            }
        }

        public class PermissionItem
        {
            public string PermissionName;
            public int FoundationLimit;
            public int TriangleFoundationLimit;

            public PermissionItem()
            {

            }

            public PermissionItem(string permissionName, int foundationLimit)
            {
                PermissionName = permissionName;
                FoundationLimit = foundationLimit;
                TriangleFoundationLimit = 0;
            }
            
            public PermissionItem(string permissionName, int squarefoundationLimit, int trianglefoundationlimit)
            {
                PermissionName = permissionName;
                FoundationLimit = squarefoundationLimit;
                TriangleFoundationLimit = trianglefoundationlimit;
            }
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                SearchRange = 5,
                UseFoundationClassification = false,
                DefaultFoundationLimit = 20,
                DefaultTriangleFoundationLimit = 0,
                MinFoundationsBeforeMsgShowsUp = -1,
                permissionItems = new List<PermissionItem>()
                {
                    new PermissionItem("foundationlimit.vip", 40),
                    new PermissionItem("foundationlimit.vip2", 60),
                    new PermissionItem("foundationlimit.vip3", 80)
                }
            };
        }

        #endregion

        #region LangManage

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["No Permission"] = "You do not have permission to use the '{0}' command.",
                ["No parameters"] = "Not enough parameters.",
                ["Invalid parameters"] = "Invalid parameters.",
                ["Parameter Not Int"] = "Parameter is not an integer.",

                ["FoundationLimited"] = "You can place up to {0} foundations.",
                ["SquareFoundationLimited"] = "You can place up to {0} square foundations.",
                ["TriangleFoundationLimited"] = "You can place up to {0} triangle foundations.",
                ["FoundationLimitDisplay"] = "Currently you placed {0} foundations, You can place up to {1} foundations.",
                ["SquareNTriangleFoundationLimitDisplay"] = "Currently you placed {0} square foundations and {1} triangle foundations, You can place up to {2} square foundations and {3} triangle foundations.",

                ["Limit Changed"] = "Foundation limit changed to {0}.",
                ["Limit Triangle Changed"] = "Square Foundation limit changed to {0} and Triangle Foundation limit changed to {0}.",
                ["Radius Changed"] = "Inter-Connected Foundation search scope has been changed to '{0}'.",

                ["Item Added"] = "Custom permission '{0}' has been added.",
                ["Item Removed"] = "Custom permission '{0}' has been removed.",
                ["Item Already Exist"] = "Item with same name already exists.",
                ["Item Not Exist"] = "Item does not exist.",

                ["Limit Item"] = "    <color=#C9AE00>{0}:</color> {1}",
                ["Limit TriangleOptioned Item"] = "    <color=#C9AE00>{0}:</color> Square - {1}, Triangle - {2}",
                ["NoData"] = "No Data",

                ["Class Enabled"] = "Foundation classification enabled.",
                ["Class Disabled"] = "Foundation classification disabled.",
                ["Msg Count Set"] = "MinFoundationsBeforeMsgShowsUp value is set to {0}.",

                ["Limit Status"] = "<size=20><color=#FFBB00>Foundation Limit Status</color></size>\n" +
                                   "\n" +
                                   "<color=#FFE400>SearchRange:</color> {0}\n" +
                                   "<color=#FFE400>MinFoundationsBeforeMsgShowsUp:</color> {1}\n" +
                                   "<color=#FFE400>DefaultFoundationLimit:</color> {2}\n" +
                                   "<color=#FFE400>CustomPermissionList:</color> \n{3}",

                ["Limit TriangleOptioned Status"] = "<size=20><color=#FFBB00>Foundation Limit Status</color></size>\n" +
                                   "\n" +
                                   "<color=#FFE400>SearchRange:</color> {0}\n" +
                                   "<color=#FFE400>MinFoundationsBeforeMsgShowsUp:</color> {1}\n" +
                                   "<color=#FFE400>DefaultSquareFoundationLimit:</color> {2}\n" +
                                   "<color=#FFE400>DefaultTriangleFoundationLimit:</color> {3}\n" +
                                   "<color=#FFE400>CustomPermissionList:</color> \n{4}",

                ["CommandList"] = "<size=20><color=#FFBB00>Foundation Limit</color></size>\n" +
                                  "\n" +
                                  "<color=#FFE400>/fdlimit default </color><color=#C9AE00>[limitcount]</color> - Set number of foundations to limit by default (-1 = Disable)\n" +
                                  "<color=#FFE400>/fdlimit add </color><color=#C9AE00>[permissionname] [limitcount]</color> - add custom vip permission\n" +
                                  "<color=#FFE400>/fdlimit remove </color><color=#C9AE00>[permissionname]</color> - remove custom vip permission\n" +
                                  "<color=#FFE400>/fdlimit radius </color><color=#C9AE00>[searchradius]</color> - Set scope to search for connected foundations\n" +
                                  "<color=#FFE400>/fdlimit class </color><color=#C9AE00>[on/off]</color> - Determine whether to treat triangle foundation and square foundation separately\n" +
                                  "<color=#FFE400>/fdlimit msg </color><color=#C9AE00>[integer (-1 = disable)]</color> - Minimum foundations required before the limit message shows up\n" +
                                  "<color=#FFE400>/fdlimit stat</color> - view config settings",

                ["CommandList TriangleOptioned"] = "<size=20><color=#FFBB00>Foundation Limit</color></size>\n" +
                                  "\n" +
                                  "<color=#FFE400>/fdlimit default </color><color=#C9AE00>[squarefoundationlimitcount] [trianglefoundationlimitcount]</color> - Set number of foundations to limit by default (-1 = Disable)\n" +
                                  "<color=#FFE400>/fdlimit add </color><color=#C9AE00>[permissionname] [squarefoundationlimitcount] [trianglefoundationlimitcount]</color> - add custom vip permission\n" +
                                  "<color=#FFE400>/fdlimit remove </color><color=#C9AE00>[permissionname]</color> - remove custom vip permission\n" +
                                  "<color=#FFE400>/fdlimit radius </color><color=#C9AE00>[searchradius]</color> - Set scope to search for connected foundations\n" +
                                  "<color=#FFE400>/fdlimit class </color><color=#C9AE00>[on/off]</color> - Determine whether to treat triangle foundation and square foundation separately\n" +
                                  "<color=#FFE400>/fdlimit msg </color><color=#C9AE00>[integer (-1 = disable)]</color> - Minimum foundations required before the limit message shows up\n" +
                                  "<color=#FFE400>/fdlimit stat</color> - view config settings"
            }, this);
        }
        
        private string Lang(string key, string id = null, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        #endregion

        #region PermissionManage

        private void RegisterPermissions()
        {
            permission.RegisterPermission(foundationlimit_admin_Perm, this);
            permission.RegisterPermission(foundationlimit_bypass_Perm, this);

            foreach (var item in config.permissionItems)
            {
                permission.RegisterPermission(item.PermissionName, this);
            }
        }

        #endregion

        #endregion

        #region InterCommand

        private void OnEntityBuilt(Planner planner, GameObject gObject)
        {
            BasePlayer player = planner?.GetOwnerPlayer();
            if (player == null)
                return;

            BaseEntity entity = gObject?.ToBaseEntity();
            if (entity == null)
                return;

            if (entity.ShortPrefabName != "foundation" && entity.ShortPrefabName != "foundation.triangle")
                return;

            if (permission.UserHasPermission(player.UserIDString, foundationlimit_bypass_Perm))
                return;

            List<BaseEntity> SearchedFoundation = FindLinkedStructures(player, entity);

            if (!config.UseFoundationClassification)
            {
                int permLimitCount = GetPermLimitCount(player);

                if (permLimitCount != -1)
                {
                    if (SearchedFoundation.Count > permLimitCount)
                    {
                        entity.Kill(BaseNetworkable.DestroyMode.Gib);
                        player.ChatMessage(Lang("FoundationLimited", player?.UserIDString, permLimitCount.ToString()));
                    }
                    else
                    {
                        if (config.MinFoundationsBeforeMsgShowsUp != -1 && SearchedFoundation.Count < config.MinFoundationsBeforeMsgShowsUp)
                            return;

                        player.ChatMessage(Lang("FoundationLimitDisplay", player?.UserIDString, SearchedFoundation.Count.ToString(), permLimitCount.ToString()));
                    }
                }
            }
            else
            {
                FoundationSet permLimitCounts = GetPermClassLimitCount(player);

                int SearchedSquareFoundationCount = 0;
                int SearchedTriangleFoundationCount = 0;

                foreach (var item in SearchedFoundation)
                {
                    if (item.ShortPrefabName == "foundation")
                        SearchedSquareFoundationCount++;
                    else
                        SearchedTriangleFoundationCount++;
                }

                if (permLimitCounts.SquareFoundation != -1)
                {
                    if (SearchedSquareFoundationCount > permLimitCounts.SquareFoundation)
                    {
                        entity.Kill(BaseNetworkable.DestroyMode.Gib);
                        player.ChatMessage(Lang("SquareFoundationLimited", player?.UserIDString, permLimitCounts.SquareFoundation.ToString()));
                    }
                    else
                    {
                        if (config.MinFoundationsBeforeMsgShowsUp != -1 && SearchedSquareFoundationCount < config.MinFoundationsBeforeMsgShowsUp)
                            return;

                        player.ChatMessage(Lang("SquareNTriangleFoundationLimitDisplay", player?.UserIDString, SearchedSquareFoundationCount.ToString(), permLimitCounts.SquareFoundation.ToString(), SearchedTriangleFoundationCount.ToString(), permLimitCounts.TriangleFoundation.ToString()));
                    }
                }

                if (permLimitCounts.TriangleFoundation != -1)
                {
                    if (SearchedTriangleFoundationCount > permLimitCounts.TriangleFoundation)
                    {
                        entity.Kill(BaseNetworkable.DestroyMode.Gib);
                        player.ChatMessage(Lang("TriangleFoundationLimited", player?.UserIDString, permLimitCounts.TriangleFoundation.ToString()));
                    }
                    else
                    {
                        if (config.MinFoundationsBeforeMsgShowsUp != -1 && SearchedTriangleFoundationCount < config.MinFoundationsBeforeMsgShowsUp)
                            return;

                        player.ChatMessage(Lang("SquareNTriangleFoundationLimitDisplay", player?.UserIDString, SearchedSquareFoundationCount.ToString(), permLimitCounts.SquareFoundation.ToString(), SearchedTriangleFoundationCount.ToString(), permLimitCounts.TriangleFoundation.ToString()));
                    }
                }
            }
        }

        object OnStructureDemolish(BaseCombatEntity entity, BasePlayer player, bool immediate)
        {
            if (player == null || entity == null)
                return null;

            if (entity.ShortPrefabName != "foundation" && entity.ShortPrefabName != "foundation.triangle")
                return null;

            if (permission.UserHasPermission(player.UserIDString, foundationlimit_bypass_Perm))
                return null;

            List<BaseEntity> SearchedFoundation = FindLinkedStructures(player, entity);

            if (!config.UseFoundationClassification)
            {
                int permLimitCount = GetPermLimitCount(player);

                if (permLimitCount != -1)
                {
                    if (SearchedFoundation.Count > permLimitCount)
                    {
                        player.ChatMessage(Lang("FoundationLimited", player?.UserIDString, permLimitCount.ToString()));
                    }
                    else
                    {
                        if (config.MinFoundationsBeforeMsgShowsUp != -1 && SearchedFoundation.Count < config.MinFoundationsBeforeMsgShowsUp)
                            return null;

                        player.ChatMessage(Lang("FoundationLimitDisplay", player?.UserIDString, SearchedFoundation.Count.ToString(), permLimitCount.ToString()));
                    }
                }
            }
            else
            {
                FoundationSet permLimitCounts = GetPermClassLimitCount(player);

                int SearchedSquareFoundationCount = 0;
                int SearchedTriangleFoundationCount = 0;

                foreach (var item in SearchedFoundation)
                {
                    if (item.ShortPrefabName == "foundation")
                        SearchedSquareFoundationCount++;
                    else
                        SearchedTriangleFoundationCount++;
                }

                if (permLimitCounts.SquareFoundation != -1)
                {
                    if (SearchedSquareFoundationCount > permLimitCounts.SquareFoundation)
                    {
                        entity.Kill(BaseNetworkable.DestroyMode.Gib);
                        player.ChatMessage(Lang("SquareFoundationLimited", player?.UserIDString, permLimitCounts.SquareFoundation.ToString()));
                    }
                    else
                    {
                        if (config.MinFoundationsBeforeMsgShowsUp != -1 && SearchedSquareFoundationCount < config.MinFoundationsBeforeMsgShowsUp)
                            return null;

                        player.ChatMessage(Lang("SquareNTriangleFoundationLimitDisplay", player?.UserIDString, SearchedSquareFoundationCount.ToString(), permLimitCounts.SquareFoundation.ToString(), SearchedTriangleFoundationCount.ToString(), permLimitCounts.TriangleFoundation.ToString()));
                    }
                }

                if (permLimitCounts.TriangleFoundation != -1)
                {
                    if (SearchedTriangleFoundationCount > permLimitCounts.TriangleFoundation)
                    {
                        entity.Kill(BaseNetworkable.DestroyMode.Gib);
                        player.ChatMessage(Lang("TriangleFoundationLimited", player?.UserIDString, permLimitCounts.TriangleFoundation.ToString()));
                    }
                    else
                    {
                        if (config.MinFoundationsBeforeMsgShowsUp != -1 && SearchedTriangleFoundationCount < config.MinFoundationsBeforeMsgShowsUp)
                            return null;

                        player.ChatMessage(Lang("SquareNTriangleFoundationLimitDisplay", player?.UserIDString, SearchedSquareFoundationCount.ToString(), permLimitCounts.SquareFoundation.ToString(), SearchedTriangleFoundationCount.ToString(), permLimitCounts.TriangleFoundation.ToString()));
                    }
                }
            }
            return null;
        }

        private List<BaseEntity> FindLinkedStructures(BasePlayer player, BaseEntity entity)
        {
            List<BaseEntity> SearchedFoundation = new List<BaseEntity>();
            List<BaseEntity> RemoveEntity = new List<BaseEntity>();
            List<BaseEntity> ExpendEntity = new List<BaseEntity>();

            List<BaseEntity> EntityList = new List<BaseEntity>();
            List<BaseEntity> SearchedTemp = new List<BaseEntity>();
            Vis.Entities<BaseEntity>(entity.transform.position, config.SearchRange, EntityList, MaskInt);

            int permLimitCount = GetPermLimitCount(player);

            while (!(SearchedFoundation.Count > permLimitCount || EntityList.Count == 0))
            {
                foreach (var item in EntityList)
                {
                    if (item.prefabID != FoundationPrefabID && item.prefabID != TriangleFoundationPrefabID)
                    {
                        RemoveEntity.Add(item);
                        continue;
                    }
                    if (SearchedFoundation.Contains(item) == false)
                    {
                        SearchedFoundation.Add(item);
                        ExpendEntity.Add(item);
                    }
                    RemoveEntity.Add(item);
                }

                foreach (var item in ExpendEntity)
                {
                    SearchedTemp.Clear();
                    Vis.Entities<BaseEntity>(item.transform.position, config.SearchRange, SearchedTemp, MaskInt);

                    foreach (var additem in SearchedTemp)
                    {
                        if (!EntityList.Contains(additem))
                            EntityList.Add(additem);
                    }
                }
                ExpendEntity.Clear();

                foreach (var item in RemoveEntity)
                {
                    EntityList.Remove(item);
                }
                RemoveEntity.Clear();
            }

            return SearchedFoundation;
        }

        private int GetPermLimitCount(BasePlayer player)
        {
            int permLimitCount = config.DefaultFoundationLimit;
            foreach (var item in config.permissionItems)
            {
                if (permission.UserHasPermission(player.UserIDString, item.PermissionName))
                {
                    if (permLimitCount < item.FoundationLimit)
                    {
                        permLimitCount = item.FoundationLimit;
                    }
                }
            }

            return permLimitCount;
        }

        private FoundationSet GetPermClassLimitCount(BasePlayer player)
        {
            int squarePermLimitCount = config.DefaultFoundationLimit;
            int trianglePermLimitCount = config.DefaultTriangleFoundationLimit;

            foreach (var item in config.permissionItems)
            {
                if (permission.UserHasPermission(player.UserIDString, item.PermissionName))
                {
                    if (squarePermLimitCount < item.FoundationLimit)
                        squarePermLimitCount = item.FoundationLimit;

                    if (trianglePermLimitCount < item.TriangleFoundationLimit)
                        trianglePermLimitCount = item.TriangleFoundationLimit;
                }
            }

            return new FoundationSet(squarePermLimitCount, trianglePermLimitCount);
        }

        private struct FoundationSet
        {
            public int SquareFoundation;
            public int TriangleFoundation;

            public FoundationSet(int squareFoundation, int triangleFoundation)
            {
                SquareFoundation = squareFoundation;
                TriangleFoundation = triangleFoundation;
            }
        }

        #endregion

        #region Command/API

        [Command("fdlimit")]
        void SetFoundationLimitCommand(IPlayer player, string command, string[] args)
        {
            if (!player.IsAdmin)
            {
                if (!player.HasPermission(foundationlimit_admin_Perm))
                {
                    player.Reply(Lang("No Permission", player.Id, command));
                    return;
                }
            }

            if (0 == args.Length)
            {
                if (!config.UseFoundationClassification)
                    player.Reply(Plugin.Lang("CommandList", player.Id));
                else
                    player.Reply(Plugin.Lang("CommandList TriangleOptioned", player.Id));
                return;
            }

            int parsednum;
            int parsednum2;

            switch (args[0].ToLower())
            {
                case "default":
                    if (!config.UseFoundationClassification)
                    {
                        if (!(2 <= args.Length))
                        {
                            player.Reply(Plugin.Lang("No parameters", player.Id));
                            break;
                        }
                        if (int.TryParse(args[1], out parsednum))
                        {
                            config.DefaultFoundationLimit = parsednum;
                            Config.WriteObject(config, true);
                            player.Reply(Plugin.Lang("Limit Changed", player.Id, parsednum.ToString()));
                        }
                        else
                            player.Reply(Plugin.Lang("Parameter Not Int", player.Id));
                    }
                    else
                    {
                        if (!(3 <= args.Length))
                        {
                            player.Reply(Plugin.Lang("No parameters", player.Id));
                            break;
                        }
                        if (int.TryParse(args[1], out parsednum) && int.TryParse(args[2], out parsednum2))
                        {
                            config.DefaultFoundationLimit = parsednum;
                            config.DefaultTriangleFoundationLimit = parsednum2;
                            Config.WriteObject(config, true);
                            player.Reply(Plugin.Lang("Limit Triangle Changed", player.Id, parsednum.ToString(), parsednum2.ToString()));
                        }
                        else
                            player.Reply(Plugin.Lang("Parameter Not Int", player.Id));
                    }
                    break;

                case "add":
                    if (!config.UseFoundationClassification)
                    {
                        if (!(3 <= args.Length))
                        {
                            player.Reply(Plugin.Lang("No parameters", player.Id));
                            break;
                        }
                        if (int.TryParse(args[2], out parsednum))
                        {
                            bool Contains = false;
                            string permissionName = args[1];
                            if (permissionName.Length <= Name.Length + 1 || permissionName.Substring(0, Name.Length + 1) != Name.ToLower() + ".")
                                permissionName = Name.ToLower() + "." + permissionName;

                            foreach (var item in config.permissionItems)
                            {
                                if (item.PermissionName == permissionName)
                                    Contains = true;
                            }
                            if (Contains)
                            {
                                player.Reply(Plugin.Lang("Item Already Exist", player.Id, permissionName));
                                return;
                            }
                            config.permissionItems.Add(new PermissionItem(permissionName, parsednum));
                            Config.WriteObject(config, true);
                            permission.RegisterPermission(permissionName, this);
                            player.Reply(Plugin.Lang("Item Added", player.Id, permissionName));
                        }
                        else
                            player.Reply(Plugin.Lang("Parameter Not Int", player.Id));
                    }
                    else
                    {
                        if (!(4 <= args.Length))
                        {
                            player.Reply(Plugin.Lang("No parameters", player.Id));
                            break;
                        }
                        if (int.TryParse(args[2], out parsednum) && int.TryParse(args[3], out parsednum2))
                        {
                            bool Contains = false;
                            string permissionName = args[1];
                            if (permissionName.Length <= Name.Length + 1 || permissionName.Substring(0, Name.Length + 1) != Name.ToLower() + ".")
                                permissionName = Name.ToLower() + "." + permissionName;

                            foreach (var item in config.permissionItems)
                            {
                                if (item.PermissionName == permissionName)
                                    Contains = true;
                            }
                            if (Contains)
                            {
                                player.Reply(Plugin.Lang("Item Already Exist", player.Id, permissionName));
                                return;
                            }
                            config.permissionItems.Add(new PermissionItem(permissionName, parsednum, parsednum2));
                            Config.WriteObject(config, true);
                            permission.RegisterPermission(permissionName, this);
                            player.Reply(Plugin.Lang("Item Added", player.Id, permissionName));
                        }
                        else
                            player.Reply(Plugin.Lang("Parameter Not Int", player.Id));
                    }
                    break;

                case "remove":
                    if (!(2 <= args.Length))
                    {
                        player.Reply(Plugin.Lang("No parameters", player.Id));
                        break;
                    }
                    foreach (var item in config.permissionItems)
                    {
                        if (item.PermissionName == args[1])
                        {
                            config.permissionItems.Remove(item);
                            Config.WriteObject(config, true);
                            player.Reply(Plugin.Lang("Item Removed", player.Id, args[1]));
                            return;
                        }
                        player.Reply(Plugin.Lang("Item Not Exist", player.Id));

                    }
                    break;

                case "radius":
                    if (!(2 <= args.Length))
                    {
                        player.Reply(Plugin.Lang("No parameters", player.Id));
                        break;
                    }
                    if (int.TryParse(args[1], out parsednum))
                    {
                        config.SearchRange = parsednum;
                        Config.WriteObject(config, true);
                        player.Reply(Plugin.Lang("Radius Changed", player.Id, parsednum.ToString()));
                    }
                    else
                        player.Reply(Plugin.Lang("Parameter Not Int", player.Id));
                    break;

                case "class":
                    if (!(2 <= args.Length))
                    {
                        player.Reply(Plugin.Lang("No parameters", player.Id));
                        break;
                    }
                    switch (args[1].ToLower())
                    {
                        case "on":
                            config.UseFoundationClassification = true;
                            Config.WriteObject(config, true);
                            player.Reply(Plugin.Lang("Class Enabled", player.Id));
                            break;

                        case "off":
                            config.UseFoundationClassification = false;
                            Config.WriteObject(config, true);
                            player.Reply(Plugin.Lang("Class Disabled", player.Id));
                            break;

                        default:
                            player.Reply(Plugin.Lang("Invalid parameters", player.Id));
                            break;
                    }
                    break;

                case "msg":
                    if (!(2 <= args.Length))
                    {
                        player.Reply(Plugin.Lang("No parameters", player.Id));
                        break;
                    }
                    if (int.TryParse(args[1], out parsednum))
                    {
                        config.MinFoundationsBeforeMsgShowsUp = parsednum;
                        Config.WriteObject(config, true);
                        player.Reply(Plugin.Lang("Msg Count Set", player.Id, parsednum.ToString()));
                    }
                    else
                        player.Reply(Plugin.Lang("Parameter Not Int", player.Id));
                    break;

                case "stat":
                    string msg = "";

                    if (!config.UseFoundationClassification)
                    {
                        foreach (var item in config.permissionItems)
                        {
                            msg += Plugin.Lang("Limit Item", player.Id, item.PermissionName, item.FoundationLimit) + "\n";
                        }
                        if (config.permissionItems.Count == 0)
                        {
                            msg += Plugin.Lang("NoData", player.Id);
                        }
                        else
                            msg = msg.Substring(0, msg.Length - 1);

                        player.Reply(Plugin.Lang("Limit Status", player.Id, config.SearchRange, config.MinFoundationsBeforeMsgShowsUp, config.DefaultFoundationLimit, msg));
                    }
                    else
                    {
                        foreach (var item in config.permissionItems)
                        {
                            msg += Plugin.Lang("Limit TriangleOptioned Item", player.Id, item.PermissionName, item.FoundationLimit, item.TriangleFoundationLimit) + "\n";
                        }
                        if (config.permissionItems.Count == 0)
                        {
                            msg += Plugin.Lang("NoData", player.Id);
                        }
                        else
                            msg = msg.Substring(0, msg.Length - 1);

                        player.Reply(Plugin.Lang("Limit TriangleOptioned Status", player.Id, config.SearchRange, config.MinFoundationsBeforeMsgShowsUp, config.DefaultFoundationLimit, config.DefaultTriangleFoundationLimit, msg));
                    }
                    break;

                default:
                    player.Reply(Plugin.Lang("Invalid parameters", player.Id));
                    break;
            }
        }

        #endregion
    }
}

// --- End of file: FoundationLimit.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/friends ---
// --- Original File Path: F/Friends/Friends.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

// TODO: Add cooldown option for adding friends
// TODO: Add ability for varying max number of friends (based on permissions?)
// TODO: Split 'friend' command into 'addfriend', 'removefriend', and 'friends'
// TODO: Create separate plugin for friend notifications (togglable)
// TODO: Create separate plugin for private chat between friends only

namespace Oxide.Plugins
{
    [Info("Friends", "Wulf", "3.1.3")]
    [Description("Friends system and API managing friend lists")]
    internal class Friends : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty("Friend list cache time (0 to disable)")]
            public int CacheTime = 0;

            [JsonProperty("Maximum number of friends (0 to disable)")]
            public int MaxFriends = 30;

            [JsonProperty("Use permission system")]
            public bool UsePermissions = false;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Stored Data

        private readonly Dictionary<string, HashSet<string>> reverseData = new Dictionary<string, HashSet<string>>();
        private Dictionary<string, PlayerData> friendsData;

        private static readonly DateTime Epoch = new DateTime(1970, 1, 1);

        private class PlayerData
        {
            public string Name { get; set; } = string.Empty;
            public HashSet<string> Friends { get; set; } = new HashSet<string>();
            public Dictionary<string, int> Cached { get; set; } = new Dictionary<string, int>();

            public bool IsCached(string playerId)
            {
                int time;
                if (!Cached.TryGetValue(playerId, out time))
                {
                    return false;
                }

                if (time >= (int)DateTime.UtcNow.Subtract(Epoch).TotalSeconds)
                {
                    return true;
                }

                Cached.Remove(playerId);
                return false;
            }
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, friendsData);
        }

        #endregion Stored Data

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AlreadyOnList"] = "{0} is already your friend",
                ["CannotAddSelf"] = "You cannot add yourself",
                ["CommandFriend"] = "friend",
                ["FriendAdded"] = "{0} is now your friend",
                ["FriendRemoved"] = "{0} was removed from your friend list",
                ["FriendList"] = "Friends {0}:\n{1}",
                ["FriendListFull"] = "Your friend list is full",
                ["NoFriends"] = "You do not have any friends",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["NoPlayersFound"] = "No players found with name or ID '{0}'",
                ["NotOnFriendList"] = "{0} not found on your friend list",
                ["PlayerNotFound"] = "Player '{0}' was not found",
                ["PlayersFound"] = "Multiple players were found, please specify: {0}",
                ["PlayersOnly"] = "Command '{0}' can only be used by players",
                ["UsageFriend"] = "Usage {0} <add|remove|list> <player name or id>"
            }, this);
        }

        #endregion Localization

        #region Initialization

        private const string permUse = "friends.use";

        private void Init()
        {
            AddLocalizedCommand(nameof(CommandFriend));

            permission.RegisterPermission(permUse, this);

            try
            {
                friendsData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, PlayerData>>(Name);
            }
            catch
            {
                friendsData = new Dictionary<string, PlayerData>();
            }

            foreach (KeyValuePair<string, PlayerData> data in friendsData)
            {
                foreach (string friendId in data.Value.Friends)
                {
                    AddFriendReverse(data.Key, friendId);
                }
            }
        }

        #endregion Initialization

        #region Add/Remove Friends

        private bool AddFriend(string playerId, string friendId)
        {
            if (!string.IsNullOrEmpty(playerId) && !string.IsNullOrEmpty(friendId))

            {
                PlayerData playerData = GetPlayerData(playerId);
                if (playerData.Friends.Count >= config.MaxFriends || !playerData.Friends.Add(friendId))
                {
                    return false;
                }

                AddFriendReverse(playerId, friendId);
                SaveData();

                Interface.Oxide.CallHook("OnFriendAdded", playerId, friendId);
                return true;
            }

            return false;
        }

        private bool AddFriend(ulong playerId, ulong friendId)
        {
            return AddFriend(playerId.ToString(), friendId.ToString());
        }

        private void AddFriendReverse(string playerId, string friendId)
        {
            HashSet<string> friends;
            if (!reverseData.TryGetValue(friendId, out friends))
            {
                reverseData[friendId] = friends = new HashSet<string>();
            }

            friends.Add(playerId);
        }

        private bool RemoveFriend(string playerId, string friendId)
        {
            if (!string.IsNullOrEmpty(playerId) && !string.IsNullOrEmpty(friendId))
            {
                PlayerData playerData = GetPlayerData(playerId);
                if (!playerData.Friends.Remove(friendId))
                {
                    return false;
                }

                HashSet<string> friends;
                if (reverseData.TryGetValue(friendId, out friends))
                {
                    friends.Remove(playerId);
                }

                if (config.CacheTime > 0)
                {
                    playerData.Cached[friendId] = (int)DateTime.UtcNow.Subtract(Epoch).TotalSeconds + config.CacheTime;
                }

                SaveData();

                Interface.Oxide.CallHook("OnFriendRemoved", playerId, friendId);
                return true;
            }

            return false;
        }

        private bool RemoveFriend(ulong playerId, ulong friendId)
        {
            return RemoveFriend(playerId.ToString(), friendId.ToString());
        }

        #endregion Add/Remove Friends

        #region Friend Checks

        private bool HasFriend(string playerId, string friendId)
        {
            if (!string.IsNullOrEmpty(playerId) && !string.IsNullOrEmpty(friendId))
            {
                return GetPlayerData(playerId).Friends.Contains(friendId);
            }

            return false;
        }

        private bool HasFriend(ulong playerId, ulong friendId)
        {
            return HasFriend(playerId.ToString(), friendId.ToString());
        }

        private bool HadFriend(string playerId, string friendId)
        {
            if (!string.IsNullOrEmpty(playerId) && !string.IsNullOrEmpty(friendId))
            {
                PlayerData playerData = GetPlayerData(playerId);
                return playerData.Friends.Contains(friendId) || playerData.IsCached(friendId);
            }

            return false;
        }

        private bool HadFriend(ulong playerId, ulong friendId)
        {
            return HadFriend(playerId.ToString(), friendId.ToString());
        }

        private bool AreFriends(string playerId, string friendId)
        {
            if (string.IsNullOrEmpty(playerId) || string.IsNullOrEmpty(friendId))
            {
                return false;
            }

            return GetPlayerData(playerId).Friends.Contains(friendId) && GetPlayerData(friendId).Friends.Contains(playerId);
        }

        private bool AreFriends(ulong playerId, ulong friendId)
        {
            return AreFriends(playerId.ToString(), friendId.ToString());
        }

        private bool WereFriends(string playerId, string friendId)
        {
            if (!string.IsNullOrEmpty(playerId) && !string.IsNullOrEmpty(friendId))
            {
                PlayerData playerData = GetPlayerData(playerId);
                PlayerData friendData = GetPlayerData(friendId);
                return (playerData.Friends.Contains(friendId) || playerData.IsCached(friendId)) && (friendData.Friends.Contains(playerId) || friendData.IsCached(playerId));
            }

            return false;
        }

        private bool WereFriends(ulong playerId, ulong friendId)
        {
            return WereFriends(playerId.ToString(), friendId.ToString());
        }

        private bool IsFriend(string playerId, string friendId)
        {
            if (!string.IsNullOrEmpty(playerId) && !string.IsNullOrEmpty(friendId))
            {
                return GetPlayerData(friendId).Friends.Contains(playerId);
            }

            return false;
        }

        private bool IsFriend(ulong playerId, ulong friendId)
        {
            return IsFriend(playerId.ToString(), friendId.ToString());
        }

        private bool WasFriend(string playerId, string friendId)
        {
            if (!string.IsNullOrEmpty(playerId) && !string.IsNullOrEmpty(friendId))
            {
                PlayerData playerData = GetPlayerData(friendId);
                return playerData.Friends.Contains(playerId) || playerData.IsCached(playerId);
            }

            return false;
        }

        private bool WasFriend(ulong playerId, ulong friendId)
        {
            return WasFriend(playerId.ToString(), friendId.ToString());
        }

        private int GetMaxFriends()
        {
            return config.MaxFriends;
        }

        #endregion Friend Checks

        #region Friend Lists

        private string[] GetFriends(string playerId)
        {
            return GetPlayerData(playerId).Friends.ToArray();
        }

        private ulong[] GetFriends(ulong playerId)
        {
            return GetPlayerData(playerId.ToString()).Friends.Select(ulong.Parse).ToArray();
        }

        private string[] GetFriendList(string playerId)
        {
            PlayerData playerData = GetPlayerData(playerId);
            List<string> players = new List<string>();

            foreach (string friendId in playerData.Friends)
            {
                players.Add(GetPlayerData(friendId).Name);
            }

            return players.ToArray();
        }

        private string[] GetFriendList(ulong playerId)
        {
            return GetFriendList(playerId.ToString());
        }

        private string[] IsFriendOf(string playerId)
        {
            HashSet<string> friends;
            return reverseData.TryGetValue(playerId, out friends) ? friends.ToArray() : new string[0];
        }

        private ulong[] IsFriendOf(ulong playerId)
        {
            return IsFriendOf(playerId.ToString()).Select(ulong.Parse).ToArray();
        }

        #endregion Friend Lists

        #region Commands

        private void CommandFriend(IPlayer player, string command, string[] args)
        {
            if (player.IsServer)
            {
                Message(player, "PlayersOnly", command);
                return;
            }

            if (config.UsePermissions && !player.HasPermission(permUse))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args.Length <= 0 || args.Length == 1 && !args[0].Equals("list", StringComparison.OrdinalIgnoreCase))
            {
                Message(player, "UsageFriend", command);
                return;
            }

            switch (args[0].ToLower())
            {
                case "list":
                    string[] friendList = GetFriendList(player.Id);
                    if (friendList.Length > 0)
                    {
                        Message(player, "FriendList", $"{friendList.Length}/{config.MaxFriends}", string.Join(", ", friendList));
                    }
                    else
                    {
                        Message(player, "NoFriends");
                    }

                    return;

                case "+":
                case "add":
                    IPlayer target = FindPlayer(args[1], player);
                    if (target == null)
                    {
                        return;
                    }

                    if (player == target)
                    {
                        Message(player, "CannotAddSelf");
                        return;
                    }

                    PlayerData playerData = GetPlayerData(player.Id);
                    if (playerData.Friends.Count >= config.MaxFriends)
                    {
                        Message(player, "FriendListFull");
                        return;
                    }

                    if (playerData.Friends.Contains(target.Id))
                    {
                        Message(player, "AlreadyOnList", target.Name);
                        return;
                    }

                    AddFriend(player.Id, target.Id);
                    Message(player, "FriendAdded", target.Name);
                    return;

                case "-":
                case "remove":
                    string friend = FindFriend(args[1]);
                    if (string.IsNullOrEmpty(friend))
                    {
                        Message(player, "NotOnFriendList", args[1]);
                        return;
                    }

                    bool removed = RemoveFriend(player.Id, friend.ToString());
                    Message(player, removed ? "FriendRemoved" : "NotOnFriendList", args[1]);
                    return;
            }
        }

        private void SendHelpText(object obj)
        {
            IPlayer player = players.FindPlayerByObj(obj);
            if (player != null)
            {
                Message(player, "HelpText");
            }
        }

        #endregion Commands

        #region Helpers

        private string FindFriend(string nameOrId)
        {
            if (!string.IsNullOrEmpty(nameOrId))
            {
                foreach (KeyValuePair<string, PlayerData> playerData in friendsData)
                {
                    if (playerData.Key.Equals(nameOrId) || playerData.Value.Name.IndexOf(nameOrId, StringComparison.OrdinalIgnoreCase) >= 0)
                    {
                        return playerData.Key;
                    }
                }
            }

            return string.Empty;
        }

        private PlayerData GetPlayerData(string playerId)
        {
            PlayerData playerData;
            if (!friendsData.TryGetValue(playerId, out playerData))
            {
                friendsData[playerId] = playerData = new PlayerData();
            }

            IPlayer player = players.FindPlayerById(playerId);
            if (player != null)
            {
                playerData.Name = player.Name;
            }

            return playerData;
        }

        private IPlayer FindPlayer(string playerNameOrId, IPlayer player)
        {
            IPlayer[] foundPlayers = players.FindPlayers(playerNameOrId).ToArray();
            if (foundPlayers.Length > 1)
            {
                Message(player, "PlayersFound", string.Join(", ", foundPlayers.Select(p => p.Name).Take(10).ToArray()).Truncate(60));
                return null;
            }

            IPlayer target = foundPlayers.Length == 1 ? foundPlayers[0] : null;
            if (target == null)
            {
                Message(player, "NoPlayersFound", playerNameOrId);
                return null;
            }

            return target;
        }

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (message.Key.Equals(command))
                    {
                        if (!string.IsNullOrEmpty(message.Value))
                        {
                            AddCovalenceCommand(message.Value, command);
                        }
                    }
                }
            }
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string textOrLang, params object[] args)
        {
            if (player.IsConnected)
            {
                string message = GetLang(textOrLang, player.Id, args);
                player.Reply(message != textOrLang ? message : textOrLang);
            }
        }

        #endregion Helpers
    }
}

// --- End of file: Friends.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/frame-box ---
// --- Original File Path: F/FrameBox/FrameBox.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Linq;
using System.Text;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Frame Box", "MJSU", "1.0.2")]
    [Description("Deploys a frame on a box allowing the player to set the image")]
    internal class FrameBox : RustPlugin
    {
        #region Class Fields
        private StoredData _storedData; //Plugin Data
        private PluginConfig _pluginConfig; //Plugin Config

        private static FrameBox _ins;

        private const string UsePermission = "framebox.use";
        private const string NoCostPermission = "framebox.nocost";
        private const string AccentColor = "#de8732";

        private readonly Hash<NetworkableId, BoxData> _boxes = new Hash<NetworkableId, BoxData>();
        private readonly Hash<NetworkableId, FrameData> _frames = new Hash<NetworkableId, FrameData>();
        private readonly Hash<string, ContainerData> _containerPositions = new Hash<string, ContainerData>();
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _ins = this;
            _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);

            permission.RegisterPermission(UsePermission, this);
            permission.RegisterPermission(NoCostPermission, this);

            cmd.AddChatCommand(_pluginConfig.ChatCommand, this, SignBoxChatCommand);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Chat] = $"<color=#bebebe>[<color={AccentColor}>{Title}</color>] {{0}}</color>",
                [LangKeys.NoPermission] = "You do not have permission to use this command",
                [LangKeys.MissingItem] = "{0}: {1}x",
                [LangKeys.MissingMessage] =
                    "You do not have enough items to add a frame to this box. You're missing:\n{0}",
                [LangKeys.CostPre] = "Cost to make:\n",
                [LangKeys.Cost] = "{0}: {1}x",
                [LangKeys.AddInvalidSyntax] =
                    $"Invalid Syntax: <color={AccentColor}>/{{0}} {{2}} front</color> - to add the frame to the front of the box" +
                    "\nAvailable frame positions for this container are {1}",
                [LangKeys.InvalidAddFramePosition] = "Invalid Frame Position. Available frame positions are:\n {0}",
                [LangKeys.NotLookingAt] = "You're not looking at a box or frame",
                [LangKeys.AddSlotIsTaken] = "The frame position {0} is already taken. Open positions are:\n{1}",
                [LangKeys.AddSuccess] = "You have successfully added a frame onto your box in position {0}. " +
                                        "In order to access the box using the frame you need to first lock the frame." +
                                        "The only way to unlock the frame is using the /fb unlock command",
                [LangKeys.RemoveSuccess] = "You have successfully removed the frame from position {0}",
                [LangKeys.UnlockBuildingBlocked] = "Cannot unlock in a building blocked zone",
                [LangKeys.UnlockSuccess] = "You have successfully unlocked the sign.",
                [LangKeys.NotLookingAtFrame] = "You're not looking at a frame.",
                [LangKeys.NotLookingAtFrameBoxFrame] = "You're not looking at a frame box frame",
                [LangKeys.NotLookingAtFrameBox] = "You're not looking at a frame box or frame box frame",
                [LangKeys.NoFrameInPosition] = "There is no frame in position {0}",
                [LangKeys.ContainerNotAllowed] = "This container is not allowed to have a frame on it.",
                [LangKeys.NoUnlockPermission] = "You do not have permission to unlock this sign.",
                [LangKeys.AddSubCommand] = "add",
                [LangKeys.RemoveSubCommand] = "remove",
                [LangKeys.CostSubCommand] = "cost",
                [LangKeys.UnlockSubCommand] = "unlock",
                [LangKeys.AllSubOption] = "all",
                [LangKeys.HelpText] =
                    "Allows placing photo frames on boxes. After settings the sign and locking it you can now access the box while looking at the sign.\n" +
                    $"<color={AccentColor}>/{{0}} {{1}}</color> to see the available positions to palace a sign\n" +
                    $"<color={AccentColor}>/{{0}} {{1}} right</color> to place a sign on the right\n" +
                    $"<color={AccentColor}>/{{0}} {{1}} frontleft</color> to place a sign on the front left\n" +
                    $"<color={AccentColor}>/{{0}} {{2}}</color> to remove a sign you're looking at\n" +
                    $"<color={AccentColor}>/{{0}} {{3}}</color> to get the cost of the sign\n" +
                    $"<color={AccentColor}>/{{0}} {{4}}</color> to unlock the sign to allow edits again\n" +
                    $"<color={AccentColor}>/{{0}}</color> to see this help text again\n"
            }, this);
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }

        //TODO: Fix config back to normal
        public PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Cost = config.Cost ?? new Hash<string, int>
            {
                ["wood"] = 150
            };

            config.SignPositions = config.SignPositions ?? new Hash<string, ContainerData>
            {
                ["box.wooden.large"] = new ContainerData
                {
                    ItemShortname = "photoframe.portrait",
                    PositionData = new Hash<string, PositionData>
                    {
                        ["Left"] = new PositionData
                        {
                            Offset = new Vector3(0.95f, 0.4f, 0),
                            Rotation = new Vector3(0, 90, 90),
                            IncludeAll = true
                        },
                        ["Right"] = new PositionData
                        {
                            Offset = new Vector3(-0.95f, 0.4f, 0),
                            Rotation = new Vector3(0, 270, 90),
                            IncludeAll = true
                        },
                        ["Front"] = new PositionData
                        {
                            Offset = new Vector3(0, 0.4f, 0.55f),
                            Rotation = new Vector3(0, 0, 90),
                            IncludeAll = false
                        },
                        ["FrontRight"] = new PositionData
                        {
                            Offset = new Vector3(-0.45f, 0.4f, 0.55f),
                            Rotation = new Vector3(0, 0, 90),
                            IncludeAll = true
                        },
                        ["FrontLeft"] = new PositionData
                        {
                            Offset = new Vector3(0.45f, 0.4f, 0.55f),
                            Rotation = new Vector3(0, 0, 90),
                            IncludeAll = true
                        },
                        ["Back"] = new PositionData
                        {
                            Offset = new Vector3(0, 0.4f, -0.55f),
                            Rotation = new Vector3(0, 180, 90),
                            IncludeAll = false
                        },
                        ["BackRight"] = new PositionData
                        {
                            Offset = new Vector3(-0.45f, 0.4f, -0.55f),
                            Rotation = new Vector3(0, 180, 90),
                            IncludeAll = true
                        },
                        ["BackLeft"] = new PositionData
                        {
                            Offset = new Vector3(0.45f, 0.4f, -0.55f),
                            Rotation = new Vector3(0, 180, 90),
                            IncludeAll = true
                        },
                        ["Top"] = new PositionData
                        {
                            Offset = new Vector3(0, 0.775f, 0),
                            Rotation = new Vector3(270, 0, 90),
                            IncludeAll = false
                        },
                        ["TopRight"] = new PositionData
                        {
                            Offset = new Vector3(-0.45f, 0.775f, 0),
                            Rotation = new Vector3(270, 0, 90),
                            IncludeAll = true
                        },
                        ["TopLeft"] = new PositionData
                        {
                            Offset = new Vector3(0.45f, 0.775f, 0),
                            Rotation = new Vector3(270, 0, 90),
                            IncludeAll = true
                        }
                    }
                },
                ["box.wooden"] = new ContainerData
                {
                    ItemShortname = "photoframe.portrait",
                    PositionData = new Hash<string, PositionData>
                    {
                        ["Left"] = new PositionData
                        {
                            Offset = new Vector3(0.49f, 0.35f, 0),
                            Rotation = new Vector3(0, 90, 90),
                            IncludeAll = true
                        },
                        ["Right"] = new PositionData
                        {
                            Offset = new Vector3(-0.49f, 0.35f, 0),
                            Rotation = new Vector3(0, 270, 90),
                            IncludeAll = true
                        },
                        ["Front"] = new PositionData
                        {
                            Offset = new Vector3(0, 0.35f, .39f),
                            Rotation = new Vector3(0, 0, 90),
                            IncludeAll = true
                        },
                        ["Back"] = new PositionData
                        {
                            Offset = new Vector3(0, 0.35f, -.39f),
                            Rotation = new Vector3(0, 180, 90),
                            IncludeAll = true
                        },
                        ["Top"] = new PositionData
                        {
                            Offset = new Vector3(0, 0.6f, 0),
                            Rotation = new Vector3(270, 0, 90),
                            IncludeAll = true
                        }
                    }
                }
            };
            return config;
        }

        private void OnServerInitialized()
        {
            foreach (KeyValuePair<string, ContainerData> entityPositions in _pluginConfig.SignPositions)
            {
                string containerShortname = GetShortPrefabName(entityPositions.Key);
                if (string.IsNullOrEmpty(containerShortname))
                {
                    continue;
                }

                string prefabName = GetPrefabName(entityPositions.Value.ItemShortname);
                if (string.IsNullOrEmpty(prefabName))
                {
                    continue;
                }

                Hash<string, PositionData> positions = new Hash<string, PositionData>();
                foreach (KeyValuePair<string, PositionData> position in entityPositions.Value.PositionData)
                {
                    PositionData data = position.Value;
                    data.DisplayName = position.Key;
                    positions[position.Key.ToLower()] = data;
                }

                ContainerData containerData = new ContainerData
                {
                    ItemShortname = prefabName,
                    PositionData = positions
                };

                _containerPositions[containerShortname] = containerData;
            }

            foreach (KeyValuePair<ulong, Hash<string, ulong>> data in _storedData.FrameData.ToList())
            {
                BoxStorage box = BaseNetworkable.serverEntities.Find(new NetworkableId(data.Key)) as BoxStorage;
                if (box == null)
                {
                    _storedData.FrameData.Remove(data.Key);
                    continue;
                }

                BoxData boxData = new BoxData(box);

                foreach (KeyValuePair<string, ulong> framePos in data.Value.ToList())
                {
                    PhotoFrame frame = BaseNetworkable.serverEntities.Find(new NetworkableId(framePos.Value)) as PhotoFrame;
                    if (frame == null)
                    {
                        data.Value.Remove(framePos.Key);
                        continue;
                    }

                    if (!boxData.AddFrame(frame, framePos.Key))
                    {
                        data.Value.Remove(framePos.Key);
                        frame.Kill();
                    }
                }
            }

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
        }

        private void OnNewSave(string filename)
        {
            _storedData = new StoredData();
            SaveData();
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            NextTick(() =>
            {
                if (player.IsAdmin || player.IsDeveloper)
                {
                    player.gameObject.AddComponent<AdminBoxBehavior>();
                }
            });
        }

        private void Unload()
        {
            foreach (AdminBoxBehavior adminBoxBehavior in GameObject.FindObjectsOfType<AdminBoxBehavior>())
            {
                adminBoxBehavior.DoDestroy();
            }

            SaveData();
            _ins = null;
        }
        #endregion

        #region Chat Command
        private void SignBoxChatCommand(BasePlayer player, string cmd, string[] args)
        {
            if (!HasPermission(player, UsePermission))
            {
                Chat(player, LangKeys.NoPermission);
                return;
            }

            if (args.Length == 0)
            {
                HandleHelp(player);
                return;
            }

            string subCommand = args[0];
            if (subCommand.Equals(Lang(LangKeys.AddSubCommand, player), StringComparison.InvariantCultureIgnoreCase))
            {
                HandleAdd(player, args);
            }
            else if (subCommand.Equals(Lang(LangKeys.RemoveSubCommand, player), StringComparison.InvariantCultureIgnoreCase))
            {
                HandleRemove(player, args);
            }
            else if (subCommand.Equals(Lang(LangKeys.CostSubCommand, player), StringComparison.InvariantCultureIgnoreCase))
            {
                HandleCost(player);
            }
            else if (subCommand.Equals(Lang(LangKeys.UnlockSubCommand, player), StringComparison.InvariantCultureIgnoreCase))
            {
                HandleUnlock(player, args);
            }
            else
            {
               HandleHelp(player);
            }
        }

        public void HandleHelp(BasePlayer player)
        {
            Chat(player, LangKeys.HelpText, _pluginConfig.ChatCommand, 
                Lang(LangKeys.AddSubCommand, player), 
                Lang(LangKeys.RemoveSubCommand, player), 
                Lang(LangKeys.CostSubCommand, player), 
                Lang(LangKeys.UnlockSubCommand, player));
        }

        public void HandleAdd(BasePlayer player, string[] args)
        {
            BaseCombatEntity box = Raycast<IItemContainerEntity>(player) as BaseCombatEntity;
            if (box == null)
            {
                Chat(player, LangKeys.NotLookingAt);
                return;
            }

            if (box is PhotoFrame)
            {
                FrameData data = _frames[box.net.ID];
                if (data == null)
                {
                    Chat(player, LangKeys.NotLookingAt);
                    return;
                }

                box = data.BoxData.Box;
            }
            
            ContainerData containerData = _containerPositions[box.ShortPrefabName];
            if (containerData == null)
            {
                Chat(player, LangKeys.ContainerNotAllowed);
                return;
            }

            if (args.Length < 2)
            {
                Chat(player, LangKeys.AddInvalidSyntax, _pluginConfig.ChatCommand, string.Join(", ", containerData.PositionData.Values.Select(cd => cd.DisplayName).ToArray()), Lang(LangKeys.AddSubCommand, player));
                return;
            }

            string pos = args[1].ToLower();
            if (!containerData.PositionData.ContainsKey(pos) && !pos.Equals(Lang(LangKeys.AllSubOption, player), StringComparison.InvariantCultureIgnoreCase))
            {
                Chat(player, LangKeys.InvalidAddFramePosition, string.Join(", ", containerData.PositionData.Values.Select(cd => cd.DisplayName).ToArray()));
                return;
            }

            BoxData boxData = _boxes[box.net.ID] ?? new BoxData(box);
            if (boxData.IsSlotTaken(pos))
            {
                Chat(player, LangKeys.AddSlotIsTaken, pos, string.Join(", ", boxData.GetOpenPositions(false)));
                return;
            }

            Hash<string, ulong> frameData = _storedData.FrameData[box.net.ID.Value];
            if (frameData == null)
            {
                frameData = new Hash<string, ulong>();
                _storedData.FrameData[box.net.ID.Value] = frameData;
            }

            if (pos.Equals(Lang(LangKeys.AllSubOption, player), StringComparison.InvariantCultureIgnoreCase))
            {
                if (!HasPermission(player, NoCostPermission) && !CanAfford(player, _pluginConfig.Cost, boxData.GetOpenPositions(true).Length))
                {
                    return;
                }

                foreach (KeyValuePair<string, PositionData> positionData in containerData.PositionData)
                {
                    if (!positionData.Value.IncludeAll)
                    {
                        continue;
                    }

                    frameData[positionData.Key] = AddFrame(boxData, containerData.ItemShortname, positionData.Value, positionData.Key);
                }
            }
            else
            {
                if (!HasPermission(player, NoCostPermission) && !CanAfford(player, _pluginConfig.Cost, 1))
                {
                    return;
                }

                PositionData framePos = containerData.PositionData[pos];
                frameData[pos] = AddFrame(boxData, containerData.ItemShortname, framePos, pos);
            }

            Chat(player, LangKeys.AddSuccess, pos);
            SaveData();
        }

        public ulong AddFrame(BoxData boxData, string prefabName, PositionData framePos, string pos)
        {
            PhotoFrame frame = GameManager.server.CreateEntity(prefabName, boxData.Box.transform.TransformPoint(framePos.Offset), boxData.Box.transform.rotation * Quaternion.Euler(framePos.Rotation)) as PhotoFrame;
            frame.Spawn();
            boxData.AddFrame(frame, pos);
            return frame.net.ID.Value;
        }

        public void HandleRemove(BasePlayer player, string[] args)
        {
            BoxData boxData;
            FrameData frameData;

            if (!GetFrameBox(player, out boxData, out frameData))
            {
                return;
            }

            string[] framesToRemove = null;
            if (args.Length == 1)
            {
                if (frameData == null)
                {
                    Chat(player, LangKeys.NotLookingAtFrame);
                    return;
                }
                
                framesToRemove = new [] {frameData.Position};
            }
            else if(args.Length > 1)
            {
                framesToRemove = ParseFramePositions(player, boxData, args[1].ToLower());
            }

            if (framesToRemove == null)
            {
                return;
            }

            int removed = 0;
            foreach (string pos in framesToRemove)
            {
                if (boxData.RemoveFrame(pos, true))
                {
                    removed++;
                }
            }

            if (removed == 0)
            {
                Chat(player, LangKeys.NoFrameInPosition, args[1].ToLower());
                return;
            }
            
            if (_pluginConfig.RefundOnRemove)
            {
                foreach (KeyValuePair<string, int> cost in _pluginConfig.Cost)
                {
                    int amount = Mathf.FloorToInt(cost.Value * _pluginConfig.RefundPercentage * removed);
                    if (amount <= 0)
                    {
                        continue;
                    }

                    Item item = ItemManager.CreateByName(cost.Key, amount);
                    player.GiveItem(item);
                }
            }
            
            Chat(player, LangKeys.RemoveSuccess, args[1]);
            SaveData();
        }

        public void HandleCost(BasePlayer player)
        {
            StringBuilder sb = new StringBuilder(Lang(LangKeys.CostPre, player));

            foreach (KeyValuePair<string, int> item in _pluginConfig.Cost)
            {
                sb.AppendLine(Lang(LangKeys.Cost, player, ItemManager.FindItemDefinition(item.Key)?.displayName.translated, item.Value));
            }

            Chat(player, sb.ToString());
        }

        public void HandleUnlock(BasePlayer player, string[] args)
        {
            BuildingPrivlidge priv = player.GetBuildingPrivilege();
            if (priv != null && !priv.IsAuthed(player))
            {
                Chat(player, LangKeys.UnlockBuildingBlocked);
                return;
            }

            BoxData boxData;
            FrameData frameData;

            if (!GetFrameBox(player, out boxData, out frameData))
            {
                return;
            }

            string[] framesToUnlock = null;
            if (args.Length == 1)
            {
                if (frameData == null)
                {
                    Chat(player, LangKeys.NotLookingAtFrame);
                    return;
                }
                
                framesToUnlock = new [] {frameData.Position};
            }
            else if(args.Length > 1)
            {
                framesToUnlock = ParseFramePositions(player, boxData, args[1].ToLower());
            }

            if (framesToUnlock == null)
            {
                return;
            }

            int unlocked = 0;
            foreach (string frame in framesToUnlock)
            {
                if (boxData.GetFrame(frame)?.Unlock(player) ?? false)
                {
                    unlocked++;
                }
            }

            if (unlocked == 0)
            {
                Chat(player, LangKeys.NoUnlockPermission);
                return;
            }
            

            Chat(player, LangKeys.UnlockSuccess);
        }

        private bool GetFrameBox(BasePlayer player, out BoxData boxData, out FrameData frameData)
        {
            boxData = null;
            frameData = null;

            BaseCombatEntity box = Raycast<IItemContainerEntity>(player) as BaseCombatEntity;
            if (box == null)
            {
                Chat(player, LangKeys.NotLookingAt);
                return false;
            }

            if (box is PhotoFrame)
            {
                frameData = _frames[box.net.ID];
                if (frameData == null)
                {
                    Chat(player, LangKeys.NotLookingAtFrameBoxFrame);
                    return false;
                }

                boxData = frameData.BoxData;
            }
            else
            {
                boxData = _boxes[box.net.ID];
                if (boxData == null)
                {
                    Chat(player, LangKeys.NotLookingAtFrameBox);
                    return false;
                }
            }

            return true;
        }

        public string[] ParseFramePositions(BasePlayer player, BoxData box, string pos)
        {
            if (pos.Equals(Lang(LangKeys.AllSubOption, player)))
            {
                return box.GetTakenFramePositions();
            }
            
            FrameData frameData = box.GetFrame(pos);
            if (frameData == null)
            {
                Chat(player, LangKeys.NoFrameInPosition, pos);
                return null;
            }

            return new []{pos};
        }
        #endregion

        #region Hooks
        private object CanLootEntity(BasePlayer player, PhotoFrame frame)
        {
            if (frame == null || !frame.IsLocked())
            {
                return null;
            }

            IItemContainerEntity box = _frames[frame.net.ID]?.BoxData.Box as IItemContainerEntity;
            if (box == null)
            {
                return null;
            }

            box.PlayerOpenLoot(player);
            return true;
        }

        private void OnEntityKill(BoxStorage box)
        {
            if (box == null)
            {
                PrintError($"Box is null???\n{Environment.StackTrace}");
            }
            
            _boxes[box.net.ID]?.OnKilled();
        }

        private void OnEntityKill(PhotoFrame frame)
        {
            if (frame == null)
            {
                PrintError($"frame is null???\n{Environment.StackTrace}");
            }
            
            _frames[frame.net.ID]?.OnKilled();
        }

        private void OnSignLocked(PhotoFrame frame, BasePlayer player)
        {
            FrameData frameData = _frames[frame.net.ID];
            if (frameData == null)
            {
                return;
            }

            frame.OwnerID = 0;
        }
        #endregion

        #region Sign Artist Hooks
        private object GetImageRotation(PhotoFrame frame)
        {
            if (!_frames.ContainsKey(frame.net.ID))
            {
                return null;
            }

            return RotateFlipType.Rotate270FlipNone;
        }
        #endregion

        #region Magic Remove Hooks
        private Hash<string, int> GetRemoveAdditionalRefund(BoxStorage entity, Hash<string, int> refund)
        {
            BoxData box = _boxes[entity.net.ID];
            if (box == null)
            {
                return null;
            }

            int frameCount = box.GetFrameCount();
            foreach (KeyValuePair<string, int> item in _pluginConfig.Cost)
            {
                int amount = Mathf.FloorToInt(item.Value * frameCount * _pluginConfig.RefundPercentage);
                if (amount == 0)
                {
                    continue;
                }

                refund[item.Key] += amount;
            }

            return refund;
        }
        #endregion

        #region Handle Paying
        public bool CanAfford(BasePlayer player, Hash<string, int> cost, int multiplier)
        {
            bool canAfford = true;
            StringBuilder missingItems = new StringBuilder();
            foreach (KeyValuePair<string, int> item in cost)
            {
                ItemDefinition def = ItemManager.FindItemDefinition(item.Key);
                int amount = player.inventory.GetAmount(def.itemid);
                if (amount < item.Value * multiplier)
                {
                    string itemName = ItemManager.FindItemDefinition(item.Key).displayName.english;
                    missingItems.AppendLine(Lang(LangKeys.MissingItem, player, itemName,
                        item.Value * multiplier - amount));
                    canAfford = false;
                }
            }

            if (!canAfford)
            {
                Chat(player, Lang(LangKeys.MissingMessage, player, missingItems));
                return false;
            }

            TakeCost(player, cost, multiplier);

            return true;
        }

        public void TakeCost(BasePlayer player, Hash<string, int> cost, int multiplier)
        {
            List<Item> items = Pool.GetList<Item>();
            foreach (KeyValuePair<string, int> item in cost)
            {
                ItemDefinition def = ItemManager.FindItemDefinition(item.Key);
                player.inventory.Take(items, def.itemid, item.Value * multiplier);
                player.Command("note.inv", def.itemid, -item.Value * multiplier);
            }

            foreach (Item item in items)
            {
                item.Remove();
            }

            Pool.FreeList(ref items);
        }
        #endregion

        #region Helper Methods
        public string GetShortPrefabName(string shortname)
        {
            ItemDefinition def = ItemManager.FindItemDefinition(shortname);
            if (def == null)
            {
                PrintWarning($"{shortname} is not a valid item shortname!");
                return null;
            }

            string prefabName = def.GetComponent<ItemModDeployable>()?.entityPrefab.Get().GetComponent<BaseEntity>()
                .ShortPrefabName;
            if (string.IsNullOrEmpty(prefabName))
            {
                PrintWarning($"{shortname} does not contain a deployable item and cannot be used");
                return null;
            }

            return prefabName;
        }

        public string GetPrefabName(string shortname)
        {
            ItemDefinition def = ItemManager.FindItemDefinition(shortname);
            if (def == null)
            {
                PrintWarning($"{shortname} is not a valid item shortname!");
                return null;
            }

            string prefabName = def.GetComponent<ItemModDeployable>()?.entityPrefab.Get().GetComponent<BaseEntity>()
                .PrefabName;
            if (string.IsNullOrEmpty(prefabName))
            {
                PrintWarning($"{shortname} does not contain a deployable item and cannot be used");
                return null;
            }

            return prefabName;
        }

        public T Raycast<T>(BasePlayer player) where T : class
        {
            RaycastHit[] hits = Physics.RaycastAll(player.eyes.HeadRay(), _pluginConfig.MaxDistance);
            GamePhysics.Sort(hits);
            foreach (RaycastHit hit in hits)
            {
                BaseEntity entity = hit.GetEntity();
                if (entity == null)
                {
                    continue;
                }

                T type = entity as T;
                if (type == null)
                {
                    continue;
                }

                if (Vector3.Distance(player.eyes.position, entity.transform.position) > _pluginConfig.MaxDistance + 3)
                {
                    continue;
                }

                return type;
            }

            return default(T);
        }

        public void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);

        public void Chat(BasePlayer player, string key, params object[] args) =>
            PrintToChat(player, Lang(LangKeys.Chat, player, Lang(key, player, args)));

        public string Lang(string key, BasePlayer player = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, player?.UserIDString), args);
            }
            catch (Exception ex)
            {
                PrintError($"Lang Key '{key}' threw exception:\n{ex}");
                throw;
            }
        }

        public bool HasPermission(BasePlayer player, string perm) =>
            permission.UserHasPermission(player.UserIDString, perm);
        #endregion

        #region Data Classes
        public class FrameData
        {
            public PhotoFrame Frame { get; }
            public BoxData BoxData { get; }
            public string Position { get; }

            public FrameData(PhotoFrame frame, BoxData boxData, string position)
            {
                Frame = frame;
                BoxData = boxData;
                Position = position;
                DestroyGroundWatch(Frame);
                _ins._frames[frame.net.ID] = this;
            }

            public bool Unlock(BasePlayer player)
            {
                if (Frame.OwnerID != 0 && !Frame.CanUnlockSign(player))
                {
                    return false;
                }

                Frame.SetFlag(BaseEntity.Flags.Locked, false);
                Frame.SendNetworkUpdate();
                return true;
            }

            private void DestroyGroundWatch(BaseEntity entity)
            {
                DestroyOnGroundMissing missing = entity.GetComponent<DestroyOnGroundMissing>();
                if (missing != null)
                {
                    GameObject.Destroy(missing);
                }

                GroundWatch watch = entity.GetComponent<GroundWatch>();
                if (watch != null)
                {
                    GameObject.Destroy(watch);
                }
            }

            public void OnKilled()
            {
                BoxData.RemoveFrame(Position, false);
            }

            public void RemoveFrame(bool kill)
            {
                _ins._frames.Remove(Frame.net.ID);
                _ins._storedData.FrameData.Remove(Frame.net.ID.Value);
                if (kill)
                {
                    Frame.Kill();
                }
            }
        }

        public class BoxData
        {
            public BaseCombatEntity Box { get; }
            private Hash<string, FrameData> BoxFrames { get; }

            public BoxData(BaseCombatEntity box)
            {
                Box = box;
                BoxFrames = new Hash<string, FrameData>();
                _ins._boxes[Box.net.ID] = this;
            }

            public FrameData GetFrame(string position)
            {
                return BoxFrames[position];
            }

            public bool AddFrame(PhotoFrame frame, string position)
            {
                if (IsSlotTaken(position))
                {
                    return false;
                }

                BoxFrames[position] = new FrameData(frame, this, position);
                return true;
            }

            public bool RemoveFrame(string position, bool kill)
            {
                FrameData frame = BoxFrames[position];
                if (frame == null)
                {
                    return false;
                }

                frame.RemoveFrame(kill);
                BoxFrames.Remove(position);
                
                Hash<string, ulong> data = _ins._storedData.FrameData[Box.net.ID.Value];
                if (data != null)
                {
                    data.Remove(position);
                    if (data.Count == 0)
                    {
                        _ins._storedData.FrameData.Remove(Box.net.ID.Value);
                        _ins._boxes.Remove(Box.net.ID);
                    }
                }
                
                return true;
            }

            public bool IsSlotTaken(string position)
            {
                return BoxFrames.ContainsKey(position);
            }

            public string[] GetOpenPositions(bool allOnly)
            {
                return _ins._containerPositions[Box.ShortPrefabName].PositionData
                    .Where(fp => !BoxFrames.ContainsKey(fp.Key) && (!allOnly || fp.Value.IncludeAll))
                    .Select(fp => fp.Value.DisplayName)
                    .ToArray();
            }

            public string[] GetTakenFramePositions()
            {
                return BoxFrames.Keys.ToArray();
            }

            public int GetFrameCount()
            {
                return BoxFrames.Count;
            }

            public void OnKilled()
            {
                foreach (string frame in BoxFrames.Keys.ToList())
                {
                    RemoveFrame(frame, true);
                }

                _ins._boxes.Remove(Box.net.ID);
                _ins._storedData.FrameData.Remove(Box.net.ID.Value);
            }
        }
        #endregion

        #region Admin Behavior
        //Players with Admin or Developer flag can always edit signs. We use this to open box for them.
        public class AdminBoxBehavior : FacepunchBehaviour
        {
            private BasePlayer Player { get; set; }
            private bool IsDown { get; set; }

            private void Awake()
            {
                Player = GetComponent<BasePlayer>();
            }

            private void Update()
            {
                if (Player.inventory.loot.IsLooting())
                {
                    return;
                }

                bool isDown = Player.serverInput.IsDown(BUTTON.USE);
                if (isDown == IsDown)
                {
                    return;
                }

                IsDown = isDown;
                if (!IsDown)
                {
                    return;
                }

                PhotoFrame frame = _ins.Raycast<PhotoFrame>(Player);
                if (frame == null || !frame.IsLocked())
                {
                    return;
                }

                FrameData frameData = _ins._frames[frame.net.ID];
                if (frameData == null)
                {
                    return;
                }

                StartCoroutine(OpenBox(frame, frameData.BoxData.Box as IItemContainerEntity));
            }

            //Needed because we need to be sure the sign is destroyed on the client before we try to open the box
            private IEnumerator OpenBox(PhotoFrame frame, IItemContainerEntity box)
            {
                frame.DestroyOnClient(Player.Connection);
                yield return null;
                yield return null;

                box?.PlayerOpenLoot(Player);

                yield return new WaitForSeconds(0.05f);

                frame.SendNetworkUpdate();
            }

            public void DoDestroy()
            {
                Destroy(this);
            }
        }
        #endregion

        #region Classes
        public class PluginConfig
        {
            [DefaultValue("fb")]
            [JsonProperty(PropertyName = "Chat Command")]
            public string ChatCommand { get; set; }

            [DefaultValue(true)]
            [JsonProperty(PropertyName = "Refund on remove")]
            public bool RefundOnRemove { get; set; }

            [DefaultValue(1f)]
            [JsonProperty(PropertyName = "Refund % (0 none - 1 max)")]
            public float RefundPercentage { get; set; }

            [DefaultValue(5f)]
            [JsonProperty(PropertyName = "Max distance (Meters)")]
            public float MaxDistance { get; set; }

            [JsonProperty(PropertyName = "Cost")]
            public Hash<string, int> Cost { get; set; }

            [JsonProperty(PropertyName = "Sign Positions")]
            public Hash<string, ContainerData> SignPositions { get; set; }
        }

        public class StoredData
        {
            public Hash<ulong, Hash<string, ulong>> FrameData = new Hash<ulong, Hash<string, ulong>>();
        }

        public class ContainerData
        {
            [JsonProperty(PropertyName = "Frame Item Shortname")]
            public string ItemShortname { get; set; }

            [JsonProperty(PropertyName = "Frame Positions")]
            public Hash<string, PositionData> PositionData { get; set; }
        }

        public class PositionData
        {
            [JsonConverter(typeof(Vector3Converter))]
            [JsonProperty(PropertyName = "Frame Position Offset")]
            public Vector3 Offset { get; set; }

            [JsonConverter(typeof(Vector3Converter))]
            [JsonProperty(PropertyName = "Frame Position Rotation")]
            public Vector3 Rotation { get; set; }

            [JsonProperty(PropertyName = "Include Position In All Option")]
            public bool IncludeAll { get; set; }

            [JsonIgnore]
            public string DisplayName { get; set; }
        }

        public class LangKeys
        {
            public const string Chat = nameof(Chat);
            public const string NoPermission = nameof(NoPermission);
            public const string HelpText = nameof(HelpText) + "_V1";
            public const string MissingItem = nameof(MissingItem);
            public const string MissingMessage = nameof(MissingMessage);
            public const string CostPre = nameof(CostPre) + "_V1";
            public const string Cost = nameof(Cost);
            public const string AddInvalidSyntax = nameof(AddInvalidSyntax) + "_V1";
            public const string InvalidAddFramePosition = nameof(InvalidAddFramePosition) + "_V1";
            public const string NotLookingAt = nameof(NotLookingAt);
            public const string AddSlotIsTaken = nameof(AddSlotIsTaken);
            public const string AddSuccess = nameof(AddSuccess);
            public const string RemoveSuccess = nameof(RemoveSuccess);
            public const string UnlockBuildingBlocked = nameof(UnlockBuildingBlocked);
            public const string UnlockSuccess = nameof(UnlockSuccess);
            public const string NotLookingAtFrame = nameof(NotLookingAtFrame);
            public const string NotLookingAtFrameBoxFrame = nameof(NotLookingAtFrameBoxFrame);
            public const string NotLookingAtFrameBox = nameof(NotLookingAtFrameBox);
            public const string NoFrameInPosition = nameof(NoFrameInPosition);
            public const string ContainerNotAllowed = nameof(ContainerNotAllowed) + "_V1";
            public const string NoUnlockPermission = nameof(NoUnlockPermission);
            public const string AddSubCommand = nameof(AddSubCommand);
            public const string RemoveSubCommand = nameof(RemoveSubCommand);
            public const string CostSubCommand = nameof(CostSubCommand);
            public const string UnlockSubCommand = nameof(UnlockSubCommand);
            public const string AllSubOption = nameof(AllSubOption);
        }
        #endregion

        #region JSON Converters
        public class Vector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                Vector3 pos = (Vector3) value;
                writer.WriteValue($"{pos.x} {pos.y} {pos.z}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue,
                JsonSerializer serializer)
            {
                string[] values = reader.Value.ToString().Trim().Split(' ');
                return new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]),
                    Convert.ToSingle(values[2]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        }
        #endregion
    }
}

// --- End of file: FrameBox.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/firework-logging ---
// --- Original File Path: F/FireWorkLogging/FireWorkLogging.cs ---

﻿using Newtonsoft.Json;
using System.Collections.Generic;
namespace Oxide.Plugins
{
    //https://discord.com/api/oauth2/authorize?client_id=923264306143985724&permissions=8&scope=bot%20applications.commands
    [Info("Firework Logging", "mrcameron999", "1.0.2")]
    [Description("Logs pattern fireworks to a discord bot")]
    public class FireWorkLogging : CovalencePlugin
    {
        private string connection = "https://fireworklogger.gameservertools.com/";

        private float timeout = 1000f;
        private string serverName = string.Empty;
        private Dictionary<string, string> headers = new Dictionary<string, string>(){};

        private void Init()
        {
            LoadConfigData();
        }

        private void LoadConfigData()
        {
            string guildId = Config["GuildId"].ToString();
            string password = Config["Password"].ToString();
            serverName = Config["ServerName"].ToString();

            headers.Add("Content-Type", "application/json");
            headers.Add("GuildId", guildId);
            headers.Add("Password", password);
        }
        protected override void LoadDefaultConfig()
        {
            Config["GuildId"] = 123456789123456789;
            Config["Password"] = "Get your password from the discord bot";
            Config["ServerName"] = "Your Server Name";
        }
        object OnEntityFlagsNetworkUpdate(PatternFirework entity)
        {
            if (!entity.IsOn() || entity.Design == null || entity.Design.stars == null) { return null; }

            List<FireworkPoint> points = new List<FireworkPoint>();

            foreach (ProtoBuf.PatternFirework.Star item in entity.Design.stars)
            {
                points.Add(new FireworkPoint() {x = item.position.x,y = item.position.y, colora = (int)(255.0f * item.color.a), colorr = (int)(255.0f * item.color.r),colorb = (int)(255.0f * item.color.b), colorg = (int)(255.0f * item.color.g) });
            }
            
            Dictionary<string, object> parameters = new Dictionary<string, object>();

            parameters.Add("userId", entity.OwnerID);
            parameters.Add("serverName", serverName);
            parameters.Add("points", points);

            string body = JsonConvert.SerializeObject(parameters);

            try
            {
                webrequest.Enqueue($"{connection}api/Rust/FireWork", body, (code, response) =>
                {
                }, this, Core.Libraries.RequestMethod.POST, headers, timeout);
            }
            catch (System.Exception e)
            {
                UnityEngine.Debug.LogError($"FireWorkLog failed {e}");
            }
            
            return null;
        }

        public class FireworkPoint
        {
            public float x { get; set; }
            public float y { get; set; }
            public int colora { get; set; }
            public int colorr { get; set; }
            public int colorg { get; set; }
            public int colorb { get; set; }
        }
    }
}


// --- End of file: FireWorkLogging.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/friendly-nature ---
// --- Original File Path: F/FriendlyNature/FriendlyNature.cs ---

﻿namespace Oxide.Plugins
{
    [Info("Friendly Nature", "Bruno Puccio", "1.0.1")]
    [Description("Stop animals from eating each other")]
    public class FriendlyNature : RustPlugin
    {
        object OnNpcTarget(BaseNpc npc, BaseEntity target)
        {
            if ((target as BaseNpc) == null || (target is NPCPlayer))
                return null;

            return false;
        }
    }
}

// --- End of file: FriendlyNature.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/fresh-start ---
// --- Original File Path: F/FreshStart/FreshStart.cs ---

﻿using System.Collections.Generic;
using Newtonsoft.Json;
using System;
using System.Linq;
using System.Collections;

namespace Oxide.Plugins
{
	[Info("FreshStart", "Yoshi", "1.1.1")]
	[Description("Removes all entities when killed by another player")]
	//shoutout to Vice for cleaning up the plugin

	class FreshStart : RustPlugin
	{
		private const string PermissionName = "freshstart.excluded";


		#region config
		private Configuration config;
		public class Configuration
		{
			[JsonProperty(PropertyName = "remove corpses on death (true/false)")]
			public bool NoCorpses = false;

			[JsonProperty(PropertyName = "kill everything belonging to the player (true/false)")]
			public bool KillAllEntitiesOnDeath = true;

			[JsonProperty(PropertyName = "only run if the player is killed by another player (true/false)")]
			public bool LimitToPVPDeath = true;

			[JsonProperty(PropertyName = "wipes all their boxes on death (true/false)")]
			public bool DespawnLoot = true;

		}

		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				config = Config.ReadObject<Configuration>();
				if (config == null) throw new Exception();
				SaveConfig();
			}
			catch
			{
				PrintError("Your configuration file contains an error. Using default configuration values.");
				LoadDefaultConfig();
			}
		}

		protected override void SaveConfig() => Config.WriteObject(config);

		protected override void LoadDefaultConfig() => config = new Configuration();

		#endregion

		#region Hooks
		void Init()
		{
			permission.RegisterPermission(PermissionName, this);
		}

		object OnPlayerDeath(BasePlayer player, HitInfo info)
		{
			if (player.IPlayer.HasPermission(PermissionName)) return null;

			if (config.LimitToPVPDeath && !(info.Initiator is BasePlayer) || info.InitiatorPlayer.userID == player.userID)
				return null;


			ServerMgr.Instance.StartCoroutine(ClearEntities(player));


			return null;
		}

		public IEnumerator ClearEntities(BasePlayer player)
		{
			int batch = 0;
			foreach (var ent in BaseNetworkable.serverEntities.Where(x => (x as BaseEntity).OwnerID == player.userID).ToList())
			{
				if (config.DespawnLoot)
				{
					if (ent is StorageContainer)
					{
						var container = ent.GetComponent<StorageContainer>();

						container.inventory.Clear();
					}
				}

				if (config.KillAllEntitiesOnDeath)
				{
					ent.Kill();
				}


				if (++batch % 20 == 0)
				{
					yield return null;
				}
			}

		}


		void OnEntitySpawned(PlayerCorpse entity)
		{
			if (!config.NoCorpses) return;
			entity.Kill();
		}
		#endregion
	}
}

// --- End of file: FreshStart.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/free-rt ---
// --- Original File Path: F/FreeRT/FreeRT.cs ---

﻿/*
*  < ----- End-User License Agreement ----->
*  
*  You may not copy, modify, merge, publish, distribute, sublicense, or sell copies of this software without the developer’s consent.
*
*  THIS SOFTWARE IS PROVIDED BY IIIaKa AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
*  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
*  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
*  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*  Developer: IIIaKa
*      https://t.me/iiiaka
*      Discord: @iiiaka
*      https://github.com/IIIaKa
*      https://umod.org/user/IIIaKa
*      https://codefling.com/iiiaka
*      https://lone.design/vendor/iiiaka/
*      https://www.patreon.com/iiiaka
*      https://boosty.to/iiiaka
*  GitHub repository page: https://github.com/IIIaKa/FreeRT
*  
*  uMod plugin page: https://umod.org/plugins/free-rt
*  uMod license: https://umod.org/plugins/free-rt#license
*  
*  Codefling plugin page: https://codefling.com/plugins/free-rt
*  Codefling license: https://codefling.com/plugins/free-rt?tab=downloads_field_4
*  
*  Lone.Design plugin page: https://lone.design/product/free-rt/
*
*  Copyright © 2020-2024 IIIaKa
*/

using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("Free RT", "IIIaKa", "0.1.8")]
	[Description("A simple plugin that allows players with permissions to open card-locked doors in Rad Towns without a card.")]
	class FreeRT : RustPlugin
	{
		#region ~Variables~
		private const string PERMISSION_ALL = "freert.all", PERMISSION_GREEN = "freert.green", PERMISSION_BLUE = "freert.blue", PERMISSION_RED = "freert.red", Str_MsgNotAllowed = "MsgNotAllowed";
		#endregion
		
		#region ~Configuration~
		private static Configuration _config;

		private class Configuration
		{
			[JsonProperty(PropertyName = "Is it worth showing messages to players who don't have permissions?")]
			public bool ShowMessage = true;
			
			[JsonProperty(PropertyName = "Time in seconds(1-10) after which the door will close(hinged doors only)")]
            public float CloseTime = 5f;
			
			public Oxide.Core.VersionNumber Version;
		}
		
		protected override void LoadConfig()
        {
            base.LoadConfig();
            try { _config = Config.ReadObject<Configuration>(); }
            catch (Exception ex) { PrintError($"{ex.Message}\n\n[{Title}] Your configuration file contains an error."); }
            if (_config == null || _config.Version == new VersionNumber())
            {
                PrintWarning("The configuration file is not found or contains errors. Creating a new one...");
                LoadDefaultConfig();
            }
            else if (_config.Version < Version)
            {
				PrintWarning($"Your configuration file version({_config.Version}) is outdated. Updating it to {Version}.");
				_config.Version = Version;
				PrintWarning($"The configuration file has been successfully updated to version {_config.Version}!");
            }
			
			_config.CloseTime = Mathf.Clamp(_config.CloseTime, 1f, 10f);
			
			SaveConfig();
        }
		
		protected override void SaveConfig() => Config.WriteObject(_config);
		protected override void LoadDefaultConfig() => _config = new Configuration() { Version = Version };
		#endregion

		#region ~Language~
		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["MsgNotAllowed"] = "You do not have permission to open this door without the card!"
			}, this);
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["MsgNotAllowed"] = "У вас недостаточно прав для открытия этой двери без карточки!"
			}, this, "ru");
		}
        #endregion

        #region ~Methods~
		private bool TryOpenDoor(CardReader cardReader, BasePlayer player, Door door = null)
        {
			bool canOpen = false;
			if (permission.UserHasPermission(player.UserIDString, PERMISSION_ALL))
				canOpen = true;
            else
            {
                switch (cardReader.accessLevel)
                {
                    case 1:
                        if (permission.UserHasPermission(player.UserIDString, PERMISSION_GREEN))
                            canOpen = true;
                        break;
                    case 2:
                        if (permission.UserHasPermission(player.UserIDString, PERMISSION_BLUE))
                            canOpen = true;
                        break;
                    case 3:
                        if (permission.UserHasPermission(player.UserIDString, PERMISSION_RED))
                            canOpen = true;
                        break;
                    default:
                        break;
                }
            }

            if (canOpen)
			{
				if (door == null)
					cardReader.GrantCard();
				else
                {
					door.SetFlag(BaseEntity.Flags.Open, true);
                    timer.Once(_config.CloseTime, () =>
					{
						if (door != null && (cardReader == null || !cardReader.HasFlag(BaseEntity.Flags.On)))
							door.SetFlag(BaseEntity.Flags.Open, false);
					});
				}
			}
            else if (_config.ShowMessage)
                player.ChatMessage(lang.GetMessage(Str_MsgNotAllowed, this, player.UserIDString));
			return canOpen;
        }
		#endregion

		#region ~Oxide Hooks~
		void OnDoorKnocked(Door door, BasePlayer player)
		{
			if (door.isSecurityDoor && !door.IsOpen())
			{
				var crList = Pool.Get<List<CardReader>>();
				Vis.Entities(door.transform.position, 6f, crList);
				if (crList.Any())
					TryOpenDoor(crList[0], player, door);
				Pool.FreeUnmanaged(ref crList);
			}
		}
		
		void OnSwitchToggled(ElectricSwitch electricSwitch, BasePlayer player)
        {
			var crList = Pool.Get<List<CardReader>>();
            Vis.Entities(electricSwitch.transform.position, 2f, crList);
            if (crList.Any())
                TryOpenDoor(crList[0], player);
            Pool.FreeUnmanaged(ref crList);
        }
		
		void OnButtonPress(PressButton button, BasePlayer player)
        {
			CardReader cardReader;
			foreach (var input in button.inputs)
            {
				cardReader = input.connectedTo?.ioEnt as CardReader;
				if (cardReader != null)
				{
					TryOpenDoor(cardReader, player);
					break;
				}
			}
		}
		
		void Init()
        {
			Unsubscribe(nameof(OnDoorKnocked));
			Unsubscribe(nameof(OnSwitchToggled));
			Unsubscribe(nameof(OnButtonPress));
			permission.RegisterPermission(PERMISSION_ALL, this);
            permission.RegisterPermission(PERMISSION_GREEN, this);
            permission.RegisterPermission(PERMISSION_BLUE, this);
            permission.RegisterPermission(PERMISSION_RED, this);
		}
		
		void OnServerInitialized(bool initial)
		{
			Subscribe(nameof(OnDoorKnocked));
			Subscribe(nameof(OnSwitchToggled));
			Subscribe(nameof(OnButtonPress));
		}
		#endregion

		#region ~Unload~
		void Unload()
		{
			_config = null;
		}
		#endregion
	}
}

// --- End of file: FreeRT.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/f1-server-console-log ---
// --- Original File Path: F/F1ServerConsoleLog/F1ServerConsoleLog.cs ---

﻿using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("F1 Server Console Log", "NooBlet", "0.1.7")]
    [Description("Logs Server Console to F1 Console")]
    public class F1ServerConsoleLog : CovalencePlugin
    {
        List<BasePlayer> playerWithPerm = new List<BasePlayer>();
        string perm = "F1ServerConsoleLog.log";

        #region Hooks
        private void OnServerInitialized()
        {
            permission.RegisterPermission(perm, this);           
            LoadConfiguration();           
        }

        private void Loaded()
        {
            UnityEngine.Application.logMessageReceived += ConsoleLog;
            playerWithPerm.Clear();
        }
        private void Unload()
        { 
            UnityEngine.Application.logMessageReceived -= ConsoleLog;
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (!playerWithPerm.Contains(player))
            {
                if (permission.UserHasPermission(player.UserIDString, perm))
                {
                    playerWithPerm.Add(player);
                }
            }
           
        }
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (playerWithPerm.Contains(player))
            {
                playerWithPerm.Remove(player);
            }
        }
        private void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!playerWithPerm.Contains(player))
            {
                if (permission.UserHasPermission(player.UserIDString, perm))
                {
                    playerWithPerm.Add(player);
                }
            }
        }


        private void ConsoleLog(string condition, string stackTrace, LogType type)
        {
            if (!string.IsNullOrEmpty(condition))
            {
                if (exclude(condition)) { return; }
                sendtoF1(condition);
            }
        }
        #endregion

        #region Cached Variables

        private string TimeString = "HH:mm:ss";
        private List<object> excludestrings = new List<object> 
        {
            "Kinematic",
            "NullReferenceException: Object reference not set to an instance of an object",
            "Invalid NavAgent Position",
            "Invalid Position",
        };

        #endregion

        #region Config

        protected override void LoadDefaultConfig()
        {
            LogWarning("Creating a new configuration file");
        }
        private void LoadConfiguration()
        {
           
            CheckCfg<string>("DateTime string format output", ref TimeString);
            CheckCfg<List<object>>("Strings to exclude from console log", ref excludestrings);

            SaveConfig();
        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }



        #endregion config       

        #region Methods

        private string GetLang(string key, string id) => lang.GetMessage(key, this, id);

        void sendtoF1(string log)
        {
            foreach (var p in playerWithPerm)
            {
               if(p == null) { continue; }
                p.ConsoleMessage($"({DateTime.Now.ToString(TimeString)}) <size=16>{log}</size>");
            }
        }

        bool exclude(string msg)
        {
            foreach(var s in excludestrings)
            {
                if (msg.Contains(s.ToString()))
                {
                    return true;
                }
            }
            return false;
        }
        #endregion

        #region Commands

        [Command("console")]
        private void consoleCommand(IPlayer iplayer, string command, string[] args)
        {
            if (!permission.UserHasPermission(iplayer.Id,perm)) { iplayer.Reply("You dont have permission for this command!"); return; }
            BasePlayer player = iplayer.Object as BasePlayer;
            if(args.Length < 0) { player.ChatMessage(string.Format(GetLang("OnOROff", player.UserIDString)));return; }
            if (args.Length > 1) { player.ChatMessage(string.Format(GetLang("ToManyArgs", player.UserIDString))); return; }
            if(args[0] == "on")
            {
                if (!playerWithPerm.Contains(player))
                {
                    playerWithPerm.Add(player);
                    player.ChatMessage(string.Format(GetLang("ConsoleOn", player.UserIDString)));
                }
            }
            if(args[0] == "off")
            {
                if (playerWithPerm.Remove(player)) 
                {
                    player.ChatMessage(string.Format(GetLang("ConsoleOff", player.UserIDString)));
                }
            }

            if (args[0] == "test")
            {
                if (playerWithPerm.Contains(player))
                {
                    player.ChatMessage("Player in console recieve list");
                }
                else
                {
                    player.ChatMessage("Player not in console recieve list");
                }
            }
        }

        #endregion Commands

        #region Lang API

        private void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["OnOROff"] = "Please input Console State (on or off)",
                ["ToManyArgs"] = "To much Info Added , Please use /console on   or    /console off",
                ["ConsoleOn"] ="Console turned on!",
                ["ConsoleOff"] = "Console turned off!",

            }, this, "en");
        }

        #endregion Lang API
    }
}


// --- End of file: F1ServerConsoleLog.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/force-join-team ---
// --- Original File Path: F/ForceJoinTeam/ForceJoinTeam.cs ---

﻿using System;
using System.Linq; 
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Force Join Team", "Akkariin", "1.0.2")]
    [Description("Force join a team")]
    public class ForceJoinTeam : RustPlugin
    {
        #region Variables
        private const string Perm = "forcejointeam.use";
        #endregion

        #region Hooks
        private void Init()
        {
            permission.RegisterPermission(Perm, this);
        }
		
        // Command for force joining a team
		[ChatCommand("forcejoin")]
        private void ForceJoinTeamCommand(BasePlayer player, string command, string[] args)
        {
			if (!permission.UserHasPermission(player.UserIDString, Perm) && !player.IsAdmin)
            {
                SendReply(player, FormatMessage("NoPermissionMsg", player));
                return;
            }

            if (args.Length == 0)
            {
                SendReply(player, FormatMessage("InvalidArgsMsg", player));
                return;
            }

            BasePlayer target = FindPlayerByName(args[0]);

            if (target == null)
            {
                SendReply(player, FormatMessage("PlayerNotFoundMsg", player));
                return;
            }

            if (target.currentTeam == 0)
            {
                SendReply(player, FormatMessage("PlayerNotInTeamMsg", player));
                return;
            }

            if (player.currentTeam == target.currentTeam)
            {
                SendReply(player, FormatMessage("AlreadyInTeamMsg", player));
                return;
            }

            // player.currentTeam = target.currentTeam;
            var team = RelationshipManager.ServerInstance.FindTeam(target.currentTeam);
            if (team == null)
            {
                SendReply(player, FormatMessage("PlayerNotInTeamMsg", player));
                return;
            }
            team.AddPlayer(player);
            SendReply(player, string.Format(FormatMessage("JoinSuccessfulMsg", player), target.displayName));
		}
        #endregion

        #region Helpers
        private BasePlayer FindPlayerByName(string keyword)
        {
            foreach (var player in BasePlayer.allPlayerList)
            {
                if (player == null || string.IsNullOrEmpty(player.displayName))
                {
                    continue;
                }

                if (player.UserIDString == keyword || player.displayName.IndexOf(keyword, StringComparison.OrdinalIgnoreCase) >= 0)
                {
                    return player;
                }
            }
            return null;
        }

        private String FormatMessage(string message, BasePlayer player)
        {
            String prefix = lang.GetMessage("MessagePrefix", this, player.UserIDString);
            return String.Format("{0} {1}", prefix, lang.GetMessage(message, this, player.UserIDString));
        }
        #endregion

        #region Language

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string,string>
            {
                {"MessagePrefix", "<color=#00FFFF>[ForceJoinTeam]</color>"},
                {"JoinSuccessfulMsg", "You have successfully joined the team of player {0}"},
                {"PlayerNotInTeamMsg", "This player does not have a team"},
                {"AlreadyInTeamMsg", "You are already in the same team as the player"},
                {"PlayerNotFoundMsg", "Cannot find this player, please check the name"},
                {"NoPermissionMsg", "You have no permission to use this command."},
                {"InvalidArgsMsg", "Invalid args, using /forcejoin <Name | SteamID>"}
            }, this);
        }
        #endregion
    }
}


// --- End of file: ForceJoinTeam.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/fireworks-monitor ---
// --- Original File Path: F/FireworksMonitor/FireworksMonitor.cs ---

﻿// ReSharper disable CheckNamespace

using System;
using System.Collections;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using UnityEngine;
using UnityEngine.Networking;

namespace Oxide.Plugins
{
    [Info( "Fireworks Monitor", "hoppel & Mr. Blue", "1.0.1" )]
    [Description( "Send a message to discord with an image of the firework pattern set by the user" )]
    public class FireworksMonitor : RustPlugin
    {
        #region Configuration

        private const string WEBHOOK_INTRO = "https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks";
        private static int? _embedColor;

        private class PluginConfiguration
        {
            [JsonProperty( "Discord Webhook" )] public string DiscordWebhook;
            [JsonProperty( "Embed Color" )] public string EmbedColor;
        }

        private PluginConfiguration _config;

        private void Init()
        {
            _config = Config.ReadObject<PluginConfiguration>();
            _embedColor = FromHex( _config.EmbedColor );

            if( _config.DiscordWebhook == WEBHOOK_INTRO )
            {
                PrintWarning( $"Please set the discord webhook in the configuration file! ({WEBHOOK_INTRO})" );
                Unsubscribe( nameof( OnFireworkDesignChanged ) );
            }
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject( GetDefaultConfig(), true );
        }

        private PluginConfiguration GetDefaultConfig()
        {
            return new PluginConfiguration
            {
                DiscordWebhook = WEBHOOK_INTRO,
                EmbedColor = "#54a8fc"
            };
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages( new Dictionary<string, string>
            {
                ["EmbedTitle"] = "Firework design changed or created!",
                ["EmbedBody"] = "**Player:**\n{playerName}\n{playerId}\n[Steam Profile](https://steamcommunity.com/profiles/{playerId})\n\n**Firework owner:**\n{ownerName}\n{ownerId}\n[Steam Profile](https://steamcommunity.com/profiles/{ownerId})\n\n**Server:\n**{serverName}"
            }, this );
        }

        private string FormatMessage( string key, BasePlayer player, BasePlayer fireworkOwner )
        {
            return lang.GetMessage( key, this )
                .Replace( "{playerName}", player.displayName )
                .Replace( "{playerId}", player.UserIDString )
                .Replace( "{ownerName}", fireworkOwner.displayName )
                .Replace( "{ownerId}", fireworkOwner.UserIDString )
                .Replace( "{serverName}", covalence.Server.Name );
        }

        #endregion

        #region Firework Logic

        private static readonly Texture2D DrawingTexture = new Texture2D( 240, 240 );

        private void OnFireworkDesignChanged( PatternFirework entity, ProtoBuf.PatternFirework.Design design, BasePlayer player )
        {
            var stars = design?.stars;
            if( stars == null || stars.Count == 0 )
            {
                return;
            }

            DrawingTexture.Clear( Color.black );
            foreach( var star in stars )
            {
                var color = new Color( star.color.r, star.color.g, star.color.b );
                var scaledX = (int) ( ( star.position.x - -1 ) * 100 ) + 20;
                var scaledY = (int) ( ( star.position.y - -1 ) * 100 ) + 20;

                // Draw the points a bit bigger
                var xCondition = scaledX + 6;
                var yCondition = scaledY + 6;
                for( var x = scaledX - 3; x < xCondition; x++ )
                {
                    for( var y = scaledY - 3; y < yCondition; y++ )
                    {
                        DrawingTexture.SetPixel( x, y, color );
                    }
                }
            }

            var encodedPng = DrawingTexture.EncodeToPNG();

            SendDiscordEmbed( encodedPng, player, entity.OwnerID );
        }

        private void SendDiscordEmbed( byte[] image, BasePlayer player, ulong fireworkOwnerId )
        {
            var fireworkOwner = BasePlayer.FindByID( fireworkOwnerId );
            var title = FormatMessage( "EmbedTitle", player, fireworkOwner );
            var description = FormatMessage( "EmbedBody", player, fireworkOwner );

            var payload = new
            {
                embeds = new[]
                {
                    new
                    {
                        title,
                        description,
                        color = _embedColor,
                        image = new
                        {
                            url = "attachment://image.png"
                        },
                        timestamp = DateTime.Now
                    }
                }
            };

            var form = new WWWForm();
            form.AddBinaryData( "file", image, "image.png" );
            form.AddField( "payload_json", JsonConvert.SerializeObject( payload ) );

            ServerMgr.Instance.StartCoroutine( HandleUpload( _config.DiscordWebhook, form ) );
        }

        private IEnumerator HandleUpload( string url, WWWForm data )
        {
            var www = UnityWebRequest.Post( url, data );
            yield return www.SendWebRequest();

            if( www.isNetworkError || www.isHttpError )
            {
                Puts( $"Failed to post firework image to discord: {www.error}" );
            }
        }

        #endregion

        #region Helpers

        private static int? FromHex( string value )
        {
            var match = Regex.Match( value, "#?([0-9a-f]{6})" );
            if( !match.Success )
            {
                return null;
            }

            return int.Parse( match.Groups[1].Value, System.Globalization.NumberStyles.HexNumber );
        }

        #endregion
    }
}

// --- End of file: FireworksMonitor.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/fast-loot ---
// --- Original File Path: F/FastLoot/FastLoot.cs ---

﻿using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Fast Loot", "DezLife", "1.0.8")]
    [Description("Loot crates quickly")]
    class FastLoot : RustPlugin
    {
        #region Var
        private const string FastLootLayer = "UI_FastLootLayer";
        private const string perm = "fastloot.use";
        #endregion

        #region Config
        private Configuration config;

        private class Configuration
        {
            [JsonProperty("Color background")]
            public string colorBackground;
            [JsonProperty("Color font")]
            public string colorFont;
            [JsonProperty("Coordinates OffsetMin")]
            public string OffsetMin;
            [JsonProperty("Coordinates OffsetMax")]
            public string OffsetMax;
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                colorBackground = "0.968627453 0.921631568632 0.882352948 0.03529412",
                colorFont = "0.87 0.84 0.80 1.00",
                OffsetMin = "290 510",
                OffsetMax = "573 540"
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<Configuration>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        #endregion  

        #region Hook
        void OnLootEntity(BasePlayer player, LootContainer loot)
        {
            if (!permission.UserHasPermission(player.UserIDString, perm))
                return;
            loot.onlyOneUser = true;
            UIFastLoot(player);
        }
        private void OnLootEntityEnd(BasePlayer player, LootContainer entity) {
            CuiHelper.DestroyUi(player, FastLootLayer);
        } 
        private void Init() => permission.RegisterPermission(perm, this);
        void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, FastLootLayer);
        }

        #endregion

        #region Lang
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["FASTLOOT_TAKE"] = "Take all",

            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["FASTLOOT_TAKE"] = "Забрать все",

            }, this, "ru");
        }

        #endregion

        #region Command

        [ConsoleCommand("UI_FastLoot")]
        void FastLootCMD(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;
            if (!permission.UserHasPermission(player.UserIDString, perm))
                return;
            if (player.inventory?.loot?.entitySource is LootContainer)
            {
                StorageContainer loot = player.inventory?.loot?.entitySource as StorageContainer;
                if (loot != null)
                {
                    MoveAllInventoryItems(loot.inventory, player.inventory.containerMain);
                }
            }
            else
                CuiHelper.DestroyUi(player, FastLootLayer);

        }
        public static bool MoveAllInventoryItems(global::ItemContainer source, global::ItemContainer dest)
        {
            bool flag = true;
            for (int i = 0; i < Mathf.Min(source.capacity, dest.capacity); i++)
            {
                global::Item slot = source.GetSlot(i);
                if (slot != null)
                {
                    bool flag2 = slot.MoveToContainer(dest, -1, true, false);
                    if (flag && !flag2)
                    {
                        flag = false;
                    }
                }
            }
            return flag;
        }
        #endregion

        #region UI
        private void UIFastLoot(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, FastLootLayer);
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = config.OffsetMin, OffsetMax = config.OffsetMax },
                Image = { Color = config.colorBackground, Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
            }, "Overlay", FastLootLayer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0 0 0 0", Command = "UI_FastLoot" },
                Text = { Text = lang.GetMessage("FASTLOOT_TAKE", this, player.UserIDString),FontSize = 17, Align = TextAnchor.MiddleCenter, Color = config.colorFont }
            }, FastLootLayer);
            CuiHelper.AddUi(player, container);
        }
        #endregion
    }
}


// --- End of file: FastLoot.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/fridge-food ---
// --- Original File Path: F/FridgeFood/FridgeFood.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("FridgeFood", "sami37", "1.1.3")]
    [Description("Prevent food from being placed in box instead of fridge.")]
    public class FridgeFood : RustPlugin
    {
        [PluginReference] Plugin Backpacks;

        private List<object> listFood = new List<object>();
        private List<object> listContainer = new List<object>();
        List<object> defaultLists = new List<object>();

        private List<object> unallowedContainer = new List<object>
        {
            "box.wooden.large",
            "box.wooden",
            "coffin.storage",
            "small.stash",
            "locker",
            "smallbackpack",
            "largebackpack"
        };

        private List<ulong> AdminDebug = new List<ulong>();

        #region ConfigFunction
        string ListToString<T>(List<T> list, int first = 0, string seperator = ", ") => string.Join(seperator, (from val in list select val.ToString()).Skip(first).ToArray());
        void SetConfig(params object[] args) { List<string> stringArgs = (from arg in args select arg.ToString()).ToList(); stringArgs.RemoveAt(args.Length - 1); if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args); }
        T GetConfig<T>(T defaultVal, params object[] args) { List<string> stringArgs = (from arg in args select arg.ToString()).ToList(); if (Config.Get(stringArgs.ToArray()) == null) { PrintError($"The plugin failed to read something from the config: {ListToString(stringArgs, 0, "/")}{Environment.NewLine}Please reload the plugin and see if this message is still showing. If so, please post this into the support thread of this plugin."); return defaultVal; } return (T)System.Convert.ChangeType(Config.Get(stringArgs.ToArray()), typeof(T)); }
        #endregion

        private static BasePlayer GetPlayerFromContainer(ItemContainer container, Item item) =>
            item.GetOwnerPlayer() ??
            BasePlayer.activePlayerList.FirstOrDefault(
                p => p.inventory.loot.IsLooting() && p.inventory.loot.entitySource == container.entityOwner);

        private static ItemContainer GetRootContainer(Item item)
        {
            var container = item.parent;
            if (container == null)
                return null;

            while (container.parent?.parent != null && container.parent != item)
            {
                container = container.parent.parent;
            }

            return container;
        }

        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            var rootContainer = GetRootContainer(item) ?? container;
            var backpacksOwnerResult = Backpacks?.Call("API_GetBackpackOwnerId", rootContainer);
            if (backpacksOwnerResult is ulong && (ulong)backpacksOwnerResult > 0)
                return;

            if (container.parent?.parent != null && container.parent.parent.playerOwner != null)
            {
                var player = container.parent.parent.playerOwner;

                if (player != null)
                {
                    var name = container.parent.info.shortname.Replace("_deployed", "")
                        .Replace(".deployed", "")
                        .Replace("_", ".");

                    foreach (var cont in listContainer)
                    {
                        if (name == cont.ToString())
                        {
                            if (listFood.Contains(item.info.itemid) || listFood.Contains(item.info.shortname))
                            {
                                SendReply(player, lang.GetMessage("NotAllowedBackpack", this, player.UserIDString));
                                player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
                                break;
                            }
                        }
                    }

                    if (AdminDebug.Contains(player.userID))
                        SendReply(player, string.Format(lang.GetMessage("ContainerName", this, player.UserIDString), name));
                }
            }

            if (container.playerOwner != null && container.playerOwner.inventory != null)
            {
                return;
            }

            if (container.entityOwner != null)
            {
                var player = GetPlayerFromContainer(container, item);
                {
                    var name = container.entityOwner.ShortPrefabName.Replace("_deployed", "")
                        .Replace(".deployed", "")
                        .Replace("_", ".");

                    foreach (var cont in listContainer)
                    {
                        if (container.entityOwner.ShortPrefabName.Contains("coffin"))
                        {
                            if (listFood.Contains(item.info.itemid) || listFood.Contains(item.info.shortname))
                            {
                                if (player != null)
                                {
                                    SendReply(player, lang.GetMessage("NotAllowed", this, player.UserIDString));
                                    player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
                                }
                                else
                                {
                                    var dropPos = container.GetEntityOwner().ServerPosition;
                                    var newDrop = new Vector3(dropPos.x, dropPos.y + 1, dropPos.z);

                                    item.Drop(newDrop, Vector3.up);
                                }

                                break;
                            }
                        }
                        if (name == cont.ToString())
                        {
                            if (listFood.Contains(item.info.itemid) || listFood.Contains(item.info.shortname))
                            {
                                if (player != null)
                                {
                                    SendReply(player, lang.GetMessage("NotAllowed", this, player.UserIDString));
                                    player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
                                }
                                else
                                {
                                    var dropPos = container.GetEntityOwner().ServerPosition;
                                    var newDrop = new Vector3(dropPos.x, dropPos.y+1, dropPos.z);

                                    item.Drop(newDrop, Vector3.up);
                                }

                                break;
                            }
                        }
                    }

                    if (player != null)
                        if (AdminDebug.Contains(player.userID))
                        SendReply(player, string.Format(lang.GetMessage("ContainerName", this, player.UserIDString), name));
                }
            }
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();

            defaultLists = new List<object>(ItemManager.GetItemDefinitions().Where(itemDef => itemDef.category == ItemCategory.Food).Select(itemDef => itemDef.shortname).ToList());

            foreach (var item in defaultLists)
                if (!listFood.Contains(item))
                    listFood.Add(item);
            SetConfig("Food List", defaultLists);
            SetConfig("Unallowed container", unallowedContainer);
            SaveConfig();
        }

        private void OnServerInitialized()
        {
            listFood = GetConfig(defaultLists, "Food List");
            listContainer = GetConfig(unallowedContainer, "Unallowed container");

            SaveConfig();

            lang.RegisterMessages(
                new Dictionary<string, string>
                {
                    {"NotAllowed", "You are not allowed to put food in normal box."},
                    {"NotAllowedBackpack", "You are not allowed to put food in backpack."},
                    {"NoRight", "You don't have permission."},
                    {"Disabled", "Disabled debug system."},
                    {"Enabled", "Enabled debug system."},
                    {"ContainerName", "The name of this container is <color=red>{0}</color>."}
                },
                this);
        }

        [ChatCommand("fdebug")]
        void chatCommand(BasePlayer player, string cmd, string[] args)
        {
            if (player.IsAdmin)
            {
                if (AdminDebug != null)
                {
                    if (AdminDebug.Contains(player.userID))
                    {
                        AdminDebug.Remove(player.userID);
                        SendReply(player, lang.GetMessage("Disabled", this, player.UserIDString));
                    }
                    else
                    {
                        AdminDebug.Add(player.userID);
                        SendReply(player, lang.GetMessage("Enabled", this, player.UserIDString));
                    }
                }
            }
            else
            {
                SendReply(player, lang.GetMessage("NoRight", this, player.UserIDString));
            }
        }
    }
}

// --- End of file: FridgeFood.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/fancy-grenades ---
// --- Original File Path: F/FancyGrenades/FancyGrenades.cs ---

﻿using System;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using System.Linq;
using System.IO;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Fancy Grenades", "PaiN", "0.1.3")]
    [Description("Adds different types of grenades to the game.")]
    class FancyGrenades : RustPlugin
    {
        [PluginReference]
        private Plugin Economics, ServerRewards;

        const int GrenadeId = 143803535;
        private Configuration config;
        private ItemDefinition item;

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PURCHASE_SUCCESS"] = "You have successfully purchased a {0} for {1} {2}",
                ["GIVE_FREE"] = "You have been given a {0}",
                ["NO_PERMISSION"] = "You do not have permission to use this command!",
                ["PURCHASE_FAILED"] = "You do not have enough {0}! You are missing {1} {2}",
                ["INVENTORY_FULL"] = "Your inventory is full!"
            }, this);
        }

        private class Configuration
        {
            [JsonProperty("General Settings")]
            public GeneralSettings settings = new GeneralSettings();

            [JsonProperty("Flashbang Settings")]
            public FlashSettings flash = new FlashSettings();

            [JsonProperty("Molotov Settings")]
            public MollySettings molly = new MollySettings();

            [JsonProperty("Pay Settings")]
            public PaySettings pay = new PaySettings();

        }

        public class GeneralSettings
        {
            [JsonProperty("Purchase Flashbang Command")]
            public string flashCmd = "flash";

            [JsonProperty("Purchase Molotov Command")]
            public string mollyCmd = "molly";

            [JsonProperty("Message SteamID icon")]
            public ulong chatId = 0;
        }

        public class PaySettings
        {
            [JsonProperty("Cost Item (Scrap, ServerRewards, Economics)")]
            public string costItem = "Scrap";

            [JsonProperty("Cost Amount (Disable Cost = 0)")]
            public int costAmount = 100;
        }

        public class MollySettings
        {
            [JsonProperty("Molotov Grenade Name")]
            public string Name = "Incendiary Grenade";

            [JsonProperty("Molotov SkinId")]
            public ulong SkinId = 856483901;
        }

        public class FlashSettings
        {
            [JsonProperty("Flashbang Grenade Name")]
            public string Name = "Stun Grenade";

            [JsonProperty("Flashbang SkinId")]
            public ulong SkinId = 815540662;

            [JsonProperty("Flashbang Range")]
            public int Range = 20;

            [JsonProperty("Flashbang Duration")]
            public float Duration = 2f;

            [JsonProperty("Disable flashing players who are not facing the grenade")]
            public bool NoFlashRule = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            string configPath = $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Name}.json";
            PrintWarning($"Could not load a valid configuration file, creating a new configuration file at {configPath}");
            config = new Configuration();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        void Loaded()
        {
            permission.RegisterPermission("fancygrenades.useflash", this);
            permission.RegisterPermission("fancygrenades.ignoreflash", this);
            permission.RegisterPermission("fancygrenades.usemolly", this);
            

            cmd.AddChatCommand(config.settings.flashCmd, this, cmdFlash);
            cmd.AddChatCommand(config.settings.mollyCmd, this, cmdMolly);

        }

        void OnServerInitialized()
        {
            if (config.pay.costItem.Equals("serverrewards", StringComparison.OrdinalIgnoreCase) && !ServerRewards)
            {
                PrintWarning("Selected payment type is set to ServerRewards but ServerRewards plugin is not loaded! Unloading the plugin...");
                Interface.Oxide.UnloadPlugin("FancyGrenades");
                return;
            }

            if (config.pay.costItem.Equals("economics", StringComparison.OrdinalIgnoreCase) && !Economics)
            {
                PrintWarning("Selected payment type is set to Economics but Economics plugin is not loaded! Unloading the plugin...");
                Interface.Oxide.UnloadPlugin("FancyGrenades");
                return;
            }

            if (!config.pay.costItem.Equals("serverrewards", StringComparison.OrdinalIgnoreCase) &&
                !config.pay.costItem.Equals("economics", StringComparison.OrdinalIgnoreCase))
            {
                item = ItemManager.FindItemDefinition(config.pay.costItem);
                if (item == null)
                {
                    PrintWarning($"Item set in config '{config.pay.costItem}' is not correct! Unloading the plugin...");
                    Interface.Oxide.UnloadPlugin("FancyGrenades");
                    return;
                }
            }
        }

        private void OnExplosiveThrown(BasePlayer player, BaseEntity entity, ThrownWeapon wep)
        {
            if (player.IsNpc || entity == null || wep == null) return;

            Item nade = wep?.GetItem();
            if (string.IsNullOrWhiteSpace(nade.name)) return;

            if (permission.UserHasPermission(player.UserIDString, "fancygrenades.useflash"))
            {
                if (nade.name.Equals(config.flash.Name, StringComparison.OrdinalIgnoreCase))
                {
                    timer.Once(2.9f, () =>
                    {
                        entity.Kill();
                        Effect.server.Run("assets/bundled/prefabs/fx/weapons/landmine/landmine_explosion.prefab", entity.transform.position);
                        foreach (var closePlayer in GetPlayersInRadius(entity.transform.position, config.flash.Range))
                        {
                            if (permission.UserHasPermission(closePlayer.UserIDString, "fancygrenades.ignoreflash")) continue;
                            if (config.flash.NoFlashRule && !InNadeAngle(player, entity)) continue;
                            FlashEffect(closePlayer);
                        }
                    });

                    return;
                }
            }
            if (permission.UserHasPermission(player.UserIDString, "fancygrenades.usemolly"))
            {
                if (nade.name.Equals(config.molly.Name, StringComparison.OrdinalIgnoreCase))
                {
                    timer.Once(2.5f, () =>
                    {
                        entity.Kill();
                        FireEffect(entity.transform.position);
                    });
                }
            }
        }
        private void OnExplosiveDropped(BasePlayer player, BaseEntity entity, ThrownWeapon item) => OnExplosiveThrown(player, entity, item);

        [ConsoleCommand("fg.give")]
        void cmdGive(ConsoleSystem.Arg arg)
        {
            if (arg.IsClientside || !arg.IsRcon) return;

            if (arg.Args == null || arg.Args.Length == 0)
            {
                arg.ReplyWith("fg.give <flash/molly> <nameOrIdOrIP>");
                return;
            }

            if (arg.Args[0] != "flash" && arg.Args[0] != "molly")
            {
                arg.ReplyWith("Wrong grenade type specified!");
                return;
            }

            BasePlayer target = Player.Find(arg.Args[1]);
            if (target == null)
            {
                arg.ReplyWith("Target not found!");
                return;
            }

            string nade = arg.Args[0] == "flash" ? config.flash.Name : config.molly.Name;
            DoPayAndGive(target, nade);
            arg.ReplyWith($"Ran command fg.give on {target.displayName}");
        }

        [ConsoleCommand("fg.givefree")]
        void cmdGiveFree(ConsoleSystem.Arg arg)
        {
            if (arg.IsClientside || !arg.IsRcon) return;

            if (arg.Args == null || arg.Args.Length == 0)
            {
                arg.ReplyWith("fg.givefree <flash/molly> <nameOrIdOrIP>");
                return;
            }

            if (arg.Args[0] != "flash" && arg.Args[0] != "molly")
            {
                arg.ReplyWith("Wrong grenade type specified!");
                return;
            }

            BasePlayer target = Player.Find(arg.Args[1]);
            if(target == null)
            {
                arg.ReplyWith("Target not found!");
                return;
            }

            string nade = arg.Args[0] == "flash" ? config.flash.Name : config.molly.Name;
            DoPayAndGive(target, nade, true);
            arg.ReplyWith($"You gave {target.displayName} a {nade}");
        }


        private void cmdFlash(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "fancygrenades.useflash"))
            {
                Player.Reply(player, lang.GetMessage("NO_PERMISSION", this, player.UserIDString), config.settings.chatId);
                return;
            }
            DoPayAndGive(player, config.flash.Name, config.pay.costAmount == 0 ? true : false);
        }

        private void cmdMolly(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "fancygrenades.usemolly"))
            {
                Player.Reply(player, lang.GetMessage("NO_PERMISSION", this, player.UserIDString), config.settings.chatId);
                return;
            }
            DoPayAndGive(player, config.molly.Name, config.pay.costAmount == 0 ? true : false);
        }

        private void DoPayAndGive(BasePlayer player, string nadeType, bool free = false)
        {
            string paymentType = config.pay.costItem;

            if (config.pay.costItem.Equals("serverrewards", StringComparison.OrdinalIgnoreCase))
                paymentType = "RP";
            else if (config.pay.costItem.Equals("economics", StringComparison.OrdinalIgnoreCase))
                paymentType = "Economics";

            ulong skinId = nadeType == config.flash.Name ? config.flash.SkinId : config.molly.SkinId;
            Item nade = ItemManager.CreateByItemID(GrenadeId, 1, skinId);
            nade.name = nadeType == config.flash.Name ? config.flash.Name : config.molly.Name;
            string symbol = paymentType == "RP" ? "RP" : paymentType == "Economics" ? "$" : config.pay.costItem;

            if (!(HasFunds(player, paymentType) is bool) && !free)
            {               
                int amount = (int)HasFunds(player, paymentType);
                Player.Message(player, string.Format(lang.GetMessage("PURCHASE_FAILED", this, player.UserIDString), symbol, (config.pay.costAmount - amount), symbol));
                return;
            }
            if(!GiveItem(player, nade))
            {
                Player.Message(player, string.Format(lang.GetMessage("INVENTORY_FULL", this, player.UserIDString)));
                return;
            }
            else
            {
                if (!free)
                {
                    switch (paymentType)
                    {
                        case "RP":
                            ServerRewards?.CallHook("TakePoints", player.userID, config.pay.costAmount);
                            break;
                        case "Economics":
                            Economics?.CallHook("Withdraw", player.userID, (double)config.pay.costAmount);
                            break;
                        default:
                            player.inventory.Take(null, item.itemid, config.pay.costAmount);
                            break;
                    }
                    Player.Message(player, string.Format(lang.GetMessage("PURCHASE_SUCCESS", this, player.UserIDString), nade.name, config.pay.costAmount, symbol));
                    return;
                }
                Player.Message(player, string.Format(lang.GetMessage("GIVE_FREE", this, player.UserIDString), nade.name));
            }
        }

        object HasFunds(BasePlayer player, string paymentType)
        {
            if (paymentType == "RP")
            {
                int playerRP = (int)ServerRewards?.CallHook("CheckPoints", player.userID);
                if (playerRP >= config.pay.costAmount)
                    return true;

                return playerRP;
            }
            else if (paymentType == "Economics")
            {
                double playerEcon = (double)Economics?.CallHook("Balance", player.userID);
                if (playerEcon >= config.pay.costAmount)
                    return true;

                return playerEcon;               
            }
            else
            {
                if (GetItemAmount(player, item.shortname) >= config.pay.costAmount)
                    return true;

                return GetItemAmount(player, item.shortname);
            }
        }

        private bool GiveItem(BasePlayer player, Item i)
        {
            if (!player.inventory.GiveItem(i))
            {
                i.Remove();
                return false;
            }
            return true;
        }

        private bool InNadeAngle(BasePlayer player, BaseEntity ent)
        {
            float angle = Vector3.Angle((ent.transform.position - player.transform.position), player.eyes.HeadForward());
            if (angle < 99) return true;

            return false;
        }

        private int GetItemAmount(BasePlayer player, string shortname)
        {
            ItemDefinition item = ItemManager.FindItemDefinition(shortname);
            Item[] playerItems = player.inventory.AllItems();

            return playerItems.FirstOrDefault(x => x.info == item) == null ? 0 : playerItems.FirstOrDefault(x => x.info == item).amount;
        }

        private List<BasePlayer> GetPlayersInRadius(Vector3 pos, int radius)
        {
            var list = new List<BasePlayer>();
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!player.userID.IsSteamId()) continue;
                if (Vector3.Distance(pos, player.transform.position) < radius)
                    list.Add(player);
            }
            return list;
        }

        private void FlashEffect(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "Flash");
            var Element = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = "1 1 1 1", FadeIn = 0.1f},
                            RectTransform = {AnchorMin = "0 0 ", AnchorMax = "1 1" },
                            CursorEnabled = false,
                            FadeOut = 2.5f
                        },
                        new CuiElement().Parent = "Overlay", "Flash"
                    }
                };
            CuiHelper.AddUi(player, Element);

            timer.Once(config.flash.Duration, () => CuiHelper.DestroyUi(player, "Flash"));
        }

        private void FireEffect(Vector3 pos)
        {
            var flame = GameManager.server.CreateEntity("assets/prefabs/ammo/rocket/rocket_fire.prefab", pos);
            flame?.Spawn();
        }
    }
}

// --- End of file: FancyGrenades.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/flippable-turrets ---
// --- Original File Path: F/FlippableTurrets/FlippableTurrets.cs ---

using Oxide.Core;
using Oxide.Core.Configuration;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Flippable Turrets", "Orange", "1.1.0")]
    [Description("Allows users to place turrets how they like")]
    public class FlippableTurrets : RustPlugin
    {
        #region Vars

        private const string prefab = "assets/prefabs/npc/autoturret/autoturret_deployed.prefab";
        private const string permUse = "flippableturrets.use";

        private DynamicConfigFile configFile;
        private Configuration config;

        #endregion

        #region Configuration

        private class Configuration
        {
            public HashSet<ulong> IgnoredSkinIDs = new HashSet<ulong>();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configFile = Config;
            try
            {
                config = Config.ReadObject<Configuration>() ?? new Configuration();
                SaveConfig();
            }
            catch
            {
                PrintError("Failed to load configuration. Using default values.");
                config = new Configuration();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        protected override void LoadDefaultConfig() => config = new Configuration();

        #endregion

        #region Language

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TurretSkinBlocked"] = "This turret cannot be flipped due to its skin."
            }, this);
        }

        private string GetMessage(string key, BasePlayer player) => lang.GetMessage(key, this, player?.UserIDString);

        #endregion

        #region Oxide Hooks

        private void Init()
        {
            permission.RegisterPermission(permUse, this);
        }

        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            CheckInput(player, input);
        }

        #endregion

        #region Core

        private void CheckInput(BasePlayer player, InputState input)
        {
            if (player == null || input == null || !input.WasJustPressed(BUTTON.FIRE_PRIMARY))
                return;

            var heldItem = player.GetActiveItem();
            if (heldItem == null
                || heldItem?.info?.shortname != "autoturret"
                || !permission.UserHasPermission(player.UserIDString, permUse)
                || !player.CanBuild())
                return;

            if (config.IgnoredSkinIDs.Contains(heldItem.skin))
            {
                SendReply(player, GetMessage("TurretSkinBlocked", player));
                return;
            }

            RaycastHit rhit;
            if (!Physics.Raycast(player.eyes.HeadRay(), out rhit))
                return;

            var entity = rhit.GetEntity();
            if (entity == null
                || rhit.distance > 5f
                || !entity.ShortPrefabName.Contains("floor")
                || entity.transform.position.y <= player.transform.position.y)
                return;

            AutoTurret turret = GameManager.server.CreateEntity(prefab) as AutoTurret;
            if (turret == null)
                return;

            turret.transform.position = rhit.point;
            turret.transform.LookAt(player.transform);
            turret.transform.rotation = Quaternion.identity;
            turret.transform.Rotate(0, 0, 180);
            turret.OwnerID = player.userID;
            turret.SetParent(entity, true);
            turret.Spawn();

            var groundMissing = turret?.gameObject?.GetComponent<DestroyOnGroundMissing>();
            if (groundMissing != null)
                UnityEngine.Object.DestroyImmediate(groundMissing);

            var groundWatch = turret?.gameObject?.GetComponent<GroundWatch>();
            if (groundWatch != null)
                UnityEngine.Object.DestroyImmediate(groundWatch);

            Interface.CallHook("OnEntityBuilt", heldItem.GetHeldEntity(), turret.gameObject);
            player.inventory.Take(null, heldItem.info.itemid, 1);
        }

        #endregion
    }
}


// --- End of file: FlippableTurrets.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/food-grill ---
// --- Original File Path: F/FoodGrill/FoodGrill.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Configuration;
using UnityEngine;
namespace Oxide.Plugins
{
    [Info("Food Grill", "Dana", "1.0.5")]
    [Description("Displays meat models on the barbeque.")]
    class FoodGrill : RustPlugin
    {
        List<FOG> FOGLIST = new List<FOG>();
        private PluginConfig _pluginConfig;
        void OnFindBurnable(BaseOven oven)
        {
            if (!_pluginConfig.Config.IsEnabled)
                return;
            if (oven.GetComponent<BaseEntity>() == null)
                return;
            if (oven.GetComponent<BaseEntity>().GetComponent<FOG>() == null)
                return;
            oven.GetComponent<BaseEntity>().GetComponent<FOG>().AddFood(_pluginConfig.Config);
        }
        void OnOvenToggle(BaseOven oven, BasePlayer player)
        {
            if (!_pluginConfig.Config.IsEnabled)
                return;

            if (oven.GetComponent<BaseEntity>().ShortPrefabName != "bbq.deployed")
                return;
            if (oven.GetComponent<FOG>() != null)
                return;
            oven.GetComponent<BaseEntity>().gameObject.AddComponent<FOG>();
            FOGLIST.Add(oven.GetComponent<BaseEntity>().GetComponent<FOG>());
        }
        void init()
        {
            LoadDefaultConfig();
        }
        void Unload()
        {
            if (FOGLIST == null)
                return;

            for (var i = 0; i < FOGLIST.Count; i++)
            {
                FOGLIST[i]?.Delete();
            }
        }
        protected override void LoadConfig()
        {
            var configPath = $"{Manager.ConfigPath}/{Name}.json";
            var newConfig = new DynamicConfigFile(configPath);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }

            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = newConfig.ReadObject<PluginConfig>();
            if (_pluginConfig.Config == null)
            {
                _pluginConfig.Config = new GrillConfig
                {
                    IsEnabled = true,
                    ShowDefaultFood = true,
                    DefaultRawFood = "chicken.raw",
                    DefaultCookedFood = "chicken.cooked",
                    DefaultBurntFood = "chicken.burned",
                    DefaultSpoiledFood = "chicken.spoiled",
                    RawFoods = new List<string>
                    {
                        "bearmeat",
                        "chicken.raw",
                        "deermeat.raw",
                        "fish.raw",
                        "fish.minnows",
                        "fish.troutsmall",
                        "horsemeat.raw",
                        "humanmeat.raw",
                        "meat.boar",
                        "wolfmeat.raw"
                    },
                    CookedFoods = new List<string>
                    {
                        "bearmeat.cooked",
                        "chicken.cooked",
                        "deermeat.cooked",
                        "fish.cooked",
                        "horsemeat.cooked",
                        "humanmeat.cooked",
                        "meat.pork.cooked",
                        "wolfmeat.cooked"
                    },
                    BurntFoods = new List<string>
                    {
                        "bearmeat.burned",
                        "chicken.burned",
                        "deermeat.burned",
                        "horsemeat.burned",
                        "humanmeat.burned",
                        "meat.pork.burned",
                        "wolfmeat.burned"
                    },
                    SpoiledFoods = new List<string>
                    {
                        "chicken.spoiled",
                        "humanmeat.spoiled",
                        "wolfmeat.spoiled"
                    }
                };
            }

            newConfig.WriteObject(_pluginConfig);
            PrintWarning("Config Loaded");
        }
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }
        class FOG : MonoBehaviour
        {
            BaseEntity entity;
            BaseOven oven;
            public List<Item> ItemList = new List<Item>();
            private IEnumerator coroutine;
            bool wait;

            private IEnumerator Wait(float waitTime)
            {
                while (true)
                {
                    yield return new WaitForSeconds(waitTime);
                    wait = false;
                }
            }

            void Awake()
            {
                entity = GetComponent<BaseEntity>();
                oven = GetComponent<BaseOven>();
            }
            public void AddFood(GrillConfig grillConfig)
            {
                if (wait)
                    return;
                wait = true;
                for (int i = 0; i < ItemList.Count; i++)
                {
                    if (ItemList[i] != null)
                    {
                        var removeitem = ItemList[i];
                        ItemList.Remove(removeitem);
                        removeitem.DoRemove();
                    }
                }

                for (int u = 0; u < oven.inventory.itemList.Count; u++)
                {
                    if (oven.inventory.itemList[u] == null)
                        continue;
                    if (oven.inventory.itemList[u].info == null)
                        continue;

                    var itemId = oven.inventory.itemList[u].info.itemid;
                    var shortName = oven.inventory.itemList[u].info.shortname;

                    if (grillConfig.RawFoods.Contains(shortName))
                    {
                        if (grillConfig.ShowDefaultFood && !string.IsNullOrWhiteSpace(grillConfig.DefaultRawFood))
                        {
                            var itemDefinition = ItemManager.FindItemDefinition(grillConfig.DefaultRawFood);
                            if (itemDefinition != null)
                                itemId = itemDefinition.itemid;
                        }
                    }
                    else if (grillConfig.CookedFoods.Contains(shortName))
                    {
                        if (grillConfig.ShowDefaultFood && !string.IsNullOrWhiteSpace(grillConfig.DefaultCookedFood))
                        {
                            var itemDefinition = ItemManager.FindItemDefinition(grillConfig.DefaultCookedFood);
                            if (itemDefinition != null)
                                itemId = itemDefinition.itemid;
                        }
                    }
                    else if (grillConfig.BurntFoods.Contains(shortName))
                    {
                        if (grillConfig.ShowDefaultFood && !string.IsNullOrWhiteSpace(grillConfig.DefaultBurntFood))
                        {
                            var itemDefinition = ItemManager.FindItemDefinition(grillConfig.DefaultBurntFood);
                            if (itemDefinition != null)
                                itemId = itemDefinition.itemid;
                        }
                    }
                    else if (grillConfig.SpoiledFoods.Contains(shortName))
                    {
                        if (grillConfig.ShowDefaultFood && !string.IsNullOrWhiteSpace(grillConfig.DefaultSpoiledFood))
                        {
                            var itemDefinition = ItemManager.FindItemDefinition(grillConfig.DefaultSpoiledFood);
                            if (itemDefinition != null)
                                itemId = itemDefinition.itemid;
                        }
                    }
                    else
                    {
                        continue;
                    }

                    var pos = entity.transform.position + new Vector3(0, 0.8f, 0);
                    var ang = entity.transform.eulerAngles;

                    var item = ItemManager.CreateByItemID(itemId, 1, (ulong)0);
                    ItemList.Add(item);
                    DroppedItem food = item.Drop(pos, Vector3.zero).GetComponent<DroppedItem>();
                    food.SetParent(entity);
                    var offset = 0f;
                    var offset2 = 0f;
                    if (u >= 6) { offset = 0.2f; offset2 = 6; }
                    food.transform.localPosition = new Vector3(-0.1f + offset, 0.8f, -0.38f + (u - offset2) * 0.15f);
                    food.transform.eulerAngles = ang;
                    food.transform.hasChanged = true;
                    food.SendNetworkUpdateImmediate();
                    food.GetComponent<Rigidbody>().isKinematic = true;
                    food.GetComponent<Rigidbody>().useGravity = false;
                    food.allowPickup = false;
                    food.GetComponent<Rigidbody>().detectCollisions = true;
                    food.CancelInvoke((Action)Delegate.CreateDelegate(typeof(Action), food, "IdleDestroy"));

                }

                coroutine = Wait(5);
                StartCoroutine(coroutine);
            }
            public void Delete()
            {
                Destroy();
            }
            void Destroy()
            {
                try
                {
                    for (int i = 0; i < ItemList.Count; i++)
                    {
                        if (ItemList[i] != null)
                        {
                            ItemList[i].DoRemove();
                        }
                    }
                    enabled = false;
                    CancelInvoke();
                    Destroy(this);
                }
                catch (Exception)
                {
                    // ignored
                }
            }
        }

        private class PluginConfig
        {
            public GrillConfig Config { get; set; }
        }

        private class GrillConfig
        {
            [JsonProperty(PropertyName = "Plugin - Enabled")]
            public bool IsEnabled { get; set; }

            [JsonProperty(PropertyName = "Show Default Food")]
            public bool ShowDefaultFood { get; set; }

            [JsonProperty(PropertyName = "Default Raw Food")]
            public string DefaultRawFood { get; set; }

            [JsonProperty(PropertyName = "Default Cooked Food")]
            public string DefaultCookedFood { get; set; }

            [JsonProperty(PropertyName = "Default Burnt Food")]
            public string DefaultBurntFood { get; set; }

            [JsonProperty(PropertyName = "Default Spoiled Food")]
            public string DefaultSpoiledFood { get; set; }

            [JsonProperty(PropertyName = "Raw Food List")]
            public List<string> RawFoods { get; set; } = new List<string>();

            [JsonProperty(PropertyName = "Cooked Food List")]
            public List<string> CookedFoods { get; set; } = new List<string>();

            [JsonProperty(PropertyName = "Burnt Food List")]
            public List<string> BurntFoods { get; set; } = new List<string>();

            [JsonProperty(PropertyName = "Spoiled Food List")]
            public List<string> SpoiledFoods { get; set; } = new List<string>();
        }
    }
}

// --- End of file: FoodGrill.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/faux-clip ---
// --- Original File Path: F/FauxClip/FauxClip.cs ---

using System;
using System.Reflection;
using System.Collections.Generic;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("FauxClip", "Colon Blow", "1.3.10")]
    class FauxClip : RustPlugin
    {
        public float GracefulLandingTime => Config.Get<float>("GracefulLandingTime");
        public float BaseNoClipSpeed => Config.Get<float>("BaseNoClipSpeed");
        public float SprintNoClipSpeed => Config.Get<float>("SprintNoClipSpeed");
        public float TurboNoClipSpeed => Config.Get<float>("TurboNoClipSpeed");
        public bool UseFauxClipGodMode => Config.Get<bool>("UseFauxClipGodMode");

        protected override void LoadDefaultConfig()
        {
            Config["GracefulLandingTime"] = 3;
            Config["BaseNoClipSpeed"] = .12;
            Config["SprintNoClipSpeed"] = .24;
            Config["TurboNoClipSpeed"] = 1;
            Config["UseFauxClipGodMode"] = true;

            SaveConfig();
        }

        class PlayerData
        {
            public BasePlayer player;
            public float speed;
            public Vector3 oldPos;
            public InputState input;
        }

        class LandingData
        {
            public BasePlayer player;
        }

        private readonly Dictionary<ulong, PlayerData> _noclip = new Dictionary<ulong, PlayerData>();
        private readonly Dictionary<ulong, LandingData> _landing = new Dictionary<ulong, LandingData>();
        private static readonly FieldInfo ServerInput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
        public static FieldInfo lastPositionValue;

        void Loaded()
        {
            permission.RegisterPermission("fauxclip.allowed", this);
            permission.RegisterPermission("fauxclip.norestriction", this);
            permission.RegisterPermission("fauxclip.canuseturbo", this);
            lastPositionValue = typeof(BasePlayer).GetField("lastPositionValue", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
        }

        void OnFrame()
        {
            if (_noclip.Count <= 0) return;

            foreach (var playerData in _noclip.Values)
            {
                var player = playerData.player;
                player.violationLevel = 0;
                if (NoBuild(player) & (NoAdmin(player) & (!IsAllowed(player, "fauxclip.norestriction"))))
                {
                    Restrictedairspace(player);
                    return;
                }

                if (player.net == null)
                {
                    Deactivatenoclip(player);
                    return;
                }

                var input = playerData.input;
                var newPos = playerData.oldPos;
                var currentRot = Quaternion.Euler(input.current.aimAngles);
                var speedMult = playerData.speed;

                if (input.IsDown(BUTTON.SPRINT))
                    speedMult = SprintNoClipSpeed;

                if (input.IsDown(BUTTON.USE) & (IsAllowed(player, "fauxclip.canuseturbo")))
                    speedMult = TurboNoClipSpeed;

                else if (input.IsDown(BUTTON.RELOAD))
                {
                    Deactivatenoclip(player);
                    return;
                }
                else if (input.IsDown(BUTTON.JUMP))
                {
                    newPos += (currentRot * Vector3.up * speedMult);
                }
                else if (input.IsDown(BUTTON.FORWARD))
                {
                    newPos += (currentRot * Vector3.forward * speedMult);
                }
                else if (input.IsDown(BUTTON.RIGHT))
                {
                    newPos += (currentRot * Vector3.right * speedMult);
                }
                else if (input.IsDown(BUTTON.LEFT))
                {
                    newPos += (currentRot * Vector3.left * speedMult);
                }
                else if (input.IsDown(BUTTON.BACKWARD))
                {
                    newPos += (currentRot * Vector3.back * speedMult);
                }
                else if (!input.IsDown(BUTTON.FORWARD))
                {
                    ForcePlayerPosition(player, newPos);
                }
                else
                    newPos = player.transform.position;

                if (newPos == playerData.oldPos) continue;

                player.PauseFlyHackDetection(5f);
                player.PauseSpeedHackDetection(5f);
                player.PauseVehicleNoClipDetection(5f);

                ForcePlayerPosition(player, newPos);
                playerData.oldPos = newPos;
            }
        }

        bool NoAdmin(BasePlayer player)
        {
            if (player.IsAdmin) return false;
            return true;
        }
        bool NoBuild(BasePlayer player)
        {
            if (player.CanBuild()) return false;
            return true;
        }

        void DamageOn(BasePlayer player)
        {
            player.metabolism.heartrate.min = 0;
            player.metabolism.heartrate.max = 1;
            player.metabolism.temperature.min = -100;
            player.metabolism.temperature.max = 100;
            player.metabolism.radiation_level.min = 0;
            player.metabolism.radiation_level.max = 100;
            player.metabolism.radiation_poison.min = 0;
            player.metabolism.radiation_poison.max = 500;
            player.metabolism.wetness.min = 0;
            player.metabolism.wetness.max = 1;
            player.metabolism.dirtyness.min = 0;
            player.metabolism.dirtyness.max = 100;
            player.metabolism.oxygen.min = 0;
            player.metabolism.oxygen.max = 1;
            player.metabolism.bleeding.min = 0;
            player.metabolism.bleeding.max = 1;
            player.metabolism.comfort.min = 0;
            player.metabolism.comfort.max = 1;
        }

        void DamageOff(BasePlayer player)
        {
            if (!UseFauxClipGodMode) return;

            foreach (var playerData in _noclip.Values)
            {
                player.metabolism.heartrate.min = 0.5f;
                player.metabolism.heartrate.max = 0.5f;
                player.metabolism.temperature.min = 32;
                player.metabolism.temperature.max = 32;
                player.metabolism.radiation_level.min = 0;
                player.metabolism.radiation_level.max = 0;
                player.metabolism.radiation_poison.max = 0;
                player.metabolism.wetness.min = 0;
                player.metabolism.wetness.max = 0;
                player.metabolism.dirtyness.min = 0;
                player.metabolism.dirtyness.max = 0;
                player.metabolism.oxygen.min = 1;
                player.metabolism.oxygen.max = 1;
                player.metabolism.bleeding.min = 0;
                player.metabolism.bleeding.max = 0;
                player.metabolism.comfort.min = 0;
                player.metabolism.comfort.max = 0;
                return;
            }
        }

        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (!UseFauxClipGodMode) return null;

            if (UseFauxClipGodMode)
            {
                if (entity is BasePlayer)
                {
                    var player = (BasePlayer)entity;
                    if (_noclip.ContainsKey(player.userID))
                    {
                        return false;
                    }
                    if (_landing.ContainsKey(player.userID))
                    {
                        return false;
                    }
                }
            }
            return null;
        }

        void Deactivatenoclip(BasePlayer player)
        {
            _noclip.Remove(player.userID);
            SendReply(player, "NoClip Deactivated");
            _landing.Add(player.userID, new LandingData
            {
                player = player
            });
            LandingCycleDone(player);
        }

        void Restrictedairspace(BasePlayer player)
        {
            _noclip.Remove(player.userID);
            SendReply(player, "You cannot noclip while under 'Building Blocked' flag !");
            _landing.Add(player.userID, new LandingData
            {
                player = player
            });
            LandingCycleDone(player);
        }

        void Activatenoclip(BasePlayer player, float speed)
        {
            _noclip.Add(player.userID, new PlayerData
            {
                player = player,
                speed = speed,
                input = player.serverInput,
                oldPos = player.transform.position
            });
            SendReply(player, "NoClip Activated, press any key to start");
            DamageOff(player);
        }

        void Togglenoclip(BasePlayer player, float speed)
        {
            if (_noclip.ContainsKey(player.userID))
                Deactivatenoclip(player);
            if (_landing.ContainsKey(player.userID))
                SendReply(player, "Please Wait...");
            else
                Activatenoclip(player, speed);
        }

        void LandingCycleDone(BasePlayer player)
        {
            foreach (var playerData in _landing.Values)
            {
                timer.Once(GracefulLandingTime, () => _landing.Remove(player.userID));
                timer.Once(GracefulLandingTime, () => DamageOn(player));
            }
        }

        [ChatCommand("noclip")]
        void cmdChatnolcip(BasePlayer player, string command, string[] args)
        {
            if (!IsAllowed(player, "fauxclip.allowed"))
            {
                SendReply(player, "You are not worthy yet!");
                return;
            }

            var speed = BaseNoClipSpeed;
            if (args.Length > 0)
                speed = Convert.ToSingle(args[0]);
            Togglenoclip(player, speed);
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            if (_noclip.ContainsKey(player.userID))
                _noclip.Remove(player.userID);
            if (_landing.ContainsKey(player.userID))
                _landing.Remove(player.userID);
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (_noclip.ContainsKey(player.userID))
                _noclip.Remove(player.userID);
            if (_landing.ContainsKey(player.userID))
                _landing.Remove(player.userID);
        }

        bool IsAllowed(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);
    }
}

// --- End of file: FauxClip.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/forever-alone ---
// --- Original File Path: F/ForeverAlone/ForeverAlone.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Forever Alone", "misticos", "1.0.1")]
    [Description("Limit the number of players in a team on the server")]
    class ForeverAlone : RustPlugin
    {
        private static readonly int playerLayer = LayerMask.GetMask("Player (Server)");

		static float AroundRadius;
        static float CheckInterval;
        static float timeBeforeShock;
        static float DamagePerTime;
		
        static int MaxAllowedPlayers;

        void OnServerInitialized()
        {
            foreach(BasePlayer player in BasePlayer.activePlayerList)
            {
                CheckComponent(player);
            }

            MaxAllowedPlayers = Config.Get<int>("MaxAllowedPlayers");

            Puts("Max allowed players in team: " + MaxAllowedPlayers);
        }

        protected override void LoadDefaultConfig()
        {
            Config["MaxAllowedPlayers"] = MaxAllowedPlayers = GetConfig("MaxAllowedPlayers", 2);
			Config["AroundRadius"] = AroundRadius = GetConfig("AroundRadius", 10f);
			Config["CheckInterval"] = CheckInterval = GetConfig("CheckInterval", 5f);
			Config["timeBeforeShock"] = timeBeforeShock = GetConfig("timeBeforeShock", 60f);
			Config["DamagePerTime"] = DamagePerTime = GetConfig("DamagePerTime", 50f);
        }
		
		T GetConfig<T>(string name, T defaultValue)
            => Config[name] == null ? defaultValue : (T)Convert.ChangeType(Config[name], typeof(T));

        void Unload()
        {
            foreach (AroundTimer arTimer in Resources.FindObjectsOfTypeAll<AroundTimer>())
            {
                UnityEngine.Object.Destroy(arTimer);
            }
        }

        void OnPlayerConnected(BasePlayer player)
        {
            CheckComponent(player);
        }

        void CheckComponent(BasePlayer player)
        {
            AroundTimer arTimer = player.GetComponent<AroundTimer>();

            if (!arTimer)
            {
                player.gameObject.AddComponent<AroundTimer>();
            }
        }

        class AroundTimer : MonoBehaviour
        {
            float ElaspedSeconds;
            BasePlayer player;

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                InvokeRepeating("CheckAround", CheckInterval, CheckInterval);
            }

            void CheckAround()
            {
                if (!player.IsConnected)
                {
                    Destroy(this);
                    return;
                }

                if (player.IsDead() || player.IsSleeping()) return;

                int entities = Physics.OverlapSphereNonAlloc(player.transform.position, AroundRadius, Vis.colBuffer, playerLayer);

                int playersAround = 0;

                for (var i = 0; i < entities; i++)
                {
                    var player = Vis.colBuffer[i].GetComponentInParent<BasePlayer>();

                    if (player != null && (player == this.player || !player.IsDead() && !player.IsSleeping() && IsVisible(player, this.player.eyes.position, player.eyes.position)))
                    {
                        playersAround++;           
                    }
                }

                if(playersAround > MaxAllowedPlayers)
                {
                    ElaspedSeconds += CheckInterval;

                    if (ElaspedSeconds >= timeBeforeShock)
                    {
                        player.ChatMessage($"You exceed the limit of the joint game.\nNo more than {MaxAllowedPlayers} people per team.");
                        DoShock(player);
                    }
                }
                else
                {
                    ElaspedSeconds = Mathf.Max(0, ElaspedSeconds - CheckInterval); 
                }
            }
        }

        int GetLimit => MaxAllowedPlayers;

        static void DoShock(BasePlayer player)
        {
            player.Hurt(DamagePerTime, DamageType.ElectricShock, player, false);
            Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.shock.prefab", player, 0, Vector3.zero, Vector3.forward, null, false);
        }

        static bool IsVisible(BasePlayer player, Vector3 source, Vector3 dest) => player.IsVisible(source, dest);
    }
}

// --- End of file: ForeverAlone.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/free-laptop ---
// --- Original File Path: F/FreeLaptop/FreeLaptop.cs ---

using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using UnityEngine;
using ProtoBuf;
using Rust;
using System.Linq;
using System.Numerics;
using System.Resources;
using Network;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Free Laptop", "Sam Greaves", "2.1.1")]
    [Description("A free plugin to add functionality to laptops")]
    class FreeLaptop : RustPlugin
    {
        private readonly int _layerMask = LayerMask.GetMask("Construction", "Deployed", "Default");
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoLaptop"] = "You dont have a laptop in your hands! noob!",
                ["NoInteraction"] = "There is nothing to interact with!",
                ["NoCodeLock"] = "There is no code lock to open!",
                ["AuthorizedPlayers"] = "Authorized players:\n",
                ["NoAuthorizedPlayers"] = "No authorized players",
                ["LaptopDistanceSettings"] = "Laptop can be used within a distance of ",
                ["CanOpenDoorsSettings"] = "Players can open code locked doors with laptops.",
                ["CanSeeTcAuthSettings"] = "Players can see who is authorized on tc with laptops.",
                ["CanSeeDoorAuth"] = "Players can see who is authorized on doors with laptops.",
                ["CanUnlockTc"] = "Players can see the tc code with a laptop",
                ["CanSeeTurretAuthSettings"] = "Players can see who is authorized on turrets with laptops.",
                ["CanUnlockTurretSettings"] = "Players can unlock turrets with laptops.",

            }, this);
        }

        [ChatCommand("laptop")]
        void ChatLaptop(BasePlayer player, string command, string[] args)
        {
            // first check for laptop
            Item item = LaptopInHands(player);
            if (item != null)
            {
                // then get entity player is looking at 
                BaseEntity entity = GetEntityLookingAt(player);

                // then decide which behaviour stream to go down
                if (args != null && args.Length > 0)
                {
                    if (args[0] == "settings")
                        ShowSettings(player);
                    if (args[0] == "auth")
                        Interact(player, entity, true);
                }
                else
                {
                    if (Interact(player, entity, false))
                        item.UseItem();
                }
            }
            else
            {
                player.ChatMessage(Lang("NoLaptop", player.UserIDString));
            }
        }

        /// <summary>
        /// Method to check if active item is a laptop.
        /// </summary>
        /// <param name="player">The player who's active item we check.</param>
        /// <returns>Item if its a laptop, null if not.</returns>
        private Item LaptopInHands(BasePlayer player)
        {
            Item activeItem = (player.GetActiveItem() as Item);

            return activeItem?.info.shortname == "targeting.computer" ? activeItem : null;
        }

        /// <summary>
        /// Get the entity the player is looking at within the config range.
        /// </summary>
        /// <param name="player">The player who is looking at entity.</param>
        /// <returns>The entity being looked at in range or null.</returns>
        private BaseEntity GetEntityLookingAt(BasePlayer player)
        {
            RaycastHit hit;
            BaseEntity entity = null;
            if (Physics.Raycast(player.eyes.HeadRay(), out hit, config.LaptopDistance, _layerMask))
            {
                return hit.GetEntity();
            }

            return null;
        }

        /// <summary>
        /// Shows the settings from the config object in a nice way for players.
        /// </summary>
        /// <param name="player">Player to show settings to.</param>
        private void ShowSettings(BasePlayer player)
        {
            player.ChatMessage(Lang("LaptopDistanceSettings", player.UserIDString) + config.LaptopDistance);
            if (config.CanOpenDoors)
                player.ChatMessage(Lang("CanOpenDoorsSettings", player.UserIDString));
            if (config.CanSeeDoorAuth)
                player.ChatMessage(Lang("CanSeeDoorAuth", player.UserIDString));
            if (config.CanSeeTcAuth)
                player.ChatMessage(Lang("CanSeeTcAuthSettings", player.UserIDString));
            if (config.CanUnlockTc)
                player.ChatMessage(Lang("CanUnlockTc", player.UserIDString));
            if (config.CanSeeTurretAuth)
                player.ChatMessage(Lang("CanSeeTurretAuthSettings", player.UserIDString));
            if (config.CanUnlockTurret)
                player.ChatMessage(Lang("CanUnlockTurretSettings", player.UserIDString));
        }

        /// <summary>
        /// Attempt to interact with the given entity.
        /// </summary>
        /// <param name="player">Player who is interacting.</param>
        /// <param name="entity">Entity to interact with.</param>
        /// <param name="showAuth">If the interaction is to show auth list.</param>
        /// <returns>True if interaction was successful.</returns>
        private bool Interact(BasePlayer player, BaseEntity entity, bool showAuth)
        {
            if (entity)
            {
                if (entity is Door)
                {
                    if (showAuth && config.CanSeeDoorAuth)
                        return DisplayDoorAuthorizedPlayers(player, entity as Door);
                    else if (config.CanOpenDoors)
                        return DoorUnlocking(entity as Door, player);
                }
                else if (entity is BuildingPrivlidge)
                {
                    if (showAuth && config.CanSeeTcAuth)
                        return DisplayTcAuthorizedPlayers(player, entity as BuildingPrivlidge);
                    else if (config.CanUnlockTc)
                        return TcUnlocking(entity as BuildingPrivlidge, player);
                }
                else if (entity is AutoTurret)
                {
                    if (showAuth && config.CanSeeTurretAuth)
                        return DisplayTurretAuthorizedPlayers(player, entity as AutoTurret);
                    else if (config.CanUnlockTurret)
                        return TurretUnlocking(entity as AutoTurret, player);
                }
            }

            player.ChatMessage(Lang("NoInteraction", player.UserIDString));
            return false;
        }

        #region Interactions

        /// <summary>
        /// Unlocks the given door.
        /// </summary>
        /// <param name="door">Door to unlock.</param>
        /// <returns>True if the door unlock is successful.</returns>
        private bool DoorUnlocking(Door door, BasePlayer player)
        {
            if (door != null)
            {
                var lockSlot = door.GetSlot(BaseEntity.Slot.Lock);

                if (lockSlot is CodeLock)
                {
                    door.SetOpen(!door.IsOpen());
                    return true;
                }
                else
                {
                    player.ChatMessage(Lang("NoCodeLock", player.UserIDString));
                }
            }

            return false;
        }

        /// <summary>
        /// Unlocks the given tc.
        /// </summary>
        /// <param name="tc">Tc to unlock.</param>
        /// <returns>True if the tc unlock is successful.</returns>
        private bool TcUnlocking(BuildingPrivlidge tc, BasePlayer player)
        {
            if (tc != null)
            {
                var lockSlot = tc.GetSlot(BaseEntity.Slot.Lock);

                if (lockSlot is CodeLock)
                {
                    var codeLock = (CodeLock) lockSlot;
                    player.ChatMessage(codeLock.code);
                    return true;
                }
                else
                {
                    player.ChatMessage(Lang("NoCodeLock", player.UserIDString));
                }
            }

            return false;
        }

        /// <summary>
        /// Unlocks the given turret.
        /// </summary>
        /// <param name="turret">Turret to unlock.</param>
        /// <returns>True if the turret unlock is successful.</returns>
        private bool TurretUnlocking(AutoTurret turret, BasePlayer player)
        {
            if (turret != null)
            {
                turret.SetIsOnline(false);
                return true;
            }

            return false;
        }

        #endregion

        #region Get Authorized players

        /// <summary>
        /// Display a list of authorized players for the given tc.
        /// </summary>
        /// <param name="player">Player making the request.</param>
        /// <param name="tc">Tc to get list from.</param>
        /// <returns>True.</returns>
        private bool DisplayTcAuthorizedPlayers(BasePlayer player, BuildingPrivlidge tc)
        {
            var lockSlot = tc.GetSlot(BaseEntity.Slot.Lock);

            if (lockSlot is CodeLock)
            {
                string msg = Lang("AuthorizedPlayers", player.UserIDString);
                int count = 0;

                foreach (var user in tc.authorizedPlayers)
                {
                    count++;
                    msg += $"{count}. {GetName(user.userid.ToString())}\n";
                }

                player.ChatMessage(count > 0 ? msg : Lang("NoAuthorizedPlayers", player.UserIDString));

                return true;
            }

            return false;
        }

        /// <summary>
        /// Display a list of authorized players for the given door.
        /// </summary>
        /// <param name="player">Player making the request.</param>
        /// <param name="door">Door to get list from.</param>
        /// <returns>True.</returns>
        private bool DisplayDoorAuthorizedPlayers(BasePlayer player, Door door)
        {
            var lockSlot = door.GetSlot(BaseEntity.Slot.Lock);

            if (lockSlot is CodeLock)
            {
                var codeLock = (CodeLock) lockSlot;
                string msg = Lang("AuthorizedPlayers", player.UserIDString, door.ShortPrefabName,
                                 GetName(door.OwnerID.ToString()));

                int authed = 0;

                foreach (var user in codeLock.whitelistPlayers)
                {
                    authed++;
                    msg += $"{authed}. {GetName(user.ToString())}\n";
                }

                player.ChatMessage(authed == 0 ? Lang("NoAuthorizedPlayers", player.UserIDString) : msg);

                return true;
            }

            return false;
        }

        /// <summary>
        /// Display a list of authorized players for the given turret.
        /// </summary>
        /// <param name="player">Player making the request.</param>
        /// <param name="turret">Turret to get list from.</param>
        /// <returns></returns>
        private bool DisplayTurretAuthorizedPlayers(BasePlayer player, AutoTurret turret)
        {
            string msg = Lang("AuthorizedPlayers", player.UserIDString);
            int count = 0;

            foreach (var user in turret.authorizedPlayers)
            {
                count++;
                msg += $"{count}. {GetName(user.userid.ToString())}\n";
            }

            player.ChatMessage(count > 0 ? msg : Lang("NoAuthorizedPlayers", player.UserIDString));

            return true;
        }

        #endregion

        private string GetName(string id) => id == "0" ? "[SERVERSPAWN]" : covalence.Players.FindPlayer(id)?.Name;

        private string Lang(string key, string id = null, params object[] args) =>
            string.Format(lang.GetMessage(key, this, id), args);

        private class PluginConfig
        {
            public float LaptopDistance;
            public bool CanOpenDoors;
            public bool CanSeeTcAuth;
            public bool CanSeeDoorAuth;
            public bool CanUnlockTc;
            public bool CanSeeTurretAuth;
            public bool CanUnlockTurret;
        }

        private PluginConfig config;

        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                CanOpenDoors = true,
                LaptopDistance = 1f,
                CanSeeTcAuth = true,
                CanSeeDoorAuth = true,
                CanUnlockTc = true,
                CanSeeTurretAuth = true,
                CanUnlockTurret = true,
            };
        }
    }
}

// --- End of file: FreeLaptop.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/flying-carpet ---
// --- Original File Path: F/FlyingCarpet/FlyingCarpet.cs ---

//#define DEBUG
using Oxide.Core;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Rust;
using System.Linq;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Globalization;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Flying Carpet", "RFC1920", "1.1.7")]
    [Description("Fly a custom object consisting of carpet, chair, lantern, lock, and small sign")]
    // Thanks to Colon Blow for his fine work on GyroCopter, upon which this was originally based.
    class FlyingCarpet : RustPlugin
    {
        #region Load
        static LayerMask layerMask;
        BaseEntity newCarpet;

        static Dictionary<ulong, PlayerCarpetData> loadplayer = new Dictionary<ulong, PlayerCarpetData>();
        static List<ulong> pilotslist = new List<ulong>();

        // SignArtist plugin
        [PluginReference]
        Plugin SignArtist;

        public class PlayerCarpetData
        {
            public BasePlayer player;
            public int carpetcount;
        }

        void Init()
        {
            LoadVariables();
            layerMask = (1 << 29);
            layerMask |= (1 << 18);
            layerMask = ~layerMask;

            AddCovalenceCommand("fc", "cmdCarpetBuild");
            AddCovalenceCommand("fcc", "cmdCarpetCount");
            AddCovalenceCommand("fcd", "cmdCarpetDestroy");
            AddCovalenceCommand("fcg", "cmdCarpetGiveChat");
            AddCovalenceCommand("fchelp", "cmdCarpetHelp");

            permission.RegisterPermission("flyingcarpet.use", this);
            permission.RegisterPermission("flyingcarpet.vip", this);
            permission.RegisterPermission("flyingcarpet.admin", this);
            permission.RegisterPermission("flyingcarpet.unlimited", this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["helptext1"] = "Flying Carpet instructions:",
                ["helptext2"] = "  type /fc to spawn a Flying Carpet",
                ["helptext3"] = "  type /fcd to destroy your flyingcarpet.",
                ["helptext4"] = "  type /fcc to show a count of your carpets",
                ["notauthorized"] = "You don't have permission to do that !!",
                ["notfound"] = "Could not locate a carpet.  You must be within {0} meters for this!!",
                ["notflyingcarpet"] = "You are not piloting a flying carpet !!",
                ["maxcarpets"] = "You have reached the maximum allowed carpets",
                ["landingcarpet"] = "Carpet landing sequence started !!",
                ["risingcarpet"] = "Carpet takeoff sequence started !!",
                ["carpetlocked"] = "You must unlock the Carpet first !!",
                ["carpetspawned"] = "Flying Carpet spawned!  Don't forget to lock it !!",
                ["carpetdestroyed"] = "Flying Carpet destroyed !!",
                ["carpetfuel"] = "You will need fuel to fly.  Do not start without fuel !!",
                ["carpetnofuel"] = "You have been granted unlimited fly time, no fuel required !!",
                ["nofuel"] = "You're out of fuel !!",
                ["noplayer"] = "Unable to find player {0}!",
                ["gaveplayer"] = "Gave carpet to player {0}!",
                ["lowfuel"] = "You're low on fuel !!",
                ["nocarpets"] = "You have no Carpets",
                ["currcarpets"] = "Current Carpets : {0}",
                ["giveusage"] = "You need to supply a valid SteamId."
            }, this);
        }

        bool isAllowed(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);
        private bool HasPermission(ConsoleSystem.Arg arg, string permname) => (arg.Connection.player as BasePlayer) == null ? true : permission.UserHasPermission((arg.Connection.player as BasePlayer).UserIDString, permname);

        private static HashSet<BasePlayer> FindPlayers(string nameOrIdOrIp)
        {
            var players = new HashSet<BasePlayer>();
            if (string.IsNullOrEmpty(nameOrIdOrIp)) return players;
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.UserIDString.Equals(nameOrIdOrIp))
                    players.Add(activePlayer);
                else if (!string.IsNullOrEmpty(activePlayer.displayName) && activePlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.IgnoreCase))
                    players.Add(activePlayer);
                else if (activePlayer.net?.connection != null && activePlayer.net.connection.ipaddress.Equals(nameOrIdOrIp))
                    players.Add(activePlayer);
            }
            foreach (var sleepingPlayer in BasePlayer.sleepingPlayerList)
            {
                if (sleepingPlayer.UserIDString.Equals(nameOrIdOrIp))
                    players.Add(sleepingPlayer);
                else if (!string.IsNullOrEmpty(sleepingPlayer.displayName) && sleepingPlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.IgnoreCase))
                    players.Add(sleepingPlayer);
            }
            return players;
        }
        #endregion

        #region Configuration
        bool UseMaxCarpetChecks = true;
        bool playemptysound = true;
        public int maxcarpets = 1;
        public int vipmaxcarpets = 2;

        static float MinAltitude = 5f;
        static float MinDistance = 10f;

        static ulong rugSkinID = 871503616;
        static ulong chairSkinID = 943293895;

        static float NormalSpeed = 12f;
        static float SprintSpeed = 25f;
        static bool requirefuel = true;
        static bool doublefuel = false;
        static bool nameOnSign = true;

        //bool Changed = false;

        protected override void LoadDefaultConfig()
        {
#if DEBUG
            Puts("Creating a new config file...");
#endif
            Config.Clear();
            LoadVariables();
        }

        private void LoadConfigVariables()
        {
            CheckCfgFloat("Minimum Flight Altitude : ", ref MinAltitude);
            CheckCfgFloat("Minimum Distance for FCD: ", ref MinDistance);
            CheckCfgFloat("Speed - Normal Flight Speed is : ", ref NormalSpeed);
            CheckCfgFloat("Speed - Sprint Flight Speed is : ", ref SprintSpeed);

            CheckCfg("Deploy - Enable limited FlyingCarpets per person : ", ref UseMaxCarpetChecks);
            CheckCfg("Deploy - Limit of Carpets players can build : ", ref maxcarpets);
            CheckCfg("Deploy - Limit of Carpets VIP players can build : ", ref vipmaxcarpets);
            CheckCfg("Require Fuel to Operate : ", ref requirefuel);
            CheckCfg("Play low fuel sound : ", ref playemptysound);
            CheckCfg("Double Fuel Consumption: ", ref doublefuel);
            CheckCfg("RugSkinID : ", ref rugSkinID);
            CheckCfg("ChairSkinID : ", ref chairSkinID);
            CheckCfg("Owner Name on Sign: ", ref nameOnSign);
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if(Config[Key] is T)
            {
                var = (T)Config[Key];
            }
            else
            {
                Config[Key] = var;
            }
        }

        private void CheckCfgFloat(string Key, ref float var)
        {
            if(Config[Key] != null)
            {
                var = Convert.ToSingle(Config[Key]);
            }
            else
            {
                Config[Key] = var;
            }
        }

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if(data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                //Changed = true;
            }

            object value;
            if(!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                //Changed = true;
            }
            return value;
        }
        #endregion

        #region Message
        private string _(string msgId, BasePlayer player, params object[] args)
        {
            var msg = lang.GetMessage(msgId, this, player?.UserIDString);
            return args.Length > 0 ? string.Format(msg, args) : msg;
        }

        private void PrintMsgL(BasePlayer player, string msgId, params object[] args)
        {
            if(player == null) return;
            PrintMsg(player, _(msgId, player, args));
        }

        private void PrintMsg(BasePlayer player, string msg)
        {
            if(player == null) return;
            SendReply(player, $"{msg}");
        }
        #endregion

        #region Chat Commands
        [Command("fc"), Permission("flyingcarpet.use")]
        void cmdCarpetBuild(IPlayer iplayer, string command, string[] args)
        {
            bool vip = false;
            var player = iplayer.Object as BasePlayer;
            if(!iplayer.HasPermission("flyingcarpet.use")) { PrintMsgL(player, "notauthorized"); return; }
            if(iplayer.HasPermission("flyingcarpet.vip"))
            {
                vip = true;
            }
            if(CarpetLimitReached(player, vip)) { PrintMsgL(player, "maxcarpets"); return; }
            AddCarpet(player, player.transform.position);
        }

        [Command("fcg"), Permission("flyingcarpet.admin")]
        void cmdCarpetGiveChat(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            if(args.Length == 0)
            {
                PrintMsgL(player, "giveusage");
                return;
            }
            bool vip = false;
            string pname = args[0] == null ? null : args[0];

            if(!iplayer.HasPermission("flyingcarpet.admin")) { PrintMsgL(player, "notauthorized"); return; }
            if(pname == null) { PrintMsgL(player, "noplayer", "NAME_OR_ID"); return; }

            BasePlayer Bplayer = BasePlayer.Find(pname);
            if(Bplayer == null)
            {
                PrintMsgL(player, "noplayer", pname);
                return;
            }

            var Iplayer = Bplayer.IPlayer;
            if(Iplayer.HasPermission("flyingcarpet.vip"))
            {
                vip = true;
            }
            if(CarpetLimitReached(Bplayer, vip)) { PrintMsgL(player, "maxcarpets"); return; }
            AddCarpet(Bplayer, Bplayer.transform.position);
            PrintMsgL(player, "gaveplayer", pname);
        }

        [ConsoleCommand("fcgive")]
        void cmdCarpetGive(ConsoleSystem.Arg arg)
        {
            if(arg.IsRcon)
            {
                if(arg.Args == null)
                {
                    Puts("You need to supply a valid SteamId.");
                    return;
                }
            }
            else if(!HasPermission(arg, "flyingcarpet.admin"))
            {
                SendReply(arg, _("notauthorized", arg.Connection.player as BasePlayer));
                return;
            }
            else if(arg.Args == null)
            {
                SendReply(arg, _("giveusage", arg.Connection.player as BasePlayer));
                return;
            }

            bool vip = false;
            string pname = arg.GetString(0);

            if(pname.Length < 1) { Puts("Player name or id cannot be null"); return; }

            BasePlayer Bplayer = BasePlayer.Find(pname);
            if(Bplayer == null) { Puts($"Unable to find player '{pname}'"); return; }

            var Iplayer = Bplayer.IPlayer;
            if(Iplayer.HasPermission("flyingcarpet.vip")) { vip = true; }
            if(CarpetLimitReached(Bplayer, vip))
            {
                Puts($"Player '{pname}' has reached maxcarpets"); return;
            }
            AddCarpet(Bplayer, Bplayer.transform.position);
            Puts($"Gave carpet to '{Bplayer.displayName}'");
        }

        [Command("fcc"), Permission("flyingcarpet.use")]
        void cmdCarpetCount(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            if(!iplayer.HasPermission("flyingcarpet.use")) { PrintMsgL(player, "notauthorized"); return; }
            if(!loadplayer.ContainsKey(player.userID))
            {
                PrintMsgL(player, "nocarpets");
                return;
            }
            string ccount = loadplayer[player.userID].carpetcount.ToString();
#if DEBUG
            Puts("CarpetCount: " + ccount);
#endif
            PrintMsgL(player, "currcarpets", ccount);
        }

        [Command("fcd"), Permission("flyingcarpet.use")]
        void cmdCarpetDestroy(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            if(!iplayer.HasPermission("flyingcarpet.use")) { PrintMsgL(player, "notauthorized"); return; }

            string target = null;
            if(args.Length > 0)
            {
                target = args[0];
            }
            if(iplayer.HasPermission("flyingcarpet.admin") && target != null)
            {
                if(target == "all")
                {
                    DestroyAllCarpets(player);
                    return;
                }
                var players = FindPlayers(target);
                if (players.Count <= 0)
                {
                    PrintMsgL(player, "PlayerNotFound", target);
                    return;
                }
                if (players.Count > 1)
                {
                    PrintMsgL(player, "MultiplePlayers", target, string.Join(", ", players.Select(p => p.displayName).ToArray()));
                    return;
                }
                var targetPlayer = players.First();
                RemoveCarpet(targetPlayer);
                DestroyRemoteCarpet(targetPlayer);
            }
            else
            {
                RemoveCarpet(player);
                DestroyLocalCarpet(player);
            }
        }

        [Command("fchelp"), Permission("flyingcarpet.use")]
        void cmdCarpetHelp(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            if(!iplayer.HasPermission("flyingcarpet.use")) { PrintMsgL(player, "notauthorized"); return; }
            PrintMsgL(player, "helptext1");
            PrintMsgL(player, "helptext2");
            PrintMsgL(player, "helptext3");
            PrintMsgL(player, "helptext4");
        }
        #endregion

        #region Hooks
        // This is how we take off or land the carpet!
        object OnOvenToggle(BaseOven oven, BasePlayer player)
        {
            bool rtrn = false; // Must match other plugins with this call to avoid conflicts. QuickSmelt uses false

            CarpetEntity activecarpet;

            try
            {
                activecarpet = player.GetMounted().GetComponentInParent<CarpetEntity>() ?? null;
                if(activecarpet == null)
                {
                    oven.StopCooking();
                    return rtrn;
                }
            }
            catch
            {
                return null;
            }

            if(activecarpet.carpetlock != null && activecarpet.carpetlock.IsLocked()) { PrintMsgL(player, "carpetlocked"); return rtrn; }
            if(!player.isMounted) return rtrn; // player offline, does not mean ismounted on carpet

            if(player.GetMounted() != activecarpet.entity) return rtrn; // online player not in seat on carpet
#if DEBUG
            Puts("OnOvenToggle: Player cycled lantern!");
#endif
            if(oven.IsOn())
            {
                oven.StopCooking();
            }
            else
            {
                oven.StartCooking();
            }
            if(!activecarpet.FuelCheck())
            {
                if(activecarpet.needfuel)
                {
                    PrintMsgL(player, "nofuel");
                    PrintMsgL(player, "landingcarpet");
                    activecarpet.engineon = false;
                }
            }
            var ison = activecarpet.engineon;
            if(ison) { activecarpet.islanding = true; PrintMsgL(player, "landingcarpet"); return null; }
            if(!ison) { AddPlayerToPilotsList(player); activecarpet.engineon = true; return null; }

            return rtrn;
        }

        // Check for carpet lantern fuel
        void OnFuelConsume(BaseOven oven, Item fuel, ItemModBurnable burnable)
        {
            // Only work on lanterns
            if(oven.ShortPrefabName != "lantern.deployed") return;
            int dbl = doublefuel ? 4 : 2;

            BaseEntity lantern = oven as BaseEntity;
            // Only work on lanterns attached to a Carpet
            var activecarpet = lantern.GetComponentInParent<CarpetEntity>() ?? null;
            if(activecarpet == null) return;
#if DEBUG
            Puts("OnConsumeFuel: found a carpet lantern!");
#endif
            if(activecarpet.needfuel)
            {
#if DEBUG
                Puts("OnConsumeFuel: carpet requires fuel!");
#endif
            }
            else
            {
#if DEBUG
                Puts("OnConsumeFuel: carpet does not require fuel!");
#endif
                fuel.amount++; // Required to keep it from decrementing
                return;
            }
            BasePlayer player = activecarpet.GetComponent<BaseMountable>().GetMounted() as BasePlayer;
            if(!player) return;
#if DEBUG
            Puts("OnConsumeFuel: checking fuel level...");
#endif
            // Before it drops to 1 (3 for doublefuel) AFTER this hook call is complete, warn them that the fuel is low (1) - ikr
            if(fuel.amount == dbl)
            {
#if DEBUG
                Puts("OnConsumeFuel: sending low fuel warning...");
#endif
                if(playemptysound)
                {
                    Effect.server.Run("assets/bundled/prefabs/fx/well/pump_down.prefab", player.transform.position);
                }
                PrintMsgL(player, "lowfuel");
            }

            if(doublefuel)
            {
                fuel.amount--;
            }

            if(fuel.amount == 0)
            {
#if DEBUG
                Puts("OnConsumeFuel: out of fuel.");
#endif
                PrintMsgL(player, "lowfuel");
                var ison = activecarpet.engineon;
                if(ison)
                {
                    activecarpet.islanding = true;
                    activecarpet.engineon = false;
                    PrintMsgL(player, "landingcarpet");
                    OnOvenToggle(oven, player);
                    return;
                }
            }
        }

        // To skip cycling our lantern (thanks, k11l0u)
        private object OnNightLanternToggle(BaseEntity entity, bool status)
        {
            // Only work on lanterns
            if(entity.ShortPrefabName != "lantern.deployed") return null;
#if DEBUG
            Puts("OnNightLanternToggle: Called on a lantern.  Checking for carpet...");
#endif

            // Only work on lanterns attached to a Carpet
            var activecarpet = entity.GetComponentInParent<CarpetEntity>() ?? null;
            if(activecarpet != null)
            {
#if DEBUG
                Puts("OnNightLanternToggle: Do not cycle this lantern!");
#endif
                return true;
            }
#if DEBUG
            Puts("OnNightLanternToggle: Not a carpet lantern.");
#endif
            return null;
        }
        #endregion

        #region Primary
        private void AddCarpet(BasePlayer player, Vector3 location)
        {
            if(player == null && location == null) return;
            if(location == null && player != null) location = player.transform.position;
            Vector3 spawnpos = new Vector3();

            // Set initial default for fuel requirement based on config
            bool needfuel = requirefuel;
            if(isAllowed(player, "flyingcarpet.unlimited"))
            {
                // User granted unlimited fly time without fuel
                needfuel = false;
#if DEBUG
                Puts("AddCarpet: Unlimited fuel granted!");
#endif
            }

            if(needfuel)
            {
                // Don't put them on the carpet since they need to fuel up first
                spawnpos = player.transform.position + -player.transform.forward * 2f + new Vector3(0, 1f, 0);
            }
            else
            {
                // Spawn at point of player
                spawnpos = new Vector3(location.x, location.y + 0.5f, location.z);
            }

            string staticprefab = "assets/bundled/prefabs/static/chair.invisible.static.prefab";
            newCarpet = GameManager.server.CreateEntity(staticprefab, spawnpos, new Quaternion(), true);
            newCarpet.name = "FlyingCarpet";
            var chairmount = newCarpet.GetComponent<BaseMountable>();
            chairmount.isMobile = true;
            newCarpet.enableSaving = false;
            newCarpet.OwnerID = player.userID;
            newCarpet.skinID = chairSkinID;
            newCarpet.Spawn();
            var carpet = newCarpet.gameObject.AddComponent<CarpetEntity>();
            carpet.needfuel = needfuel;
            // Unlock the tank if they need fuel.
            carpet.lantern1.SetFlag(BaseEntity.Flags.Locked, !needfuel);
            if(needfuel)
            {
#if DEBUG
                // We have to set this after the spawn.
                Puts("AddCarpet: Emptying the tank!");
#endif
                carpet.SetFuel(0);
            }

            // paint sign with username
            if(SignArtist && nameOnSign)
            {
                // This only works with version 1.1.7 on
                if(SignArtist.Version >= new VersionNumber(1, 1, 7))
                {
                    string message = player.displayName;
                    int fontsize = Convert.ToInt32(Math.Floor(150f / message.Length));
                    SignArtist.Call("signText", player, carpet.sign, message, fontsize, "00FF00", "000000");
                }
            }
            carpet.sign.SetFlag(BaseEntity.Flags.Locked, true);

            AddPlayerID(player.userID);

            if(chairmount != null && player != null)
            {
                PrintMsgL(player, "carpetspawned");
                if(carpet.needfuel)
                {
                    PrintMsgL(player, "carpetfuel");
                }
                else
                {
                    // Put them in the chair.  They will still need to unlock it.
                    PrintMsgL(player, "carpetnofuel");
                    chairmount.MountPlayer(player);
                }
                return;
            }
        }

        public bool PilotListContainsPlayer(BasePlayer player)
        {
            if(pilotslist.Contains(player.userID)) return true;
            return false;
        }

        void AddPlayerToPilotsList(BasePlayer player)
        {
            if(PilotListContainsPlayer(player)) return;
            pilotslist.Add(player.userID);
        }

        public void RemovePlayerFromPilotsList(BasePlayer player)
        {
            if(PilotListContainsPlayer(player))
            {
                pilotslist.Remove(player.userID);
                return;
            }
        }

        void DestroyLocalCarpet(BasePlayer player)
        {
            if(player == null) return;
            List<BaseEntity> carpetlist = new List<BaseEntity>();
            Vis.Entities<BaseEntity>(player.transform.position, MinDistance, carpetlist);
            bool foundcarpet = false;

            foreach(BaseEntity p in carpetlist)
            {
                var foundent = p.GetComponentInParent<CarpetEntity>() ?? null;
                if(foundent != null)
                {
                    foundcarpet = true;
                    if(foundent.ownerid != player.userID) return;
                    foundent.entity.Kill(BaseNetworkable.DestroyMode.Gib);
                    PrintMsgL(player, "carpetdestroyed");
                }
            }
            if(!foundcarpet)
            {
                PrintMsgL(player, "notfound", MinDistance.ToString());
            }
        }

        void DestroyAllCarpets(BasePlayer player)
        {
            List<BaseEntity> carpetlist = new List<BaseEntity>();
            Vis.Entities<BaseEntity>(new Vector3(0,0,0), 3500f, carpetlist);
            bool foundcarpet = false;

            foreach(BaseEntity p in carpetlist)
            {
                var foundent = p.GetComponentInParent<CarpetEntity>() ?? null;
                if(foundent != null)
                {
                    foundcarpet = true;
                    foundent.entity.Kill(BaseNetworkable.DestroyMode.Gib);
                    PrintMsgL(player, "carpetdestroyed");
                }
            }
            if(!foundcarpet)
            {
                PrintMsgL(player, "notfound", MinDistance.ToString());
            }
        }

        void DestroyRemoteCarpet(BasePlayer player)
        {
            if(player == null) return;
            List<BaseEntity> carpetlist = new List<BaseEntity>();
            Vis.Entities<BaseEntity>(new Vector3(0,0,0), 3500f, carpetlist);
            bool foundcarpet = false;

            foreach(BaseEntity p in carpetlist)
            {
                var foundent = p.GetComponentInParent<CarpetEntity>() ?? null;
                if(foundent != null)
                {
                    foundcarpet = true;
                    if(foundent.ownerid != player.userID) return;
                    foundent.entity.Kill(BaseNetworkable.DestroyMode.Gib);
                    PrintMsgL(player, "carpetdestroyed");
                }
            }
            if(!foundcarpet)
            {
                PrintMsgL(player, "notfound", MinDistance.ToString());
            }
        }

        void OnPlayerInput(BasePlayer player, InputState input)
        {
            if(player == null || input == null) return;
            if(!player.isMounted) return;
            var activecarpet = player.GetMounted().GetComponentInParent<CarpetEntity>() ?? null;
            if(activecarpet == null) return;
            if(player.GetMounted() != activecarpet.entity) return;
            if(input != null)
            {
                activecarpet.CarpetInput(input, player);
            }
            return;
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if(entity == null || hitInfo == null) return;
            var iscarpet = entity.GetComponentInParent<CarpetEntity>() ?? null;
            if(iscarpet != null) hitInfo.damageTypes.ScaleAll(0);
            return;
        }

        object OnEntityGroundMissing(BaseEntity entity)
        {
            var iscarpet = entity.GetComponentInParent<CarpetEntity>() ?? null;
            if(iscarpet != null) return false;
            return null;
        }

        bool CarpetLimitReached(BasePlayer player, bool vip=false)
        {
            if(UseMaxCarpetChecks)
            {
                if(loadplayer.ContainsKey(player.userID))
                {
                    var currentcount = loadplayer[player.userID].carpetcount;
                    int maxallowed = maxcarpets;
                    if(vip)
                    {
                        maxallowed = vipmaxcarpets;
                    }
                    if(currentcount >= maxallowed) return true;
                }
            }
            return false;
        }

        object CanDismountEntity(BasePlayer player, BaseMountable entity)
        {
            if(player == null) return null;
            if(PilotListContainsPlayer(player)) return false;
            return null;
        }

        void OnEntityMounted(BaseMountable mountable, BasePlayer player)
        {
            var activecarpet = mountable.GetComponentInParent<CarpetEntity>() ?? null;
            if(activecarpet != null)
            {
#if DEBUG
                Puts("OnEntityMounted: player mounted copter!");
#endif
                if(mountable.GetComponent<BaseEntity>() != activecarpet.entity) return;
                activecarpet.lantern1.SetFlag(BaseEntity.Flags.On, false);
            }
        }

        void OnEntityDismounted(BaseMountable mountable, BasePlayer player)
        {
            var activecarpet = mountable.GetComponentInParent<CarpetEntity>() ?? null;
            if(activecarpet != null)
            {
#if DEBUG
                Puts("OnEntityMounted: player dismounted copter!");
#endif
                if(mountable.GetComponent<BaseEntity>() != activecarpet.entity) return;
            }
        }

        private object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if(container == null || player == null) return null;
            var iscarpet = container.GetComponentInParent<CarpetEntity>() ?? null;
            if(iscarpet != null)
            {
                if(iscarpet.carpetlock != null && iscarpet.carpetlock.IsLocked()) return false;
            }
            return null;
        }

        private object CanPickupEntity(BasePlayer player, BaseCombatEntity entity)
        {
            if(entity == null || player == null) return null;

            BaseEntity myent = entity as BaseEntity;
            string myparent = null;
            try
            {
                myparent = myent.GetParentEntity().name;
            }
            catch {}

            if(myparent == "FlyingCarpet" || myent.name == "FlyingCarpet")
            {
#if DEBUG
                if(myent.name == "FlyingCarpet")
                {
                    Puts("CanPickupEntity: player trying to pickup the carpet!");
                }
                else if(myparent == "FlyingCarpet")
                {
                    string entity_name = myent.LookupPrefab().name;
                    Puts($"CanPickupEntity: player trying to remove {entity_name} from a carpet!");
                }
#endif
                PrintMsgL(player, "notauthorized");
                return false;
            }
            return null;
        }

        private object CanPickupLock(BasePlayer player, BaseLock baseLock)
        {
            if(baseLock == null || player == null) return null;

            BaseEntity myent = baseLock as BaseEntity;
            string myparent = null;
            try
            {
                myparent = myent.GetParentEntity().name;
            }
            catch {}

            if(myparent == "FlyingCarpet")
            {
#if DEBUG
                Puts("CanPickupLock: player trying to remove lock from a carpet!");
#endif
                PrintMsgL(player, "notauthorized");
                return false;
            }
            return null;
        }

        void AddPlayerID(ulong ownerid)
        {
            if(!loadplayer.ContainsKey(ownerid))
            {
                loadplayer.Add(ownerid, new PlayerCarpetData
                {
                    carpetcount = 1,
                });
                return;
            }
            loadplayer[ownerid].carpetcount = loadplayer[ownerid].carpetcount + 1;
        }

        void RemovePlayerID(ulong ownerid)
        {
            if(loadplayer.ContainsKey(ownerid)) loadplayer[ownerid].carpetcount = loadplayer[ownerid].carpetcount - 1;
            return;
        }

        object OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            RemovePlayerFromPilotsList(player);
            return null;
        }

        void RemoveCarpet(BasePlayer player)
        {
            RemovePlayerFromPilotsList(player);
            return;
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            RemoveCarpet(player);
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            RemoveCarpet(player);
        }

        void DestroyAll<T>()
        {
            var objects = GameObject.FindObjectsOfType(typeof(T));
            if(objects != null)
            {
                foreach(var gameObj in objects)
                {
                    GameObject.Destroy(gameObj);
                }
            }
        }

        void Unload()
        {
            DestroyAll<CarpetEntity>();
        }
        #endregion

        #region Carpet Antihack check
        static List<BasePlayer> carpetantihack = new List<BasePlayer>();

        object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
        {
            if(player == null) return null;
            if(carpetantihack.Contains(player)) return false;
            return null;
        }
        #endregion

        #region Carpet Entity
        class CarpetEntity : BaseEntity
        {
            public BaseEntity entity;
            public BasePlayer player;
            public BaseEntity sitbox;
            public BaseEntity carpet1;
            public BaseEntity lantern1;
            public BaseEntity carpetlock;
            public BaseEntity lights1;
            public BaseEntity lights2;
            public BaseEntity sign;

            public string entname = "FlyingCarpet";

            Quaternion entityrot;
            Vector3 entitypos;

            public bool moveforward;
            public bool movebackward;
            public bool moveup;
            public bool movedown;
            public bool rotright;
            public bool rotleft;
            public bool sprinting;
            public bool islanding;
            public bool mounted;

            public bool engineon;
            public bool hasFuel;
            public bool needfuel;

            public ulong skinid = 1;
            public ulong ownerid;
            //int count;
            float minaltitude;
            FlyingCarpet instance;
            public bool throttleup;
            float sprintspeed;
            float normalspeed;
            //bool isenabled = true;
            SphereCollider sphereCollider;

            string prefabbox = "assets/prefabs/deployable/signs/sign.small.wood.prefab";
            string prefabcarpet = "assets/prefabs/deployable/rug/rug.deployed.prefab";
            string prefablamp = "assets/prefabs/deployable/lantern/lantern.deployed.prefab";
            string prefablights = "assets/prefabs/misc/xmas/christmas_lights/xmas.lightstring.deployed.prefab";
            string prefablock = "assets/prefabs/locks/keypad/lock.code.prefab";
            string prefabsign = "assets/prefabs/deployable/signs/sign.small.wood.prefab";

            void Awake()
            {
                entity = GetComponentInParent<BaseEntity>();
                entityrot = Quaternion.identity;
                entitypos = entity.transform.position;
                minaltitude = MinAltitude;
                instance = new FlyingCarpet();
                ownerid = entity.OwnerID;
                gameObject.name = "FlyingCarpet";

                engineon = false;
                hasFuel = false;
                //needfuel = requirefuel;
                if(!needfuel)
                {
                    hasFuel = true;
                }
                moveforward = false;
                movebackward = false;
                moveup = false;
                movedown = false;
                rotright = false;
                rotleft = false;
                sprinting = false;
                islanding = false;
                mounted = false;
                throttleup = false;
                sprintspeed = SprintSpeed;
                normalspeed = NormalSpeed;
                //isenabled = false;
                skinid = rugSkinID;
                SpawnCarpet();
                lantern1.OwnerID = entity.OwnerID;
                sign.OwnerID = entity.OwnerID;

                sphereCollider = entity.gameObject.AddComponent<SphereCollider>();
                sphereCollider.gameObject.layer = (int)Layer.Reserved1;
                sphereCollider.isTrigger = true;
                sphereCollider.radius = 6f;
            }

            BaseEntity SpawnPart(string prefab, BaseEntity entitypart, bool setactive, int eulangx, int eulangy, int eulangz, float locposx, float locposy, float locposz, BaseEntity parent, ulong skinid)
            {
                entitypart = new BaseEntity();
                entitypart = GameManager.server.CreateEntity(prefab, entitypos, entityrot, setactive);
                entitypart.transform.localEulerAngles = new Vector3(eulangx, eulangy, eulangz);
                entitypart.transform.localPosition = new Vector3(locposx, locposy, locposz);

                entitypart.SetParent(parent, 0);
                entitypart.skinID = skinid;
                entitypart?.Spawn();
                SpawnRefresh(entitypart);
                return entitypart;
            }

            void SpawnRefresh(BaseEntity entity)
            {
                var hasstab = entity.GetComponent<StabilityEntity>() ?? null;
                if(hasstab != null)
                {
                    hasstab.grounded = true;
                }
                var hasmount = entity.GetComponent<BaseMountable>() ?? null;
                if(hasmount != null)
                {
                    hasmount.isMobile = true;
                }
            }

            public void SetFuel(int amount = 0)
            {
                BaseOven lanternCont = lantern1 as BaseOven;
                ItemContainer container1 = lanternCont.inventory;

                if(amount == 0)
                {
                    while(container1.itemList.Count > 0)
                    {
                        var item = container1.itemList[0];
                        item.RemoveFromContainer();
                        item.Remove(0f);
                    }
                }
                else
                {
                    Item addfuel = ItemManager.CreateByItemID(-946369541, amount);
                    container1.itemList.Add(addfuel);
                    addfuel.parent = container1;
                    addfuel.MarkDirty();
                }
            }

            public void SpawnCarpet()
            {
                sitbox = SpawnPart(prefabbox, sitbox, false, 90, 0, 0, -0.01f, 0.5f, -0.1f, entity, skinid);
				sitbox.SetFlag(BaseEntity.Flags.Locked, true);
                carpet1 = SpawnPart(prefabcarpet, carpet1, false, 0, 0, 0, 0f, 0.3f, 0f, entity, skinid);
                carpet1.SetFlag(BaseEntity.Flags.Busy, true, true);
				carpet1.SetFlag(BaseEntity.Flags.Locked, true);

                lantern1 = SpawnPart(prefablamp, lantern1, true, 0, 0, 0, 0f, 0.3f, 1f, entity, 1);
                lantern1.SetFlag(BaseEntity.Flags.On, false);
                carpetlock = SpawnPart(prefablock, carpetlock, true, 0, 90, 90, 0.5f, 0.3f, 0.7f, entity, 1);
                sign = SpawnPart(prefabsign, sign, true, -45, 0, 0, 0, 0.25f, 1.75f, entity, 1);

                if(needfuel)
                {
                    // Empty tank
                    SetFuel(0);
                }
                else
                {
                    // Cannot be looted
                    lantern1.SetFlag(BaseEntity.Flags.Locked, true);
                    // Add some fuel (1 lgf) so it lights up anyway.  It should always stay at 1.
                    SetFuel(1);
                }

                lights1 = SpawnPart(prefablights, lights1, true, 0, 90, 0, 0.8f, 0.31f, 0.1f, entity, 1);
                lights1.SetFlag(BaseEntity.Flags.Busy, true);
                lights2 = SpawnPart(prefablights, lights2, true, 0, 90, 0, -0.9f, 0.31f, 0.1f, entity, 1);
                lights2.SetFlag(BaseEntity.Flags.Busy, true);
                sitbox.SetFlag(BaseEntity.Flags.Busy, true);
            }

            private void OnTriggerEnter(Collider col)
            {
                var target = col.GetComponentInParent<BasePlayer>();
                if(target != null)
                {
                    carpetantihack.Add(target);
                }
            }

            private void OnTriggerExit(Collider col)
            {
                var target = col.GetComponentInParent<BasePlayer>();
                if(target != null)
                {
                    carpetantihack.Remove(target);
                }
            }

            BasePlayer GetPilot()
            {
                player = entity.GetComponent<BaseMountable>().GetMounted() as BasePlayer;
                return player;
            }

            public void CarpetInput(InputState input, BasePlayer player)
            {
                if(input == null || player == null) return;
                if(input.WasJustPressed(BUTTON.FORWARD)) moveforward = true;
                if(input.WasJustReleased(BUTTON.FORWARD)) moveforward = false;
                if(input.WasJustPressed(BUTTON.BACKWARD)) movebackward = true;
                if(input.WasJustReleased(BUTTON.BACKWARD)) movebackward = false;
                if(input.WasJustPressed(BUTTON.RIGHT)) rotright = true;
                if(input.WasJustReleased(BUTTON.RIGHT)) rotright = false;
                if(input.WasJustPressed(BUTTON.LEFT)) rotleft = true;
                if(input.WasJustReleased(BUTTON.LEFT)) rotleft = false;
                if(input.IsDown(BUTTON.SPRINT)) throttleup = true;
                if(input.WasJustReleased(BUTTON.SPRINT)) throttleup = false;
                if(input.WasJustPressed(BUTTON.JUMP)) moveup = true;
                if(input.WasJustReleased(BUTTON.JUMP)) moveup = false;
                if(input.WasJustPressed(BUTTON.DUCK)) movedown = true;
                if(input.WasJustReleased(BUTTON.DUCK)) movedown = false;
            }

            public bool FuelCheck()
            {
                if(!needfuel)
                {
                    return true;
                }
                BaseOven lantern = lantern1 as BaseOven;
                Item slot = lantern.inventory.GetSlot(0);
                if(slot == null)
                {
                    islanding = true;
                    hasFuel = false;
                    return false;
                }
                else
                {
                    hasFuel = true;
                    return true;
                }
            }

            void FixedUpdate()
            {
                if(engineon)
                {
                    if(!GetPilot()) islanding = true;
                    var currentspeed = normalspeed;
                    if(throttleup) { currentspeed = sprintspeed; }

                    // This is a little weird.  Fortunately, some of the hooks determine fuel status...
                    if(!hasFuel)
                    {
                        if(needfuel)
                        {
                            islanding = false;
                            engineon = false;
                            return;
                        }
                    }
                    if(islanding)
                    {
                        entity.transform.localPosition += (transform.up * -5f) * Time.deltaTime;
                        RaycastHit hit;
                        if(Physics.Raycast(new Ray(entity.transform.position, Vector3.down), out hit, 1f, layerMask))
                        {
                            islanding = false;
                            engineon = false;
                            if(pilotslist.Contains(player.userID))
                            {
                                pilotslist.Remove(player.userID);
                            }
                        }
                        ResetMovement();
                        ServerMgr.Instance.StartCoroutine(RefreshTrain());
                        return;
                    }

                    if(Physics.Raycast(new Ray(entity.transform.position, Vector3.down), minaltitude, layerMask))
                    {
                        entity.transform.localPosition += transform.up * minaltitude * Time.deltaTime;
                        ServerMgr.Instance.StartCoroutine(RefreshTrain());
                        return;
                    }

                    if(rotright) entity.transform.eulerAngles += new Vector3(0, 2, 0);
                    else if(rotleft) entity.transform.eulerAngles += new Vector3(0, -2, 0);

                    if(moveforward) entity.transform.localPosition += ((transform.forward * currentspeed) * Time.deltaTime);
                    else if(movebackward) entity.transform.localPosition = entity.transform.localPosition - ((transform.forward * currentspeed) * Time.deltaTime);

                    if(moveup) entity.transform.localPosition += ((transform.up * currentspeed) * Time.deltaTime);
                    else if(movedown) entity.transform.localPosition += ((transform.up * -currentspeed) * Time.deltaTime);

                    ServerMgr.Instance.StartCoroutine(RefreshTrain());
                }
            }

            private IEnumerator RefreshTrain()
            {
                entity.transform.hasChanged = true;
                for(int i = 0; i < entity.children.Count; i++)
                {
                    entity.children[i].transform.hasChanged = true;
                    entity.children[i].SendNetworkUpdateImmediate();
                    entity.children[i].UpdateNetworkGroup();
                }
                entity.SendNetworkUpdateImmediate();
                entity.UpdateNetworkGroup();
                yield return new WaitForEndOfFrame();
            }

            void ResetMovement()
            {
                moveforward = false;
                movebackward = false;
                moveup = false;
                movedown = false;
                rotright = false;
                rotleft = false;
                throttleup = false;
            }

            public void OnDestroy()
            {
                if(loadplayer.ContainsKey(ownerid)) loadplayer[ownerid].carpetcount = loadplayer[ownerid].carpetcount - 1;
                if(entity != null) { entity.Invoke("KillMessage", 0.1f); }
            }
        }
        #endregion
    }
}

// --- End of file: FlyingCarpet.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/flying-vehicle ---
// --- Original File Path: F/FlyingVehicle/FlyingVehicle.cs ---

using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;
using Physics = UnityEngine.Physics;

namespace Oxide.Plugins
{
    [Info("Flying Vehicle", "misticos", "1.0.3")]
    [Description("Make vehicles fly on your server")]
    class FlyingVehicle : CovalencePlugin
    {
        #region Variables

        private const string PermissionUse = "flyingvehicle.use";

        private const string PrefabBoat = "assets/content/vehicles/boats/rowboat/rowboat.prefab";
        private const string PrefabRhib = "assets/content/vehicles/boats/rhib/rhib.prefab";
        private const string PrefabSedan = "assets/content/vehicles/sedan_a/sedantest.entity.prefab";

        private const string PrefabSeat = "assets/prefabs/vehicle/seats/copilotseat.prefab";

        private string _seatGuid = string.Empty;
        
        #endregion
        
        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(PermissionUse, this);
            
            AddCovalenceCommand("flyingvehicle.spawn", nameof(CommandSpawn));
            AddCovalenceCommand("flyingvehicle.claim", nameof(CommandClaim));
        }

        private void OnServerInitialized()
        {
            // Find the GUID of the seat we need
            // It is a foreach because pathToGuid is internal
            foreach (var x in GameManifest.guidToPath)
            {
                if (x.Value == PrefabSeat)
                    _seatGuid = x.Key;
            }
        }

        private void Unload()
        {
            foreach (var boat in UnityEngine.Object.FindObjectsOfType<VehicleController>())
                UnityEngine.Object.DestroyImmediate(boat.gameObject);
        }

        private void OnPlayerInput(BasePlayer player, InputState state)
        {
            var vehicle = player.GetMountedVehicle()?.GetComponent<VehicleController>(); // TODO: Toggle collider
            if (vehicle == null || vehicle.Vehicle.GetDriver() != player)
                return;

            if (state.WasJustPressed(BUTTON.USE))
            {
                vehicle.Toggle();
            }

            /*
            if (state.WasJustPressed(BUTTON.DUCK))
            {
                foreach (var rigidbody in vehicle.Vehicle.GetComponentsInChildren<Rigidbody>())
                    rigidbody.detectCollisions = !rigidbody.detectCollisions;
            }
            */
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"No Permission", "You do not have enough permissions to do this (flyingvehicle.use)."},
                {"Command: Spawn: Syntax", "Syntax (flyingvehicle.spawn):\n" +
                                           "(rhib/car/boat)"},
                {"Command: Spawn: Spawned", "Your vehicle was spawned."},
                {"Command: Spawn: Unknown Prefab", "Entity was not spawned, contact the developer."},
                {"Command: Claim: Player Only", "You should be in the game to run this command."},
                {"Command: Claim: Unknown Entity", "We were unable to get this entity or it is already spawned with this plugin."},
                {"Command: Claim: Claimed", "We have successfully modified this entity."}
            }, this);
        }

        #endregion
        
        #region Commands

        private void CommandSpawn(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PermissionUse))
            {
                player.Reply(GetMsg("No Permission", player.Id));
                return;
            }

            var basePlayer = player.Object as BasePlayer;
            if (basePlayer == null)
                return;

            RaycastHit hit;
            if (!Physics.Raycast(basePlayer.eyes.HeadRay(), out hit))
                return;

            var position = hit.point;
            var type = args.Length > 0 ? args[0] : string.Empty;
            var prefab = string.Empty;
            
            switch (type)
            {
                case "rhib":
                {
                    prefab = PrefabRhib;
                    break;
                }

                case "car":
                {
                    prefab = PrefabSedan;
                    break;
                }
                
                case "boat":
                {
                    prefab = PrefabBoat;
                    break;
                }
            }

            if (string.IsNullOrEmpty(prefab))
            {
                player.Reply(GetMsg("Command: Spawn: Syntax", player.Id));
                return;
            }

            var entity = GameManager.server.CreateEntity(prefab, position + Vector3.up * 3f) as BaseVehicle;
            if (entity == null)
            {
                player.Reply(GetMsg("Command: Spawn: Unknown Prefab", player.Id));
                return;
            }

            Setup(entity);
        }

        private void CommandClaim(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PermissionUse))
            {
                player.Reply(GetMsg("No Permission", player.Id));
                return;
            }

            var basePlayer = player.Object as BasePlayer;
            if (basePlayer == null)
            {
                player.Reply(GetMsg("Command: Claim: Player Only", player.Id));
                return;
            }

            var entity = basePlayer.GetMountedVehicle();
            if (entity == null || entity.GetComponent<VehicleController>() != null)
            {
                player.Reply(GetMsg("Command: Claim: Unknown Entity", player.Id));
                return;
            }

            Setup(entity);
            
            player.Reply(GetMsg("Command: Claim: Claimed", player.Id));
        }

        private object OnVehiclePush(BaseVehicle boat, BasePlayer player)
        {
            if (boat.GetComponent<VehicleController>()?.IsEnabled ?? false)
                return false;
            
            return null;
        }

        // ReSharper disable once SuggestBaseTypeForParameter
        private object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if (container.GetParentEntity()?.GetComponent<VehicleController>()?.IsEnabled ?? false)
                return false;

            return null;
        }
        
        #endregion
        
        #region Helpers

        private void Setup(BaseVehicle entity)
        {
            if (entity.mountPoints.Count > 0)
                entity.mountPoints[0].prefab.guid = _seatGuid; // Assign new driver seat so that you cannot look around

            if (!entity.isSpawned)
            {
                entity.Spawn();
            }
            else
            {
                entity.DismountAllPlayers();
                
                // Delete all old seats
                foreach (var mount in entity.mountPoints)
                    mount.mountable.Kill();
                
                // Respawn all new seats including the modified driver one
                entity.SpawnSubEntities();
            }

            var boat = entity as BaseBoat;
            if (boat != null)
            {
                boat.engineThrust = 0.0f;
                boat.steeringScale = 0.0f;
                boat.buoyancy.doEffects = false;
                boat.buoyancy.buoyancyScale = 0.0f;
                boat.buoyancy.flowMovementScale = 0.0f;

                foreach (var point in boat.buoyancy.points)
                {
                    point.doSplashEffects = false;
                    point.waveScale = 0.0f;
                    point.waveFrequency = 0.0f;
                }
            }

            var car = entity as BasicCar;
            if (car != null)
            {
                foreach (var wheel in car.wheels)
                {
                    var col = wheel.wheelCollider;
                    
                    col.suspensionDistance = 0.2f;
                    col.suspensionSpring = new JointSpring
                    {
                        damper = 200,
                        targetPosition = 0.3f,
                        spring = 2000
                    };
                }
            }

            foreach (var mount in entity.mountPoints)
            {
                // You should not be able to hold items!
                mount.mountable.canWieldItems = false;
            }
            
            entity.gameObject.AddComponent<VehicleController>();
        }
        
        #endregion
        
        #region Controller

        private class VehicleController : FacepunchBehaviour
        {
            public Rigidbody Rigidbody;
            public BaseVehicle Vehicle;
            public bool IsEnabled = false;

            private void Awake()
            {
                Rigidbody = GetComponent<Rigidbody>();
                Vehicle = GetComponent<BaseVehicle>();

                Rigidbody.velocity = Vector3.down;
                Rigidbody.mass = 50f;
                Rigidbody.angularVelocity = Vector3.zero;
                Rigidbody.centerOfMass = new Vector3(0.0f, -0.2f, 1.4f);
                Rigidbody.inertiaTensor = new Vector3(220.8f, 207.3f, 55.5f);
            }

            private void OnDestroy()
            {
                if (Vehicle != null && !Vehicle.IsDestroyed)
                    Vehicle.Kill();
            }

            private void FixedUpdate()
            {
                if ((Vehicle?.IsDestroyed ?? true) || Rigidbody == null)
                {
                    DestroyImmediate(this);
                    return;
                }

                // yes.
                Rigidbody.drag = 0.6f;
                Rigidbody.angularDrag = 5.0f;

                if (!IsEnabled)
                    return;

                var driver = Vehicle.GetDriver();
                if (driver == null)
                    return;
                
                var input = driver.serverInput;
                if (input.IsDown(BUTTON.RELOAD))
                {
                    // STOP!
                    Rigidbody.drag *= 5;
                    Rigidbody.angularDrag *= 2;
                }
                
                /*
                 * FORCE (MOVEMENT)
                 */

                var direction = Vector3.zero;

                if (input.IsDown(BUTTON.FORWARD))
                    direction += Vector3.forward;

                if (input.IsDown(BUTTON.BACKWARD))
                    direction += Vector3.back;

                if (direction != Vector3.zero)
                {
                    const float moveSpeed = 500f;
                    var speed = input.IsDown(BUTTON.SPRINT) ? moveSpeed * 3f : moveSpeed;

                    Rigidbody.AddRelativeForce(direction * speed, ForceMode.Force);
                }

                /*
                 * TORQUE (ROTATION)
                 */
                
                // PLEASE! Let me know if you have better ideas regarding rotation and making it smoother, better, et cetera.
                
                var torque = Vector3.zero;

                const float rotationSpeed = 700f;
                if (input.IsDown(BUTTON.LEFT))
                {
                    torque += new Vector3(0, -rotationSpeed, 0);
                }

                if (input.IsDown(BUTTON.RIGHT))
                {
                    torque += new Vector3(0, rotationSpeed, 0);
                }

                const float mouseSpeedY = 400f;
                const float mouseSpeedX = 100f;

                var mouse = input.current.mouseDelta;
                torque += new Vector3(mouse.y * mouseSpeedY, 0, mouse.x * -mouseSpeedX);
                
                Rigidbody.AddRelativeTorque(torque, ForceMode.Force);
            }

            public void Toggle()
            {
                if (IsEnabled)
                {
                    Rigidbody.useGravity = true;
                }
                else
                {
                    Rigidbody.useGravity = false;
                    Rigidbody.AddForce(Vector3.up * 50f, ForceMode.Impulse);
                }

                IsEnabled = !IsEnabled;
            }
        }
        
        #endregion
        
        #region Helpers

        private string GetMsg(string key, string userId = null) => lang.GetMessage(key, this, userId);

        #endregion
    }
}

// --- End of file: FlyingVehicle.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/free-cctv ---
// --- Original File Path: F/FreeCCTV/FreeCCTV.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Free CCTV", "mspeedie", "0.1.2")]
    [Description("Allows CCTVs to operate without electricity.")]
    
    class FreeCCTV : RustPlugin
    {
        #region Initialization
        void OnServerInitialized()
        {
            ChangePower(999999);
        }
        #endregion
        
        #region cctv
        void OnEntitySpawned(CCTV_RC cctv)
        {
            cctv.UpdateHasPower(999999, 1);
            cctv.SendNetworkUpdateImmediate();
        }
         
        void ChangePower(int amt)
        {
            foreach (var cctv in UnityEngine.Object.FindObjectsOfType<CCTV_RC>())
            {
                cctv.UpdateHasPower(amt, 1);
				cctv.SendNetworkUpdateImmediate();
            }
        }
        void Unload()
        {
            ChangePower(0);
        }
        #endregion
    }
}

// --- End of file: FreeCCTV.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/fixed-headshot-sounds ---
// --- Original File Path: F/FixedHeadshotSounds/FixedHeadshotSounds.cs ---

﻿using UnityEngine;

namespace Oxide.Plugins
{
    [Info( "Fixed Headshot Sounds", "Waggy", "1.0.1" )]
    [Description( "Fixes headshot sounds not playing for melee PvP and for animals" )]

    class FixedHeadshotSounds : RustPlugin
    {
        public static Effect headshotEffect;

        public void CreateHeadshotEffect( BasePlayer player )
        {
            headshotEffect = new Effect();
            headshotEffect.Init( Effect.Type.Generic, player, 0, Vector3.zero, Vector3.zero, null );
            headshotEffect.pooledString = "assets/bundled/prefabs/fx/headshot.prefab";
        }

        public void SendHeadshotEffect( BasePlayer player )
        {
            EffectNetwork.Send( headshotEffect, player.Connection );
        }

        public void CheckHeadshot( HitInfo info )
        {
            var player = info.InitiatorPlayer;

            if ( player != null )
            {
                if ( headshotEffect == null )
                {
                    CreateHeadshotEffect( player );
                }
                
                SendHeadshotEffect( player );
            }
        }

        object OnEntityTakeDamage( BaseCombatEntity entity, HitInfo info )
        {
            if ( entity is BaseNpc && info.isHeadshot )
            {
                CheckHeadshot( info );
            }
            else if ( entity is BasePlayer && info.isHeadshot )
            {
                switch ( info.damageTypes.GetMajorityDamageType() )
                {
                    default: return null;

                    case Rust.DamageType.Blunt:
                    case Rust.DamageType.Slash:
                    case Rust.DamageType.Stab:
                        {
                            CheckHeadshot( info );
                            return null;
                        }
                }
            }

            return null;
        }
    }
}

// --- End of file: FixedHeadshotSounds.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/furnace-splitter ---
// --- Original File Path: F/FurnaceSplitter/FurnaceSplitter.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

/*
v2.5.0 - Clearshot

fixed cookable item splitting
fixed auto fuel
fixed ui updating when disabled
fixed fuel and time calculations
fixed bugs with right clicking items into furnace
fixed FormatTime displaying long decimal points
clamp total stacks to 1 instead of 0

added support for multiple items
added support for splitting stack from rust item splitter ui
added support for multiple fuel slots
added config option for enabing/disabling furnace splitter per furnace
added config option for fuel multiplier per furnace
added config option for saving player data

dynamically generate oven config
dynamically generate initialStackOptions

notes:
before updating from 2.4.1 -> 2.5.0
    - unload FurnaceSplitter (oxide.unload furnacesplitter)
    - delete /oxide/data/FurnaceSplitter.json
    - optionally delete /oxide/config/FurnaceSplitter.json, but it should update with new config options automatically
*/

namespace Oxide.Plugins
{
    [Info("Furnace Splitter", "FastBurst", "2.5.2")]
    [Description("Splits up resources in furnaces automatically and shows useful furnace information")]
    public class FurnaceSplitter : RustPlugin
    {
        [PluginReference]
        private Plugin UIScaleManager;

        private class OvenSlot
        {
            /// <summary>The item in this slot. May be null.</summary>
            public Item Item;

            /// <summary>The slot position</summary>
            public int? Position;

            /// <summary>The slot's index in the itemList list.</summary>
            public int Index;

            /// <summary>How much should be added/removed from stack</summary>
            public int DeltaAmount;
        }

        public class OvenInfo
        {
            public float ETA;
            public float FuelNeeded;
        }

        private class StoredData
        {
            public Dictionary<ulong, PlayerOptions> AllPlayerOptions { get; private set; } = new Dictionary<ulong, PlayerOptions>();
        }

        private class PlayerOptions
        {
            public bool Enabled;
            public Dictionary<string, int> TotalStacks = new Dictionary<string, int>();
        }

        public enum MoveResult
        {
            Ok,
            SlotsFilled,
            NotEnoughSlots
        }

        private StoredData storedData = new StoredData();
        private Dictionary<ulong, PlayerOptions> allPlayerOptions => storedData.AllPlayerOptions;
        private Dictionary<string, int> initialStackOptions = new Dictionary<string, int>();
        private PluginConfig config;

        private const string permUse = "furnacesplitter.use";

        private readonly Dictionary<ulong, string> openUis = new Dictionary<ulong, string>();
        private readonly Dictionary<BaseOven, List<BasePlayer>> looters = new Dictionary<BaseOven, List<BasePlayer>>();
        private readonly Stack<BaseOven> queuedUiUpdates = new Stack<BaseOven>();

        private void Init()
        {
            permission.RegisterPermission(permUse, this);
        }

        private void OnServerInitialized()
        {
            var saveCfg = false;
            foreach (var prefab in GameManifest.Current.entities)
            {
                var gameObj = GameManager.server.FindPrefab(prefab);
                if (gameObj == null) continue;

                var oven = gameObj.GetComponent<BaseOven>();
                if (oven != null && oven.allowByproductCreation) // ignore pumpkins, lanterns, etc
                {
                    if (!initialStackOptions.ContainsKey(oven.ShortPrefabName))
                    {
                        //Puts($"Add oven [{oven.ShortPrefabName}] - fuelSlots: {oven.fuelSlots}, inputSlots: {oven.inputSlots}, outputSlots: {oven.outputSlots}");
                        initialStackOptions[oven.ShortPrefabName] = oven.inputSlots;
                    }

                    if (!config.ovens.ContainsKey(oven.ShortPrefabName))
                    {
                        config.ovens[oven.ShortPrefabName] = new PluginConfig.OvenConfig {
                            enabled = false, // global '*' is enabled by default, disable all oven configs
                            fuelMultiplier = 1.0f
                        };
                        saveCfg = true;
                    }
                }
            }

            if (saveCfg)
                SaveConfig();

            Unsubscribe(nameof(OnServerSave));
            if (config.savePlayerData)
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name) ?? new StoredData();
                Subscribe(nameof(OnServerSave));
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            DestroyUI(player);
        }

        private void OnServerSave()
        {
            SaveData();
        }

        private void SaveData()
        {
            if (!config.savePlayerData) return;

            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }

        private void InitPlayer(BasePlayer player)
        {
            if (!allPlayerOptions.ContainsKey(player.userID))
            {
                allPlayerOptions[player.userID] = new PlayerOptions
                {
                    Enabled = true,
                    TotalStacks = new Dictionary<string, int>()
                };
            }

            PlayerOptions options = allPlayerOptions[player.userID];

            foreach (var kv in initialStackOptions)
            {
                if (!options.TotalStacks.ContainsKey(kv.Key))
                    options.TotalStacks.Add(kv.Key, kv.Value);
            }
        }

        private void OnTick()
        {
            while (queuedUiUpdates.Count > 0)
            {
                BaseOven oven = queuedUiUpdates.Pop();

                if (!oven || oven.IsDestroyed)
                    continue;

                OvenInfo ovenInfo = GetOvenInfo(oven);

                GetLooters(oven)?.ForEach(player =>
                {
                    if (player != null && !player.IsDestroyed && HasPermission(player) && GetEnabled(player))
                    {
                        CreateUi(player, oven, ovenInfo);
                    }
                });
            }
        }

        public OvenInfo GetOvenInfo(BaseOven oven)
        {
            OvenInfo result = new OvenInfo();
            PluginConfig.OvenConfig ovenCfg = GetOvenConfig(oven.ShortPrefabName);
            float fuelMultiplier = ovenCfg != null ? ovenCfg.fuelMultiplier : 1.0f;
            float ETA = GetTotalSmeltTime(oven) / oven.smeltSpeed;
            float fuelUnits = oven.fuelType.GetComponent<ItemModBurnable>().fuelAmount;
            float neededFuel = (float)Math.Ceiling(ETA * (oven.cookingTemperature / 200.0f) / fuelUnits);

            result.FuelNeeded = neededFuel * fuelMultiplier;
            result.ETA = ETA;

            return result;
        }

        private void Unload()
        {
            SaveData();

            foreach (var kv in openUis.ToDictionary(kv => kv.Key, kv => kv.Value))
            {
                BasePlayer player = BasePlayer.FindByID(kv.Key);
                DestroyUI(player);
            }
        }

        private bool GetEnabled(BasePlayer player)
        {
            if (!allPlayerOptions.ContainsKey(player.userID))
                InitPlayer(player);
            
            return allPlayerOptions[player.userID].Enabled;
        }

        private void SetEnabled(BasePlayer player, bool enabled)
        {
            if (allPlayerOptions.ContainsKey(player.userID))
                allPlayerOptions[player.userID].Enabled = enabled;
            CreateUiIfFurnaceOpen(player);
        }

        private bool IsSlotCompatible(Item item, BaseOven oven, ItemDefinition itemDefinition)
        {
            ItemModCookable cookable = item.info.GetComponent<ItemModCookable>();

            if (item.amount < item.info.stackable && item.info == itemDefinition)
                return true;

            if (oven.allowByproductCreation && oven.fuelType.GetComponent<ItemModBurnable>().byproductItem == item.info)
                return true;

            if (cookable == null || cookable.becomeOnCooked == itemDefinition)
                return true;

            if (CanCook(cookable, oven))
                return true;

            return false;
        }

        private void OnFuelConsume(BaseOven oven, Item fuel, ItemModBurnable burnable)
        {
            if (IsOvenCompatible(oven))
                queuedUiUpdates.Push(oven);
        }

        private List<BasePlayer> GetLooters(BaseOven oven)
        {
            if (looters.ContainsKey(oven))
                return looters[oven];

            return null;
        }

        private void AddLooter(BaseOven oven, BasePlayer player)
        {
            if (!looters.ContainsKey(oven))
                looters[oven] = new List<BasePlayer>();

            var list = looters[oven];
            list.Add(player);
        }

        private void RemoveLooter(BaseOven oven, BasePlayer player)
        {
            if (!looters.ContainsKey(oven))
                return;

            looters[oven].Remove(player);
        }

        private object CanMoveItem(Item item, PlayerInventory inventory, ItemContainerId targetContainerId, int targetSlotIndex, int splitAmount)
        {
            if (item == null || inventory == null)
                return null;

            BasePlayer player = inventory.GetComponent<BasePlayer>();
            if (player == null)
                return null;

            BaseOven oven = inventory.loot.entitySource as BaseOven;
            if (oven == null)
                return null;

            ItemContainer targetContainer = inventory.FindContainer(targetContainerId);
            if (targetContainer != null && !(targetContainer?.entityOwner is BaseOven))
                return null; // ignore moving items within player inventory or container that is not an oven

            ItemContainer container = oven.inventory;
            ItemContainer originalContainer = item.GetRootContainer();
            if (container == null || originalContainer == null || originalContainer?.entityOwner is BaseOven)
                return null; // ignore invalid container or moving items within oven

            BaseOven.MinMax? allowedSlots = oven.GetAllowedSlots(item);
            if (allowedSlots == null)
                return null;

            for (int i = allowedSlots.Value.Min; i <= allowedSlots.Value.Max; i++)
            {
                Item slot = oven.inventory.GetSlot(i);
                if (slot != null && slot.info.shortname != item.info.shortname)
                    return null; // ignore splitting for different item types but allow item to be added to oven
            }

            Func<object> splitFunc = () =>
            {
                if (player == null || !HasPermission(player) || !GetEnabled(player))
                    return null;

                PlayerOptions playerOptions = allPlayerOptions[player.userID];

                if (container == null || originalContainer == null || container == item.GetRootContainer())
                    return null;

                ItemModCookable cookable = item.info.GetComponent<ItemModCookable>();

                if (oven == null || cookable == null || oven.IsOutputItem(item))
                    return null;

                int totalSlots = oven.inputSlots;
                if (playerOptions.TotalStacks.ContainsKey(oven.ShortPrefabName))
                {
                    totalSlots = playerOptions.TotalStacks[oven.ShortPrefabName];
                }

                if (cookable.lowTemp > oven.cookingTemperature || cookable.highTemp < oven.cookingTemperature)
                    return null;

                MoveSplitItem(item, oven, totalSlots, splitAmount);
                return true;
            };

            object returnValue = splitFunc();

            if (HasPermission(player) && GetEnabled(player))
            {
                if (oven != null && IsOvenCompatible(oven))
                {
                    if (returnValue is bool && (bool)returnValue)
                        AutoAddFuel(inventory, oven);

                    queuedUiUpdates.Push(oven);
                }
            }

            return returnValue;
        }

        private MoveResult MoveSplitItem(Item item, BaseOven oven, int totalSlots, int splitAmount)
        {
            ItemContainer container = oven.inventory;
            int numOreSlots = totalSlots;
            int totalMoved = 0;
            int itemAmount = item.amount > splitAmount ? splitAmount : item.amount;
            int totalAmount = Math.Min(itemAmount + container.itemList.Where(slotItem => slotItem.info == item.info).Take(numOreSlots).Sum(slotItem => slotItem.amount), Math.Abs(item.info.stackable * numOreSlots));

            if (numOreSlots <= 0)
            {
                return MoveResult.NotEnoughSlots;
            }

            //Puts("---------------------------");

            int totalStackSize = Math.Min(totalAmount / numOreSlots, item.info.stackable);
            int remaining = totalAmount - totalAmount / numOreSlots * numOreSlots;

            List<int> addedSlots = new List<int>();

            //Puts("total: {0}, remaining: {1}, totalStackSize: {2}", totalAmount, remaining, totalStackSize);

            List<OvenSlot> ovenSlots = new List<OvenSlot>();

            for (int i = 0; i < numOreSlots; ++i)
            {
                Item existingItem;
                int slot = FindMatchingSlotIndex(oven, container, out existingItem, item.info, addedSlots);

                if (slot == -1) // full
                {
                    return MoveResult.NotEnoughSlots;
                }

                addedSlots.Add(slot);

                OvenSlot ovenSlot = new OvenSlot
                {
                    Position = existingItem?.position,
                    Index = slot,
                    Item = existingItem
                };

                int currentAmount = existingItem?.amount ?? 0;
                int missingAmount = totalStackSize - currentAmount + (i < remaining ? 1 : 0);
                ovenSlot.DeltaAmount = missingAmount;

                //Puts("[{0}] current: {1}, delta: {2}, total: {3}", slot, currentAmount, ovenSlot.DeltaAmount, currentAmount + missingAmount);

                if (currentAmount + missingAmount <= 0)
                    continue;

                ovenSlots.Add(ovenSlot);
            }

            foreach (OvenSlot slot in ovenSlots)
            {
                if (slot.Item == null)
                {
                    Item newItem = ItemManager.Create(item.info, slot.DeltaAmount, item.skin);
                    slot.Item = newItem;
                    newItem.MoveToContainer(container, slot.Position ?? slot.Index);
                }
                else
                {
                    slot.Item.amount += slot.DeltaAmount;
                }

                totalMoved += slot.DeltaAmount;
            }

            container.MarkDirty();

            if (totalMoved >= item.amount)
            {
                item.Remove();
                item.GetRootContainer()?.MarkDirty();
                return MoveResult.Ok;
            }
            else
            {
                item.amount -= totalMoved;
                item.GetRootContainer()?.MarkDirty();
                return MoveResult.SlotsFilled;
            }
        }

        private void AutoAddFuel(PlayerInventory playerInventory, BaseOven oven)
        {
            int neededFuel = (int)Math.Ceiling(GetOvenInfo(oven).FuelNeeded);
            neededFuel -= oven.inventory.GetAmount(oven.fuelType.itemid, false);
            var playerFuel = playerInventory.FindItemsByItemID(oven.fuelType.itemid);
            int fuelSlotIndex = 0;

            if (neededFuel <= 0 || playerFuel.Count <= 0)
                return;

            foreach (Item fuelItem in playerFuel)
            {
                var existingFuel = oven.inventory.GetSlot(fuelSlotIndex);
                if (existingFuel != null && existingFuel.amount >= existingFuel.info.stackable) // fuel slot full
                {
                    if (fuelSlotIndex < oven.fuelSlots) // check fuel slots
                        fuelSlotIndex++; // move to next fuel slot
                    else
                        break; // break if no fuel slots available
                }

                Item largestFuelStack = oven.inventory.itemList.Where(item => item.info == oven.fuelType).OrderByDescending(item => item.amount).FirstOrDefault();
                int toTake = Math.Min(neededFuel, (oven.fuelType.stackable * oven.fuelSlots) - (largestFuelStack?.amount ?? 0));

                if (toTake > fuelItem.amount)
                    toTake = fuelItem.amount;

                if (toTake <= 0)
                    break;

                neededFuel -= toTake;

                int currentFuelAmount = oven.inventory.GetAmount(oven.fuelType.itemid, false);
                if (currentFuelAmount >= oven.fuelType.stackable * oven.fuelSlots)
                    break; // Break if oven is full

                if (toTake >= fuelItem.amount)
                {
                    fuelItem.MoveToContainer(oven.inventory, fuelSlotIndex);
                }
                else
                {
                    Item splitItem = fuelItem.SplitItem(toTake);
                    if (!splitItem.MoveToContainer(oven.inventory, fuelSlotIndex)) // Break if oven is full
                        break;
                }

                if (neededFuel <= 0)
                    break;
            }
        }

        private int FindMatchingSlotIndex(BaseOven oven, ItemContainer container, out Item existingItem, ItemDefinition itemType, List<int> indexBlacklist)
        {
            existingItem = null;
            int firstIndex = -1;
            int inputSlotsMin = oven._inputSlotIndex;
            int inputSlotsMax = oven._inputSlotIndex + oven.inputSlots;
            Dictionary<int, Item> existingItems = new Dictionary<int, Item>();

            for (int i = inputSlotsMin; i < inputSlotsMax; ++i)
            {
                if (indexBlacklist.Contains(i))
                    continue;

                Item itemSlot = container.GetSlot(i);
                if (itemSlot == null || itemType != null && itemSlot.info == itemType)
                {
                    if (itemSlot != null)
                        existingItems.Add(i, itemSlot);

                    if (firstIndex == -1)
                    {
                        existingItem = itemSlot;
                        firstIndex = i;
                    }
                }
            }

            if (existingItems.Count <= 0 && firstIndex != -1)
            {
                return firstIndex;
            }
            else if (existingItems.Count > 0)
            {
                var largestStackItem = existingItems.OrderByDescending(kv => kv.Value.amount).First();
                existingItem = largestStackItem.Value;
                return existingItem.position;
            }

            existingItem = null;
            return -1;
        }

        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            BaseOven oven = entity as BaseOven;

            if (oven == null || !HasPermission(player) || !IsOvenCompatible(oven))
                return;

            AddLooter(oven, player);
            if (GetEnabled(player))
                queuedUiUpdates.Push(oven); // queue ui updates
            else
                CreateUi(player, oven, new OvenInfo()); // create ui without updates
        }

        private void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity)
        {
            BaseOven oven = entity as BaseOven;

            if (oven == null || !IsOvenCompatible(oven))
                return;

            DestroyUI(player);
            RemoveLooter(oven, player);
        }

        private void OnEntityKill(BaseNetworkable networkable)
        {
            BaseOven oven = networkable as BaseOven;

            if (oven != null)
            {
                DestroyOvenUI(oven);
            }
        }

        private void OnOvenToggle(BaseOven oven, BasePlayer player)
        {
            if (IsOvenCompatible(oven))
                queuedUiUpdates.Push(oven);
        }

        private void CreateUiIfFurnaceOpen(BasePlayer player)
        {
            BaseOven oven = player.inventory.loot?.entitySource as BaseOven;

            if (oven != null && IsOvenCompatible(oven))
                queuedUiUpdates.Push(oven);
        }

        private CuiElementContainer CreateUi(BasePlayer player, BaseOven oven, OvenInfo ovenInfo)
        {
            PlayerOptions options = allPlayerOptions[player.userID];
            int totalSlots = GetTotalStacksOption(player, oven) ?? oven.inputSlots;
            string remainingTimeStr;
            string neededFuelStr;

            if (ovenInfo.ETA <= 0)
            {
                remainingTimeStr = "0s";
                neededFuelStr = "0";
            }
            else
            {
                remainingTimeStr = FormatTime(ovenInfo.ETA);
                neededFuelStr = ovenInfo.FuelNeeded.ToString("##,###");
            }

            float uiScale = 1.0f;
            float[] playerUiInfo = UIScaleManager?.Call<float[]>("API_CheckPlayerUIInfo", player.UserIDString);
            if (playerUiInfo?.Length > 0)
            {
                uiScale = playerUiInfo[2];
            }
            string contentColor = "0.7 0.7 0.7 1.0";
            int contentSize = Convert.ToInt32(10 * uiScale);
            string toggleStateStr = (!options.Enabled).ToString();
            string toggleButtonColor = !options.Enabled
                    ? "0.415 0.5 0.258 0.4"
                    : "0.8 0.254 0.254 0.4";
            string toggleButtonTextColor = !options.Enabled
                    ? "0.607 0.705 0.431"
                    : "0.705 0.607 0.431";
            string buttonColor = "0.75 0.75 0.75 0.1";
            string buttonTextColor = "0.77 0.68 0.68 1";

            int nextDecrementSlot = totalSlots - 1;
            int nextIncrementSlot = totalSlots + 1;

            DestroyUI(player);

            Vector2 uiPosition = new Vector2(
                ((((config.UiPosition.x) - 0.5f) * uiScale) + 0.5f),
                (config.UiPosition.y - 0.02f) + 0.02f * uiScale);
            Vector2 uiSize = new Vector2(0.1785f * uiScale, 0.111f * uiScale);

            CuiElementContainer result = new CuiElementContainer();
            string rootPanelName = result.Add(new CuiPanel
            {
                Image = new CuiImageComponent
                {
                    Color = "0 0 0 0"
                },
                RectTransform =
                {
                    AnchorMin = uiPosition.x + " " + uiPosition.y,
                    AnchorMax = uiPosition.x + uiSize.x + " " + (uiPosition.y + uiSize.y)
                    //AnchorMin = "0.6505 0.022",
                    //AnchorMax = "0.829 0.133"
                }
            }, "Hud.Menu");

            string headerPanel = result.Add(new CuiPanel
            {
                Image = new CuiImageComponent
                {
                    Color = "0.75 0.75 0.75 0.1"
                },
                RectTransform =
                {
                    AnchorMin = "0 0.775",
                    AnchorMax = "1 1"
                }
            }, rootPanelName);

            // Header label
            result.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0.051 0",
                    AnchorMax = "1 0.95"
                },
                Text =
                {
                    Text = lang.GetMessage("title", this, player.UserIDString),
                    Align = TextAnchor.MiddleLeft,
                    Color = "0.77 0.7 0.7 1",
                    FontSize = Convert.ToInt32(13 * uiScale)
                }
            }, headerPanel);

            string contentPanel = result.Add(new CuiPanel
            {
                Image = new CuiImageComponent
                {
                    Color = "0.65 0.65 0.65 0.06"
                },
                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 0.74"
                }
            }, rootPanelName);

            // ETA label
            result.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0.02 0.7",
                    AnchorMax = "0.98 1"
                },
                Text =
                {
                    Text = string.Format("{0}: " + (ovenInfo.ETA > 0 ? "~" : "") + remainingTimeStr + " (" + neededFuelStr +  " " + oven.fuelType.displayName.english.ToLower() + ")", lang.GetMessage("eta", this, player.UserIDString)),
                    Align = TextAnchor.MiddleLeft,
                    Color = contentColor,
                    FontSize = contentSize
                }
            }, contentPanel);

            // Toggle button
            result.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "0.02 0.4",
                    AnchorMax = "0.25 0.7"
                },
                Button =
                {
                    Command = "furnacesplitter.enabled " + toggleStateStr,
                    Color = toggleButtonColor
                },
                Text =
                {
                    Align = TextAnchor.MiddleCenter,
                    Text = options.Enabled ? lang.GetMessage("turnoff", this, player.UserIDString) : lang.GetMessage("turnon", this, player.UserIDString),
                    Color = toggleButtonTextColor,
                    FontSize = Convert.ToInt32(11 * uiScale)
                }
            }, contentPanel);

            // Trim button
            result.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "0.27 0.4",
                    AnchorMax = "0.52 0.7"
                },
                Button =
                {
                    Command = "furnacesplitter.trim",
                    Color = buttonColor
                },
                Text =
                {
                    Align = TextAnchor.MiddleCenter,
                    Text = lang.GetMessage("trim", this, player.UserIDString),
                    Color = contentColor,
                    FontSize = Convert.ToInt32(11 * uiScale)
                }
            }, contentPanel);

            // Decrease stack button
            result.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "0.02 0.05",
                    AnchorMax = "0.07 0.35"
                },
                Button =
                {
                    Command = "furnacesplitter.totalstacks " + nextDecrementSlot,
                    Color = buttonColor
                },
                Text =
                {
                    Align = TextAnchor.MiddleCenter,
                    Text = "<",
                    Color = buttonTextColor,
                    FontSize = contentSize
                }
            }, contentPanel);

            // Empty slots label
            result.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0.08 0.05",
                    AnchorMax = "0.19 0.35"
                },
                Text =
                {
                    Align = TextAnchor.MiddleCenter,
                    Text = totalSlots.ToString(),
                    Color = contentColor,
                    FontSize = contentSize
                }
            }, contentPanel);

            // Increase stack button
            result.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "0.19 0.05",
                    AnchorMax = "0.25 0.35"
                },
                Button =
                {
                    Command = "furnacesplitter.totalstacks " + nextIncrementSlot,
                    Color = buttonColor
                },
                Text =
                {
                    Align = TextAnchor.MiddleCenter,
                    Text = ">",
                    Color = buttonTextColor,
                    FontSize = contentSize
                }
            }, contentPanel);

            // Stack itemType label
            result.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0.27 0.05",
                    AnchorMax = "1 0.35"
                },
                Text =
                {
                    Align = TextAnchor.MiddleLeft,
                    Text = string.Format("({0})", lang.GetMessage("totalstacks", this, player.UserIDString)),
                    Color = contentColor,
                    FontSize = contentSize
                }
            }, contentPanel);

            openUis.Add(player.userID, rootPanelName);
            CuiHelper.AddUi(player, result);
            return result;
        }

        private string FormatTime(float totalSeconds)
        {
            int hours = (int)Math.Floor(totalSeconds / 3600);
            int minutes = (int)Math.Floor(totalSeconds / 60 % 60);
            int seconds = (int)Math.Floor(totalSeconds % 60);

            if (hours <= 0 && minutes <= 0)
                return seconds + "s";
            if (hours <= 0)
                return minutes + "m" + seconds + "s";
            return hours + "h" + minutes + "m" + seconds + "s";
        }

        private float GetTotalSmeltTime(BaseOven oven)
        {
            float ETA = 0f;
            for (int i = oven._inputSlotIndex; i < oven._inputSlotIndex + oven.inputSlots; i++)
            {
                Item inputItem = oven.inventory.GetSlot(i);
                if (inputItem == null) continue;

                ItemModCookable cookable = inputItem.info.GetComponent<ItemModCookable>();
                if (cookable == null) continue;

                ETA += GetSmeltTime(cookable, inputItem.amount);
            }
            return ETA;
        }

        private bool CanCook(ItemModCookable cookable, BaseOven oven)
        {
            return oven.cookingTemperature >= cookable.lowTemp && oven.cookingTemperature <= cookable.highTemp;
        }

        private float GetSmeltTime(ItemModCookable cookable, int amount)
        {
            float smeltTime = cookable.cookTime * amount;
            return smeltTime;
        }

        private int? GetTotalStacksOption(BasePlayer player, BaseOven oven)
        {
            PlayerOptions options = allPlayerOptions[player.userID];

            if (options.TotalStacks.ContainsKey(oven.ShortPrefabName))
                return options.TotalStacks[oven.ShortPrefabName];

            return null;
        }

        private void DestroyUI(BasePlayer player)
        {
            if (!openUis.ContainsKey(player.userID))
                return;

            string uiName = openUis[player.userID];

            if (openUis.Remove(player.userID))
                CuiHelper.DestroyUi(player, uiName);
        }

        private void DestroyOvenUI(BaseOven oven)
        {
            if (oven == null) throw new ArgumentNullException(nameof(oven));

            foreach (KeyValuePair<ulong, string> kv in openUis.ToDictionary(kv => kv.Key, kv => kv.Value))
            {
                BasePlayer player = BasePlayer.FindByID(kv.Key);

                BaseOven playerLootOven = player.inventory.loot?.entitySource as BaseOven;

                if (playerLootOven != null && oven == playerLootOven)
                {
                    DestroyUI(player);
                    RemoveLooter(oven, player);
                }
            }
        }

        private PluginConfig.OvenConfig GetOvenConfig(string ovenShortname)
        {
            PluginConfig.OvenConfig ovenCfg;
            if (config.ovens.TryGetValue(ovenShortname, out ovenCfg) && ovenCfg.enabled)
                return ovenCfg;

            if (config.ovens.TryGetValue("*", out ovenCfg) && ovenCfg.enabled)
                return ovenCfg;

            return null;
        }

        private bool IsOvenCompatible(BaseOven oven)
        {
            if (oven == null || !oven.allowByproductCreation)
                return false;

            return GetOvenConfig(oven.ShortPrefabName) != null;
        }

        [ChatCommand("fs")]
        void cmdToggle(BasePlayer player, string cmd, string[] args)
        {
            if (!HasPermission(player))
            {
                player.ConsoleMessage(lang.GetMessage("nopermission", this, player.UserIDString));
                return;
            }

            var status = string.Empty;
            var statuson = lang.GetMessage("StatusONColor", this, player.UserIDString);
            var statusoff = lang.GetMessage("StatusOFFColor", this, player.UserIDString);
            if (args.Length == 0)
            {
                if (GetEnabled(player)) status = statuson;
                else status = statusoff;

                var helpmsg = new StringBuilder();
                helpmsg.Append("<size=22><color=green>Furnace Splitter</color></size> by: FastBurst\n");
                helpmsg.Append(lang.GetMessage("StatusMessage", this, player.UserIDString) + status + "\n");
                helpmsg.Append("<color=orange>/fs on</color> - Toggles Furnace Splitter to ON\n");
                helpmsg.Append("<color=orange>/fs off</color> - Toggles Furnace Splitter to OFF\n");
                player.ChatMessage(helpmsg.ToString().TrimEnd());
                return;
            }

            switch (args[0].ToLower())
            {
                case "on":
                    SetEnabled(player, true);
                    CreateUiIfFurnaceOpen(player);

                    if (GetEnabled(player)) status = statuson;
                    else status = statusoff;

                    player.ChatMessage(lang.GetMessage("StatusMessage", this, player.UserIDString) + status);
                    break;
                case "off":
                    SetEnabled(player, false);
                    DestroyUI(player);

                    if (GetEnabled(player)) status = statuson;
                    else status = statusoff;

                    player.ChatMessage(lang.GetMessage("StatusMessage", this, player.UserIDString) + status);
                    break;
                default:
                    player.ChatMessage("Invalid syntax!");
                    break;
            }
        }

        [ConsoleCommand("furnacesplitter.enabled")]
        private void ConsoleCommand_Toggle(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            if (!HasPermission(player))
            {
                player.ConsoleMessage(lang.GetMessage("nopermission", this, player.UserIDString));
                return;
            }

            if (!arg.HasArgs())
            {
                player.ConsoleMessage(GetEnabled(player).ToString());
                return;
            }

            bool enabled = arg.GetBool(0);
            SetEnabled(player, enabled);
            if (enabled)
            {
                CreateUiIfFurnaceOpen(player); // queue ui updates
            }
            else
            {
                BaseOven oven = player.inventory.loot?.entitySource as BaseOven;
                CreateUi(player, oven, new OvenInfo()); // create ui without updates
            }
        }

        [ConsoleCommand("furnacesplitter.totalstacks")]
        private void ConsoleCommand_TotalStacks(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            BaseOven lootSource = player.inventory.loot?.entitySource as BaseOven;

            if (!HasPermission(player))
            {
                player.ConsoleMessage(lang.GetMessage("nopermission", this, player.UserIDString));
                return;
            }

            if (lootSource == null || !IsOvenCompatible(lootSource))
            {
                player.ConsoleMessage(lang.GetMessage("lootsource_invalid", this, player.UserIDString));
                return;
            }

            if (!GetEnabled(player))
                return;

            string ovenName = lootSource.ShortPrefabName;
            PlayerOptions playerOption = allPlayerOptions[player.userID];

            if (playerOption.TotalStacks.ContainsKey(ovenName))
            {
                if (!arg.HasArgs())
                {
                    player.ConsoleMessage(playerOption.TotalStacks[ovenName].ToString());
                }
                else
                {
                    int newValue = (int)Mathf.Clamp(arg.GetInt(0), 1, lootSource.inputSlots);
                    playerOption.TotalStacks[ovenName] = newValue;
                }
            }
            else
            {
                PrintWarning($"Unsupported furnace '{ovenName}'");
                player.ConsoleMessage(lang.GetMessage("unsupported_furnace", this, player.UserIDString));
            }

            CreateUiIfFurnaceOpen(player);
        }

        [ConsoleCommand("furnacesplitter.trim")]
        private void ConsoleCommand_Trim(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            if (!GetEnabled(player))
                return;

            BaseOven lootSource = player.inventory.loot?.entitySource as BaseOven;

            if (!HasPermission(player))
            {
                player.ConsoleMessage(lang.GetMessage("nopermission", this, player.UserIDString));
                return;
            }

            if (lootSource == null || !IsOvenCompatible(lootSource))
            {
                player.ConsoleMessage(lang.GetMessage("lootsource_invalid", this, player.UserIDString));
                return;
            }

            OvenInfo ovenInfo = GetOvenInfo(lootSource);
            var fuelSlots = lootSource.inventory.itemList.Where(item => item.info == lootSource.fuelType).ToList();
            int totalFuel = fuelSlots.Sum(item => item.amount);
            int toRemove = (int)Math.Floor(totalFuel - ovenInfo.FuelNeeded);

            if (toRemove <= 0)
                return;

            foreach (Item fuelItem in fuelSlots)
            {
                int toTake = Math.Min(fuelItem.amount, toRemove);
                toRemove -= toTake;

                Vector3 dropPosition = player.GetDropPosition();
                Vector3 dropVelocity = player.GetDropVelocity();

                if (toTake >= fuelItem.amount)
                {
                    if (!player.inventory.GiveItem(fuelItem))
                        fuelItem.Drop(dropPosition, dropVelocity, Quaternion.identity);
                }
                else
                {
                    Item splitItem = fuelItem.SplitItem(toTake);
                    if (!player.inventory.GiveItem(splitItem))
                        splitItem.Drop(dropPosition, dropVelocity, Quaternion.identity);
                }

                if (toRemove <= 0)
                    break;
            }
        }

        private bool HasPermission(BasePlayer player)
        {
            return permission.UserHasPermission(player.UserIDString, permUse);
        }

        #region Configuration

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string> {
                // English
                { "turnon", "Turn On" },
                { "turnoff", "Turn Off" },
                { "title", "Furnace Splitter" },
                { "eta", "ETA" },
                { "totalstacks", "Total stacks" },
                { "trim", "Trim fuel" },
                { "lootsource_invalid", "Current loot source invalid" },
                { "unsupported_furnace", "Unsupported furnace." },
                { "nopermission", "You don't have permission to use this." },
                { "StatusONColor", "<color=green>ON</color>"},
                { "StatusOFFColor", "<color=red>OFF</color>"},
                { "StatusMessage", "Furnace Splitter status set to: "}
            }, this);
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating default config for FurnaceSplitter.");
            config = GetDefaultConfig();
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig {
                UiPosition = new Vector2(0.6505f, 0.022f),
                savePlayerData = true,
                ovens = new SortedDictionary<string, PluginConfig.OvenConfig> {
                    { "*", new PluginConfig.OvenConfig { enabled = true, fuelMultiplier = 1.0f } }
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.Converters.Add(new Vector2Converter());
            config = Config.ReadObject<PluginConfig>();

            if (!config.ovens.ContainsKey("*"))
            {
                config.ovens["*"] = new PluginConfig.OvenConfig {
                    enabled = true,
                    fuelMultiplier = 1.0f
                };
            }

            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(config, true);

        private class PluginConfig
        {
            public Vector2 UiPosition;
            public bool savePlayerData;
            public SortedDictionary<string, OvenConfig> ovens = new SortedDictionary<string, OvenConfig>();

            public class OvenConfig
            {
                public bool enabled;
                public float fuelMultiplier = 1.0f;
            }
        }

        private class Vector2Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                Vector2 vec = (Vector2)value;
                serializer.Serialize(writer, new { vec.x, vec.y });
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                Vector2 result = new Vector2();
                JObject jVec = JObject.Load(reader);

                result.x = jVec["x"].ToObject<float>();
                result.y = jVec["y"].ToObject<float>();

                return result;
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector2);
            }
        }

        #endregion Configuration

        #region Exposed plugin methods

        [HookMethod("MoveSplitItem")]
        public string Hook_MoveSplitItem(Item item, BaseOven oven, int totalSlots, int splitAmount)
        {
            MoveResult result = MoveSplitItem(item, oven, totalSlots, splitAmount);
            return result.ToString();
        }

        [HookMethod("GetOvenInfo")]
        public JObject Hook_GetOvenInfo(BaseOven oven)
        {
            OvenInfo ovenInfo = GetOvenInfo(oven);
            return JObject.FromObject(ovenInfo);
        }

        #endregion Exposed plugin methods
    }
}

// --- End of file: FurnaceSplitter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/upgrade-workbench ---
// --- Original File Path: U/UpgradeWorkbench/UpgradeWorkbench.cs ---

using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Upgrade Workbench", "mvrb", "0.1.4")]
    [Description("Allows players to upgrade workbenches using a command")]
    class UpgradeWorkbench : RustPlugin
    {
        private const string permissionUse = "upgradeworkbench.use";
        private const string permissionNoCost = "upgradeworkbench.nocost";

        private Dictionary<string, Dictionary<int, int>> WorkbenchIngredients = new Dictionary<string, Dictionary<int, int>>();

        private void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoWorkbenchFound"] = "No Workbench found. Make sure you are looking at a Workbench.",
                ["UpgradeComplete"] = "You have successfully upgraded your workbench.",
                ["Error: Level3"] = "You can't upgrade a Tier 3 Workbench.",
                ["Error: NotEnoughResources"] = "You do not have the required resources to upgrade this Workbech: \n",
                ["Error: NotEmpty"] = "You can only upgrade empty workbenches! Please empty the workbench.",
                ["Error: NoPermission"] = "You do not have permission to use this command."
            }, this);
        }

        private void OnServerInitialized()
        {
            permission.RegisterPermission(permissionUse, this);
            permission.RegisterPermission(permissionNoCost, this);

            foreach (ItemDefinition itemDef in ItemManager.GetItemDefinitions())
            {
                if (itemDef.name.Contains("workbench"))
                {
                    foreach (var ingredient in itemDef.Blueprint.ingredients)
                    {
                        string formattedItemDefName = itemDef.name.Replace(".item", string.Empty);

                        if (!WorkbenchIngredients.ContainsKey(formattedItemDefName))
                        {
                            WorkbenchIngredients.Add(formattedItemDefName, new Dictionary<int, int>() { { ingredient.itemid, (int)ingredient.amount } });
                        }
                        else
                        {
                            WorkbenchIngredients[formattedItemDefName].Add(ingredient.itemid, (int)ingredient.amount);
                        }
                    }
                }
            }
        }

        [ChatCommand("upgradewb")]
        private void cmdUpgradeWorkbench(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionUse))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            RaycastHit hit;
            var raycast = Physics.Raycast(player.eyes.HeadRay(), out hit, 5f, 2097409);
            BaseEntity entity = raycast ? hit.GetEntity() : null;

            if (entity == null || entity && !entity.ShortPrefabName.StartsWith("workbench"))
            {
                player.ChatMessage(Lang("NoWorkbenchFound", player.UserIDString));
                return;
            }

            if (entity.ShortPrefabName.StartsWith("workbench3"))
            {
                player.ChatMessage(Lang("Error: Level3", player.UserIDString));
                return;
            }

            if ((entity as StorageContainer)?.inventory.itemList.Count > 0)
            {
                player.ChatMessage(Lang("Error: NotEmpty", player.UserIDString));
                return;
            }

            TryUpgradeWorkbench(player, entity);
        }

        private bool ReplaceWorkbench(BaseEntity originalWorkbench)
        {
            if (originalWorkbench == null)
            {
                PrintWarning("Failed to get original Workbench");
                return false;
            }

            string workbenchName = originalWorkbench.ShortPrefabName.StartsWith("workbench1") ? "assets/prefabs/deployable/tier 2 workbench/workbench2.deployed.prefab" : "assets/prefabs/deployable/tier 3 workbench/workbench3.deployed.prefab";

            var workbench = GameManager.server.CreateEntity(workbenchName, originalWorkbench.transform.position, originalWorkbench.transform.rotation, true);

            if (workbench == null)
            {
                PrintWarning("Failed to spawn a new Workbench");
                return false;
            }

            workbench.OwnerID = originalWorkbench.OwnerID;
            workbench.Spawn();

            originalWorkbench.Kill();

            return true;
        }

        private class MissingItem
        {
            public int CurrentAmount;
            public int RequiredAmount;

            public MissingItem(int current, int required)
            {
                CurrentAmount = current;
                RequiredAmount = required;
            }
        }

        private void TryUpgradeWorkbench(BasePlayer player, BaseEntity entity)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionNoCost))
            {
				string wbName = string.Empty;
				
				if (entity.ShortPrefabName.Contains("1"))
				{
					wbName = "workbench2";
				}
				else
				{
					wbName = "workbench3";
				}
				
                Dictionary<int, MissingItem> MissingItems = new Dictionary<int, MissingItem>();

                foreach (KeyValuePair<int, int> entry in WorkbenchIngredients[wbName])
                {
                    int ingredientItemId = entry.Key;
                    int playerItemAmount = player.inventory.GetAmount(ingredientItemId);
                    int ingredientItemAmount = entry.Value;

                    if (playerItemAmount < ingredientItemAmount)
                    {
                        if (!MissingItems.ContainsKey(ingredientItemId))
                        {
                            MissingItems.Add(ingredientItemId, new MissingItem(playerItemAmount, ingredientItemAmount));
                        }
                    }
                }

                if (MissingItems.Count > 0)
                {
                    string msg = Lang("Error: NotEnoughResources", player.UserIDString);

                    foreach (KeyValuePair<int, MissingItem> entry in MissingItems)
                    {
                        Item item = ItemManager.CreateByItemID(entry.Key);

                        if (item == null)
                        {
                            PrintWarning($"Skipping invalid item: {entry.Key}");
                            continue;
                        }

                        string itemName = item.info.displayName.english;

                        msg += $"- {entry.Value.CurrentAmount}/{entry.Value.RequiredAmount} {itemName} \n";
                    }

                    player.ChatMessage(msg);

                    return;
                }

                if (ReplaceWorkbench(entity))
                {
                    foreach (KeyValuePair<int, int> entry in WorkbenchIngredients[wbName])
                    {
                        Item item = ItemManager.CreateByItemID(entry.Key, entry.Value);

                        if (item == null)
                        {
                            PrintWarning($"Skipping invalid item: {entry.Key}");
                            continue;
                        }

                        player.inventory.Take(new List<Item>(), item.info.itemid, item.amount);
                        player.Command(string.Concat("note.inv ", item.info.itemid, " ", -item.amount));
                    }
                }
            }
			else
			{
				ReplaceWorkbench(entity);
			}

            player.ChatMessage(Lang("UpgradeComplete", player.UserIDString));
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
    }
}

// --- End of file: UpgradeWorkbench.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/useable-shovels ---
// --- Original File Path: U/UseableShovels/UseableShovels.cs ---

using System.Linq;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;
using System;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Useable Shovels", "mr01sam", "1.0.3")]
    [Description("Allows you to dig into the ground using shovels!")]
    partial class UseableShovels : CovalencePlugin
    {
    
        private const string PERMISSION_USE = "useableshovels.use";

        void Init()
        {
            Unsubscribe(nameof(OnMeleeAttack));
            permission.RegisterPermission(PERMISSION_USE, this);
        }

        void Unload()
        {
            _monumentInfoCache = null;
        }

        void OnServerInitialized()
        {
            Subscribe(nameof(OnMeleeAttack));
        }
    }
}

namespace Oxide.Plugins
{
    partial class UseableShovels : CovalencePlugin
    {
        private Configuration config;

        private partial class Configuration
        {

            [JsonProperty(PropertyName = "Gain Stone")]
            public bool GainStone = true;

            [JsonProperty(PropertyName = "Gain Metal/Sulfur")]
            public bool GainMetalAndSulfur = true;

            [JsonProperty(PropertyName = "Gain Bait")]
            public bool GainBait = true;

            [JsonProperty(PropertyName = "Gain Plant Fiber")]
            public bool GainPlantFiber = true;

            [JsonProperty(PropertyName = "Reveal Player Stashes")]
            public bool RevealStashes = true;

            [JsonProperty(PropertyName = "Allow Digging in Monuments")]
            public bool AllowDiggingMonuments = false;

            [JsonProperty(PropertyName = "Allow Digging in Building Privileges")]
            public bool AllowDiggingBuildingPrivilege = false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        protected override void LoadDefaultConfig() => config = new Configuration();
    }
}

namespace Oxide.Plugins
{
    partial class UseableShovels : CovalencePlugin
    {
        private readonly string STONE_ITEM = "stones";
        private readonly string SULPHUR_ITEM = "sulfur.ore";
        private readonly string METAL_ITEM = "metal.ore";
        private readonly string GRUB_ITEM = "grub";
        private readonly string WORM_ITEM = "worm";
        private readonly string PLANT_FIBER_ITEM = "plantfiber";

        private static MonumentInfo[] _monumentInfoCache;
        public static MonumentInfo[] MonumentInfoCached
        {
            get
            {
                if (_monumentInfoCache == null)
                {
                    _monumentInfoCache = UnityEngine.Object.FindObjectsOfType<MonumentInfo>();
                }
                return _monumentInfoCache;
            }
        }

        enum LocationType
        {
            Generic,
            Monument,
            BuildingPrivilege
        }

        LocationType GetLocationTypeFromPosition(BasePlayer basePlayer, Vector3 position)
        {
            bool inBuildingBlockedZone = basePlayer != null && basePlayer.GetBuildingPrivilege() != null;
            if (inBuildingBlockedZone)
            {
                return LocationType.BuildingPrivilege;
            }
            bool inMonument = MonumentInfoCached.Any(x => x.IsInBounds(position));
            if (inMonument)
            {
                return LocationType.Monument;
            }
            return LocationType.Generic;
        }

        ItemChance[] GetItemsFromMaterial(HitMaterial material)
        {
            switch (material)
            {
                case HitMaterial.Grass:
                    return new ItemChance[]
                    {
                        new ItemChance(GRUB_ITEM, 5, config.GainBait),
                        new ItemChance(PLANT_FIBER_ITEM, 40, config.GainPlantFiber)
                    };
                case HitMaterial.SnowGrass:
                    return new ItemChance[]
                    {
                        new ItemChance(PLANT_FIBER_ITEM, 10, config.GainPlantFiber)
                    };
                case HitMaterial.Sand:
                    return new ItemChance[]
                    {
                        new ItemChance(SULPHUR_ITEM, 10, config.GainMetalAndSulfur)
                    };
                case HitMaterial.Dirt:
                    return new ItemChance[]
                    {
                        new ItemChance(WORM_ITEM, 5, config.GainBait),
                    };
                case HitMaterial.Riverbed:
                    return new ItemChance[]
                    {
                        new ItemChance(METAL_ITEM, 10, config.GainMetalAndSulfur),
                        new ItemChance(GRUB_ITEM, 2, config.GainBait),
                    };
                case HitMaterial.Gravel:
                    return new ItemChance[]
                    {
                        new ItemChance(METAL_ITEM, 30, config.GainMetalAndSulfur),
                    };
                default:
                    return new ItemChance[0];
            }
        }

        enum HitMaterial
        {
            Undiggable,
            Grass,
            Gravel,
            Riverbed,
            SnowGrass,
            Sand,
            Dirt
        }

        HitMaterial GetHitMaterialFromID(uint material)
        {
            switch (material)
            {
                case 2306822461: return HitMaterial.Gravel;
                case 1109271974: return HitMaterial.Riverbed;
                case 3829453833: return HitMaterial.Grass;
                case 3620698611: return HitMaterial.Grass;
                case 3757806379: return HitMaterial.SnowGrass;
                case 1533752200: return HitMaterial.Sand;
                case 2551253961: return HitMaterial.Dirt;
            }
            return HitMaterial.Undiggable;
        }

        object OnMeleeAttack(BasePlayer basePlayer, HitInfo info)
        {
            object defaultReturn = null;
            if (info != null && info.Weapon != null && info.Weapon.ShortPrefabName == "paddle.entity")
            {
                var localPosition = info.HitPositionLocal;
                var worldPosition = info.HitPositionWorld;
                var locationType = GetLocationTypeFromPosition(basePlayer, worldPosition);
                var hitMaterial = GetHitMaterialFromID(info.HitMaterial);
                if (hitMaterial == HitMaterial.Undiggable)
                {
                    return defaultReturn;
                }
                if (!permission.UserHasPermission(basePlayer.UserIDString, PERMISSION_USE) || (locationType == LocationType.Monument && !config.AllowDiggingMonuments) || (locationType == LocationType.BuildingPrivilege && !config.AllowDiggingBuildingPrivilege))
                {
                    basePlayer.IPlayer.Reply(Lang("cannot dig here", basePlayer));
                    return defaultReturn;
                }
                DigHoleAndGetStuff(basePlayer, hitMaterial, localPosition, worldPosition);
            }
            return defaultReturn;
        }

        void DigHoleAndGetStuff(BasePlayer basePlayer, HitMaterial hitMaterial, Vector3 localPosition, Vector3 worldPosition)
        {
            int roll;
            int amt;
            var tool = (Paddle)basePlayer.GetActiveItem().GetHeldEntity();
            var gatherRate = (tool.damageTypes.First(x => x.type == Rust.DamageType.Blunt).amount / 40f);
            if (config.GainStone)
            {
                roll = UnityEngine.Random.Range(1, 10);
                amt = roll >= 9 ? 3 : (roll >= 4 ? 2 : 1);
                GiveItemByShortName(basePlayer, STONE_ITEM, RoundGatherAmount(amt, gatherRate));
            }
            var chances = GetItemsFromMaterial(hitMaterial);
            foreach (var itemChance in chances)
            {
                roll = UnityEngine.Random.Range(1, 100);
                amt = roll >= 100 - itemChance.Chance ? 1 : 0;
                GiveItemByShortName(basePlayer, itemChance.ItemShortName, RoundGatherAmount(amt, gatherRate));
            }
            bool didRevealStash = false;
            if (config.RevealStashes)
            {
                didRevealStash = RevealPlayerStashes(worldPosition) > 0;
            }
            if (!didRevealStash)
            {
                PlayDigEffect(basePlayer, localPosition);
            }
            Interface.CallHook("OnDig", basePlayer, localPosition, worldPosition);
        }

        int RevealPlayerStashes(Vector3 position)
        {
            var stashes = GetNearbyStashes(position, 1f);
            int revealed = 0;
            foreach (var stash in stashes)
            {
                if (stash.IsHidden())
                {
                    stash.ToggleHidden();
                    revealed++;
                }
            }
            return revealed;
        }

        List<StashContainer> GetNearbyStashes(Vector3 position, float radius)
        {
            List<StashContainer> stashes = new List<StashContainer>();
            Vis.Entities(position, radius, stashes);
            return stashes;
        }

        int RoundGatherAmount(int amt, float gatherRate)
        {
            return amt <= 0 || gatherRate <= 0 ? 0 : (int)Math.Max(1, Math.Floor(amt * gatherRate));
        }

        void PlayDigEffect(BaseEntity entity, Vector3 position)
        {
            var effect = new Effect("assets/bundled/prefabs/fx/dig_effect.prefab", position, Vector3.one);
            EffectNetwork.Send(effect);
        }

        void GiveItemByShortName(BasePlayer basePlayer, string name, int amount)
        {
            if (amount > 0)
            {
                var item = ItemManager.CreateByName(name, amount);
                basePlayer.GiveItem(item);
            }
        }
    }
}

namespace Oxide.Plugins
{
    partial class UseableShovels : CovalencePlugin
    {
        public class ItemChance
        {
            public string ItemShortName { get; set; }

            public int Chance { get; set; }

            public bool Enabled { get; set; }

            public ItemChance(string itemShortName, int chance, bool enabled)
            {
                this.ItemShortName = itemShortName;
                this.Chance = chance;
                this.Enabled = enabled;
            }
        }
    }
}

namespace Oxide.Plugins
{
    partial class UseableShovels : CovalencePlugin
    {
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["cannot dig here"] = "You cannot dig in this area."
            }, this);
        }

        private string Lang(string key, BasePlayer basePlayer, params object[] args) => string.Format(lang.GetMessage(key, this, basePlayer?.UserIDString), args);
    }
}

// --- End of file: UseableShovels.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/upgrade-timer ---
// --- Original File Path: U/UpgradeTimer/UpgradeTimer.cs ---

﻿using System.Collections.Generic;
using UnityEngine;
using System;
using System.IO;
using Newtonsoft.Json;
using System.Text;
using System.IO.Compression;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;

namespace Oxide.Plugins
{
    [Info("UpgradeTimer", "Jake_Rich", "2.0.0", ResourceId = 2740)]
    [Description("Time limit to upgrade twig after it has been placed")]

    public class UpgradeTimer : RustPlugin
    {
        public static UpgradeTimer _plugin;
        public static JSONFile<ConfigData> _settingsFile;
        public static ConfigData Settings { get { return _settingsFile.Instance; } }
        public Dictionary<BaseEntity,EntityData> EntityDictionary;

        void Init()
        {
            _plugin = this;
        }

        void Loaded()
        {
            _settingsFile = new JSONFile<ConfigData>($"{Name}", ConfigLocation.Config, extension: ".cfg");
            EntityDictionary = new Dictionary<BaseEntity, EntityData>();
        }

        void Unload()
        {

        }

        public class ConfigData
        {
            public int UpgradeDelay = 10;
            public int WoodUpgradeDelay = 3 * 60;
            public int StoneUpgradeDelay = 10 * 60;
            public int MetalUpgradeDelay = 20 * 60;
            public int ArmouredUpgradeDelay = 30 * 60;
            public float ExplosiveDamageDelay = 90f;
            public float NormalDamageDelay = 10f;

            public Dictionary<string, int> EntityUpgradeTime = new Dictionary<string, int>()
            {
                { "wall.external.high.stone", 20 * 60},
                { "wall.external.high.wood",  10 * 60},
                { "gates.external.high.stone", 20 * 60},
                { "gates.external.high.wood", 10 * 60},
                { "door.hinged.wood", 3 * 60},
                { "door.hinged.metal", 10 * 60},
                { "door.hinged.toptier", 20 * 60},
                { "door.double.hinged.wood", 3 * 60},
                { "door.double.hinged.metal", 10 * 60},
                { "door.double.hinged.toptier", 20 * 60},
                { "wall.frame.garagedoor", 10 * 60},
            };
        }

        public class EntityData
        {
            public BaseCombatEntity Entity;
            public Timer timer;
            public int TimerRate = 6;
            public float NextRepairTime;
            public float NextUpgradeTime;

            public EntityData(BaseCombatEntity block)
            {
                Entity = block;
            }

            public void ResetTimer()
            {
                StartTimer();
            }

            public void StartTimer()
            {
                NextRepairTime = Mathf.Max(UnityEngine.Time.time + TimerRate + 4, NextRepairTime);
                timer?.Destroy();
                timer = _plugin.timer.Every(TimerRate, TimerLoop);
            }

            private void TimerLoop()
            {
                if (Entity == null)
                {
                    return;
                }
                NextRepairTime = Mathf.Max(UnityEngine.Time.time + TimerRate + 4, NextRepairTime);
                float rate = 0;
                if (Entity is BuildingBlock)
                {
                    switch (((BuildingBlock)Entity).grade)
                    {
                        case BuildingGrade.Enum.Wood: { rate = Settings.WoodUpgradeDelay; break; }
                        case BuildingGrade.Enum.Stone: { rate = Settings.StoneUpgradeDelay; break; }
                        case BuildingGrade.Enum.Metal: { rate = Settings.MetalUpgradeDelay; break; }
                        case BuildingGrade.Enum.TopTier: { rate = Settings.ArmouredUpgradeDelay; break; }
                        default: { return; }
                    }
                }
                int amount;
                if (Settings.EntityUpgradeTime.TryGetValue(Entity.ShortPrefabName, out amount))
                {
                    rate = amount;
                }
                Entity.healthFraction = Mathf.Min(1f, Entity.healthFraction + (TimerRate / rate));
                if (Entity.healthFraction >= 1f)
                {
                    Destroy();
                }
                if (!(Entity is BuildingBlock))
                {
                    Entity.SendNetworkUpdate();
                }
            }

            public void Destroy()
            {
                timer?.Destroy();
            }
        }

        public EntityData GetEntityData(BaseCombatEntity entity)
        {
            EntityData data;
            if (!EntityDictionary.TryGetValue(entity, out data))
            {
                data = new EntityData(entity);
                EntityDictionary.Add(entity, data);
            }
            return data;
        }

        void OnEntityBuilt(Planner plan, GameObject go)
        {
            BaseCombatEntity entity = go.ToBaseEntity() as BaseCombatEntity;

            if (entity == null)
            {
                return;
            }

            if (Settings.EntityUpgradeTime.ContainsKey(entity.ShortPrefabName) == false)
            {
                return;
            }

            var data = GetEntityData(entity);
            entity.healthFraction = (float)data.TimerRate / Settings.EntityUpgradeTime[entity.ShortPrefabName];
            entity.SendNetworkUpdate();
            data.StartTimer();

            return;

            Timer _timer = null;
            entity.healthFraction = 0;
            entity.lastAttackedTime = Time.time;
            _timer = timer.Repeat(1f, Settings.UpgradeDelay, () =>
            {
                if (entity == null || entity.IsDestroyed || _timer == null)
                {
                    _timer?.Destroy();
                    return;
                }
                entity.lastAttackedTime = Time.time;
                entity.healthFraction = 1f / Settings.UpgradeDelay * (Settings.UpgradeDelay - _timer.Repetitions);
                if (_timer.Repetitions == 0)
                {
                    entity.lastAttackedTime = 0;
                    //timers.Remove(entity);
                }
            });
            //timers.Add(entity, _timer);
        }

        void OnEntityKill(BaseNetworkable net)
        {
            var entity = net as BaseCombatEntity;
            if (entity == null)
            {
                return;
            }
            if (entity is BuildingBlock || Settings.EntityUpgradeTime.ContainsKey(net.ShortPrefabName))
            {
                GetEntityData(entity).Destroy();
                EntityDictionary.Remove(entity);
            }
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if ((entity is BuildingBlock || Settings.EntityUpgradeTime.ContainsKey(entity.ShortPrefabName)) == false)
            {
                return;
            }
            var data = GetEntityData(entity);
            if (info.damageTypes.Has(Rust.DamageType.Explosion))
            {
                data.Destroy();
                data.NextRepairTime = Mathf.Max(UnityEngine.Time.time + Settings.ExplosiveDamageDelay, data.NextRepairTime);
                data.NextUpgradeTime = data.NextRepairTime;
                return;
            }
            if (info.damageTypes.Has(Rust.DamageType.Decay))
            {
                return;
            }
            data.NextRepairTime = Mathf.Max(UnityEngine.Time.time + Settings.NormalDamageDelay, data.NextRepairTime);
            data.NextUpgradeTime = data.NextRepairTime;
            data.ResetTimer();
        }

        object OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade)
        {
            var data = GetEntityData(block);
            if (data.NextUpgradeTime > UnityEngine.Time.time)
            {
                return false;
            }
            float oldHealth = block.health;
            NextFrame(() =>
            {
                if (block == null)
                {
                    return;
                }
                block.health = oldHealth;
                data.ResetTimer();
            });
            return null;
        }

        object OnStructureRepair(BaseCombatEntity entity, BasePlayer player)
        {
            var block = entity as BuildingBlock;
            if (block == null)
            {
                return null;
            }
            var data = GetEntityData(block);
            if (data.NextRepairTime <= UnityEngine.Time.time)
            {
                return null;
            }
            return false;
        }

        #region Configuration Files

        public enum ConfigLocation
        {
            Data = 0,
            Config = 1,
            Logs = 2,
            Plugins = 3,
            Lang = 4,
            Custom = 5,
        }

        public class JSONFile<Type> where Type : class
        {
            private DynamicConfigFile _file;
            public string _name { get; set; }
            public Type Instance { get; set; }
            private ConfigLocation _location { get; set; }
            private string _path { get; set; }
            public bool SaveOnUnload = false;
            public bool Compressed = false;

            public JSONFile(string name, ConfigLocation location = ConfigLocation.Data, string path = null, string extension = ".json", bool saveOnUnload = false)
            {
                SaveOnUnload = saveOnUnload;
                _name = name.Replace(".json", "");
                _location = location;
                switch (location)
                {
                    case ConfigLocation.Data:
                        {
                            _path = $"{Oxide.Core.Interface.Oxide.DataDirectory}/{name}{extension}";
                            break;
                        }
                    case ConfigLocation.Config:
                        {
                            _path = $"{Oxide.Core.Interface.Oxide.ConfigDirectory}/{name}{extension}";
                            break;
                        }
                    case ConfigLocation.Logs:
                        {
                            _path = $"{Oxide.Core.Interface.Oxide.LogDirectory}/{name}{extension}";
                            break;
                        }
                    case ConfigLocation.Lang:
                        {
                            _path = $"{Oxide.Core.Interface.Oxide.LangDirectory}/{name}{extension}";
                            break;
                        }
                    case ConfigLocation.Custom:
                        {
                            _path = $"{path}/{name}{extension}";
                            break;
                        }
                }
                _file = new DynamicConfigFile(_path);
                _file.Settings = new JsonSerializerSettings() { ReferenceLoopHandling = ReferenceLoopHandling.Ignore };
                Init();
            }

            public virtual void Init()
            {
                _plugin.OnRemovedFromManager.Add(new Action<Plugin, PluginManager>(Unload));
                Load();
                Save();
                Load();
            }

            public virtual void Load()
            {
                if (Compressed)
                {
                    LoadCompressed();
                    return;
                }

                if (!_file.Exists())
                {
                    Save();
                }
                Instance = _file.ReadObject<Type>();
                if (Instance == null)
                {
                    Instance = Activator.CreateInstance<Type>();
                    Save();
                }
                return;
            }

            private void LoadCompressed()
            {
                string str = _file.ReadObject<string>();
                if (str == null || str == "")
                {
                    Instance = Activator.CreateInstance<Type>();
                    return;
                }
                using (var compressedStream = new MemoryStream(Convert.FromBase64String(str)))
                using (var zipStream = new GZipStream(compressedStream, CompressionMode.Decompress))
                using (var resultStream = new MemoryStream())
                {
                    var buffer = new byte[4096];
                    int read;

                    while ((read = zipStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        resultStream.Write(buffer, 0, read);
                    }

                    Instance = JsonConvert.DeserializeObject<Type>(Encoding.UTF8.GetString(resultStream.ToArray()));
                }
            }

            public virtual void Save()
            {
                if (Compressed)
                {
                    SaveCompressed();
                    return;
                }

                _file.WriteObject(Instance);
                return;
            }

            private void SaveCompressed()
            {
                using (var stream = new MemoryStream())
                {
                    using (GZipStream zipStream = new GZipStream(stream, CompressionMode.Compress))
                    {
                        byte[] bytes = Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(Instance));
                        zipStream.Write(bytes, 0, bytes.Length);
                        zipStream.Close();
                        _file.WriteObject(Convert.ToBase64String(stream.ToArray()));
                    }
                }
            }

            public virtual void Reload()
            {
                Load();
            }

            private void Unload(Plugin sender, PluginManager manager)
            {
                if (SaveOnUnload)
                {
                    Save();
                }
            }
        }

        #endregion

    }
}

// --- End of file: UpgradeTimer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/underworld ---
// --- Original File Path: U/Underworld/Underworld.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using CompanionServer.Handlers;
using Facepunch;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;

/*
Fixed noclip not always being set when connecting to server
Fix for Rust update
*/

namespace Oxide.Plugins
{
    [Info("Underworld", "nivex", "1.0.8")]
    [Description("Teleports youu under the world when disconnected.")]
    class Underworld : RustPlugin
    {
        [PluginReference] Plugin Vanish;

        private const string permBlocked = "underworld.blocked";
        private const string permName = "underworld.use";
        private StoredData storedData = new();
        private List<ulong> protect = new();

        public class StoredData
        {
            public Dictionary<string, UserInfo> Users = new();
        }

        public class UserInfo
        {
            public string Home { get; set; } = Vector3.zero.ToString();
            public bool WakeOnLand { get; set; } = true;
            public bool SaveInventory { get; set; } = true;
            public bool AutoNoClip { get; set; } = true;
            public List<UnderworldItem> Items { get; set; } = new();
        }

        public class UnderworldItem
        {
            public List<UnderworldItem> contents { get; set; }
            public string container { get; set; } = "main";
            public int ammo { get; set; }
            public int amount { get; set; }
            public string ammoType { get; set; }
            public float condition { get; set; }
            public float fuel { get; set; }
            public int frequency { get; set; }
            public int itemid { get; set; }
            public float maxCondition { get; set; }
            public string name { get; set; }
            public int position { get; set; } = -1;
            public ulong skin { get; set; }
            public string text { get; set; }
            public int blueprintAmount { get; set; }
            public int blueprintTarget { get; set; }
            public int dataInt { get; set; }
            public ulong subEntity { get; set; }
            public bool shouldPool { get; set; }

            public UnderworldItem() { }

            public UnderworldItem(string container, Item item)
            {
                this.container = container;
                itemid = item.info.itemid;
                name = item.name;
                text = item.text;
                amount = item.amount;
                condition = item.condition;
                maxCondition = item.maxCondition;
                fuel = item.fuel;
                position = item.position;
                skin = item.skin;

                if (item.instanceData != null)
                {
                    dataInt = item.instanceData.dataInt;
                    blueprintAmount = item.instanceData.blueprintAmount;
                    blueprintTarget = item.instanceData.blueprintTarget;
                    subEntity = item.instanceData.subEntity.Value;
                    shouldPool = item.instanceData.ShouldPool;
                }

                if (item.GetHeldEntity() is HeldEntity e)
                {
                    if (e is BaseProjectile baseProjectile)
                    {
                        ammo = baseProjectile.primaryMagazine.contents;
                        ammoType = baseProjectile.primaryMagazine.ammoType.shortname;
                    }
                    else if (e is FlameThrower flameThrower)
                    {
                        ammo = flameThrower.ammo;
                    }
                }

                if (ItemModAssociatedEntity<PagerEntity>.GetAssociatedEntity(item) is PagerEntity pagerEntity)
                {
                    frequency = pagerEntity.GetFrequency();
                }

                if (item.contents?.itemList?.Count > 0)
                {
                    contents = new();

                    foreach (var mod in item.contents.itemList)
                    {
                        if (!Blacklisted(mod))
                        {
                            contents.Add(new("default", mod));
                        }
                    }
                }
            }

            public static Item Create(UnderworldItem uwi)
            {
                if (uwi.itemid == 0 || string.IsNullOrEmpty(uwi.container))
                {
                    return null;
                }

                Item item;
                if (uwi.blueprintTarget != 0)
                {
                    item = ItemManager.Create(Workbench.GetBlueprintTemplate());
                    item.blueprintTarget = uwi.blueprintTarget;
                    item.amount = uwi.blueprintAmount;
                }
                else item = ItemManager.CreateByItemID(uwi.itemid, uwi.amount, uwi.skin);

                if (item == null)
                {
                    return null;
                }

                if (uwi.blueprintAmount != 0 || uwi.blueprintTarget != 0 || uwi.dataInt != 0 || uwi.subEntity != 0)
                {
                    item.instanceData = uwi.shouldPool ? Pool.Get<ProtoBuf.Item.InstanceData>() : new ProtoBuf.Item.InstanceData();
                    item.instanceData.ShouldPool = uwi.shouldPool;
                    item.instanceData.blueprintAmount = uwi.blueprintAmount;
                    item.instanceData.blueprintTarget = uwi.blueprintTarget;
                    item.instanceData.dataInt = uwi.dataInt;
                    item.instanceData.subEntity = new(uwi.subEntity);
                }

                if (!string.IsNullOrEmpty(uwi.name))
                {
                    item.name = uwi.name;
                }

                if (!string.IsNullOrEmpty(uwi.text))
                {
                    item.text = uwi.text;
                }

                if (item.GetHeldEntity() is HeldEntity e)
                {
                    if (item.skin != 0)
                    {
                        e.skinID = item.skin;
                    }

                    if (e is BaseProjectile baseProjectile)
                    {
                        baseProjectile.DelayedModsChanged();
                        baseProjectile.primaryMagazine.contents = uwi.ammo;
                        if (!string.IsNullOrEmpty(uwi.ammoType))
                        {
                            baseProjectile.primaryMagazine.ammoType = ItemManager.FindItemDefinition(uwi.ammoType);
                        }
                    }
                    else if (e is FlameThrower flameThrower)
                    {
                        flameThrower.ammo = uwi.ammo;
                    }
                    else if (e is Chainsaw chainsaw)
                    {
                        chainsaw.ammo = uwi.ammo;
                    }

                    e.SendNetworkUpdate();
                }

                if (uwi.frequency > 0 && item.info.GetComponentInChildren<ItemModRFListener>() is ItemModRFListener rfListener)
                {
                    if (item.instanceData.subEntity.IsValid && BaseNetworkable.serverEntities.Find(item.instanceData.subEntity) is PagerEntity pagerEntity)
                    {
                        pagerEntity.ChangeFrequency(uwi.frequency);
                    }
                }

                if (uwi.contents != null)
                {
                    foreach (var uwm in uwi.contents)
                    {
                        Item mod = Create(uwm);

                        if (mod != null && !mod.MoveToContainer(item.contents))
                        {
                            mod.Remove();
                        }
                    }
                }

                if (item.hasCondition)
                {
                    item._maxCondition = uwi.maxCondition;
                    item._condition = uwi.condition;
                }

                item.fuel = uwi.fuel;
                item.MarkDirty();

                return item;
            }

            public static void Restore(BasePlayer player, UnderworldItem uwi)
            {
                Item item = Create(uwi);

                if (item == null)
                {
                    return;
                }

                ItemContainer newcontainer = uwi.container switch
                {
                    "belt" => player.inventory.containerBelt,
                    "wear" => player.inventory.containerWear,
                    "main" or _ => player.inventory.containerMain,
                };

                if (!item.MoveToContainer(newcontainer, uwi.position, true))
                {
                    player.GiveItem(item);
                }
            }
        }

        private void OnNewSave()
        {
            if (wipeSaves)
            {
                wipeSaves = false; 
                
                foreach (var pair in storedData.Users)
                {
                    pair.Value.Items.Clear();
                }

                SaveData();
            }
        }

        private void Init()
        {
            Unsubscribe(nameof(OnPlayerSleep));
            Unsubscribe(nameof(OnPlayerSleepEnded));
            Unsubscribe(nameof(OnPlayerRespawned));

            permission.RegisterPermission(permBlocked, this);
            permission.RegisterPermission(permName, this);

            LoadData();
            LoadVariables();
        }

        private void OnServerInitialized()
        {
            Subscribe(nameof(OnPlayerSleep));
            Subscribe(nameof(OnPlayerSleepEnded));
            Subscribe(nameof(OnPlayerRespawned));

            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
        }

        private void Unload()
        {
            SaveData();
            Blacklist.Clear();
        }

        private object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
        {
            if (type == AntiHackType.InsideTerrain && GetUser(player, false) != null)
            {
                return true;
            }
            return null;
        }

        private void OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo)
        {
            if (protect.Count == 0) Unsubscribe(nameof(OnEntityTakeDamage));
            if (hitInfo == null || !player || !protect.Contains(player.userID)) return;
            if (hitInfo.damageTypes.Has(Rust.DamageType.Cold)) hitInfo.damageTypes = new();
            if (hitInfo.damageTypes.Has(Rust.DamageType.Drowned)) hitInfo.damageTypes = new();
            if (hitInfo.damageTypes.Has(Rust.DamageType.Suicide) && player.IsSleeping() && player.IdleTime > 0.5f) hitInfo.damageTypes = new();
        }

        private void OnPlayerSleep(BasePlayer player)
        {
            NextTick(() =>
            {
                if (!player || player.IsDestroyed || player.IsConnected || !IsAllowed(player))
                {
                    return;
                }

                var user = GetUser(player, false);

                if (user == null)
                {
                    return;
                }

                var userHome = user.Home.ToVector3();
                var position = userHome == Vector3.zero ? defaultPos : userHome;

                if (position == Vector3.zero)
                {
                    position = new Vector3(player.transform.position.x, TerrainMeta.HeightMap.GetHeight(player.transform.position) - 5f, player.transform.position.z);
                }

                SaveInventory(player, user);

                player.Teleport(position);
                player.ChatMessage("Sleep underworld");
            });
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            var user = GetUser(player);

            if (user == null || !player.IsConnected)
            {
                return;
            }

            if (!protect.Contains(player.userID))
            {
                protect.Add(player.userID);
                Subscribe(nameof(OnEntityTakeDamage));
            }

            if (player.IsDead())
            {
                return;
            }

            if (player.IsSleeping())
            {
                StopDrowning(player);
                timer.Once(0.5f, () => OnPlayerConnected(player));
                return;
            }

            if (user.WakeOnLand)
            {
                float y = TerrainMeta.HeightMap.GetHeight(player.transform.position);
                player.Teleport(player.transform.position.WithY(y + 2f));
                player.SendNetworkUpdateImmediate();
                player.ChatMessage("Awake on land");
            }

            if (user.AutoNoClip)
            {
                player.Invoke(() =>
                {
                    if (!player.IsFlying)
                    {
                        player.SendConsoleCommand("noclip");
                    }
                }, 0.1f);
            }

            Disappear(player);

            ulong userid = player.userID;

            timer.Once(5f, () =>
            {
                protect.Remove(userid);
                if (protect.Count == 0) Unsubscribe(nameof(OnEntityTakeDamage));
            });
        }

        private void Disappear(BasePlayer player)
        {
            if (autoVanish)
            {
                if (!player.limitNetworking) Vanish?.Call("Disappear", player);
                else Vanish?.Call("VanishGui", player);
            }
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            var user = GetUser(player);

            if (user == null)
            {
                return;
            }

            protect.Remove(player.userID);

            if (maxHHT)
            {
                player.health = 100f;
                player.metabolism.hydration.value = player.metabolism.hydration.max;
                player.metabolism.calories.value = player.metabolism.calories.max;
            }

            if (allowSaveInventory && user.SaveInventory && user.Items.Count > 0)
            {
                List<Item> items = Pool.Get<List<Item>>();
                int count = player.inventory.GetAllItems(items);
                Pool.FreeUnmanaged(ref items);
                if (count == 2)
                {
                    if (player.inventory.GetAmount(ItemManager.FindItemDefinition("rock").itemid) == 1)
                    {
                        if (player.inventory.GetAmount(ItemManager.FindItemDefinition("torch").itemid) == 1)
                        {
                            player.inventory.Strip();
                        }
                    }
                }

                foreach (var uwi in user.Items.ToList())
                {
                    UnderworldItem.Restore(player, uwi);
                }

                user.Items.Clear();
                SaveData();
            }

            Disappear(player);
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            if (!player || !player.IsConnected)
            {
                return;
            }

            var user = GetUser(player);

            if (user == null)
            {
                return;
            }

            Disappear(player);

            if (user.AutoNoClip)
            {
                player.Invoke(() =>
                {
                    if (!player.IsFlying)
                    {
                        player.SendConsoleCommand("noclip");
                    }
                }, 0.1f);
            }
        }

        [ChatCommand("uw")]
        private void cmdUnderworld(BasePlayer player, string command, string[] args)
        {
            if (!IsAllowed(player))
            {
                Message(player, "NoPermission");
                return;
            }

            var user = GetUser(player);

            if (user == null)
            {
                Message(player, "NoPermission");
                return;
            }

            if (args.Length >= 1)
            {
                switch (args[0].ToLower())
                {
                    case "tp":
                        {
                            player.Teleport(user.Home.ToVector3());
                            break;
                        }
                    case "save":
                        {
                            if (!allowSaveInventory)
                                return;

                            user.SaveInventory = !user.SaveInventory;
                            Message(player, user.SaveInventory ? "SavingInventory" : "NotSavingInventory");
                            SaveData();
                        }
                        return;
                    case "set":
                        {
                            var position = player.transform.position;

                            if (args.Length == 4)
                            {
                                if (args[1].All(char.IsDigit) && args[2].All(char.IsDigit) && args[3].All(char.IsDigit))
                                {
                                    var customPos = new Vector3(float.Parse(args[1]), 0f, float.Parse(args[3]));

                                    if (Vector3.Distance(customPos, Vector3.zero) <= TerrainMeta.Size.x / 1.5f)
                                    {
                                        customPos.y = float.Parse(args[2]);

                                        if (customPos.y > -100f && customPos.y < 4400f)
                                            position = customPos;
                                        else
                                            Message(player, "OutOfBounds");
                                    }
                                    else
                                        Message(player, "OutOfBounds");
                                }
                                else
                                    Message(player, "Help1", FormatPosition(user.Home.ToVector3()));
                            }

                            user.Home = position.ToString();
                            Message(player, "PositionAdded", FormatPosition(position));
                            SaveData();
                        }
                        return;
                    case "reset":
                        {
                            user.Home = Vector3.zero.ToString();

                            if (defaultPos != Vector3.zero)
                            {
                                user.Home = defaultPos.ToString();
                                Message(player, "PositionRemoved2", user.Home);
                            }
                            else
                                Message(player, "PositionRemoved1");

                            SaveData();
                        }
                        return;
                    case "wakeup":
                        {
                            user.WakeOnLand = !user.WakeOnLand;
                            Message(player, user.WakeOnLand ? "PlayerWakeUp" : "PlayerWakeUpReset");
                            SaveData();
                        }
                        return;
                    case "noclip":
                        {
                            user.AutoNoClip = !user.AutoNoClip;
                            Message(player, user.AutoNoClip ? "PlayerNoClipEnabled" : "PlayerNoClipDisabled");
                            SaveData();
                        }
                        return;
                    case "g":
                    case "ground":
                        {
                            player.Teleport(new Vector3(player.transform.position.x, TerrainMeta.HeightMap.GetHeight(player.transform.position) + 1f, player.transform.position.z));
                        }
                        return;
                }
            }

            string homePos = FormatPosition(user.Home.ToVector3() == Vector3.zero ? defaultPos : user.Home.ToVector3());

            Message(player, "Help0", user.SaveInventory && allowSaveInventory);
            Message(player, "Help1", homePos);
            Message(player, "Help2");
            Message(player, "Help3", user.WakeOnLand);
            Message(player, "Help4", user.AutoNoClip);
            Message(player, "Help5");
        }

        public void StopDrowning(BasePlayer player)
        {
            if (player.transform.position.y < WaterSystem.OceanLevel && !player.IsFlying)
            {
                player.SendConsoleCommand("noclip");
            }
        }

        private UserInfo GetUser(BasePlayer player, bool f = true)
        {
            if (!player || f && !player.IsConnected || !IsAllowed(player) || permission.UserHasPermission(player.UserIDString, permBlocked))
            {
                return null;
            }

            if (!storedData.Users.TryGetValue(player.UserIDString, out var user))
            {
                storedData.Users[player.UserIDString] = user = new();
            }

            return user;
        }

        public string FormatPosition(Vector3 position)
        {
            return $"{position.x:N2} {position.y:N2} {position.z:N2}";
        }

        private void LoadData()
        {
            try { storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name); } catch (Exception ex) { Puts(ex.ToString()); } finally { storedData ??= new(); }
        }

        private void SaveData()
        {
            if (storedData != null)
            {
                Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
            }
        }

        private void SaveInventory(BasePlayer player, UserInfo user)
        {
            if (!allowSaveInventory || !user.SaveInventory)
            {
                return;
            }

            List<Item> itemList = Pool.Get<List<Item>>();
            int num = player.inventory.GetAllItems(itemList);
            Pool.FreeUnmanaged(ref itemList);

            if (num == 0)
            {
                user.Items.Clear();
                SaveData();
                return;
            }

            List<UnderworldItem> items = new();

            foreach (Item item in player.inventory.containerWear.itemList.ToList())
            {
                if (Blacklisted(item)) continue;
                items.Add(new("wear", item));
                item.Remove();
            }

            foreach (Item item in player.inventory.containerMain.itemList.ToList())
            {
                if (Blacklisted(item)) continue;
                items.Add(new("main", item));
                item.Remove();
            }

            foreach (Item item in player.inventory.containerBelt.itemList.ToList())
            {
                if (Blacklisted(item)) continue;
                items.Add(new("belt", item));
                item.Remove();
            }

            if (items.Count == 0)
            {
                return;
            }

            ItemManager.DoRemoves();
            user.Items.Clear();
            user.Items.AddRange(items);
            SaveData();
        }

        private bool IsAllowed(BasePlayer player)
        {
            return player != null && (player.IsAdmin || DeveloperList.Contains(player.userID) || permission.UserHasPermission(player.UserIDString, permName));
        }

        private static bool Blacklisted(Item item)
        {
            return item == null || Blacklist.Contains(item.info.shortname) || Blacklist.Contains(item.info.itemid.ToString());
        }

        #region Config

        private bool Changed;
        private Vector3 defaultPos;
        private bool allowSaveInventory;
        private bool maxHHT;
        private bool autoVanish;
        private static List<string> Blacklist = new();
        private bool wipeSaves;

        private List<object> DefaultBlacklist
        {
            get
            {
                return new()
                {
                    "2080339268",
                    "can.tuna.empty"
                };
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new()
            {
                ["PositionAdded"] = "You will now teleport to <color=yellow>{0}</color> on disconnect.",
                ["PositionRemoved1"] = "You will now teleport under ground on disconnect.",
                ["PositionRemoved2"] = "You will now teleport to <color=yellow>{0}</color> on disconnect.",
                ["PlayerWakeUp"] = "You will now teleport above ground when you wake up.",
                ["PlayerWakeUpReset"] = "You will no longer teleport above ground when you wake up.",
                ["PlayerNoClipEnabled"] = "You will now automatically be noclipped on reconnect.",
                ["PlayerNoClipDisabled"] = "You will no longer be noclipped on reconnect.",
                ["SavingInventory"] = "Your inventory will be saved and stripped on disconnect, and restored when you wake up.",
                ["NotSavingInventory"] = "Your inventory will no longer be saved.",
                ["Help0"] = "/uw save - toggles saving inventory (enabled: {0})",
                ["Help1"] = "/uw set <x y z> - sets your log out position. can specify coordinates <color=yellow>{0}</color>",
                ["Help2"] = "/uw reset - resets your log out position to be underground unless a position is configured in the config file",
                ["Help3"] = "/uw wakeup - toggle waking up on land (enabled: {0})",
                ["Help4"] = "/uw noclip - toggle auto noclip on reconnect (enabled: {0})",
                ["Help5"] = "/uw g - teleport to the ground",
                ["OutOfBounds"] = "The specified coordinates are not within the allowed boundaries of the map.",
                ["NoPermission"] = "You do not have permission to use this command."
            }, this);
        }

        private void LoadVariables()
        {
            maxHHT = Convert.ToBoolean(GetConfig("Settings", "Set Health, Hunger and Thirst to Max", false));
            defaultPos = GetConfig("Settings", "Default Teleport To Position On Disconnect", "(0, 0, 0)").ToString().ToVector3();
            allowSaveInventory = Convert.ToBoolean(GetConfig("Settings", "Allow Save And Strip Admin Inventory On Disconnect", true));
            Blacklist = (GetConfig("Settings", "Blacklist", DefaultBlacklist) as List<object>).Where(o => o != null && o.ToString().Length > 0).Cast<string>().ToList();
            autoVanish = Convert.ToBoolean(GetConfig("Settings", "Auto Vanish On Connect", true));
            wipeSaves = Convert.ToBoolean(GetConfig("Settings", "Wipe Saved Inventories On Map Wipe", false));
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            Config.Clear();
            LoadVariables();
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new();
                Config[menu] = data;
                Changed = true;
            }

            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }

            return value;
        }

        private void Message(BasePlayer player, string key, params object[] args)
        {
            if (player != null)
            {
                Player.Message(player, GetMessage(key, player.UserIDString, args));
            }
        }

        private string GetMessage(string key, string id = null, params object[] args)
        {
            return args.Length > 0 ? string.Format(lang.GetMessage(key, this, id), args) : lang.GetMessage(key, this, id);
        }

        #endregion
    }
}

// --- End of file: Underworld.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/universal-ui ---
// --- Original File Path: U/UniversalUI/UniversalUI.cs ---

﻿using System.Collections.Generic;
using UnityEngine;
using Oxide.Game.Rust.Cui;
using System;
using System.Linq;
using Oxide.Core.Plugins;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Universal UI", "Absolut", "2.1.5")]
    [Description("A fully customizable UI for info and buttons")]
    class UniversalUI : RustPlugin
    {
        [PluginReference]
        Plugin ImageLibrary, Kits;

        string TitleColor = "<color=orange>";
        string MsgColor = "<color=#A9A9A9>";
        bool SkinsReady = false;
        private Dictionary<ulong, screen> UniversalUIInfo = new Dictionary<ulong, screen>();
        class screen
        {
            public int section;
            public int page;
            public bool open;
            public int showSection;
            public bool admin;
        }
        private bool Debugging;
        private List<ulong> NoInfo = new List<ulong>();
        private Dictionary<ulong, DelayedCommand> OnDelay = new Dictionary<ulong, DelayedCommand>();
        class DelayedCommand
        {
            public bool closeui;
            public List<string> args;
        }
        private Dictionary<string, Timer> timers = new Dictionary<string, Timer>();

        #region Server Hooks

        void Loaded()
        {
            lang.RegisterMessages(messages, this);
            Debugging = false;
        }

        void Unload()
        {
            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                DestroyPlayer(p);
            }
            foreach (var entry in timers)
                entry.Value.Destroy();
            timers.Clear();
        }

        void OnServerInitialized()
        {
            try
            {
                ImageLibrary.Call("isLoaded", null);
            }
            catch (Exception)
            {
                PrintWarning($"ImageLibrary is missing. Unloading {Name} as it will not work without ImageLibrary.");
                Interface.Oxide.UnloadPlugin(Name);
                return;
            }
            LoadVariables();
            RegisterPermissions();
            foreach (BasePlayer p in BasePlayer.activePlayerList)
                OnPlayerInit(p);
            GetAllImages();
            timers.Add("info", timer.Once(configData.InfoInterval * 60, () => InfoLoop()));
        }

        private void OnPlayerInit(BasePlayer player)
        {
            if (player != null)
            {
                if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
                {
                    timer.Once(5, () => OnPlayerInit(player));
                    return;

                }
                if (configData.MenuKeyBinding != "")
                    player.Command($"bind {configData.MenuKeyBinding} \"UI_OpenUniversalUI\"");
                if (configData.InfoInterval != 0)
                    if (configData.MenuKeyBinding != "")
                        GetSendMSG(player, "UIInfo", configData.MenuKeyBinding.ToString());
                    else GetSendMSG(player, "UIInfo1");
                if (configData.ForceOpenOnJoin)
                    OpenUniversalUI(player);
            }
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            DestroyUniversalUI(player);
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            DestroyPlayer(player);
        }

        object OnServerCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection?.player as BasePlayer;
            if (player == null)
                return null;
            if (OnDelay.ContainsKey(player.userID) && arg.cmd?.FullName == "chat.say")
            {
                if (arg.Args.Contains("quit"))
                {
                    OnDelay.Remove(player.userID);
                    GetSendMSG(player, "ExitDelayed");
                    return false;
                }
                foreach (var entry in arg.Args)
                    OnDelay[player.userID].args.Add(entry);
                RunCommand(player, OnDelay[player.userID].args.ToArray());
                return false;
            }
            return null;
        }

        private void RunCommand(BasePlayer player, string[] command)
        {
            if (command[0] == "chat.say")
            {
                rust.RunClientCommand(player, $"chat.say 0", string.Join(" ", command.Skip(1).ToArray()));
                if(Debugging) Puts($"Chat say:");
            }
            else
            {
                rust.RunClientCommand(player, string.Join(" ", command.ToArray()));
                if (Debugging) Puts($"Console Command: {string.Join(" ", command.ToArray())}");
            }
            if (OnDelay.ContainsKey(player.userID))
                OnDelay.Remove(player.userID);
        }

    #endregion

        #region Functions
    [ConsoleCommand("UI_OpenUniversalUI")]
        private void cmdUI_OpenUniversalUI(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (UniversalUIInfo.ContainsKey(player.userID))
                if (!UniversalUIInfo[player.userID].open)
                {
                    UniversalUIInfo[player.userID].open = true;
                    OpenUniversalUI(player);
                }
                else
                    DestroyUniversalUI(player);
            else
                OpenUniversalUI(player);
        }

        private void OpenUniversalUI(BasePlayer player)
        {
            if (!SkinsReady) { GetSendMSG(player, "ImageLibraryNotReady"); return; }
            if (!UniversalUIInfo.ContainsKey(player.userID))
                UniversalUIInfo.Add(player.userID, new screen { page = 0, section = 0, showSection = 0, open = true });
            UniversalUIPanel(player);
            if (!NoInfo.Contains(player.userID))
                BackgroundPanel(player);
            return;
        }

        [ConsoleCommand("UI_DestroyUniversalUI")]
        private void cmdUI_DestroyUniversalUI(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyUniversalUI(player);
        }

        [ConsoleCommand("UI_OpenInfoUI")]
        private void cmdUI_OpenInfoUI(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (NoInfo.Contains(player.userID))
                NoInfo.Remove(player.userID);
            OpenUniversalUI(player);
        }

        [ConsoleCommand("UI_HideInfo")]
        private void cmdUI_HideInfo(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (!NoInfo.Contains(player.userID))
                NoInfo.Add(player.userID);
            CuiHelper.DestroyUi(player, PanelInfo);
            OpenUniversalUI(player);
        }

        private object KitMax(string kitname) => Kits?.Call("KitMax", kitname);
        public int GetKitMax(string kitname)
        {
            var Max = KitMax(kitname);
            if (Max != null)
            {
                return Convert.ToInt32(Max);
            }
            return 0;
        }

        private object KitItemAmount(string kitname, int ID) => Kits?.Call("KitItemAmount", kitname, ID);
        public int GetKitItemAmount(string kitname, int ID)
        {
            var amount = KitItemAmount(kitname, ID);
            if (amount != null)
            {
                return Convert.ToInt32(amount);
            }
            return 0;
        }

        private object KitDescription(string kitname) => Kits?.Call("KitDescription", kitname);
        public string GetKitDescription(string kitname)
        {
            var Desc = KitDescription(kitname);
            if (Desc != null)
            {
                if (Desc is string)
                {
                    string dsc = Desc as string;
                    return dsc;
                }
            }
            return "NONE";
        }


        private object KitImage(string kitname) => Kits?.Call("KitImage", kitname);
        public string GetKitImage(string kitname)
        {
            var image = KitImage(kitname);
            if (image != null)
            {
                if (image is string)
                {
                    string img = image as string;
                    return img;
                }
            }
            return "http://i.imgur.com/xxQnE1R.png";
        }

        private object KitCooldown(string kitname) => Kits?.Call("KitCooldown", kitname);
        public int GetKitCooldown(string kitname)
        {
            var cooldown = KitCooldown(kitname);
            if (cooldown != null)
            {
                return Convert.ToInt32(cooldown) / 60;
            }
            return 0;
        }

        private object GetKits() => Kits?.Call("GetAllKits");
        public string[] GetKitNames()
        {
            var kits = GetKits();
            if (kits != null)
            {
                if (kits is string[])
                {
                    var array = kits as string[];
                    return array;
                }
            }
            return null;
        }



        void AskForPageType(BasePlayer player, int page)
        {
            if (!UniversalUIInfo.ContainsKey(player.userID)) return;
            DestroyUniversalUI(player);
                CuiHelper.DestroyUi(player, PanelInfo);
                var element = UI.CreateElementContainer(PanelInfo, "0 0 0 0", "0.3 0.4", "0.7 0.6", true);
                var types = Enum.GetValues(typeof(PageType)).Cast<PageType>();
                var amount = types.Count();
                var i = 0;
                float[] pos;
                foreach (var entry in types)
                {
                    pos = SelectionButtonLocation(i, amount);
                    UI.LoadImage(ref element, PanelInfo, TryForImage(entry.ToString()), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                    UI.CreateTextOutline(ref element, PanelInfo, UIColors["white"], UIColors["black"], GetMSG("Type",player, entry.ToString()), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3] + .05f}", TextAnchor.UpperCenter);
                    UI.CreateButton(ref element, PanelInfo, "0 0 0 0", "", 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_SetPageType {entry.ToString()} {page}", TextAnchor.MiddleCenter);
                    i++;
                }
                CuiHelper.AddUi(player, element);
        }

        [ConsoleCommand("UI_SetPageType")]
        private void cmdUI_SetPageType(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (!UniversalUIInfo.ContainsKey(player.userID)) return;
            DestroyUniversalUI(player);
            if (configData.sections.ContainsKey(UniversalUIInfo[player.userID].section))
            {
                configData.sections[UniversalUIInfo[player.userID].section].pages[Convert.ToInt32(arg.Args[1])].type = (PageType)Enum.Parse(typeof(PageType), arg.Args[0]);
                Config.WriteObject(configData, true);
            }
            else GetSendMSG(player, "SectionNotFound");
            OpenUniversalUI(player);
        }


        private float[] SelectionButtonLocation(int number, int amount)
        {
            var size = Decimal.Divide(1, amount);
            Vector2 position = new Vector2(0.03f, (float)(1 - size));
            Vector2 dimensions = new Vector2((float)size, .9f);
            float offsetY = 0;
            float offsetX = (0.015f + dimensions.x) * number;
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        [ConsoleCommand("UI_AddNewSection")]
        private void cmdUI_AddNewSection(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (!UniversalUIInfo.ContainsKey(player.userID)) return;
            var index = 1;
            foreach (var entry in configData.sections.Where(k => k.Key == index))
            {
                index++;
                continue;
            }
            configData.sections.Add(index, new Section { name = index.ToString().ToUpper(), pages = new List<Page> { new Page { page = 0, name = $"Added By {player.displayName}" } } });
            Config.WriteObject(configData, true);
            OpenUniversalUI(player);
        }

        [ConsoleCommand("UI_RemoveSection")]
        private void cmdUI_RemoveSection(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (!UniversalUIInfo.ContainsKey(player.userID)) return;
            if (configData.sections.ContainsKey(UniversalUIInfo[player.userID].section))
                configData.sections.Remove(UniversalUIInfo[player.userID].section);
            Config.WriteObject(configData, true);
            UniversalUIInfo[player.userID].section = 0;
            OpenUniversalUI(player);
        }

        [ConsoleCommand("UI_AddNewPage")]
        private void cmdUI_AddNewPage(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (!UniversalUIInfo.ContainsKey(player.userID)) return;
            var existingPages = configData.sections[UniversalUIInfo[player.userID].section].pages;
            var index = 0;
            foreach (var entry in existingPages.Where(k => k.page == index))
                index++;
            configData.sections[UniversalUIInfo[player.userID].section].pages.Add(new Page { page = index, name = $"Added By {player.displayName}", buttons = new List<PageButton> { new PageButton { order = 0 }, new PageButton { order = 1 }, new PageButton { order = 2 }, new PageButton { order = 3 } } });
            AskForPageType(player, index);
            Config.WriteObject(configData, true);
        }

        [ConsoleCommand("UI_RemovePage")]
        private void cmdUI_RemovePage(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (!UniversalUIInfo.ContainsKey(player.userID)) return;
            foreach (var entry in configData.sections[UniversalUIInfo[player.userID].section].pages.Where(k => k.page == UniversalUIInfo[player.userID].page))
            {
                configData.sections[UniversalUIInfo[player.userID].section].pages.Remove(entry);
                break;
            }
            Config.WriteObject(configData, true);
            UniversalUIInfo[player.userID].page = 0;
            OpenUniversalUI(player);
        }




        [ConsoleCommand("UI_RunConsoleCommand")]
        private void cmdUI_RunConsoleCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            //Puts(string.Join(" ",arg.Args));
            var cmd = "";
            if (arg.Args[1] == "delay")
            {
                if (OnDelay.ContainsKey(player.userID))
                    OnDelay.Remove(player.userID);
                OnDelay.Add(player.userID, new DelayedCommand { closeui = Convert.ToBoolean(arg.Args[0]), args = new List<string>() });
                foreach (var e in arg.Args.Skip(2))
                OnDelay[player.userID].args.Add(e);
                var message = string.Join(" ", arg.Args.Skip(2).ToArray());
                //Puts(message);
                //if (arg.Args[2] == "chat.say")
                //   message = string.Join(" ", arg.Args.Skip(3).ToArray());
                GetSendMSG(player, "DelayedCMD", message);
                DestroyUniversalUI(player);
            }
            else if (arg.Args[1] == "chat.say")
            {
                cmd = string.Join(" ", arg.Args.Skip(2).ToArray());
                rust.RunClientCommand(player, $"chat.say 0", cmd);
                if (Convert.ToBoolean(arg.Args[0]))
                    DestroyUniversalUI(player);
            }
            else
            {
                cmd = string.Join(" ", arg.Args.Skip(1).ToArray());
                rust.RunClientCommand(player, $"{cmd}");
                if (Convert.ToBoolean(arg.Args[0]))
                    DestroyUniversalUI(player);
            }
        }

        [ConsoleCommand("UI_PageTurn")]
        private void cmdUI_PageTurn(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int page = Convert.ToInt32(arg.Args[0]);
            UniversalUIInfo[player.userID].page = page;
            UIInfoPanel(player);
        }

        [ConsoleCommand("UI_SwitchSection")]
        private void cmdUI_SwitchSection(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var section = Convert.ToInt32(arg.Args[0]);
            if (section != 0)
            {
                var admin = arg.Args[1];
                if (admin == "false")
                {
                    if (arg.Args.Length > 2)
                        if (!isAllowed(player, false, arg.Args[2]))
                        {
                            GetSendMSG(player, "NotAuth");
                            return;
                        }
                }
                else
                {
                    if (!isAllowed(player, true))
                    {
                        GetSendMSG(player, "NotAuth");
                        return;
                    }
                }
            }
            UniversalUIInfo[player.userID].section = section;
            UniversalUIInfo[player.userID].page = 0;
            UIInfoPanel(player);
        }

        [ConsoleCommand("UI_InfoSectionButtonChange")]
        private void cmdUI_InfoSectionButtonChange(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var section = Convert.ToInt32(arg.Args[0]);
            if (Debugging) Puts($"{section}");
            UniversalUIInfo[player.userID].showSection = section;
            UIInfoPanel(player);
        }



        private void DestroyUniversalUI(BasePlayer player)
        {
            if (UniversalUIInfo.ContainsKey(player.userID))
                if (UniversalUIInfo[player.userID].open)
                    UniversalUIInfo[player.userID].open = false;
            CuiHelper.DestroyUi(player, PanelStatic);
            CuiHelper.DestroyUi(player, PanelUUI);
            CuiHelper.DestroyUi(player, PanelInfo);
        }

        private void DestroyPlayer(BasePlayer player)
        {
            if (UniversalUIInfo.ContainsKey(player.userID))
                UniversalUIInfo.Remove(player.userID);
            CuiHelper.DestroyUi(player, PanelUUI);
            CuiHelper.DestroyUi(player, PanelInfo);
            //player.Command("bind tab \"inventory.toggle\"");
            //player.Command("bind q \"inventory.togglecrafting\"");
            //player.Command("bind escape \"\"");
            if (configData.MenuKeyBinding != "")
                player.Command($"bind {configData.MenuKeyBinding} \"\"");
        }

        private string GetLang(string msg, BasePlayer player = null)
        {
            if (messages.ContainsKey(msg))
                return lang.GetMessage(msg, this);
            else return msg;
        }

        private void GetSendMSG(BasePlayer player, string message, string arg1 = "", string arg2 = "", string arg3 = "")
        {
            string msg = string.Format(lang.GetMessage(message, this, player.UserIDString), arg1, arg2, arg3);
            SendReply(player, TitleColor + lang.GetMessage("title", this, player.UserIDString) + "</color>" + MsgColor + msg + "</color>");
        }

        private string GetMSG(string message, BasePlayer player = null, string arg1 = "", string arg2 = "", string arg3 = "")
        {
            string p = null;
            if (player != null)
                p = player.UserIDString;
            string msg = string.Format(lang.GetMessage(message, this, p), arg1, arg2, arg3);
            return msg;
        }

        bool isAuth(BasePlayer player)
        {
            if (player.net.connection != null)
                if (player.net.connection.authLevel < 2 && !permission.UserHasPermission(player.UserIDString, "UniversalUI.admin"))
                    return false;
            return true;
        }

        private void RegisterPermissions()
        {
            if (!permission.PermissionExists("UniversalUI.admin"))
                permission.RegisterPermission("UniversalUI.admin", this);
            foreach (var entry in configData.buttons)
                if (!string.IsNullOrEmpty(entry.Value.permission) && !permission.PermissionExists("UniversalUI." + entry.Value.permission))
                    permission.RegisterPermission("UniversalUI."+entry.Value.permission, this);
            foreach (var section in configData.sections)
            {
                if (!string.IsNullOrEmpty(section.Value.permission) && !permission.PermissionExists("UniversalUI." + section.Value.permission))
                    permission.RegisterPermission("UniversalUI." + section.Value.permission, this);
                foreach (var page in section.Value.pages)
                    foreach (var button in page.buttons)
                        if (!string.IsNullOrEmpty(button.permission) && !permission.PermissionExists("UniversalUI." + button.permission))
                            permission.RegisterPermission("UniversalUI." + button.permission, this);
            }

        }

        bool isAllowed(BasePlayer player, bool adminonly, string perm = "")
        {
            if (isAuth(player)) return true;
            if (adminonly) return false;
            if (!string.IsNullOrEmpty(perm))
                if (!permission.UserHasPermission(player.UserIDString, "UniversalUI." + perm)) return false;
            return true;
        }

        private string TryForImage(string shortname, ulong skin = 99)
        {
            if (shortname.Contains("http")) return shortname;
            if (skin == 99) skin = (ulong)ResourceId;
            return GetImage(shortname, skin, true);
        }

        private bool Valid(string name, ulong id = 99)
        {
            if (id == 99) id = (ulong)ResourceId;
            return HasImage(name, id);
        }

        public string GetImage(string shortname, ulong skin = 0, bool returnUrl = false) => (string)ImageLibrary.Call("GetImage", shortname.ToLower(), skin, returnUrl);
        public bool HasImage(string shortname, ulong skin = 0) => (bool)ImageLibrary.Call("HasImage", shortname.ToLower(), skin);
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname.ToLower(), skin);
        public List<ulong> GetImageList(string shortname) => (List<ulong>)ImageLibrary.Call("GetImageList", shortname.ToLower());
        public bool isReady() => (bool)ImageLibrary?.Call("IsReady");
        #endregion

        #region UI Creation

        private string PanelStatic = "PanelStatic";
        private string PanelUUI = "PanelUUI";
        private string PanelInfo = "PanelInfo";
        public class UI
        {
            static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor = false)
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor
                    },
                    new CuiElement().Parent,
                    panelName
                }
            };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = 1.0f, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);
            }

            static public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 1.0f },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }

            static public void LoadImage(ref CuiElementContainer container, string panel, string img, string aMin, string aMax)
            {
                if (img.StartsWith("http") || img.StartsWith("www"))
                {
                    container.Add(new CuiElement
                    {
                        Parent = panel,
                        Components =
                    {
                        new CuiRawImageComponent {Url = img, Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                    });
                }
                else
                    container.Add(new CuiElement
                    {
                        Parent = panel,
                        Components =
                    {
                        new CuiRawImageComponent {Png = img, Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                    });
            }

            static public void CreateTextOverlay(ref CuiElementContainer element, string panel, string text, string color, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 1.0f)
            {
                //if (configdata.DisableUI_FadeIn)
                //    fadein = 0;
                element.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = fadein, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);

            }
            static public void CreateTextOutline(ref CuiElementContainer element, string panel, string colorText, string colorOutline, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                element.Add(new CuiElement
                {
                    Parent = panel,
                    Components =
                    {
                        new CuiTextComponent{Color = colorText, FontSize = size, Align = align, Text = text },
                        new CuiOutlineComponent {Distance = "1 1", Color = colorOutline},
                        new CuiRectTransformComponent {AnchorMax = aMax, AnchorMin = aMin }
                    }
                });
            }
        }

        private Dictionary<string, string> UIColors = new Dictionary<string, string>
        {
            {"black", "0 0 0 1.0" },
            {"dark", "0.1 0.1 0.1 0.98" },
            {"header", "1 1 1 0.3" },
            {"light", "0.7 0.7 0.7 0.3" },
            {"grey1", "0.6 0.6 0.6 1.0" },
            {"brown", "0.3 0.16 0.0 1.0" },
            {"yellow", "0.9 0.9 0.0 1.0" },
            {"orange", "1.0 0.65 0.0 1.0" },
            {"limegreen", "0.42 1.0 0 1.0" },
            {"blue", "0.2 0.6 1.0 1.0" },
            {"red", "1.0 0.1 0.1 1.0" },
            {"white", "1 1 1 1" },
            {"green", "0.28 0.82 0.28 1.0" },
            {"grey", "0.85 0.85 0.85 1.0" },
            {"lightblue", "0.6 0.86 1.0 1.0" },
            {"buttonbg", "0.2 0.2 0.2 0.7" },
            {"buttongreen", "0.133 0.965 0.133 0.9" },
            {"buttonred", "0.964 0.133 0.133 0.9" },
            {"buttongrey", "0.8 0.8 0.8 0.9" },
            {"CSorange", "1.0 0.64 0.10 1.0" }
        };

        private Dictionary<string, string> TextColors = new Dictionary<string, string>
        {
            {"limegreen", "<color=#6fff00>" }
        };

        #endregion

        #region UI Panels

        void UniversalUIPanel(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelUUI);
            if (configData.UseButtonPanel)
            {
                var element = UI.CreateElementContainer(PanelUUI, "0 0 0 0", "0.85 0.225", "1.0 0.725", true);
                foreach (var entry in configData.buttons)
                        if (!string.IsNullOrEmpty(entry.Value.command) && isAllowed(player, entry.Value.adminOnly, entry.Value.permission))
                            CreateButtonOnUI(ref element, PanelUUI, entry.Value, entry.Key);
                if (configData.UseInfoPanel)
                    if (NoInfo.Contains(player.userID))
                        UI.CreateButton(ref element, PanelUUI, UIColors["blue"], GetLang("InfoPanel"), 12, "0.2 -.1", "0.8 -.06", "UI_OpenInfoUI");
                CuiHelper.AddUi(player, element);
            }
        }

        private void CreateButtonOnUI(ref CuiElementContainer container, string panelName, MainButton button, int num)
        {
            var pos = CalcButtonPos(num);
            if (Valid($"UUIMainButton{num}"))
            {
                UI.LoadImage(ref container, panelName, TryForImage($"UUIMainButton{num}"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                UI.CreateButton(ref container, panelName, "0 0 0 0", button.name, 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_RunConsoleCommand {button.CloseUI} {button.command}");
            }
            else
            {
                UI.CreateButton(ref container, panelName, UIColors["red"], button.name, 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_RunConsoleCommand {button.CloseUI} {button.command}");
            }
        }

        void BackgroundPanel(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelStatic);
            if (!UniversalUIInfo.ContainsKey(player.userID))
                UniversalUIInfo.Add(player.userID, new screen { page = 0, section = 0, showSection = 0 });
            CuiElementContainer element = element = UI.CreateElementContainer(PanelStatic, "0 0 0 0", "0.2 0.2", "0.8 0.8", true);
            CuiHelper.AddUi(player, element);
            UIInfoPanel(player);
        }

        void UIInfoPanel(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelInfo);
            CuiElementContainer element = element = UI.CreateElementContainer(PanelInfo, "0 0 0 0", "0.2 0.2", "0.8 0.8");
            //if (UniversalUIInfo[player.userID].section != 0)
            foreach (var entry in configData.sections.Where(k => k.Key == UniversalUIInfo[player.userID].section))
            {
                if (Debugging) Puts($"No Home Page - Trying Section: {entry.Key.ToString()}");
                if (entry.Key == UniversalUIInfo[player.userID].section)
                    foreach (var page in entry.Value.pages.Where(kvp => kvp.page == UniversalUIInfo[player.userID].page))
                    {
                        switch (page.type)
                        {
                            case PageType.text:
                                {
                                    if (Valid($"UUIPage{entry.Key}-{UniversalUIInfo[player.userID].page}"))
                                        UI.LoadImage(ref element, PanelInfo, TryForImage($"UUIPage{entry.Key}-{UniversalUIInfo[player.userID].page}"), "0 0", "1 0.88");
                                    else
                                    {
                                        UI.CreatePanel(ref element, PanelInfo, UIColors["dark"], "0 0", "1 1");
                                        UI.CreatePanel(ref element, PanelInfo, UIColors["light"], "0.01 0.02", "0.99 0.98");
                                    }
                                    if (!string.IsNullOrEmpty(page.name))
                                        UI.CreateLabel(ref element, PanelInfo, UIColors["white"], page.name.ToUpper(), 24, "0.3 0.8", "0.7 0.9");
                                    if (!string.IsNullOrEmpty(page.text))
                                        UI.CreateLabel(ref element, PanelInfo, UIColors["white"], page.text, 12, "0.03 0.2", "0.97 0.65");
                                    //foreach (var button in page.buttons.OrderBy(kvp => kvp.order))
                                    //    if (!string.IsNullOrEmpty(button.command) && isAllowed(player, button.adminOnly, button.permission))
                                    //    {
                                    //        var pos = CalcInfoButtonPos(button.order);
                                    //        if (Valid($"UUIPageButton{entry.Key}-{UniversalUIInfo[player.userID].page}-{button.order}"))
                                    //        {
                                    //            UI.LoadImage(ref element, PanelInfo, TryForImage($"UUIPageButton{entry.Key}-{UniversalUIInfo[player.userID].page}-{button.order}"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                    //            if (!string.IsNullOrEmpty(button.name))
                                    //            {
                                    //                UI.CreateLabel(ref element, PanelInfo, UIColors["red"], button.name, 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                    //                UI.CreateButton(ref element, PanelInfo, "0 0 0 0", button.name, 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_RunConsoleCommand {button.CloseUI} {button.command}");
                                    //            }
                                    //            else
                                    //                UI.CreateButton(ref element, PanelInfo, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_RunConsoleCommand {button.CloseUI} {button.command}");
                                    //        }
                                    //        else
                                    //        {
                                    //            if (!string.IsNullOrEmpty(button.name))
                                    //                UI.CreateButton(ref element, PanelInfo, UIColors["red"], button.name, 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_RunConsoleCommand {button.CloseUI} {button.command}");
                                    //            else
                                    //                UI.CreateButton(ref element, PanelInfo, UIColors["red"], "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_RunConsoleCommand {button.CloseUI} {button.command}");
                                    //        }
                                    //    }
                                    break;
                                }
                            case PageType.buttons:
                                {
                                    if (Valid($"UUIPage{entry.Key}-{UniversalUIInfo[player.userID].page}"))
                                        UI.LoadImage(ref element, PanelInfo, TryForImage($"UUIPage{entry.Key}-{UniversalUIInfo[player.userID].page}"), "0 0", "1 0.88");
                                    else
                                    {
                                        UI.CreatePanel(ref element, PanelInfo, UIColors["dark"], "0 0", "1 1");
                                        UI.CreatePanel(ref element, PanelInfo, UIColors["light"], "0.01 0.02", "0.99 0.98");
                                    }
                                    if (!string.IsNullOrEmpty(page.name))
                                        UI.CreateLabel(ref element, PanelInfo, UIColors["white"], page.name.ToUpper(), 24, "0.3 0.8", "0.7 0.9");
                                    //if (!string.IsNullOrEmpty(page.text))
                                    //    UI.CreateLabel(ref element, PanelInfo, UIColors["white"], page.text, 12, "0.03 0.2", "0.85 0.65", TextAnchor.UpperLeft);
                                    foreach (var button in page.buttons.OrderByDescending(kvp => kvp.order))
                                        if (!string.IsNullOrEmpty(button.command) && isAllowed(player, button.adminOnly, button.permission))
                                        {
                                            if (button.order > 69) continue;
                                            var pos = CalcButtonPagePos(button.order);
                                            if (Valid($"UUIPageButton{entry.Key}-{UniversalUIInfo[player.userID].page}-{button.order}"))
                                            {
                                                UI.LoadImage(ref element, PanelInfo, TryForImage($"UUIPageButton{entry.Key}-{UniversalUIInfo[player.userID].page}-{button.order}"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                                if (!string.IsNullOrEmpty(button.name))
                                                {
                                                    UI.CreateLabel(ref element, PanelInfo, UIColors["red"], button.name, 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                                    UI.CreateButton(ref element, PanelInfo, "0 0 0 0", button.name, 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_RunConsoleCommand {button.CloseUI} {button.command}");
                                                }
                                                else
                                                    UI.CreateButton(ref element, PanelInfo, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_RunConsoleCommand {button.CloseUI} {button.command}");
                                            }
                                            else
                                            {
                                                if (!string.IsNullOrEmpty(button.name))
                                                    UI.CreateButton(ref element, PanelInfo, UIColors["red"], button.name, 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_RunConsoleCommand {button.CloseUI} {button.command}");
                                                else
                                                    UI.CreateButton(ref element, PanelInfo, UIColors["red"], "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_RunConsoleCommand {button.CloseUI} {button.command}");
                                            }
                                        }
                                    break;
                                }
                            case PageType.kits:
                                {
                                    if (Valid($"UUIPage{entry.Key}-{UniversalUIInfo[player.userID].page}"))
                                        UI.LoadImage(ref element, PanelInfo, TryForImage($"UUIPage{entry.Key}-{UniversalUIInfo[player.userID].page}"), "0 0", "1 0.88");
                                    else
                                    {
                                        UI.CreatePanel(ref element, PanelInfo, UIColors["dark"], "0 0", "1 1");
                                        UI.CreatePanel(ref element, PanelInfo, UIColors["light"], "0.01 0.02", "0.99 0.98");
                                    }
                                    if (!string.IsNullOrEmpty(page.name))
                                        UI.CreateLabel(ref element, PanelInfo, UIColors["white"], page.name.ToUpper(), 24, "0.3 0.8", "0.7 0.9");
                                    var i = 0;
                                    foreach (var kit in page.Kits)
                                    {
                                        if (i > 7) break;
                                        CreateKitEntry(ref element, PanelInfo, player, kit, i); i++;
                                    }
                                    if (UniversalUIInfo[player.userID].admin)
                                        UI.CreateButton(ref element, PanelInfo, UIColors["header"], GetLang("AddKit"), 12, "0.03 0.11", "0.13 0.17", $"UI_SelectKitToAdd {0}");
                                    break;
                                }
                            default:
                                {
                                    if (Valid($"UUIPage{entry.Key}-{UniversalUIInfo[player.userID].page}"))
                                        UI.LoadImage(ref element, PanelInfo, TryForImage($"UUIPage{entry.Key}-{UniversalUIInfo[player.userID].page}"), "0 0", "1 0.88");
                                    else
                                    {
                                        UI.CreatePanel(ref element, PanelInfo, UIColors["dark"], "0 0", "1 1");
                                        UI.CreatePanel(ref element, PanelInfo, UIColors["light"], "0.01 0.02", "0.99 0.98");
                                    }
                                    if (!string.IsNullOrEmpty(page.name))
                                        UI.CreateLabel(ref element, PanelInfo, UIColors["white"], page.name.ToUpper(), 24, "0.3 0.8", "0.7 0.9");
                                    if (!string.IsNullOrEmpty(page.text))
                                        UI.CreateLabel(ref element, PanelInfo, UIColors["white"], page.text, 12, "0.03 0.2", "0.85 0.65", TextAnchor.UpperLeft);
                                    foreach (var button in page.buttons.OrderBy(kvp => kvp.order))
                                        if (!string.IsNullOrEmpty(button.command) && isAllowed(player, button.adminOnly, button.permission))
                                        {
                                            var pos = CalcInfoButtonPos(button.order);
                                            if (Valid($"UUIPageButton{entry.Key}-{UniversalUIInfo[player.userID].page}-{button.order}"))
                                            {
                                                UI.LoadImage(ref element, PanelInfo, TryForImage($"UUIPageButton{entry.Key}-{UniversalUIInfo[player.userID].page}-{button.order}"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                                if (!string.IsNullOrEmpty(button.name))
                                                {
                                                    UI.CreateLabel(ref element, PanelInfo, UIColors["red"], button.name, 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                                                    UI.CreateButton(ref element, PanelInfo, "0 0 0 0", button.name, 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_RunConsoleCommand {button.CloseUI} {button.command}");
                                                }
                                                else
                                                    UI.CreateButton(ref element, PanelInfo, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_RunConsoleCommand {button.CloseUI} {button.command}");
                                            }
                                            else
                                            {
                                                if (!string.IsNullOrEmpty(button.name))
                                                    UI.CreateButton(ref element, PanelInfo, UIColors["red"], button.name, 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_RunConsoleCommand {button.CloseUI} {button.command}");
                                                else
                                                    UI.CreateButton(ref element, PanelInfo, UIColors["red"], "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_RunConsoleCommand {button.CloseUI} {button.command}");
                                            }
                                        }
                                    break;
                                }
                        }
                    }
                break;
            }
            //Create Section Buttons at the Top

            if (UniversalUIInfo[player.userID].section == 0)
            {
                if (Valid(configData.HomePage.name))
                    UI.LoadImage(ref element, PanelInfo, TryForImage(configData.HomePage.name), "0 0", "1 0.88");
                else
                {
                    UI.CreatePanel(ref element, PanelInfo, UIColors["dark"], "0 0", "1 1");
                    UI.CreatePanel(ref element, PanelInfo, UIColors["light"], "0.01 0.02", "0.99 0.98");
                }
                if (!string.IsNullOrEmpty(configData.HomePage.text))
                    UI.CreateLabel(ref element, PanelInfo, UIColors["white"], configData.HomePage.text, 12, "0.02 0.2", "0.97 0.65");

                UI.CreatePanel(ref element, PanelInfo, UIColors["red"], "0.02 0.9", "0.16 0.975");
                UI.CreateLabel(ref element, PanelInfo, UIColors["white"], configData.HomePage.name.ToUpper(), 12, "0.02 0.9", "0.16 0.975");
            }
            else
            {
                UI.CreateButton(ref element, PanelInfo, UIColors["blue"], configData.HomePage.name.ToUpper(), 12, "0.02 0.9", "0.16 0.975", $"UI_SwitchSection {0} false ");
            }
            foreach (var entry in configData.sections/*.Where(k => k.Key >= UniversalUIInfo[player.userID].showSection && k.Key < (UniversalUIInfo[player.userID].showSection + 4))*/)
            {
                if (entry.Key < UniversalUIInfo[player.userID].showSection) continue;
                if (entry.Key > UniversalUIInfo[player.userID].showSection + 5) continue;
                var pos = CalcSectionButtonPos(entry.Key - UniversalUIInfo[player.userID].showSection);
                if (Debugging) Puts($"Trying Section: {entry.Key}");
                if (Debugging) Puts($"Shown Section: { UniversalUIInfo[player.userID].showSection}");
                if (Debugging) Puts($"Last Section: { UniversalUIInfo[player.userID].showSection + 4}");
                var admin = "false";
                if (entry.Value.adminOnly)
                    admin = "true";
                if (entry.Key == UniversalUIInfo[player.userID].section)
                {
                    if (Debugging) Puts($"Section Match: {entry.Key}");
                    var lastpage = configData.sections[UniversalUIInfo[player.userID].section].pages.Count() - 1;
                    var currentpage = UniversalUIInfo[player.userID].page;
                    if (currentpage < lastpage - 1)
                    {
                        UI.CreateButton(ref element, PanelInfo, UIColors["dark"], GetLang("Last"), 12, "0.9 0.03", "0.95 0.085", $"UI_PageTurn {lastpage}");
                    }
                    if (currentpage < lastpage)
                    {
                        UI.CreateButton(ref element, PanelInfo, UIColors["dark"], GetLang("Next"), 12, "0.84 0.03", "0.89 0.085", $"UI_PageTurn {currentpage + 1}");
                    }
                    if (currentpage > 0)
                    {
                        UI.CreateButton(ref element, PanelInfo, UIColors["dark"], GetLang("Back"), 12, "0.77 0.03", "0.82 0.085", $"UI_PageTurn {currentpage - 1}");
                    }
                    if (currentpage > 1)
                    {
                        UI.CreateButton(ref element, PanelInfo, UIColors["dark"], GetLang("First"), 12, "0.71 0.03", "0.76 0.085", $"UI_PageTurn {0}");
                    }
                    UI.CreatePanel(ref element, PanelInfo, UIColors["red"], $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                    if (!string.IsNullOrEmpty(entry.Value.name))
                        UI.CreateLabel(ref element, PanelInfo, UIColors["white"], entry.Value.name.ToUpper(), 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                    else UI.CreateLabel(ref element, PanelInfo, UIColors["white"], $"Section:{entry.Key.ToString().ToUpper()}", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                }
                else
                {
                    if (Debugging) Puts($"Section Didn't Match: {entry.Key}");
                    if (Valid($"UUISectionButton{entry.Key}"))
                    {
                        if (HasImage($"UUISectionButton{entry.Key}", (ulong)ResourceId))
                        {
                            UI.LoadImage(ref element, PanelInfo, TryForImage($"UUISectionButton{entry.Key}"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                            UI.CreateButton(ref element, PanelInfo, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_SwitchSection {entry.Key} {admin} {entry.Value.permission}");
                        }
                        else
                        {
                            if (!string.IsNullOrEmpty(entry.Value.name))
                                UI.CreateButton(ref element, PanelInfo, "0 0 0 0", entry.Value.name.ToUpper(), 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_SwitchSection {entry.Key} {admin} {entry.Value.permission}");
                            else
                                UI.CreateButton(ref element, PanelInfo, "0 0 0 0", $"Section:{entry.Key.ToString().ToUpper()}", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_SwitchSection {entry.Key} {admin} {entry.Value.permission}");
                        }
                    }
                    else
                    {
                        if (!string.IsNullOrEmpty(entry.Value.name))
                            UI.CreateButton(ref element, PanelInfo, UIColors["blue"], entry.Value.name.ToUpper(), 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_SwitchSection {entry.Key} {admin} {entry.Value.permission}");
                        else
                            UI.CreateButton(ref element, PanelInfo, UIColors["blue"], $"Section:{entry.Key.ToString().ToUpper()}", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_SwitchSection {entry.Key} {admin} {entry.Value.permission}");
                    }
                }
            }
            if (UniversalUIInfo[player.userID].showSection != 0)
                UI.CreateButton(ref element, PanelInfo, UIColors["black"], "<--", 12, "0.17 0.9", "0.2 0.975", $"UI_InfoSectionButtonChange {UniversalUIInfo[player.userID].showSection - 1}");
            if (Debugging) Puts($"Max Section: {configData.sections.Max(kvp => kvp.Key) - 1}");
            if (UniversalUIInfo[player.userID].showSection + 5 < configData.sections.Max(kvp => kvp.Key))
                UI.CreateButton(ref element, PanelInfo, UIColors["black"], "-->", 12, "0.95 0.9", "0.98 0.975", $"UI_InfoSectionButtonChange {UniversalUIInfo[player.userID].showSection + 1}");
            UI.CreateButton(ref element, PanelInfo, UIColors["red"], GetLang("Close"), 12, "0.03 0.03", "0.13 0.085", "UI_DestroyUniversalUI");
            if (configData.UseButtonPanel)
                UI.CreateButton(ref element, PanelInfo, UIColors["red"], GetLang("HideInfoPanel"), 12, "0.14 0.03", "0.24 0.085", "UI_HideInfo");
            if (isAuth(player))
                UI.CreateButton(ref element, PanelInfo, UIColors["buttonred"], GetLang("ToggleAdmin"), 13, "-0.13 0.03", "-0.03 0.085", $"UI_AdminView");
            if (UniversalUIInfo[player.userID].admin)
            {
                UI.CreateButton(ref element, PanelInfo, UIColors["green"], GetLang("AddSection"), 12, "0.25 0.03", "0.35 0.085", "UI_AddNewSection");
                if (UniversalUIInfo[player.userID].section != 0)
                {
                    UI.CreateButton(ref element, PanelInfo, UIColors["red"], GetLang("RemoveSection"), 12, "0.36 0.03", "0.46 0.085", "UI_RemoveSection");
                    UI.CreateButton(ref element, PanelInfo, UIColors["green"], GetLang("AddPage"), 12, "0.47 0.03", "0.57 0.085", "UI_AddNewPage");
                    if (UniversalUIInfo[player.userID].page != 0) UI.CreateButton(ref element, PanelInfo, UIColors["red"], GetLang("RemovePage"), 12, "0.58 0.03", "0.68 0.085", "UI_RemovePage");
                }
            }
            CuiHelper.AddUi(player, element);
        }

        private void CreateKitEntry(ref CuiElementContainer container, string panelName, BasePlayer player, string kit, int num)
        {
            var pos = KitPos(num);
            UI.CreatePanel(ref container, panelName, UIColors["header"], $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
            if (num == 0)
            {
                UI.CreateLabel(ref container, panelName, UIColors["white"], "Kit", 12, $"{pos[0] + .1f} {pos[1] + .07f}", $"{pos[0] + .22f} {pos[3] + .07f}");
                UI.CreateLabel(ref container, panelName, UIColors["white"], "Description", 12, $"{pos[0] + .23f} {pos[1] + .07f}", $"{pos[0] + .6f} {pos[3] + .07f}");
                UI.CreateLabel(ref container, panelName, UIColors["white"], "Cooldown", 12, $"{pos[0] + .64f} {pos[1] + .07f}", $"{pos[0] + .73f} {pos[3] + .07f}");
                UI.CreateLabel(ref container, panelName, UIColors["white"], "Max", 12, $"{pos[0] + .72f} {pos[1] + .07f}", $"{pos[0] + .78f} {pos[3] + .07f}");
            }
            var description = "";
            if (!string.IsNullOrEmpty(GetKitDescription(kit)))
                description = GetKitDescription(kit);
            UI.LoadImage(ref container, panelName, GetKitImage(kit) , $"{pos[0]+.01f} {pos[1]}", $"{pos[0] + .09f} {pos[3]}");
            UI.CreateLabel(ref container, panelName, UIColors["white"], kit.ToUpper(), 12, $"{pos[0] + .1f} {pos[1] + .01f}", $"{pos[0] + .22f} {pos[3] - .01f}");
            UI.CreateLabel(ref container, panelName, UIColors["white"], description, 12, $"{pos[0] + .23f} {pos[1] + .01f}", $"{pos[0] + .6f} {pos[3] - .01f}", TextAnchor.MiddleLeft);
            UI.CreateLabel(ref container, panelName, UIColors["white"], GetKitCooldown(kit).ToString(), 12, $"{pos[0] + .66f} {pos[1] + .01f}", $"{pos[0] + .72f} {pos[3] - .01f}");
            UI.CreateLabel(ref container, panelName, UIColors["white"], GetKitMax(kit).ToString(), 12, $"{pos[0] + .72f} {pos[1] + .01f}", $"{pos[0] + .78f} {pos[3] - .01f}");
            UI.CreateButton(ref container, panelName, UIColors["dark"], GetLang("Redeem"), 12, $"{pos[2] - .16f} {pos[1] + .01f}", $"{pos[2] - .09f} {pos[3] - .01f}", $"UI_RedeemKit {kit}");
            if (UniversalUIInfo[player.userID].admin)
                UI.CreateButton(ref container, panelName, UIColors["buttonred"], GetLang("Remove"), 12, $"{pos[2] - .08f} {pos[1] + .01f}", $"{pos[2] - .01f} {pos[3] - .01f}", $"UI_RemoveKit {kit}");
        }

        private void AddKit(BasePlayer player, int page = 0)
        {
            double count = GetKitNames().Count() - configData.sections[UniversalUIInfo[player.userID].section].pages[UniversalUIInfo[player.userID].page].Kits.Count();
            if (count == 0)
            {
                GetSendMSG(player, "NoKitsFound");
                return;
            }
            CuiHelper.DestroyUi(player, PanelInfo);
            var element = UI.CreateElementContainer(PanelInfo, UIColors["dark"], "0.2 0.15", "0.8 0.85", true);
            UI.CreatePanel(ref element, PanelInfo, UIColors["light"], "0.01 0.015", ".99 .985");
            UI.CreateLabel(ref element, PanelInfo, UIColors["limegreen"], GetMSG("SelectKit"), 20, "0.05 .95", ".95 1", TextAnchor.MiddleCenter);
            int entriesallowed = 30;
            double remainingentries = count - (page * (entriesallowed));
            double totalpages = (Math.Floor(count / (entriesallowed)));
            {
                if (page < totalpages - 1)
                {
                    UI.CreateButton(ref element, PanelInfo, UIColors["dark"], GetLang("Last"), 16, "0.8 0.02", "0.85 0.075", $"UI_SelectKitToAdd {totalpages}");
                }
                if (remainingentries > entriesallowed)
                {
                    UI.CreateButton(ref element, PanelInfo, UIColors["dark"], GetLang("Next"), 16, "0.74 0.02", "0.79 0.075", $"UI_SelectKitToAdd {page + 1}");
                }
                if (page > 0)
                {
                    UI.CreateButton(ref element, PanelInfo, UIColors["dark"], GetLang("Back"), 16, "0.68 0.02", "0.73 0.075", $"UI_SelectKitToAdd {page - 1}");
                }
                if (page > 1)
                {
                    UI.CreateButton(ref element, PanelInfo, UIColors["dark"], GetLang("First"), 16, "0.62 0.02", "0.67 0.075", $"UI_SelectKitToAdd {0}");
                }
            }
            var i = 0;
            int n = 0;
            double shownentries = page * entriesallowed;
            foreach (string kitname in GetKitNames().Where(k => !configData.sections[UniversalUIInfo[player.userID].section].pages[UniversalUIInfo[player.userID].page].Kits.Contains(k)))
            {
                i++;
                if (i < shownentries + 1) continue;
                else if (i <= shownentries + entriesallowed)
                {
                    CreateKitButton(ref element, PanelInfo, UIColors["buttonbg"], kitname, $"UI_AddKit {kitname}", n);
                    n++;
                }
            }
            UI.CreateButton(ref element, PanelInfo, UIColors["buttonred"], GetLang("Quit"), 16, "0.87 0.02", "0.97 0.075", $"UI_DestroyUniversalUI");
            CuiHelper.AddUi(player, element);
        }

        private void CreateKitButton(ref CuiElementContainer container, string panelName, string color, string name, string cmd, int num)
        {
            var pos = CalcKitButtonPos(num);
            UI.CreateButton(ref container, panelName, color, name, 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", cmd);
        }

        [ConsoleCommand("UI_SelectKitToAdd")]
        private void cmdUI_SelectKitToAdd(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int page;
            if (!int.TryParse(arg.Args[0], out page)) return;
            AddKit(player, page);
        }

        [ConsoleCommand("UI_AddKit")]
        private void cmdUI_AddKit(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var kit = arg.Args[0];
            configData.sections[UniversalUIInfo[player.userID].section].pages[UniversalUIInfo[player.userID].page].Kits.Add(kit);
            Config.WriteObject(configData, true);
            OpenUniversalUI(player);
        }

        [ConsoleCommand("UI_RedeemKit")]
        private void cmdUI_RedeemKit(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var kit = arg.Args[0];
            object isKit = Kits?.Call("isKit", new object[] { kit });
            if (isKit is bool)
                if ((bool)isKit)
                {
                    Kits?.Call("TryGiveKit", player, kit);
                }
            UniversalUIPanel(player);
        }

        [ConsoleCommand("UI_RemoveKit")]
        private void cmdUI_RemoveKit(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var kit = arg.Args[0];
            configData.sections[UniversalUIInfo[player.userID].section].pages[UniversalUIInfo[player.userID].page].Kits.Remove(kit);
            Config.WriteObject(configData, true);
            OpenUniversalUI(player);
        }


        private float[] CalcKitButtonPos(int number)
        {
            Vector2 position = new Vector2(0.05f, 0.82f);
            Vector2 dimensions = new Vector2(0.125f, 0.125f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 6)
            {
                offsetX = (0.03f + dimensions.x) * number;
            }
            if (number > 5 && number < 12)
            {
                offsetX = (0.03f + dimensions.x) * (number - 6);
                offsetY = (-0.06f - dimensions.y) * 1;
            }
            if (number > 11 && number < 18)
            {
                offsetX = (0.03f + dimensions.x) * (number - 12);
                offsetY = (-0.06f - dimensions.y) * 2;
            }
            if (number > 17 && number < 24)
            {
                offsetX = (0.03f + dimensions.x) * (number - 18);
                offsetY = (-0.06f - dimensions.y) * 3;
            }
            if (number > 23 && number < 36)
            {
                offsetX = (0.03f + dimensions.x) * (number - 24);
                offsetY = (-0.06f - dimensions.y) * 4;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] KitPos(int number)
        {
            Vector2 position = new Vector2(0.015f, 0.71f);
            Vector2 dimensions = new Vector2(0.965f, 0.07f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 10)
            {
                offsetY = (-0.005f - dimensions.y) * number;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] CalcButtonPos(int number)
        {
            Vector2 position = new Vector2(0.03f, 0.95f);
            Vector2 dimensions = new Vector2(0.45f, 0.1f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 10)
            {
                offsetY = (-0.01f - dimensions.y) * number;
            }
            if (number > 9 && number < 20)
            {
                offsetY = (-0.01f - dimensions.y) * (number - 10);
                offsetX = (0.01f + dimensions.x) * 1;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] CalcButtonPagePos(int number)
        {
            Vector2 position = new Vector2(0.03f, 0.75f);
            Vector2 dimensions = new Vector2(0.125f, 0.05f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 10)
            {
                offsetY = (-0.01f - dimensions.y) * number;
            }
            if (number > 9 && number < 20)
            {
                offsetY = (-0.01f - dimensions.y) * (number - 10);
                offsetX = (0.01f + dimensions.x) * 1;
            }
            if (number > 19 && number < 30)
            {
                offsetY = (-0.01f - dimensions.y) * (number - 20);
                offsetX = (0.01f + dimensions.x) * 2;
            }
            if (number > 29 && number < 40)
            {
                offsetY = (-0.01f - dimensions.y) * (number - 30);
                offsetX = (0.01f + dimensions.x) * 3;
            }
            if (number > 39 && number < 50)
            {
                offsetY = (-0.01f - dimensions.y) * (number - 40);
                offsetX = (0.01f + dimensions.x) * 4;
            }
            if (number > 49 && number < 60)
            {
                offsetY = (-0.01f - dimensions.y) * (number - 50);
                offsetX = (0.01f + dimensions.x) * 5;
            }
            if (number > 59 && number < 70)
            {
                offsetY = (-0.01f - dimensions.y) * (number - 60);
                offsetX = (0.01f + dimensions.x) * 6;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] CalcSectionButtonPos(int number)
        {
            number--;
            Vector2 position = new Vector2(0.23f, 0.9f);
            Vector2 dimensions = new Vector2(0.13f, 0.075f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 5)
            {
                offsetX = (0.01f + dimensions.x) * number;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] CalcInfoButtonPos(int number)
        {
            Vector2 position = new Vector2(0.85f, 0.75f);
            Vector2 dimensions = new Vector2(0.125f, 0.05f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 10)
            {
                offsetY = (-0.01f - dimensions.y) * number;
            }
            if (number > 9 && number < 20)
            {
                offsetX = (-0.01f - dimensions.x) * 1;
                offsetY = (-0.01f - dimensions.y) * (number - 10);
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        #endregion

        #region Class

        class MainButton
        {
            public string name;
            public string command;
            public string ButtonImage;
            public bool adminOnly;
            public string permission;
            public bool CloseUI;
        }

        class PageButton
        {
            public string name;
            public string command;
            public string PageButtonImage;
            public bool adminOnly;
            public int order;
            public string permission;
            public bool CloseUI;
        }

        class Section
        {
            public string name;
            public string SectionButtonimage;
            public bool adminOnly;
            public List<Page> pages = new List<Page>();
            public string permission;
        }

        class Page
        {
            public int page;
            public string name;
            public string text;
            public string PageImage;
            public List<PageButton> buttons = new List<PageButton>();
            public PageType type = PageType.standard;
            public List<string> Kits = new List<string>();
        }

        enum PageType
        {
            standard,
            text,
            buttons,
            kits
        }

        #endregion

        #region Misc Commands

        [ChatCommand("ui")]
        private void cmdui(BasePlayer player, string command, string[] args)
        {
            if (UniversalUIInfo.ContainsKey(player.userID) && !UniversalUIInfo[player.userID].open)
            {
                UniversalUIInfo[player.userID].open = true;
                OpenUniversalUI(player);
            }
            else
                OpenUniversalUI(player);
        }

        [ConsoleCommand("UI_AdminView")]
        private void cmdUI_AdminView(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (UniversalUIInfo[player.userID].admin == true)
                UniversalUIInfo[player.userID].admin = false;
            else UniversalUIInfo[player.userID].admin = true;
            OpenUniversalUI(player);
        }


        [ChatCommand("uuidebug")]
        private void cmduuidebug(BasePlayer player, string command, string[] args)
        {
            if (Debugging)
                Debugging = false;
            else Debugging = true;
        }

        [ConsoleCommand("GetAllImages")]
        private void cmdGetAllImages(ConsoleSystem.Arg arg)
        {
            GetAllImages();
        }

        private void GetAllImages()
        {
            if (timers.ContainsKey("skins"))
            {
                timers["skins"].Destroy();
                timers.Remove("skins");
            }
            if (!isReady()) { Puts(GetMSG("WaitingImageLibrary")); timers.Add("skins", timer.Once(60, () => GetAllImages())); return; };
            AddImage("http://i.imgur.com/GT0ngNJ.png", "text", (ulong)ResourceId);
            AddImage("http://i.imgur.com/9IpSF2b.png", "buttons", (ulong)ResourceId);
            AddImage("http://i.imgur.com/DUpRzdb.png", "standard", (ulong)ResourceId);
            AddImage("http://i.imgur.com/GbNMTDA.png", "kits", (ulong)ResourceId);
            if (string.IsNullOrEmpty(configData.HomePage.PageImage)) configData.HomePage = DefaultHomePage;
            AddImage(configData.HomePage.PageImage, configData.HomePage.name, (ulong)ResourceId);
            foreach (var entry in configData.buttons)
                if (!string.IsNullOrEmpty(entry.Value.ButtonImage))
                    AddImage(entry.Value.ButtonImage, $"UUIMainButton{entry.Key}", (ulong)ResourceId);
            foreach (var entry in configData.sections)
            {
                if (!string.IsNullOrEmpty(entry.Value.SectionButtonimage))
                    AddImage(entry.Value.SectionButtonimage, $"UUISectionButton{entry.Key}", (ulong)ResourceId);
                foreach (var page in entry.Value.pages)
                {
                    if (!string.IsNullOrEmpty(page.PageImage))
                        AddImage(page.PageImage, $"UUIPage{entry.Key}-{page.page}", (ulong)ResourceId);
                    foreach (var button in page.buttons)
                        if (!string.IsNullOrEmpty(button.PageButtonImage))
                            AddImage(button.PageButtonImage, $"UUIPageButton{entry.Key}-{page.page}-{button.order}", (ulong)ResourceId);
                }
            }
            if (timers.ContainsKey("skins"))
            {
                timers["skins"].Destroy();
                timers.Remove("skins");
            }
            SkinsReady = true;
            Puts(GetMSG("AllImagesInitialized"));
        }

        private void CheckNewImages()
        {
            if (string.IsNullOrEmpty(configData.HomePage.PageImage)) configData.HomePage = DefaultHomePage;
            if (!Valid(configData.HomePage.name))
                AddImage(configData.HomePage.PageImage, configData.HomePage.name, (ulong)ResourceId);
            foreach (var entry in configData.buttons)
                if (!string.IsNullOrEmpty(entry.Value.ButtonImage))
                    if (!Valid($"UUIMainButton{entry.Key}"))
                        AddImage(entry.Value.ButtonImage, $"UUIMainButton{entry.Key}", (ulong)ResourceId);
            foreach (var entry in configData.sections)
            {
                if (!string.IsNullOrEmpty(entry.Value.SectionButtonimage))
                    if (!Valid($"UUISectionButton{entry.Key}"))
                        AddImage(entry.Value.SectionButtonimage, $"UUISectionButton{entry.Key}", (ulong)ResourceId);
                foreach (var page in entry.Value.pages)
                {
                    if (!string.IsNullOrEmpty(page.PageImage))
                        if (!Valid($"UUIPage{entry.Key}-{page.page}"))
                            AddImage(page.PageImage, $"UUIPage{entry.Key}-{page.page}", (ulong)ResourceId);
                    foreach (var button in page.buttons)
                        if (!string.IsNullOrEmpty(button.PageButtonImage))
                            if (!Valid($"UUIPageButton{entry.Key}-{page.page}-{button.order}"))
                                AddImage(button.PageButtonImage, $"UUIPageButton{entry.Key}-{page.page}-{button.order}", (ulong)ResourceId);
                }
            }
        }

        #endregion

        #region Timers
        private void InfoLoop()
        {
            if (timers.ContainsKey("info"))
            {
                timers["info"].Destroy();
                timers.Remove("info");
            }
            if (configData.InfoInterval == 0) return;
            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                if (configData.MenuKeyBinding != "")
                    GetSendMSG(p, "UIInfo", configData.MenuKeyBinding.ToString());
                else GetSendMSG(p, "UIInfo1");
            }
            timers.Add("info", timer.Once(configData.InfoInterval * 60, () => InfoLoop()));
        }
        #endregion

        #region Config
        private ConfigData configData;
        class ConfigData
        {
            public string MenuKeyBinding { get; set; }
            public Page HomePage = new Page();
            public Dictionary<int, Section> sections = new Dictionary<int, Section>();
            public Dictionary<int, MainButton> buttons = new Dictionary<int, MainButton>();
            public bool UseInfoPanel { get; set; }
            public bool UseButtonPanel { get; set; }
            public int InfoInterval { get; set; }
            public bool ForceOpenOnJoin { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        private Page DefaultHomePage = new Page
        {
            PageImage = "http://i.imgur.com/ygJ6m7w.png",
            name = "HomePage",
        };

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                MenuKeyBinding = "f5",
                UseInfoPanel = true,
                UseButtonPanel = true,
                InfoInterval = 15,
                ForceOpenOnJoin = false,
                HomePage = new Page
                {
                    PageImage = "http://i.imgur.com/ygJ6m7w.png",
                    name = "HomePage",
                    buttons = new List<PageButton> {
                        new PageButton {order = 0 },
                        new PageButton {order = 1 },
                        new PageButton {order = 2 },
                        new PageButton {order = 3 }
                    } },
                sections = new Dictionary<int, Section>
                    {
                    {1, new Section
                    {pages = new List<Page>
                    {
                    { new Page
                {page = 0, buttons = new List<PageButton> {new PageButton
                { order = 0 },new PageButton
                { order = 1 },new PageButton
                { order = 2 },new PageButton
                { order = 3 } } } },
                    { new Page
                {page = 1, buttons = new List<PageButton> {new PageButton
                { order = 0 },new PageButton
                { order = 1 },new PageButton
                { order = 2 },new PageButton
                { order = 3 } } } },
                    { new Page
                {page = 2, buttons = new List<PageButton> {new PageButton
                { order = 0 },new PageButton
                { order = 1 },new PageButton
                { order = 2 },new PageButton
                { order = 3 } } } }
                    } } },
                    {2, new Section
                    {pages = new List<Page>
                    {
                    { new Page
                {page = 0, buttons = new List<PageButton> {new PageButton
                { order = 0 },new PageButton
                { order = 1 },new PageButton
                { order = 2 },new PageButton
                { order = 3 } } } },
                    { new Page
                {page = 1, buttons = new List<PageButton> {new PageButton
                { order = 0 },new PageButton
                { order = 1 },new PageButton
                { order = 2 },new PageButton
                { order = 3 } } } },
                    { new Page
                {page = 2, buttons = new List<PageButton> {new PageButton
                { order = 0 },new PageButton
                { order = 1 },new PageButton
                { order = 2 },new PageButton
                { order = 3 } } } }
                    } } },
                    {3, new Section
                    {pages = new List<Page>
                    {
                    { new Page
                {page = 0, buttons = new List<PageButton> {new PageButton
                { order = 0 },new PageButton
                { order = 1 },new PageButton
                { order = 2 },new PageButton
                { order = 3 } } } },
                    { new Page
                {page = 1, buttons = new List<PageButton> {new PageButton
                { order = 0 },new PageButton
                { order = 1 },new PageButton
                { order = 2 },new PageButton
                { order = 3 } } } },
                    { new Page
                {page = 2, buttons = new List<PageButton> {new PageButton
                { order = 0 },new PageButton
                { order = 1 },new PageButton
                { order = 2 },new PageButton
                { order = 3 } } } }
                    } } },
                },

                buttons = new Dictionary<int, MainButton>
                {
                    {0, new MainButton() },
                    {1, new MainButton() },
                    {2, new MainButton() },
                    {3, new MainButton() },
                    {4, new MainButton() },
                    {5, new MainButton() },
                    {6, new MainButton() },
                    {7, new MainButton() },
                    {8, new MainButton() },
                    {9, new MainButton() },
                    {10, new MainButton() },
                    {11, new MainButton() },
                    {12, new MainButton() },
                    {13, new MainButton() },
                    {14, new MainButton() },
                    {15, new MainButton() },
                    {16, new MainButton() },
                    {17, new MainButton() },
                    {18, new MainButton() },
                    {19, new MainButton() },
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Messages
        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"title", "UniversalUI: " },
            {"UIInfo", "This server is running Universal UI. Press <color=yellow>( {0} )</color> or Type <color=yellow>( /ui )</color> to access the Menu."},
            {"UIInfo1", "This server is running Universal UI. Type <color=yellow>( /ui )</color> to access the Menu."},
            {"InfoPanel","Show Info" },
            {"HideInfoPanel", "Hide Info" },
            {"NotAuth", "You are not authorized." },
            {"DelayedCMD", "You have selected a Delayed Command. To finish the command please type a 'parameter' for command: {0}. Or Type 'quit' to exit." },
            {"ExitDelayed", "You have exited the Delayed Command." },
            {"Type", "Type: {0}" },
            {"ImageLibraryNotReady", "ImageLibrary is not loaded. Unable to open the GUI." },
            {"WaitingImageLibrary", "Waiting on Image Library to initialize. Trying again in 60 Seconds" },
            {"AllImagesInitialized", "All Images Initiailized" },
        };
        #endregion

    }
}

// --- End of file: UniversalUI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ultimate-queue ---
// --- Original File Path: U/UltimateQueue/UltimateQueue.cs ---

﻿using ConVar;
using Network;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Ultimate Queue", "Bobakanoosh", "1.0.4")]
    [Description("Adds a plethora of additional features to server queue for players with permission.")]
    class UltimateQueue : RustPlugin
    {
        private PluginConfig config;

        private const string FIRST_CONNECT = "ultimatequeue.firstconnect";
        private Dictionary<ulong, int> userDisconnectionTimes = new Dictionary<ulong, int>(); 

        private void Init()
        {
            LoadConfig();

            timer.Every(60f, () => CheckDisconnections());
        }

        private void Loaded()
        {
            RegisterPermissions();
        }

        #region Hooks

        private object CanBypassQueue(Connection connection)
        {
            if (connection.authLevel >= config.ignoreWithAuthlevel)
            {
                return true;
            }

            string userIdString = connection.userid.ToString();

            if (config.enableFirstConnectSkip && !permission.UserHasPermission(userIdString, FIRST_CONNECT))
            {
                return true;

            }
            else if (config.enableHoldQueue && userDisconnectionTimes.ContainsKey(connection.userid))
            {
                 return true;

            }
            else if (config.enableQueueSkip && UserHasAnyPermission(userIdString, config.permsGrantingSkipQueue))
            {
                return true;

            }

            return null;
        }

        private object CanClientLogin(Connection connection)
        {
            if (connection.authLevel >= config.ignoreWithAuthlevel)
            {
                return true;
            }

            string userId = connection.userid.ToString();

            if (config.enableQueueCapacity)
            {
                if (UserHasAnyPermission(userId, config.permsAffectedByQueueCapacity))
                {
                    if (Admin.ServerInfo().Queued >= config.queueCapacity) 
                    {
                        return lang.GetMessage("CapacityReached", this, userId);
                    }
                }

                return true;
            }

            return true;
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (config.enableHoldQueue)
            {
                if (UserHasAnyPermission(player.UserIDString, config.permsGrantingHoldQueue))
                {
                    userDisconnectionTimes[player.userID] = Epoch.Current();
                }
            }
        }
        private void OnPlayerConnected(BasePlayer player)
        {
            if (config.enableFirstConnectSkip)
            {
                if (!permission.UserHasPermission(player.UserIDString, FIRST_CONNECT))
                {
                    Puts($"Granting {player.displayName} {FIRST_CONNECT}");
                    permission.GrantUserPermission(player.UserIDString, FIRST_CONNECT, this);

                    if (config.enableGlobalFirstJoinWelcomeMessage)
                    {
                        MessageAllExclude(player, string.Format(lang.GetMessage("FirstJoinMessageGlobal", this), player.displayName));
                    }

                    if (config.enablePersonalFirstJoinWelcomeMessage)
                    {
                        PrintToChat(player, string.Format(lang.GetMessage("FirstJoinMessage", this)));
                    }

                }
            }
        }

        #endregion

        #region Helpers

        public void RegisterPermissions()
        {
            permission.RegisterPermission(FIRST_CONNECT, this);

            config.permsAffectedByQueueCapacity.ForEach(perm => TryRegister(perm));
            config.permsGrantingHoldQueue.ForEach(perm => TryRegister(perm));
            config.permsGrantingSkipQueue.ForEach(perm => TryRegister(perm));
        }

        private void TryRegister(string perm)
        {
            if (perm.StartsWith(Name.ToLower()) && !permission.PermissionExists(perm, this))
            {
                permission.RegisterPermission(perm, this);
            }
        }

        private bool UserHasAnyPermission(string userid, List<string> perms)
        {
            foreach(string perm in perms)
            {
                if (permission.UserHasPermission(userid, perm))
                {
                    return true;
                }
            }

            return false;
        }

        private void CheckDisconnections()
        {
            int current = Epoch.Current();
            int holdTimeSeconds = config.holdTime * 60;

            foreach(KeyValuePair<ulong, int> pair in userDisconnectionTimes.ToArray())
            {
                if (Epoch.SecondsElapsed(current, pair.Value) >= holdTimeSeconds)
                {
                    userDisconnectionTimes.Remove(pair.Key);
                }
            }
        }

        private void MessageAllExclude(BasePlayer exclude, string message, params object[] args)
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player.userID != exclude.userID)
                {
                    PrintToChat(player, message, args);
                }
            }
        }

        #endregion

        #region Config

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        protected override void LoadDefaultConfig()
        {
            config = new PluginConfig
            {
                ignoreWithAuthlevel = 1,
                enableFirstConnectSkip = true,
                enableQueueCapacity = false,
                permsAffectedByQueueCapacity = new List<string> { "ultimatequeue.default" },
                queueCapacity = 50,
                enableHoldQueue = true,
                permsGrantingHoldQueue = new List<string> { "ultimatequeue.default", "ultimatequeue.vip" },
                holdTime = 5,
                enableQueueSkip = true,
                permsGrantingSkipQueue = new List<string> { "ultimatequeue.vip" },
                enablePersonalFirstJoinWelcomeMessage = true,
                enableGlobalFirstJoinWelcomeMessage = true,
            };

            SaveConfig();
        }

        private class PluginConfig
        {
            [JsonProperty("Auth Level required to skip queue no matter what (3 = none, 2 = admin, 1 = moderator)")]
            public int ignoreWithAuthlevel;

            [JsonProperty("Enable first connect skip queue?")]
            public bool enableFirstConnectSkip;

            [JsonProperty("Enable Queue Capacity?")]
            public bool enableQueueCapacity;

            [JsonProperty("If a player has one of the listed permissions, they are affected by queue capacity.")]
            public List<string> permsAffectedByQueueCapacity;

            [JsonProperty("Queue capacity")]
            public int queueCapacity;

            [JsonProperty("Enable Queue Holding?")]
            public bool enableHoldQueue;

            [JsonProperty("If a player has one of the listed permissions, their queue spot is held on disconnect")]
            public List<string> permsGrantingHoldQueue;

            [JsonProperty("Number of minutes to allow a user to reconnect without a queue")]
            public int holdTime;

            [JsonProperty("Enable Queue Skipping?")]
            public bool enableQueueSkip;

            [JsonProperty("If a player has one of the listed permissions, they will skip the queue")]
            public List<string> permsGrantingSkipQueue;

            [JsonProperty("When a user joins for the first time, message the new user. Only works with first connect queue skip enabled")]
            public bool enablePersonalFirstJoinWelcomeMessage;

            [JsonProperty("When a user joins for the first time, announce it to all users. Only works with first connect queue skip enabled")]
            public bool enableGlobalFirstJoinWelcomeMessage;

        }

        #endregion Config

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CapacityReached"] = "The server's queue is full.",
                ["FirstJoinMessage"] = "Welcome to the server!",
                ["FirstJoinMessageGlobal"] = "Welcome {0} to the server!"
            }, this);
        }

        #endregion

        #region Classes

        public static class Epoch
        {
            public static int Current()
            {
                DateTime epochStart = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
                int currentEpochTime = (int)(DateTime.UtcNow - epochStart).TotalSeconds;

                return currentEpochTime;
            }

            public static int SecondsElapsed(int t1)
            {
                int difference = Current() - t1;

                return Mathf.Abs(difference);
            }

            public static int SecondsElapsed(int t1, int t2)
            {
                int difference = t1 - t2;

                return Mathf.Abs(difference);
            }

        }

        #endregion

    }

}


// --- End of file: UltimateQueue.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/unwound ---
// --- Original File Path: U/Unwound/Unwound.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Oxide.Core.Plugins;

/*
 * This update 1.0.12
 * Fixes economic issues
 * Finished old feature integration for PopUpNotifications plugin
 * Added new config option for setting custom health level
 * Updated auto updater to include new config variables.
 *
 * This update 1.0.20
 * Added ServerRewards Support (Updated variables/logic)
 * Updated Lang
 * Updated To OnPlayerWounded to save on performance rather than using OnEntityTakeDamage.
 */

namespace Oxide.Plugins
{
    [Info("Unwound", "mk_sky/Khan", "1.0.20")]
    [Description("The sky presents the newest technology in calling the MEDIC!")]

    class Unwound : RustPlugin
    {
        #region vars
        ListDictionary<string, string> localization;

        List<ulong> called = new List<ulong>();

        ListDictionary<uint, uint> ecoSettings;

        List<ulong> inUnwoundZone = new List<ulong>();

        float startHealth = 50;

        uint waitTillMedic = 10;

        bool popupsEnabled = false;

        uint chanceTheMedicSavesYou = 100;

        bool canCallMedicOncePerWounded = true;

        bool enableServerRewards = false;

        bool enableEconomics = true;
        
        bool enableCurrency = false;

        bool forceCurrency = false;

        [PluginReference]
        Plugin Economics, ZoneManager, PopupNotifications, ServerRewards;

        #endregion

        void OnServerInitialized()
        {
            ConfigLoader();
            permission.RegisterPermission("unwound.canuse", this);
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();

            Config["Version"] = Version.ToString();

            #region localization
            Config["Localization", "PermissionMissing"] = "You have no permission to use this command, if you're wounded right now it means you're probably screwed!";

            Config["Localization", "TheMedicIsComing"] = "The medic is coming for you ... that means if you can survive another {0} seconds.";

            Config["Localization", "NotWounded"] = "You're not wounded, get your extra shots somewhere else!";

            Config["Localization", "Survived"] = "The claws of death failed to claim you this time!";

            Config["Localization", "DontTrollTheMedic"] = "How dare you call the medic and then don't wait for him before staying up again!";

            Config["Localization", "AboutToDie"] = "You are about to die, use /aid to call for a medic.\n{0}";

            Config["Localization", "MedicToLate"] = "Seems like your medic found some free beer on the way and won't come in time now ... I think we have to cut his salary!";

            Config["Localization", "MedicIncompetent"] = "This incompetent troll of a medic is just to stupid to get you back up, we will get rid of him!";

            Config["Localization", "MedicAlreadyCalled"] = "You already called for a medic, just wait for him.";

            Config["Localization", "NotEnoughMoney"] = "You don't have enough money, how horrible ... You have {0} and you would need {1} so just wait the full {2} seconds for the medic.";

            Config["Localization", "NotEnoughMoney_ForcedEco"] = "You don't have enough money, how horrible ... You have {0} and you would need {1}, maybe I'll come to your funeral then.";
            #endregion
            #region settings
            Config["Settings", "StartHealth"] = 50f;
            
            Config["Settings", "WaitTillMedic"] = 10;

            Config["Settings", "ChanceTheMedicSavesYou"] = 100;

            Config["Settings", "CanCallMedicOncePerWounded"] = true;

            Config["Settings", "EnablePopups"] = false;

            Config["Settings", "EnableServerRewards"] = false;
            
            Config["Settings", "EnableEconomics"] = true;

            Config["Settings", "EnableCurrency"] = false;

            Config["Settings", "ForceCurrency"] = false;

            Config["EcoSettings", "10"] = 10;

            Config["EcoSettings", "100"] = 1;
            #endregion

            SaveConfig();

            PrintWarning("Unwound created a new config.");
        }

        void ConfigLoader()
        {
            base.LoadConfig();

            if (Config.Exists() &&
                Config["Version"].ToString() != Version.ToString())
                ConfigUpdater();

            #region localization
            localization = new ListDictionary<string, string>();

            localization.Add("PermissionMissing", Config["Localization", "PermissionMissing"].ToString());

            localization.Add("TheMedicIsComing", Config["Localization", "TheMedicIsComing"].ToString());

            localization.Add("NotWounded", Config["Localization", "NotWounded"].ToString());

            localization.Add("Survived", Config["Localization", "Survived"].ToString());

            localization.Add("DontTrollTheMedic", Config["Localization", "DontTrollTheMedic"].ToString());

            localization.Add("AboutToDie", Config["Localization", "AboutToDie"].ToString());

            localization.Add("MedicToLate", Config["Localization", "MedicToLate"].ToString());

            localization.Add("MedicIncompetent", Config["Localization", "MedicIncompetent"].ToString());

            localization.Add("MedicAlreadyCalled", Config["Localization", "MedicAlreadyCalled"].ToString());

            localization.Add("NotEnoughMoney", Config["Localization", "NotEnoughMoney"].ToString());

            localization.Add("NotEnoughMoney_ForcedEco", Config["Localization", "NotEnoughMoney_ForcedEco"].ToString());
            #endregion
            #region settings

            startHealth = Convert.ToSingle(Config["Settings", "StartHealth"])> 100 ? 100 : Convert.ToUInt32(Config["Settings", "StartHealth"]);

            if (startHealth == 0)
            {
                PrintError("The startHealth can't be 0, Plugin will run it with 1."); //still almost 0 but not 0

                startHealth = 1;
            }

            waitTillMedic = Convert.ToUInt32(Config["Settings", "WaitTillMedic"]);

            chanceTheMedicSavesYou = Convert.ToUInt32(Config["Settings", "ChanceTheMedicSavesYou"]) > 100 ? 100 : Convert.ToUInt32(Config["Settings", "ChanceTheMedicSavesYou"]);

            if (chanceTheMedicSavesYou == 0)
            {
                PrintError("The ChanceTheMedicSavesYou can't be 0, Plugin will run it with 1."); //still almost 0 but not 0

                chanceTheMedicSavesYou = 1;
            }

            canCallMedicOncePerWounded = Convert.ToBoolean(Config["Settings", "CanCallMedicOncePerWounded"]);

            if (PopupNotifications == null &&
                Convert.ToBoolean(Config["Settings", "EnablePopups"]))
                PrintError("PopupNotifications-Plugin missing, can't enable pop-ups. Get the plugin first: https://umod.org/plugins/popup-notifications/");
            else if (PopupNotifications != null &&
                     Convert.ToBoolean(Config["Settings", "EnablePopups"]))
                popupsEnabled = true;
            
            enableEconomics = Convert.ToBoolean(Config["Settings", "EnableEconomics"]);
                
            enableServerRewards = Convert.ToBoolean(Config["Settings", "EnableServerRewards"]);

            ecoSettings = new ListDictionary<uint, uint>();
            
            if (Convert.ToBoolean(Config["Settings", "EnableCurrency"]))
            {
                Puts("settings EnableCurrency is true");
                enableCurrency = true;

                forceCurrency = Convert.ToBoolean(Config["Settings", "ForceCurrency"]);

                Dictionary<string, string> temp = Config.Get<Dictionary<string, string>>("EcoSettings");

                foreach (KeyValuePair<string, string> s in temp)
                    if (Convert.ToUInt32(s.Value) >= 0)
                        ecoSettings.Add(Convert.ToUInt32(s.Key), Convert.ToUInt32(s.Value));

                Puts($"{ecoSettings.Count}");

                ecoSettings.Keys.Reverse();
            }
            if (Convert.ToBoolean(Config["Settings", "EnableEconomics"]) && Economics == null)
            {
                PrintError("Economics-Plugin missing, can't enable economics. Get the plugin first: https://umod.org/plugins/economics");
            }
            if (Convert.ToBoolean(Config["Settings", "EnableServerRewards"]) && ServerRewards == null)
            {
                PrintError("ServerRewards-Plugin missing, can't enable server rewards. Get the plugin first: https://umod.org/plugins/server-rewards");
            }
                
            #endregion
        }

        void ConfigUpdater()
        {
            PrintWarning(String.Format("Config updated from v{0} to v{1}.", Config["Version"].ToString(), this.Version.ToString()));

            while (Config["Version"].ToString() != this.Version.ToString())
                switch (Config["Version"].ToString())
                {
                    #region 1.0.0 => 1.0.1
                    case "1.0.0":
                        Config["Localization", "AboutToDie"] = "You are about to die, use /aid to call for a medic.";

                        Config["Localization", "MedicToLate"] = "Seems like your medic found some free beer on the way and won't come in time now ... I think we have to cut his salary!";

                        Config["Localization", "MedicIncompetent"] = "This incompetent troll of a medic is just to stupid to get you back up, we will get rid of him!";

                        Config["Localization", "MedicAlreadyCalled"] = "You already called for a medic, just wait for him.";

                        Config["Localization", "NotEnoughMoney"] = "You don't have enough money, how horrible ... You have {0} and you would need {1} so just wait the full {2} seconds for the medic.";

                        Config["Settings", "ChanceTheMedicSavesYou"] = 100;

                        Config["Settings", "CanCallMedicOncePerWounded"] = true;

                        Config["Settings", "EnablePopups"] = false;

                        Config["Settings", "EnableEconomics"] = false;

                        Config["EcoSettings", "500"] = 0;

                        Config["EcoSettings", "250"] = 5;

                        Config["Version"] = "1.0.1";
                        break;
                    #endregion
                    #region 1.0.1 || 1.0.2 || 1.0.3 || 1.0.4 || 1.0.5 || 1.0.6 || 1.0.7 => 1.0.8
                    case "1.0.1":
                    case "1.0.2":
                    case "1.0.3":
                    case "1.0.4":
                    case "1.0.5":
                    case "1.0.6":
                    case "1.0.7":
                        Config["Version"] = "1.0.8";
                        break;
                    #endregion
                    #region 1.0.8 => 1.0.9
                    case "1.0.8":
                        if (permission.PermissionExists("canuseunwound"))
                        {
                            string[] playersWithPermission = permission.GetPermissionUsers("canuseunwound");

                            foreach (string s in playersWithPermission)
                                if (permission.UserHasPermission(s.Substring(0, s.IndexOf('(')), "canuseunwound"))
                                {
                                    permission.RevokeUserPermission(s.Substring(0, s.IndexOf('(')), "canuseunwound");

                                    permission.GrantUserPermission(s.Substring(0, s.IndexOf('(')), "unwound.canuse", this);
                                }

                            string[] groupsWithPermission = permission.GetPermissionGroups("canuseunwound");

                            foreach (string s in groupsWithPermission)
                                if (permission.GroupHasPermission(s, "canuseunwound"))
                                {
                                    permission.RevokeGroupPermission(s, "canuseunwound");

                                    permission.GrantGroupPermission(s, "unwound.canuse", this);
                                }

                            permission.RemoveGroup("canuseunwound");
                        }

                        Config["Localization", "NotEnoughMoney_ForcedEco"] = "You don't have enough money, how horrible ... You have {0} and you would need {1}, maybe I'll come to your funeral then.";

                        Config["Settings", "EnablePopups"] = null;

                        Config["Settings", "ForceEconomics"] = false;

                        Config["Version"] = "1.0.9";
                        break;
                        #endregion
                    #region 1.0.11 => 1.0.12
                    case "1.0.11":

                        Config["Settings", "EnablePopups"] = false;
                        
                        Config["Settings", "StartHealth"] = 50;
                        
                        Config["Version"] = "1.0.12";
                        break;
                    #endregion
                    #region 1.0.12 => 1.0.20
                    case "1.0.12":

                        Config["Settings", "EnableServerRewards"] = false;
        
                        Config["Localization", "AboutToDie"] = "You are about to die, use /aid to call for a medic.\n{0}";

                        Config["Settings", "EnableCurrency"] = false;

                        Config["Settings", "ForceCurrency"] = false;
                            
                        Config["Version"] = "1.0.20";
                        break;
                    #endregion
                }

            SaveConfig();
        }

        [ConsoleCommand("unwound.recreate")]
        void ConsoleCommandConfigRecreate()
        {
            LoadDefaultConfig();

            ConfigLoader();
        }

        [ConsoleCommand("unwound.load")]
        void ConsoleCommandConfigLoad()
        {
            ConfigLoader();
        }

        [ConsoleCommand("unwound.set")]
        void ConsoleCommandConfigSet(ConsoleSystem.Arg arg)
        {
            if (IsUInt(arg.GetString(2)))
                Config[arg.GetString(0), arg.GetString(1)] = arg.GetUInt(2);
            else if (arg.GetString(2) == "true" ||
                     arg.GetString(2) == "false")
                Config[arg.GetString(0), arg.GetString(1)] = arg.GetBool(2);
            else
                Config[arg.GetString(0), arg.GetString(1)] = arg.GetString(2);

            SaveConfig();

            ConfigLoader();
        }

        [ChatCommand("aid")]
        void ChatCommandAid(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "unwound.canuse"))
            {
                if (!popupsEnabled)
                    SendReply(player, localization["PermissionMissing"]);
                else
                    PopupNotifications.Call("CreatePopupNotification", localization["PermissionMissing"], player);

                return;
            }
            if (!player.IsWounded())
            {
                if (!popupsEnabled)
                    SendReply(player, localization["NotWounded"]);
                else
                    PopupNotifications.Call("CreatePopupNotification", localization["NotWounded"], player);

                return;
            }

            if (canCallMedicOncePerWounded && waitTillMedic > 0 && !CheckCanCall(player))
                return;


            if (args.Length > 0 && args[0] == "0" || args.Length > 0 && IsUInt(args[0]) && !ecoSettings.Contains(Convert.ToUInt32(args[0])) && !enableCurrency && args[0] != "?")
            {
                args = new string[0];
            }

            double playerMoney = GetCurrency(player); // Economics.Call<double>("Balance", player.userID);

            if (args.Length == 0 && enableCurrency && forceCurrency || args.Length == 1 && args[0] == "?" && enableCurrency)
            {
                playerMoney = GetCurrency(player); // Economics.Call<double>("Balance", player.userID);
                uint test = 0;
                
                for (int i = 0; i < ecoSettings.Count; i++)
                    if (playerMoney >= ecoSettings.GetByIndex(i).Key && test < ecoSettings.GetByIndex(i).Key)
                    {
                        test = ecoSettings.GetByIndex(i).Key;
                    }

                    else if (i + 1 == ecoSettings.Count && test == 0 && forceCurrency)
                    {
                        test = ecoSettings.GetByIndex(0).Key;
                    }

                if (forceCurrency || test != 0)
                {
                    args = new string[1] { test.ToString() };
                }
                else if (args.Length == 1 && args[0] == "?")
                {
                    args = new string[0];
                }
            }

            if (waitTillMedic > 0 || enableCurrency && forceCurrency)
            {
                if (args.Length >= 1 && IsUInt(args[0]))
                {
                    if (playerMoney >= Convert.ToDouble(args[0]))
                    {
                        uint waittime = waitTillMedic;
                        if (ecoSettings.Contains(Convert.ToUInt32(args[0])))
                        {
                            Withdraw(player, Convert.ToDouble(args[0]));
                            
                            waittime = ecoSettings[Convert.ToUInt32(args[0])];
                        }
                        else if (!ecoSettings.Contains(Convert.ToUInt32(args[0])))
                        {
                            SendReply(player, $"Invalid aid amount, valid options are\n{string.Join("\n", ecoSettings.Select(x => $"Cost {x.Key}, Seconds until revived {x.Value}").ToArray())}");
                        }
                        //Economics.Call("Withdraw", player.userID, Convert.ToDouble(args[0]));

                        if (waittime > 0)
                        {
                            if (!popupsEnabled)
                                SendReply(player, String.Format(localization["TheMedicIsComing"], waittime.ToString()));
                            else
                                PopupNotifications.Call("CreatePopupNotification", String.Format(localization["TheMedicIsComing"], waittime.ToString()), player);

                            Action timed = new Action(() => TimedMedic(player.userID));

                            timer.In(waittime, timed);
                        }
                        else
                        {
                            called.Remove(player.userID);

                            if (!MedicGetsYouUp(player))
                            {
                                switch (Oxide.Core.Random.Range(0, 1))
                                {
                                    case 0:
                                        if (!popupsEnabled)
                                            SendReply(player, localization["MedicToLate"]);
                                        else
                                            PopupNotifications.Call("CreatePopupNotification", localization["MedicToLate"], player);
                                        break;
                                    case 1:
                                        if (!popupsEnabled)
                                            SendReply(player, localization["MedicIncompetent"]);
                                        else
                                            PopupNotifications.Call("CreatePopupNotification", localization["MedicIncompetent"], player);
                                        break;
                                }

                                return;
                            }

                            player.StopWounded();

                            player.health = startHealth;

                            player.metabolism.bleeding.value = 0f;

                            if (!popupsEnabled)
                                SendReply(player, localization["Survived"]);
                            else
                                PopupNotifications.Call("CreatePopupNotification", localization["Survived"], player);
                        }
                    }
                    else
                    {
                        if (!popupsEnabled)
                            SendReply(player, String.Format((forceCurrency ? localization["NotEnoughMoney_ForcedEco"] : localization["NotEnoughMoney"]), playerMoney.ToString(""), args[0], waitTillMedic.ToString()));
                        else
                            PopupNotifications.Call("CreatePopupNotification", String.Format((forceCurrency ? localization["NotEnoughMoney_ForcedEco"] : localization["NotEnoughMoney"]), playerMoney.ToString(""), args[0], waitTillMedic.ToString()), player);
                        
                        if (!forceCurrency)
                        {
                            Action timed = new Action(() => TimedMedic(player.userID));

                            timer.In(waitTillMedic, timed);
                        }
                        else
                            called.Remove(player.userID);
                    }
                }
                else if (!forceCurrency)
                {
                    Puts("is called inside the !forceCurrency");
                    if (!popupsEnabled)
                        SendReply(player, String.Format(localization["TheMedicIsComing"], waitTillMedic.ToString()));
                    else
                        PopupNotifications.Call("CreatePopupNotification", String.Format(localization["TheMedicIsComing"], waitTillMedic.ToString()), player);

                    Action timed = new Action(() => TimedMedic(player.userID));

                    timer.In(waitTillMedic, timed);
                }
            }
            else
            {
                if (!MedicGetsYouUp(player))
                {
                    switch (Oxide.Core.Random.Range(0, 1))
                    {
                        case 0:
                            if (!popupsEnabled)
                                SendReply(player, localization["MedicToLate"]);
                            else
                                PopupNotifications.Call("CreatePopupNotification", localization["MedicToLate"], player);
                            break;
                        case 1:
                            if (!popupsEnabled)
                                SendReply(player, localization["MedicIncompetent"]);
                            else
                                PopupNotifications.Call("CreatePopupNotification", localization["MedicIncompetent"], player);
                            break;
                    }

                    return;
                }

                player.StopWounded();
                
                player.health = startHealth;
                
                player.metabolism.bleeding.value = 0f;

                if (!popupsEnabled)
                    SendReply(player, localization["Survived"]);
                else
                    PopupNotifications.Call("CreatePopupNotification", localization["Survived"], player);
            }
        }

        void TimedMedic(ulong playerID)
        {
            BasePlayer player = BasePlayer.FindByID(playerID);

            if (player == null)
            {
                PrintWarning(String.Format("Unwound reports that the medic has arrived, but player \"{0}\" does not exist ...", playerID.ToString()));
                SendReply(player, String.Format("Unwound reports that the medic has arrived, but player \"{0}\" does not exist ...", playerID.ToString()));

                return;
            }
            else if (!player.IsConnected)
                return;
            else if (player.IsDead())
            {
                //TODO: code to enqueue a message for the player
                return;
            }
            else if (!player.IsWounded())
            {
                if (!popupsEnabled)
                    SendReply(player, localization["DontTrollTheMedic"]);
                else
                    PopupNotifications.Call("CreatePopupNotification", localization["DontTrollTheMedic"], player);

                return;
            }
            else if (!MedicGetsYouUp(player))
            {
                called.Remove(player.userID);

                switch (Oxide.Core.Random.Range(0, 1))
                {
                    case 0:
                        if (!popupsEnabled)
                            SendReply(player, localization["MedicToLate"]);
                        else
                           PopupNotifications.Call("CreatePopupNotification", localization["MedicToLate"], player);
                        break;
                    case 1:
                        if (!popupsEnabled)
                            SendReply(player, localization["MedicIncompetent"]);
                        else
                            PopupNotifications.Call("CreatePopupNotification", localization["MedicIncompetent"], player);
                        break;
                }

                return;
            }

            called.Remove(player.userID);

            player.StopWounded();

            player.health = startHealth;
            
            player.metabolism.bleeding.value = 0f;

            if (!popupsEnabled)
                SendReply(player, localization["Survived"]);
            else
                PopupNotifications.Call("CreatePopupNotification", localization["Survived"], player);
        }

        void OnPlayerWound(BasePlayer player, HitInfo hitInfo)
        {
            if (ZoneManager != null)
            {
                object canBeWounded = ZoneManager.Call("CanBeWounded", player, hitInfo);

                if (canBeWounded == null)
                    return;
            }
            
            if (!popupsEnabled)
                SendReply(player, string.Format(localization["AboutToDie"],string.Join("\n", ecoSettings.Select(x => $"Cost {x.Key}, Seconds until revived {x.Value}").ToArray())));
            else
                PopupNotifications.Call("CreatePopupNotification", string.Format(localization["AboutToDie"],string.Join("\n", ecoSettings.Select(x => $"Cost {x.Key}, Seconds until revived {x.Value}").ToArray())), player);
        }

        bool CheckCanCall(BasePlayer player)
        {
            if (called.Contains(player.userID))
            {
                if (!popupsEnabled)
                    SendReply(player, localization["MedicAlreadyCalled"]);
                else
                    PopupNotifications.Call("CreatePopupNotification", localization["MedicAlreadyCalled"], player);

                return false;
            }
            else
            {
                called.Add(player.userID);

                return true;
            }
        }

        bool MedicGetsYouUp(BasePlayer player)
        {
            if (chanceTheMedicSavesYou == 100)
                return true;

            uint success = 0;

            //with 100k-test-rounds this seemed pretty accurate ... well 99% chance is as failsafe as 100%, so not perfect but good enough

            for (int i = 0; i <= 100; i++)
                success += (uint)Oxide.Core.Random.Range(1, 100);

            success = success % 100;

            return success <= chanceTheMedicSavesYou;
        }

        static double ConvertToUnixTimestamp(DateTime date)
        {
            DateTime origin = new DateTime(1970, 1, 1, 0, 0, 0, 0);

            TimeSpan diff = date.ToUniversalTime() - origin;

            return Math.Floor(diff.TotalSeconds);
        }

        static bool IsUInt(string s)
        {
            Regex _uint = new Regex("^\\d*$");

            return _uint.Match(s).Success;
        }

        #region Currency System

        double GetCurrency(BasePlayer player)
        {
            if (enableEconomics && !enableServerRewards && Economics != null)
            {
                return Economics.Call<double>("Balance", player.UserIDString);
            }

            if (enableServerRewards && !enableEconomics && ServerRewards != null)
            {
                return ServerRewards.Call<int>("CheckPoints", player.UserIDString);
            }

            PrintWarning("Default currency not selected");
            return 0;
        }

        bool Withdraw(BasePlayer player, double amount)
        {
            if (enableEconomics && !enableServerRewards && Economics != null)
            {
                Puts("Economics called all good.");
                return Economics.Call<bool>("Withdraw", player.userID, amount);
            }

            if (enableServerRewards && !enableEconomics && ServerRewards != null)
            {
                Puts("Yo called fucking Server Rewards bitch");
                return ServerRewards.Call<object>("TakePoints", player.userID, (int)amount) != null;
            }

            Puts("Both failed.");
            return false;
        }

        #endregion
    }
}

// --- End of file: Unwound.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/unique-names ---
// --- Original File Path: U/UniqueNames/UniqueNames.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Unique Names", "Wulf/lukespragg", "1.0.3")]
    [Description("Automatic renames and/or kicks players with non-unique/duplicate names")]
    class UniqueNames : CovalencePlugin
    {
        #region Initialization

        private const string permBypass = "uniquenames.bypass";

        private void Init()
        {
            permission.RegisterPermission(permBypass, this);
        }

        #endregion Initialization

        #region Configuration

        private Configuration config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Kick player with non-unique name")]
            public bool KickPlayer { get; set; } = true;

            [JsonProperty(PropertyName = "Rename player with non-unqiue name")]
            public bool RenamePlayer { get; set; } = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }
            }
            catch
            {
                string configPath = $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Name}";
                LogWarning($"Could not load a valid configuration file, creating a new configuration file at {configPath}.json");
                Config.WriteObject(config, false, $"{configPath}_invalid.json");
                LoadDefaultConfig();
                SaveConfig();
            }
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["KickReason"] = "The name {0} is already in use",
                ["Renamed"] = "{0} already in use, you have been renamed to {1}"
            }, this);
        }

        private string Lang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        #endregion Localization

        #region Name Handling

        private void OnUserConnected(IPlayer player)
        {
            if (!permission.UserHasPermission(player.Id, permBypass))
            {
                List<IPlayer> duplicates = players.Connected.ToList().Where(p => p.Name == player.Name).ToList();
                if (duplicates.Count > 1)
                {
                    if (config.RenamePlayer)
                    {
                        string newName = player.Name + duplicates.Count;
                        player.Message(Lang("Renamed", player.Id, player.Name, newName));
                        player.Rename(newName);
                    }
                    if (config.KickPlayer)
                    {
                        player.Kick(Lang("KickReason", player.Id, player.Name));
                    }
                }
            }
        }

        #endregion Name Handling
    }
}


// --- End of file: UniqueNames.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ugather ---
// --- Original File Path: U/UGather/UGather.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("UGather", "dFxPhoeniX", "1.1.6")]
    [Description("Adds zones, permissions, and other options to modify gather rates!")]
    class UGather : RustPlugin
    {
        #region Variables
        [PluginReference] Plugin ZoneManager;
        public static UGather plugin;

        private DynamicConfigFile ZoneDataFile;
        private ZoneData zoneData;
        private Configuration config;

        private const string SphereEnt = "assets/prefabs/visualization/sphere.prefab"; // Thanks to ZoneDomes
        #endregion

        #region Data
        public class ZoneData
        {
            public List<GatherZone> Zones = new List<GatherZone>();

            public GatherZone GetZoneByID(string id)
            {
                return Zones.Find(x => x.id == id);
            }
        }
        public class GatherZone
        {
            // The message a user will see upon entering this gather zone, string.Empty for nothing
            public string enterMessage;
            // The message a user will see upon leaving this gather zone, string.Empty for nothing
            public string leaveMessage;

            // The permission we will use from the config to use certain gather rates.
            public string permissionToUse;
            // If a should have to have the permission to use these gather rates : This effects if a player will see the leave/enter mesage
            public bool requireUserHavePermission;
            // If this zone should have priority over everything else, or should it just leave it to the plugin to figure out.
            public bool overTakePriority;
            // If I should disable the regular permission, this prevents it from being used anywhere but the zone
            public bool restrictPermission;

            // The location of zone, probably dont need this. But just incase we have to recreate the zone
            public float x, y, z;
            // The id of the zone we use in ZoneManager, used to get at a later point.
            public string id;
            // The radius of the zone
            public int radius;

            public void OnPlayerEntered(BasePlayer player)
            {
                if (enterMessage == string.Empty) return; // No enter message, get out of here
                if (!plugin.permission.UserHasPermission(player.UserIDString, permissionToUse) && requireUserHavePermission) return;

                plugin.SendReply(player, enterMessage);
            }

            public void OnPlayerLeave(BasePlayer player)
            {
                if (leaveMessage == string.Empty) return; // No enter message, get out of here
                if (!plugin.permission.UserHasPermission(player.UserIDString, permissionToUse) && requireUserHavePermission) return;

                plugin.SendReply(player, leaveMessage);
            }
        }
        private void SaveData()
        {
            ZoneDataFile.WriteObject(zoneData);
        }
        private void LoadData()
        {
            plugin = this;
            try
            {
                ZoneDataFile.Settings.NullValueHandling = NullValueHandling.Ignore;
                zoneData = ZoneDataFile.ReadObject<ZoneData>();
                Puts($"Loaded {zoneData.Zones.Count} UGather Zones!");
            }
            catch
            {
                Puts("Failed to load ZoneData, creating new data.");
                zoneData = new ZoneData();
            }
        }
        #endregion

        #region ZoneManager
        private void OnEnterZone(string ZoneID, BasePlayer player)
        {
            GatherZone zone = zoneData.GetZoneByID(ZoneID);
            zone?.OnPlayerEntered(player);
        }

        private void OnExitZone(string ZoneID, BasePlayer player)
        {
            GatherZone zone = zoneData.GetZoneByID(ZoneID);
            zone?.OnPlayerLeave(player);
        }
        #endregion

        #region Configuration
        public class Configuration
        {
            [JsonProperty(PropertyName = "Gather Perms : The list of permissions that grant specified gather rates.")]
            public Dictionary<string, Dictionary<string, Dictionary<string, float>>> GatherPerms;

            [JsonProperty(PropertyName = "Base Permission : The basic permission given to group default.")]
            public string BasePerm;

            [JsonProperty(PropertyName = "Default Group : The group all players should be in, these players get the base perm.")]
            public string DefaultGroup;

            [JsonProperty(PropertyName = "Stackable Permissions : If a user has multiple perms, should they stack gather rate.")]
            public bool Stack;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file.");
            config = new Configuration()
            {
                GatherPerms = new Dictionary<string, Dictionary<string, Dictionary<string, float>>>()
                {
                    {"ugather.basic", new Dictionary<string, Dictionary<string, float>>()
                    {
                        {"Dispenser", new Dictionary<string, float>(){
                            { "bone_fragments", 2 },
                            { "cloth", 2 },
                            {"fat.animal", 2 },
                            {"meat.horse.raw", 2 },
                            {"hq_metal_ore", 2 },
                            {"humanmeat_raw", 2 },
                            {"meat.bear.raw", 2 },
                            {"meat.pork.raw", 2 },
                            {"leather", 2 },
                            {"metal_ore", 2 },
                            {"stones", 2 },
                            {"sulfur_ore", 2 },
                            {"meat.wolf.raw", 2 },
                            {"skull_wolf", 2 },
                            {"wood", 2 },
                            {"metal_fragments", 2},
                            {"metal_refined", 2},
                            {"charcoal", 2 }
                        }},
                        {"Bonus", new Dictionary<string, float>(){
                            {"stones", 2},
                            {"sulfur_ore", 2},
                            {"metal_ore", 2},
                            {"hq_metal_ore", 2},
                            {"wood", 2}
                        }},
                        {"Quarry", new Dictionary<string, float>(){
                            {"stones", 2},
                            {"sulfur_ore", 2},
                            {"metal_ore", 2},
                            {"hq_metal_ore", 2}
                        }},
                        {"Survey", new Dictionary<string, float>(){
                            {"stones", 2},
                            {"sulfur_ore", 2},
                            {"metal_ore", 2},
                            {"hq_metal_ore", 2}
                        }},
                        {"Pickups", new Dictionary<string, float>(){
                            {"stones", 2},
                            {"sulfur_ore", 2},
                            {"metal_ore", 2},
                            {"wood", 2},
                            {"mushroom", 2},
                            {"cloth", 2},
                            {"corn", 2},
                            {"pumpkin", 2},
                            {"corn_seed", 2},
                            {"hemp_seed", 2},
                            {"pumpkin_seed", 2}
                        }}
                    }},
                    {"ugather.advanced", new Dictionary<string, Dictionary<string, float>>()
                    {
                        {"Dispenser", new Dictionary<string, float>(){
                            { "bone_fragments", 2 },
                            { "cloth", 2 },
                            {"fat.animal", 2 },
                            {"meat.horse.raw", 2 },
                            {"hq_metal_ore", 2 },
                            {"humanmeat_raw", 2 },
                            {"meat.bear.raw", 2 },
                            {"meat.pork.raw", 2 },
                            {"leather", 2 },
                            {"metal_ore", 2 },
                            {"stones", 2 },
                            {"sulfur_ore", 2 },
                            {"meat.wolf.raw", 2 },
                            {"skull_wolf", 2 },
                            {"wood", 2 },
                            {"metal_fragments", 2},
                            {"metal_refined", 2},
                            {"charcoal", 2 }
                        }},
                        {"Bonus", new Dictionary<string, float>(){
                            {"stones", 2},
                            {"sulfur_ore", 2},
                            {"metal_ore", 2},
                            {"hq_metal_ore", 2},
                            {"wood", 2}
                        }},
                        {"Quarry", new Dictionary<string, float>(){
                            {"stones", 2},
                            {"sulfur_ore", 2},
                            {"metal_ore", 2},
                            {"hq_metal_ore", 2}
                        }},
                        {"Survey", new Dictionary<string, float>(){
                            {"stones", 2},
                            {"sulfur_ore", 2},
                            {"metal_ore", 2},
                            {"hq_metal_ore", 2}
                        }},
                        {"Pickups", new Dictionary<string, float>(){
                            {"stones", 2},
                            {"sulfur_ore", 2},
                            {"metal_ore", 2},
                            {"wood", 2},
                            {"mushroom", 2},
                            {"cloth", 2},
                            {"corn", 2},
                            {"pumpkin", 2},
                            {"corn_seed", 2},
                            {"hemp_seed", 2},
                            {"pumpkin_seed", 2}
                        }}
                    }},
                    {"ugather.donor", new Dictionary<string, Dictionary<string, float>>()
                    {
                        {"Dispenser", new Dictionary<string, float>(){
                            { "bone_fragments", 2 },
                            { "cloth", 2 },
                            {"fat.animal", 2 },
                            {"meat.horse.raw", 2 },
                            {"hq_metal_ore", 2 },
                            {"humanmeat_raw", 2 },
                            {"meat.bear.raw", 2 },
                            {"meat.pork.raw", 2 },
                            {"leather", 2 },
                            {"metal_ore", 2 },
                            {"stones", 2 },
                            {"sulfur_ore", 2 },
                            {"meat.wolf.raw", 2 },
                            {"skull_wolf", 2 },
                            {"wood", 2 },
                            {"metal_fragments", 2},
                            {"metal_refined", 2},
                            {"charcoal", 2 }
                        }},
                        {"Bonus", new Dictionary<string, float>(){
                            {"stones", 2},
                            {"sulfur_ore", 2},
                            {"metal_ore", 2},
                            {"hq_metal_ore", 2},
                            {"wood", 2}
                        }},
                        {"Quarry", new Dictionary<string, float>(){
                            {"stones", 2},
                            {"sulfur_ore", 2},
                            {"metal_ore", 2},
                            {"hq_metal_ore", 2}
                        }},
                        {"Survey", new Dictionary<string, float>(){
                            {"stones", 2},
                            {"sulfur_ore", 2},
                            {"metal_ore", 2},
                            {"hq_metal_ore", 2}
                        }},
                        {"Pickups", new Dictionary<string, float>(){
                            {"stones", 2},
                            {"sulfur_ore", 2},
                            {"metal_ore", 2},
                            {"wood", 2},
                            {"mushroom", 2},
                            {"cloth", 2},
                            {"corn", 2},
                            {"pumpkin", 2},
                            {"corn_seed", 2},
                            {"hemp_seed", 2},
                            {"pumpkin_seed", 2}
                        }}
                    }},
                    {"ugather.admin", new Dictionary<string, Dictionary<string, float>>()
                    {
                        {"Dispenser", new Dictionary<string, float>(){
                            { "bone_fragments", 2 },
                            { "cloth", 2 },
                            {"fat.animal", 2 },
                            {"meat.horse.raw", 2 },
                            {"hq_metal_ore", 2 },
                            {"humanmeat_raw", 2 },
                            {"meat.bear.raw", 2 },
                            {"meat.pork.raw", 2 },
                            {"leather", 2 },
                            {"metal_ore", 2 },
                            {"stones", 2 },
                            {"sulfur_ore", 2 },
                            {"meat.wolf.raw", 2 },
                            {"skull_wolf", 2 },
                            {"wood", 2 },
                            {"metal_fragments", 2},
                            {"metal_refined", 2},
                            {"charcoal", 2 }
                        }},
                        {"Bonus", new Dictionary<string, float>(){
                            {"stones", 2},
                            {"sulfur_ore", 2},
                            {"metal_ore", 2},
                            {"hq_metal_ore", 2},
                            {"wood", 2}
                        }},
                        {"Quarry", new Dictionary<string, float>(){
                            {"stones", 2},
                            {"sulfur_ore", 2},
                            {"metal_ore", 2},
                            {"hq_metal_ore", 2}
                        }},
                        {"Survey", new Dictionary<string, float>(){
                            {"stones", 2},
                            {"sulfur_ore", 2},
                            {"metal_ore", 2},
                            {"hq_metal_ore", 2}
                        }},
                        {"Pickups", new Dictionary<string, float>(){
                            {"stones", 2},
                            {"sulfur_ore", 2},
                            {"metal_ore", 2},
                            {"wood", 2},
                            {"mushroom", 2},
                            {"cloth", 2},
                            {"corn", 2},
                            {"pumpkin", 2},
                            {"corn_seed", 2},
                            {"hemp_seed", 2},
                            {"pumpkin_seed", 2}
                        }}
                    }}
                },
                BasePerm = "ugather.basic",
                Stack = false,
                DefaultGroup = "default"
            };
            SaveConfig(config);
        }
        void SaveConfig(Configuration config)
        {
            Config.WriteObject(config, true);
            SaveConfig();
        }
        public void LoadConfigVars()
        {
            PrintWarning("Loading configuration.");
            config = Config.ReadObject<Configuration>();
            Config.WriteObject(config, true);
        }
        #endregion

        void Loaded()
        {
            LoadConfigVars();

            if(!permission.PermissionExists("ugather.admin"))
                permission.RegisterPermission("ugather.admin", this);

            foreach (var x in config.GatherPerms)
                permission.RegisterPermission(x.Key, this);

            if (!permission.GroupHasPermission(config.DefaultGroup, config.BasePerm))
                permission.GrantGroupPermission(config.DefaultGroup, config.BasePerm, this);

            ZoneDataFile = Interface.Oxide.DataFileSystem.GetFile("UGather_ZoneData");
            LoadData();

            lang.RegisterMessages(new Dictionary<string, string>()
            {
                // General Command Lang
                {"Command : Prefix", "<color=#0dba86>[UGather]: </color>"},
                {"Command : Help (General)",
                    "\nUse any of these commands to see more information about them:" +
                    "\n • /ugather rate - Show's information about config gather rates." +
                    "\n • /ugather zone - Show's information about the zone gather system." +
                    "\n\n - UGather Zone Status: <color={zonestatuscolor}>{zonestatus}</color>"
                },
                {"Command : No Permission", "You do not have permission to run that command!"},

                // Zone Command Lang
                {"Command : Help (Zone)", "Commands for the zoning system:" +
                    "\n <b><i>* = Optional Parameter</i></b>" +
                    "\n • /ugather zone add <permission> <radius> - Creates a gather zone using a permission from config for reference, and a radius using zonemanager." +
                    "\n • /ugather zone list *<page> - Show's the list of gather zones, the page param is optional if you have too many zones to show on one page." +
                    "\n • /ugather zone edit <number from list> <variable> <value> - Sets a flag/variable for the zone. Use /ugather zone editinfo for more info." +
                    "\n • /ugather zone show <number from list> - Creates a sphere showing the radius of the zone" +
                    "\n • /ugather zone variables - Shows a list of variables you can edit using the /ugather zone edit command" +
                    "\n • /ugather zone delete <number from list> - Deletes a zone based on the number from /ugather zone list!"
                },
                {"Command : Not A Number", "The parameter <i>{param}</i> requires a valid positive number! Ex: 5"},
                {"Command : Not A Boolean", "The paramter <i>{param}</i> requires a valid boolean! Ex: true or false"},
                {"Command : Value Updated", "The variable {var} has been changed to {val} for the selected zone!"},
                {"Command : Failed To Update", "Failed to update the following variable: {var}"},
                {"Command : No Available Zone With ID", "Unable to find zone from the list with the number of {num}"},
                {"Command : Zone Created", "A gather zone with the ID of {id} and radius of {rad} was successfully created! Permission: {perm}"},
                {"Command : Zone Failed", "Failed to create a zone with the id of {id}!"},
                {"Command : Zone Manager Not Loaded", "The zone portion of the plugin is not available as ZoneManager is not loaded!"},
                {"Command : No Zones", "There are currently no gather zones! Use /ugather zone to learn more about creating zones!"},
                {"Command : Delete Success", "You have successfully deleted the zone with the ID of {id}!"},
                {"Command : Zone List", "Available Zones:" +
                    "\nPage {p1} out of {p2}" +
                    "\n{zones}"
                },
                {"Command : Zone Variables", "Editable Variables:" +
                    "\n • position (No Arguments) (The location of the zone)" +
                    "\n • radius (Integer - Example: 50) (The radius of the zone)" +
                    "\n • enter_message (String - Example: \"Hi!\") (The message you get upon entering the zone)" +
                    "\n • leave_message (String - Example: \"Bye!\") (The message you get upon leaving the zone)" +
                    "\n • require_permission (Boolean - Example: true) (If you require permission to gain gather rates from the zone)" +
                    "\n • overtake_priority (Boolean - Example: true) (If it should override all other gather rates)" +
                    "\n • restrict_permission (Boolean - Example: true) (If the permission it is using should be disabled unless used for the zone)"
                },

                // Rate Command Lang
                {"Command : Help (Rate)", "Commands for the gather rates system:" +
                    "\n <b><i>* = Optional Parameter</i></b>" +
                    "\n • /ugather rate list - Show's a list of current permissions" +
                    "\n • /ugather rate info <permission> - Shows info about a permissions rates" +
                    "\n • /ugather rate stats <permission> <type> - Shows info about a permissions rates, in a category." +
                    "\n • /ugather rate types - Show's a list of valid types"
                },
                {"Command : Permission List", "Available Permissions:" +
                    "\n{perms}"
                },
                {"Command : Invalid Permission", "Could not find a permission with the name of {name}!"},
                {"Command : Perm Info", "Permission Info:" +
                    "\n • Types: {typeCount}" +
                    "\n • Registered Zone: {hasRegisteredZone}" +
                    "\n • Players With Permission: {playerCount}"
                },
                {"Command : Permission Info List", "Showing type of {type} for permission {perm}:" +
                    "\n{stats}"
                },
                {"Command : Gather Types", "Available Gather Types:\n" +
                    "\n • Dispenser - The materials you get from harvesting with a pickaxe, hatchet, etc." +
                    "\n • Bonus - That little extra you get at the end of a harvest." +
                    "\n • Pickups - The materials you get from picking things up, like food." +
                    "\n • Quarry - The materials you get from a quarry." +
                    "\n • Survey - The materials you get from a survey charge"
                },
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                // General Command Lang
                {"Command : Prefix", "<color=#0dba86>[UGather]: </color>"},
                {"Command : Help (General)",
                    "\nFolosește oricare din aceste comenzi pentru a vedea mai multe informații despre ele:" +
                    "\n • /ugather rate - Afișează informații despre ratele de recoltare." +
                    "\n • /ugather zone - Afișează informații despre zona ratei de recoltare." +
                    "\n\n - Statusul zonei UGather: <color={zonestatuscolor}>{zonestatus}</color>"
                },
                {"Command : No Permission", "Nu ai permisiunea de a folosi această comandă!"},
            
                // Zone Command Lang
                {"Command : Help (Zone)", "Comenzi pentru sistemele de zonare:" +
                    "\n <b><i>* = Parametru Opțional</i></b>" +
                    "\n • /ugather zone add <permisiune> <raza> - Creează o zonă de recoltare folosind o permisiune din config pentru referință și o rază folosind ZoneManager." +
                    "\n • /ugather zone list *<pagina> - Afișează lista zonelor de recoltare. Parametrul paginii este opțional dacă ai prea multe zone de afișat într-o pagină." +
                    "\n • /ugather zone edit <număr din listă> <variabilă> <valoare> - Setează un steag/variabilă pentru zona. Folosește /ugather zone editinfo pentru mai multe informații." +
                    "\n • /ugather zone show <număr din listă> - Creează o sferă care arată raza zonei." +
                    "\n • /ugather zone variables - Afișează o listă de variabile pe care le poți edita folosind comanda /ugather zone edit." +
                    "\n • /ugather zone delete <număr din listă> - Șterge o zonă bazată pe numărul din /ugather zone list!"
                },
                {"Command : Not A Number", "Parametrul <i>{param}</i> necesită un număr valid pozitiv! Exemplu: 5"},
                {"Command : Not A Boolean", "Parametrul <i>{param}</i> necesită o valoare booleană validă! Exemplu: true sau false"},
                {"Command : Value Updated", "Variabila {var} a fost actualizată cu {val} pentru zona selectată!"},
                {"Command : Failed To Update", "Nu s-a putut actualiza următoarea variabilă: {var}"},
                {"Command : No Available Zone With ID", "Nu s-a putut găsi o zonă în lista cu numărul {num}"},
                {"Command : Zone Created", "O zonă de recoltare cu ID-ul {id} și rază de {rad} a fost creată cu succes! Permisiune: {perm}"},
                {"Command : Zone Failed", "Nu s-a putut crea o zonă cu ID-ul {id}!"},
                {"Command : Zone Manager Not Loaded", "Portiunea de zonă a pluginului nu este disponibilă deoarece ZoneManager nu este încărcat!"},
                {"Command : No Zones", "Momentan nu există zone de recoltare! Folosește /ugather zone pentru a afla mai multe despre crearea unei zone!"},
                {"Command : Delete Success", "Ai șters cu succes zona cu ID-ul {id}!"},
                {"Command : Zone List", "Zone disponibile:" +
                    "\nPagina {p1} din {p2}" +
                    "\n{zones}"
                },
                {"Command : Zone Variables", "Variabile editabile:" +
                    "\n • position (Fără argumente) (Locația zonei)" +
                    "\n • radius (Număr întreg - Exemplu: 50) (Raza zonei)" +
                    "\n • enter_message (Șir de caractere - Exemplu: \"Salut!\") (Mesajul pe care îl primești la intrarea în zonă)" +
                    "\n • leave_message (Șir de caractere - Exemplu: \"La revedere!\") (Mesajul pe care îl primești la părăsirea zonei)" +
                    "\n • require_permission (Valoare booleană - Exemplu: true) (Dacă necesită permisiune pentru a obține ratele de recoltare din zona respectivă)" +
                    "\n • overtake_priority (Valoare booleană - Exemplu: true) (Dacă ar trebui să suprascrie toate celelalte rate de recoltare)" +
                    "\n • restrict_permission (Valoare booleană - Exemplu: true) (Dacă permisiunea folosită ar trebui dezactivată doar dacă nu este utilizată pentru zona respectivă)"
                },
            
                // Rate Command Lang
                {"Command : Help (Rate)", "Comenzi pentru sistemul de rate de recoltare:" +
                    "\n <b><i>* = Parametru opțional</i></b>" +
                    "\n • /ugather rate list - Afișează o listă cu permisiunile curente" +
                    "\n • /ugather rate info <permisiune> - Afișează informații despre ratele permisiunii" +
                    "\n • /ugather rate stats <permisiune> <tip> - Afișează informații despre ratele permisiunii într-o categorie." +
                    "\n • /ugather rate types - Afișează o listă de tipuri valide"
                },
                {"Command : Permission List", "Permisiuni disponibile:" +
                    "\n{perms}"
                },
                {"Command : Invalid Permission", "Nu s-a putut găsi o permisiune cu numele {name}!"},
                {"Command : Perm Info", "Informații despre permisiune:" +
                    "\n • Tipuri: {typeCount}" +
                    "\n • Zonă înregistrată: {hasRegisteredZone}" +
                    "\n • Jucători cu permisiune: {playerCount}"
                },
                {"Command : Permission Info List", "Afișează tipul {type} pentru permisiunea {perm}:" +
                    "\n{stats}"
                },
                {"Command : Gather Types", "Tipuri de recoltare disponibile:\n" +
                    "\n • Dispenser - Materialele pe care le primești din recoltare cu un topor, o secure, etc." +
                    "\n • Bonus - Un mic bonus pe care îl primești la sfârșitul recoltării." +
                    "\n • Pickups - Materialele pe care le primești luându-le de jos, precum mâncarea." +
                    "\n • Cariera - Materialele pe care le primești dintr-o carieră." +
                    "\n • Studiu - Materialele pe care le primești dintr-un sondaj"
                },
            }, this, "ro");
        }

        void Reply(BasePlayer player, string raw, params string[] args)
        {
            var msg = lang.GetMessage(raw, this, player.UserIDString);
            if (args.Length > 0)
                for (var i = 0; i < args.Length; i += 2)
                    msg = msg.Replace("{"+args[i]+"}", args[i + 1]);

            SendReply(player, lang.GetMessage("Command : Prefix", this, player.UserIDString) + msg);
        }

        [ChatCommand("ugather")]
        void UGather_Command(BasePlayer player, string command, string[] args)
        {
            if(!permission.UserHasPermission(player.UserIDString, "ugather.admin"))
            {
                Reply(player, "Command : No Permission");
                return;
            }
            if(args.Length == 0)
            {
                Reply(player, "Command : Help (General)", "zonestatuscolor", (ZoneManager == null) ? "red" : "green", "zonestatus", (ZoneManager == null) ? "Disabled" : "Enabled");
                return;
            }

            if(args[0].ToLower() == "zone")
            {
                if(ZoneManager == null)
                {
                    Reply(player, "Command : Zone Manager Not Loaded");
                    return;
                }
                if(args.Length < 2)
                {
                    Reply(player, "Command : Help (Zone)");
                    return;
                }

                switch (args[1])
                {
                    case "variables":
                        Reply(player, "Command : Zone Variables");
                        break;
                    case "add":
                        if (args.Length != 4)
                        {
                            Reply(player, "Command : Help (Zone)");
                            return;
                        }

                        string permission = args[2];
                        int radius = 0;
                        if (!int.TryParse(args[3], out radius))
                        {
                            Reply(player, "Command : Not A Number", "param", "radius");
                            return;
                        }

                        if (!config.GatherPerms.ContainsKey(permission))
                        {
                            Reply(player, "Command : Invalid Permission", "name", permission);
                            return;
                        }

                        GatherZone zone = new GatherZone()
                        {
                            enterMessage = string.Empty,
                            leaveMessage = string.Empty,

                            id = $"UGATHER_ZONE_{permission}",
                            overTakePriority = false,
                            permissionToUse = permission,
                            requireUserHavePermission = true,
                            x = player.transform.position.x,
                            y = player.transform.position.y,
                            z = player.transform.position.z,
                            restrictPermission = false,
                            radius = radius
                        };

                        List<string> Arguments = new List<string>()
                        {
                            "radius",
                            radius.ToString()
                        };

                        bool zoneManagerZone = (bool)ZoneManager?.CallHook("CreateOrUpdateZone", zone.id, Arguments.ToArray(), new Vector3(zone.x, zone.y, zone.z));
                        if (zoneManagerZone)
                        {
                            zoneData.Zones.Add(zone);
                            Reply(player, "Command : Zone Created", "id", zone.id, "rad", radius.ToString(), "perm", zone.permissionToUse);
                            SaveData();
                        }
                        else
                        {
                            Reply(player, "Command : Zone Failed", "id", zone.id);
                            ZoneManager?.CallHook("EraseZone", "UGATHER_ZONE_" + permission);
                        }

                        break;
                    case "list":
                        int page = 1;
                        if (args.Length == 3)
                        {
                            if (int.TryParse(args[2], out page))
                                if (page < 0)
                                    page = 1;
                            else
                                Reply(player, "Command : Not A Number", "param", "page");
                        }

                        StringBuilder zoneBuilder = new StringBuilder();
                        if (zoneData.Zones.Count == 0)
                        {
                            Reply(player, "Command : No Zones");
                            return;
                        }
                        for (var i = (page - 1) * 8; i < page * 8; i++)
                        {
                            if (!(zoneData.Zones.Count >= i + 1)) break;

                            zoneBuilder.AppendLine($" • {i + 1} - {zoneData.Zones[i].id}");
                        }

                        Reply(player, "Command : Zone List", "zones", zoneBuilder.ToString(), "p1", page.ToString(), "p2", Math.Ceiling(zoneData.Zones.Count / 8.0).ToString());
                        break;
                    case "show":
                        if (args.Length != 3)
                        {
                            Reply(player, "Command : Help (Zone)");
                            return;
                        }

                        int set2 = -1;

                        if (!int.TryParse(args[2], out set2))
                        {
                            Reply(player, "Command : Not A Number", "param", "id");
                            return;
                        }

                        if (!(zoneData.Zones.Count >= (set2 - 1)))
                        {
                            Reply(player, "Command : No Available Zone With ID", "num", set2.ToString());
                            return;
                        }

                        GatherZone showingZone = zoneData.Zones[set2 - 1];

                        for (int i = 0; i < 15; i++)
                        {
                            BaseEntity sphere = GameManager.server.CreateEntity(SphereEnt, new Vector3(showingZone.x, showingZone.y, showingZone.z), new Quaternion(), true);
                            SphereEntity ent = sphere.GetComponent<SphereEntity>();
                            ent.currentRadius = showingZone.radius * 2;
                            ent.lerpSpeed = 0f;

                            sphere.Spawn();

                            timer.Once(15f, () =>
                            {
                                sphere.Kill();
                            });
                        }
                        break;
                    case "delete":
                        if (args.Length != 3)
                        {
                            Reply(player, "Command : Help (Zone)");
                            return;
                        }

                        int set3 = -1;

                        if (!int.TryParse(args[2], out set3))
                        {
                            Reply(player, "Command : Not A Number", "param", "id");
                            return;
                        }

                        if (!(zoneData.Zones.Count >= (set3 - 1)))
                        {
                            Reply(player, "Command : No Available Zone With ID", "num", set3.ToString());
                            return;
                        }

                        GatherZone editingZone2 = zoneData.Zones[set3 - 1];

                        ZoneManager?.CallHook("EraseZone", editingZone2.id);
                        Reply(player, "Command : Delete Success", "id", editingZone2.id);
                        zoneData.Zones.Remove(editingZone2);
                        SaveData();

                        break;
                    case "edit":
                        if (args.Length != 5)
                        {
                            Reply(player, "Command : Help (Zone)");
                            return;
                        }

                        int set = -1;

                        if(!int.TryParse(args[2], out set))
                        {
                            Reply(player, "Command : Not A Number", "param", "id");
                            return;
                        }

                        if(!(zoneData.Zones.Count >= (set - 1)))
                        {
                            Reply(player, "Command : No Available Zone With ID", "num", set.ToString());
                            return;
                        }

                        GatherZone editingZone = zoneData.Zones[set - 1];
                        switch (args[3])
                        {
                            case "radius":
                                int editingZoneRadius = 0;

                                if(!int.TryParse(args[4], out editingZoneRadius))
                                {
                                    Reply(player, "Command : Not A Number", "param", "radius");
                                    return;
                                }

                                if(editingZoneRadius <= 0)
                                {
                                    Reply(player, "Command : Not A Number", "param", "radius");
                                    return;
                                }

                                List<string> editingZoneArgumentsRadius = new List<string>()
                                {
                                    "radius",
                                    editingZoneRadius.ToString()
                                };

                                bool wasZoneRadiusUpdated = (bool)ZoneManager?.CallHook("CreateOrUpdateZone", editingZone.id, editingZoneArgumentsRadius.ToArray(), new Vector3(editingZone.x, editingZone.y, editingZone.z));
                                if (wasZoneRadiusUpdated)
                                {
                                    Reply(player, "Command : Value Updated", "var", "radius", "val", editingZoneRadius.ToString());
                                    editingZone.radius = editingZoneRadius;
                                }
                                else
                                    Reply(player, "Command : Failed To Update", "var", "radius");

                                break;
                            case "position":

                                List<string> editingPositionZone = new List<string>()
                                {
                                    "location",
                                    $"{player.transform.position.x} {player.transform.position.y} {player.transform.position.z}"
                                };

                                bool wasZonePositionUpdated = (bool)ZoneManager?.CallHook("CreateOrUpdateZone", editingZone.id, editingPositionZone.ToArray(), new Vector3(editingZone.x, editingZone.y, editingZone.z));
                                if (wasZonePositionUpdated)
                                {
                                    Reply(player, "Command : Value Updated", "var", "position", "val", player.transform.position.ToString());
                                    editingZone.x = player.transform.position.x;
                                    editingZone.y = player.transform.position.y;
                                    editingZone.z = player.transform.position.z;
                                }
                                else
                                    Reply(player, "Command : Failed To Update", "var", "position");

                                break;
                            case "enter_message":
                                Reply(player, "Command : Value Updated", "var", "enter_message", "val", args[4]);
                                editingZone.enterMessage = args[4];
                                break;
                            case "leave_message":
                                Reply(player, "Command : Value Updated", "var", "leave_message", "val", args[4]);
                                editingZone.leaveMessage = args[4];
                                break;

                            case "require_permission":
                                bool shouldUsePerm = editingZone.requireUserHavePermission;
                                if(bool.TryParse(args[4], out shouldUsePerm))
                                {
                                    Reply(player, "Command : Value Updated", "var", "require_permission", "val", shouldUsePerm.ToString());
                                    editingZone.requireUserHavePermission = shouldUsePerm;
                                } else
                                {
                                    Reply(player, "Command : Failed To Update", "var", "require_permission");
                                    Reply(player, "Command : Not A Boolean", "param", "require_permission");
                                }
                                break;

                            case "overtake_priority":
                                bool shouldOvertakePriority = editingZone.overTakePriority;
                                if (bool.TryParse(args[4], out shouldOvertakePriority))
                                {
                                    Reply(player, "Command : Value Updated", "var", "overtake_priority", "val", shouldOvertakePriority.ToString());
                                    editingZone.overTakePriority = shouldOvertakePriority;
                                }
                                else
                                {
                                    Reply(player, "Command : Failed To Update", "var", "overtake_priority");
                                    Reply(player, "Command : Not A Boolean", "param", "overtake_priority");
                                }
                                break;

                            case "restrict_permission":
                                bool shouldRestrictPermission = editingZone.overTakePriority;
                                if (bool.TryParse(args[4], out shouldRestrictPermission))
                                {
                                    Reply(player, "Command : Value Updated", "var", "restrict_permission", "val", shouldRestrictPermission.ToString());
                                    editingZone.restrictPermission = shouldRestrictPermission;
                                }
                                else
                                {
                                    Reply(player, "Command : Failed To Update", "var", "restrict_permission");
                                    Reply(player, "Command : Not A Boolean", "param", "restrict_permission");
                                }
                                break;
                            default:
                                Reply(player, "Command : Zone Variables");
                                break;
                        }
                        break;
                    default:
                        Reply(player, "Command : Help (Zone)");
                        break;
                }

                return;
            }
            else if (args[0].ToLower() == "rate")
            {
                if(args.Length < 2)
                {
                    Reply(player, "Command : Help (Rate)");
                    return;
                }

                switch (args[1])
                {
                    case "list":
                        StringBuilder permissionList = new StringBuilder();
                        foreach(var gatherPerm in config.GatherPerms)
                            permissionList.AppendLine($" • {gatherPerm.Key}");

                        Reply(player, "Command : Permission List", "perms", permissionList.ToString());
                        break;
                    case "info":
                        if(args.Length != 3)
                        {
                            Reply(player, "Command : Help (Rate)");
                            return;
                        }

                        if(config.GatherPerms.Where(x => x.Key.ToLower() == args[2].ToLower()).Count() == 0)
                        {
                            Reply(player, "Command : Invalid Permission", "name", args[2]);
                            return;
                        }

                        int countTypes = config.GatherPerms[args[2]].Count();
                        bool regZone = zoneData.Zones.Any(x => x.permissionToUse.ToLower() == args[2].ToLower());
                        int playersUsing = covalence.Players.All.Where(x => permission.UserHasPermission(x.Id, args[2].ToLower())).Count();

                        Reply(player, "Command : Perm Info", "typeCount", countTypes.ToString(), "hasRegisteredZone", regZone.ToString(), "playerCount", playersUsing.ToString());
                        break;
                    case "stats":
                        if (args.Length != 4)
                        {
                            Reply(player, "Command : Help (Rate)");
                            return;
                        }

                        if (config.GatherPerms.Where(x => x.Key.ToLower() == args[2].ToLower()).Count() == 0)
                        {
                            Reply(player, "Command : Invalid Permission", "name", args[2]);
                            return;
                        }

                        if(!config.GatherPerms[args[2]].ContainsKey(args[3]))
                        {
                            Reply(player, "Command : Invalid Permission Type", "name", args[2], "type", args[3]);
                            return;
                        }

                        StringBuilder statBuilder = new StringBuilder();
                        foreach (var v in config.GatherPerms[args[2]][args[3]])
                            statBuilder.AppendLine($" • {v.Key} : {v.Value}x");

                        Reply(player, "Command : Permission Info List", "type", args[3], "perm", args[2], "stats", statBuilder.ToString());
                        break;
                    case "types":
                        Reply(player, "Command : Gather Types");
                        break;
                    default:
                        Reply(player, "Command : Help (Rate)");
                        break;
                }
            } else
            {
                Reply(player, "Command : Help (General)", "zonestatuscolor", (ZoneManager == null) ? "red" : "green", "zonestatus", (ZoneManager == null) ? "Disabled" : "Enabled");
            }
        }

        public float GetZoneRate(string permission, string type, string name)
        {
            if (!config.GatherPerms.ContainsKey(permission)) return 1f;

            if (!config.GatherPerms[permission].ContainsKey(type)) return 1f;

            if (!config.GatherPerms[permission][type].ContainsKey(name))
            {
                config.GatherPerms[permission][type].Add(name, 1f);
                SaveConfig();
            }

            return config.GatherPerms[permission][type][name];
        }

        public float GetStackedMultiplier(BasePlayer player, string type, string name, bool forced = false, Vector3 usePosition = new Vector3())
        {
            float highestValue = 0;

            if (ZoneManager != null)
            {
                foreach (GatherZone zone in zoneData.Zones)
                {
                    if (usePosition != new Vector3())
                    {
                        if (Vector3.Distance(usePosition, new Vector3(zone.x, zone.y, zone.z)) > zone.radius)
                            continue; // Not within the zones radius
                    }
                    else
                    {
                        bool playerZone = (bool)ZoneManager?.CallHook("isPlayerInZone", zone.id, player);
                        if (!playerZone)
                            continue;
                    }

                    var zoneRate = GetZoneRate(zone.permissionToUse, type, name);

                    if (zone.requireUserHavePermission)
                        if (!permission.UserHasPermission(player.UserIDString, zone.permissionToUse))
                            continue;

                    if (zone.overTakePriority)
                        return zoneRate;

                    if (zoneRate > highestValue)
                        highestValue = zoneRate;
                }
            }

            if (config.Stack)
            {
                foreach (var pair in config.GatherPerms)
                {
                    if (permission.UserHasPermission(player.UserIDString, pair.Key) || forced)
                        if (pair.Value[type].ContainsKey(name))
                            highestValue += pair.Value[type][name];
                }
            }

            return highestValue;
        }

        public float GetSingleMultiplier(BasePlayer player, string type, string name, bool forced = false, Vector3 usePosition = new Vector3())
        {
            float highestValue = 1f;

            if(ZoneManager != null)
            {
                foreach (GatherZone zone in zoneData.Zones)
                {
                    // Distance Checks
                    if(usePosition != new Vector3())
                    {
                        if (Vector3.Distance(usePosition, new Vector3(zone.x, zone.y, zone.z)) > zone.radius)
                            continue; // Not within the zones radius
                    } else
                    {
                        bool playerZone = (bool)ZoneManager?.CallHook("isPlayerInZone", zone.id, player);
                        if (!playerZone)
                            continue;
                    }

                    var zoneRate = GetZoneRate(zone.permissionToUse, type, name);

                    if (zone.requireUserHavePermission)
                        if (!permission.UserHasPermission(player.UserIDString, zone.permissionToUse))
                            continue;

                    if (zone.overTakePriority)
                        return zoneRate;

                    if (zoneRate > highestValue)
                        highestValue = zoneRate;
                }
            }

            foreach (var pair in config.GatherPerms.Where(x => permission.UserHasPermission(player.UserIDString, x.Key) || forced).ToDictionary(p => p.Key, p => p.Value))
            {
                if (zoneData.Zones.Where(x => x.restrictPermission && x.permissionToUse == pair.Key).Count() != 0)
                    continue;

                if (!pair.Value.ContainsKey(type))
                {
                    PrintWarning($"GetSingleMultiplier :: Unable to find type of {type}");
                    return 0.0f;
                }
                if (!pair.Value[type].ContainsKey(name))
                {
                    PrintWarning($"GetSingleMultiplier :: Unable to find resource of {name} in type {type}. Adding to config and force saving. Assuming default value of 1.0");
                    config.GatherPerms[pair.Key][type].Add(name, 1f);
                    SaveConfig(config);
                }
                else
                {
                    if (pair.Value[type][name] > highestValue)
                        highestValue = pair.Value[type][name];
                }
            }

            return highestValue;
        }

        private void Unload()
        {
            SaveData();
        }

        private void OnQuarryGather(MiningQuarry quarry, Item item)
        {
            if (quarry == null) return;
            BasePlayer player = BasePlayer.FindByID(quarry.OwnerID);
            if (player == null) return;

            float resourceMult = -1;
            if (config.Stack)
                resourceMult = GetStackedMultiplier(player, "Quarry", item.info.name.Replace(".item", ""), false, quarry.transform.position);
            else
                resourceMult = GetSingleMultiplier(player, "Quarry", item.info.name.Replace(".item", ""), false, quarry.transform.position);

            if (resourceMult == -1) return;
            item.amount = (int)(item.amount * resourceMult);
        }

        private void OnCollectiblePickup(Item item, BasePlayer player)
        {
            float resourceMult = -1;
            if (config.Stack)
                resourceMult = GetStackedMultiplier(player, "Pickups", item.info.name.Replace(".item", ""));
            else
                resourceMult = GetSingleMultiplier(player, "Pickups", item.info.name.Replace(".item", ""));

            if (resourceMult == -1) return;
            item.amount = (int)(item.amount * resourceMult);
        }

        Dictionary<BaseEntity, BasePlayer> SurveyCharges = new Dictionary<BaseEntity, BasePlayer>();
        void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            if (!entity.name.ToLower().Contains("survey")) return;

            SurveyCharges.Add(entity, player);
        }

        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            float resourceMult = -1;
            if (config.Stack)
                resourceMult = GetStackedMultiplier(player, "Bonus", item.info.name.Replace(".item", ""));
            else
                resourceMult = GetSingleMultiplier(player, "Bonus", item.info.name.Replace(".item", ""));

            if (resourceMult == -1) return;
            item.amount = (int)(item.amount * resourceMult);
        }

        private void OnSurveyGather(SurveyCharge survey, Item item)
        {
            BasePlayer player = null;

            if (SurveyCharges.ContainsKey(survey))
                player = SurveyCharges[survey];

            if (player == null)
                return;

            SurveyCharges.Remove(survey);

            float resourceMult = -1;
            if (config.Stack)
                resourceMult = GetStackedMultiplier(player, "Survey", item.info.name.Replace(".item", ""), false, survey.transform.position);
            else
                resourceMult = GetSingleMultiplier(player, "Survey", item.info.name.Replace(".item", ""), false, survey.transform.position);

            if (resourceMult == -1) return;
            item.amount = (int)(item.amount * resourceMult);
        }

        private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity.ToPlayer();
            if (player == null) return;

            float resourceMult = -1;
            if (config.Stack)
                resourceMult = GetStackedMultiplier(player, "Dispenser", item.info.name.Replace(".item", ""));
            else
                resourceMult = GetSingleMultiplier(player, "Dispenser", item.info.name.Replace(".item", ""));

            if (resourceMult == -1) return;
            item.amount = (int)(item.amount * resourceMult);
        }
    }
}

// --- End of file: UGather.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/url-copy ---
// --- Original File Path: U/URLCopy/URLCopy.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("URL Copy", "PaiN", "0.1.0")]
    [Description("Gives a player a note with a set message.")]
    class URLCopy : RustPlugin
    {
        private Configuration config;
        const int NoteID = 1414245162;

        private Dictionary<string, float> cmdCD = new Dictionary<string, float>();

        private class Configuration
        {
            [JsonProperty("Command || Note Text")]
            public Dictionary<string, string> cmds = new Dictionary<string, string>
            {
                ["umod"] = "To copy the link, mark it with your mouse and then press Ctrl+C on your keyboard \n www.umod.org",
                ["discord"] = "To copy the link, mark it with your mouse and then press Ctrl+C on your keyboard \n DiscordLinkHere"
            };

            [JsonProperty("Command usage cooldown in seconds (0 = Disabled)")]
            public int cooldown = 60;

            [JsonProperty("Message SteamID icon")]
            public ulong chatId = 0;

        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            string configPath = $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Name}.json";
            PrintWarning($"Could not load a valid configuration file, creating a new configuration file at {configPath}");
            config = new Configuration();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        void Loaded()
        {
            foreach (var command in config.cmds.Keys)
                cmd.AddChatCommand(command, this, HandleNote);

            permission.RegisterPermission("urlcopy.use", this);
        }

        private void HandleNote(BasePlayer player, string cmd, string[] args)
        {
            if(!permission.UserHasPermission(player.UserIDString, "urlcopy.use"))
            {
                Player.Reply(player,
                    lang.GetMessage("NO_PERMISSION", this, player.UserIDString),
                    config.chatId);
                return;
            }

            if (OnCooldown(player))
            {
                Player.Reply(player,
                    string.Format(lang.GetMessage("CMD_COOLDOWN", this, player.UserIDString),
                    GetCooldown(player.UserIDString),
                    config.chatId));
                return;
            }

            Item note = ItemManager.CreateByItemID(NoteID);
            note.text = config.cmds.FirstOrDefault(x => x.Key == cmd).Value;

            if(!player.inventory.GiveItem(note))                
            {
                note.Remove();
                Player.Reply(player, lang.GetMessage("INVENTORY_FULL", this, player.UserIDString), config.chatId);
                return;
            }

            player.inventory.GiveItem(note);
            Player.Reply(player, lang.GetMessage("NOTE_RECEIVED", this, player.UserIDString), config.chatId);
            
            if (config.cooldown > 0)
            {
                cmdCD.Remove(player.UserIDString);
                cmdCD.Add(player.UserIDString, Time.realtimeSinceStartup);
            }
        }

        private bool OnCooldown(BasePlayer player)
        {
            if (config.cooldown == 0) return false;
            if(cmdCD.ContainsKey(player.UserIDString))
            {
                if ((Time.realtimeSinceStartup - cmdCD[player.UserIDString]) < config.cooldown)
                    return true;
            }
            return false;
        }

        private int GetCooldown(string userid) => (int)((config.cooldown + cmdCD[userid]) - Time.realtimeSinceStartup);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NOTE_RECEIVED"] = "You have received a note! Check your inventory.",
                ["INVENTORY_FULL"] = "You don't have enough space in your inventory!",
                ["NO_PERMISSION"] = "You do not have permission to use this command!",
                ["CMD_COOLDOWN"] = "You are on cooldown! {0}s remaining"
            }, this);
        }
    }
}

// --- End of file: URLCopy.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ui-notify ---
// --- Original File Path: U/UINotify/UINotify.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Oxide.Plugins.UINotifyExtensionMethods;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("UI Notify", "Mevent", "1.0.12")]
	[Description("Adds custom notifications for players")]
	public class UINotify : RustPlugin
	{
		#region Fields

		[PluginReference] private Plugin ImageLibrary = null;

		private const string Layer = "UI.Notify";

		private static UINotify _instance;

		private readonly Dictionary<ulong, NotifyComponent> _notifications =
			new Dictionary<ulong, NotifyComponent>();

		private class NotifyData
		{
			public string Message;

			public int Type;

			public readonly string Uid = CuiHelper.GetGuid();

			public float StartTime;
		}

		private const string
			PermSeeNotify = "uinotify.see",
			PermNotify = "uinotify.notify",
			PermPlayerNotify = "uinotify.player",
			PermAllPlayersNotify = "uinotify.allplayer";

		#endregion

		#region Config

		private static Configuration _config;

		private class Configuration
		{
			[JsonProperty(PropertyName = "Display type (Overlay/Hud)")]
			public string DisplayType = "Overlay";

			[JsonProperty(PropertyName = "Height")]
			public float Height = 50;

			[JsonProperty(PropertyName = "Width")] public float Width = 260;

			[JsonProperty(PropertyName = "X Margin")]
			public float XMargin = 20;

			[JsonProperty(PropertyName = "Y Margin")]
			public float YMargin = 5;

			[JsonProperty(PropertyName = "Y Indent")]
			public float ConstYSwitch = -50f;

			[JsonProperty(PropertyName = "Display notifications on the top right?")]
			public bool IsUpperRight = true;

			[JsonProperty(PropertyName = "Notify Cooldown")]
			public float Cooldown = 10f;

			[JsonProperty(PropertyName = "Max Notifications On Screen")]
			public int MaxNotificationsOnScreen = 10;

			[JsonProperty(PropertyName = "Send text message to chat if player doesn't have notification permission")]
			public bool SendTextMessageOnDontHavePermission = true;

			[JsonProperty(PropertyName = "Notifications (type - settings)",
				ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public Dictionary<int, NotifyType> Types = new Dictionary<int, NotifyType>
			{
				[0] = new NotifyType
				{
					Enabled = true,
					BackgroundImage = string.Empty,
					BackgroundColor = new IColor("#000000",
						98),
					EnableGradient = true,
					GradientColor = new IColor("#4B68FF",
						35),
					Sprite = "assets/content/ui/ui.background.transparent.linearltr.tga",
					Material = "Assets/Icons/IconMaterial.mat",
					IconColor = new IColor("#4B68FF",
						100),
					IconText = "!",
					TitleKey = "Notification",
					FadeIn = 0.1f,
					FadeOut = 1f,
					Effect = "assets/bundled/prefabs/fx/notice/item.select.fx.prefab",
					Image = new ImageSettings
					{
						AnchorMin = "0 0",
						AnchorMax = "0 0",
						OffsetMin = "12.5 12.5",
						OffsetMax = "37.5 37.5",
						Enabled = false,
						Image = string.Empty
					},
					UseCustomWidth = false,
					CustomWidth = 0,
					UseCustomHeight = false,
					CustomHeight = 0,
					UseCommand = false,
					Command = string.Empty,
					CloseAfterUsingCommand = false,
					IconSettings = new TextSettings
					{
						AnchorMin = "0 0.5",
						AnchorMax = "0 0.5",
						OffsetMin = "12.5 -12.5",
						OffsetMax = "37.5 12.5",
						FontSize = 12,
						IsBold = false,
						Align = TextAnchor.MiddleCenter,
						Color = new IColor("#FFFFFF",
							100),
					},
					TitleSettings = new TextSettings
					{
						AnchorMin = "0 0.5",
						AnchorMax = "1 1",
						OffsetMin = "47.5 0",
						OffsetMax = "0 0",
						FontSize = 12,
						IsBold = false,
						Align = TextAnchor.LowerLeft,
						Color = new IColor("#FFFFFF",
							50)
					},
					TextSettings = new TextSettings
					{
						AnchorMin = "0 0",
						AnchorMax = "1 0.5",
						OffsetMin = "47.5 0",
						OffsetMax = "0 0",
						FontSize = 10,
						IsBold = false,
						Align = TextAnchor.UpperLeft,
						Color = new IColor("#FFFFFF",
							100),
					},
					UseCustomCooldown = false,
					Cooldown = 0
				},
				[1] = new NotifyType
				{
					Enabled = true,
					BackgroundImage = string.Empty,
					BackgroundColor = new IColor("#000000", 98),
					EnableGradient = true,
					GradientColor = new IColor("#FF6060", 35),
					Sprite = "assets/content/ui/ui.background.transparent.linearltr.tga",
					Material = "Assets/Icons/IconMaterial.mat",
					IconColor = new IColor("#FF6060", 100),
					IconText = "X",
					TitleKey = "Error",
					FadeIn = 0.1f,
					FadeOut = 1f,
					Effect = "assets/bundled/prefabs/fx/notice/item.select.fx.prefab",
					Image = new ImageSettings
					{
						AnchorMin = "0 0", AnchorMax = "0 0",
						OffsetMin = "12.5 12.5",
						OffsetMax = "37.5 37.5",
						Enabled = false,
						Image = string.Empty
					},
					UseCustomWidth = false,
					CustomWidth = 0,
					UseCustomHeight = false,
					CustomHeight = 0,
					UseCommand = false,
					Command = string.Empty,
					CloseAfterUsingCommand = false,
					IconSettings = new TextSettings
					{
						AnchorMin = "0 0.5",
						AnchorMax = "0 0.5",
						OffsetMin = "12.5 -12.5",
						OffsetMax = "37.5 12.5",
						FontSize = 12,
						IsBold = false,
						Align = TextAnchor.MiddleCenter,
						Color = new IColor("#4B68FF", 100),
					},
					TitleSettings = new TextSettings
					{
						AnchorMin = "0 0.5",
						AnchorMax = "1 1",
						OffsetMin = "47.5 0",
						OffsetMax = "0 0",
						FontSize = 12,
						IsBold = false,
						Align = TextAnchor.LowerLeft,
						Color = new IColor("#FFFFFF", 50)
					},
					TextSettings = new TextSettings
					{
						AnchorMin = "0 0",
						AnchorMax = "1 0.5",
						OffsetMin = "47.5 0",
						OffsetMax = "0 0",
						FontSize = 10,
						IsBold = false,
						Align = TextAnchor.UpperLeft,
						Color = new IColor("#FFFFFF", 100),
					},
					UseCustomCooldown = false,
					Cooldown = 0
				},
				[2130354] = new NotifyType
				{
					Enabled = true,
					BackgroundImage = "https://i.ibb.co/x1npBZr/image.png",
					BackgroundColor = new IColor("#FFFFFF", 100),
					EnableGradient = false,
					GradientColor = new IColor("#202224", 80),
					Sprite = string.Empty,
					Material = string.Empty,
					IconColor = new IColor("#EF5125", 100),
					IconText = "!",
					TitleKey = "AwardAvailable",
					FadeIn = 0.1f,
					FadeOut = 1f,
					Effect = "assets/bundled/prefabs/fx/notice/item.select.fx.prefab",
					Image = new ImageSettings
					{
						AnchorMin = "0 0.5",
						AnchorMax = "0 0.5",
						OffsetMin = "12.5 -16",
						OffsetMax = "44.5 16",
						Enabled = true,
						Image = "https://i.ibb.co/xLsSknw/image.png"
					},
					UseCustomWidth = true,
					CustomWidth = 280,
					UseCustomHeight = true,
					CustomHeight = 60,
					UseCommand = true,
					Command = "daily",
					CloseAfterUsingCommand = true,
					IconSettings = new TextSettings
					{
						AnchorMin = "0 0.5",
						AnchorMax = "0 0.5",
						OffsetMin = "12.5 -16",
						OffsetMax = "44.5 16",
						FontSize = 16,
						IsBold = false,
						Align = TextAnchor.MiddleCenter,
						Color = new IColor("#FFFFFF", 100),
					},
					TitleSettings = new TextSettings
					{
						AnchorMin = "0 0.5",
						AnchorMax = "1 1",
						OffsetMin = "47.5 0",
						OffsetMax = "-20 0",
						FontSize = 18,
						IsBold = true,
						Align = TextAnchor.LowerRight,
						Color = new IColor("#DCDCDC", 50)
					},
					TextSettings = new TextSettings
					{
						AnchorMin = "0 0",
						AnchorMax = "1 0.5",
						OffsetMin = "47.5 0",
						OffsetMax = "-20 0",
						FontSize = 14,
						IsBold = true,
						Align = TextAnchor.UpperRight,
						Color = new IColor("#DCDCDC", 100),
					},
					UseCustomCooldown = true,
					Cooldown = 60
				},
				[2130355] = new NotifyType
				{
					Enabled = true,
					BackgroundImage = "https://i.ibb.co/x1npBZr/image.png",
					BackgroundColor = new IColor("#FFFFFF", 100),
					EnableGradient = false,
					GradientColor = new IColor("#202224", 80),
					Sprite = string.Empty,
					Material = string.Empty,
					IconColor = new IColor("#EF5125", 100),
					IconText = "!",
					TitleKey = "AwardCooldown",
					FadeIn = 0.1f,
					FadeOut = 1f,
					Effect = "assets/bundled/prefabs/fx/notice/item.select.fx.prefab",
					Image = new ImageSettings
					{
						AnchorMin = "0 0.5", AnchorMax = "0 0.5",
						OffsetMin = "12.5 -12.5",
						OffsetMax = "37.5 12.5",
						Enabled = false,
						Image = string.Empty
					},
					UseCustomWidth = true,
					CustomWidth = 280,
					UseCustomHeight = true,
					CustomHeight = 60,
					UseCommand = true,
					Command = "daily",
					CloseAfterUsingCommand = true,
					IconSettings = new TextSettings
					{
						AnchorMin = "0 0.5",
						AnchorMax = "0 0.5",
						OffsetMin = "12.5 -16",
						OffsetMax = "44.5 16",
						FontSize = 16,
						IsBold = false,
						Align = TextAnchor.MiddleCenter,
						Color = new IColor("#FFFFFF", 100),
					},
					TitleSettings = new TextSettings
					{
						AnchorMin = "0 0.5",
						AnchorMax = "1 1",
						OffsetMin = "47.5 0",
						OffsetMax = "-20 0",
						FontSize = 18,
						IsBold = true,
						Align = TextAnchor.LowerRight,
						Color = new IColor("#DCDCDC", 100)
					},
					TextSettings = new TextSettings
					{
						AnchorMin = "0 0",
						AnchorMax = "1 0.5",
						OffsetMin = "47.5 0",
						OffsetMax = "-20 0",
						FontSize = 14,
						IsBold = true,
						Align = TextAnchor.UpperRight,
						Color = new IColor("#DCDCDC", 100)
					},
					UseCustomCooldown = true,
					Cooldown = 0.9f
				},
				[2130356] = new NotifyType
				{
					Enabled = true,
					BackgroundImage = "https://i.ibb.co/x1npBZr/image.png",
					BackgroundColor = new IColor("#FFFFFF", 100),
					EnableGradient = false,
					GradientColor = new IColor("#202224", 80),
					Sprite = string.Empty,
					Material = string.Empty,
					IconColor = new IColor("#EF5125", 100),
					IconText = "!",
					TitleKey = "AwardReceived",
					FadeIn = 0.1f,
					FadeOut = 1f,
					Effect = "assets/bundled/prefabs/fx/notice/item.select.fx.prefab",
					Image = new ImageSettings
					{
						AnchorMin = "0 0.5", AnchorMax = "0 0.5",
						OffsetMin = "12.5 -12.5",
						OffsetMax = "37.5 12.5",
						Enabled = false,
						Image = string.Empty
					},
					UseCustomWidth = true,
					CustomWidth = 280,
					UseCustomHeight = true,
					CustomHeight = 60,
					UseCommand = true,
					Command = "daily",
					CloseAfterUsingCommand = true,
					IconSettings = new TextSettings
					{
						AnchorMin = "0 0.5",
						AnchorMax = "0 0.5",
						OffsetMin = "12.5 -16",
						OffsetMax = "44.5 16",
						FontSize = 16,
						IsBold = false,
						Align = TextAnchor.MiddleCenter,
						Color = new IColor("#FFFFFF", 100),
					},
					TitleSettings = new TextSettings
					{
						AnchorMin = "0 0.5",
						AnchorMax = "1 1",
						OffsetMin = "47.5 0",
						OffsetMax = "-20 0",
						FontSize = 18,
						IsBold = true,
						Align = TextAnchor.LowerRight,
						Color = new IColor("#DCDCDC", 100)
					},
					TextSettings = new TextSettings
					{
						AnchorMin = "0 0",
						AnchorMax = "1 0.5",
						OffsetMin = "47.5 0",
						OffsetMax = "-20 0",
						FontSize = 14,
						IsBold = true,
						Align = TextAnchor.UpperRight,
						Color = new IColor("#DCDCDC", 100)
					},
					UseCustomCooldown = true,
					Cooldown = 60
				}
			};

			public VersionNumber Version;
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				_config = Config.ReadObject<Configuration>();
				if (_config == null) throw new Exception();

				if (_config.Version < Version)
					UpdateConfigValues();

				SaveConfig();
			}
			catch
			{
				PrintError("Your configuration file contains an error. Using default configuration values.");
				LoadDefaultConfig();
			}
		}

		private void UpdateConfigValues()
		{
			if (_config.Version == default(VersionNumber) || _config.Version < new VersionNumber(1, 0, 9))
			{
				var baseConfig = new Configuration();

				var maxNotificationsOnScreen = Config.Get("Max Notifications On Screen");
				if (maxNotificationsOnScreen == null)
				{
					_config.MaxNotificationsOnScreen = baseConfig.MaxNotificationsOnScreen;

					_config.SendTextMessageOnDontHavePermission = baseConfig.SendTextMessageOnDontHavePermission;

					foreach (var notifyType in _config.Types)
					{
						switch (notifyType.Key)
						{
							default:
							{
								NotifyType newNotify;
								if (baseConfig.Types.TryGetValue(notifyType.Key, out newNotify))
								{
									notifyType.Value.Enabled = newNotify.Enabled;
									notifyType.Value.BackgroundImage = newNotify.BackgroundImage;
									notifyType.Value.CloseAfterUsingCommand = newNotify.CloseAfterUsingCommand;
									notifyType.Value.Command = newNotify.Command;
									notifyType.Value.CustomHeight = newNotify.CustomHeight;
									notifyType.Value.CustomWidth = newNotify.CustomWidth;
									notifyType.Value.IconSettings = newNotify.IconSettings;
									notifyType.Value.TextSettings = newNotify.TextSettings;
									notifyType.Value.TitleSettings = newNotify.TitleSettings;
									notifyType.Value.UseCommand = newNotify.UseCommand;
									notifyType.Value.UseCustomCooldown = newNotify.UseCustomCooldown;
									notifyType.Value.UseCustomHeight = newNotify.UseCustomHeight;
									notifyType.Value.UseCustomWidth = newNotify.UseCustomWidth;

									var oldTitleColor = Config.Get<IColor>("Notifications (type - settings)",
										notifyType.Key.ToString(), "Title Color");
									if (oldTitleColor != null)
										notifyType.Value.TitleSettings.Color = oldTitleColor;

									var oldTextColor = Config.Get<IColor>("Notifications (type - settings)",
										notifyType.Key.ToString(), "Text Color");
									if (oldTitleColor != null)
										notifyType.Value.TextSettings.Color = oldTextColor;

									var oldIconTextColor = Config.Get<IColor>("Notifications (type - settings)",
										notifyType.Key.ToString(), "Icon Text Color");
									if (oldIconTextColor != null)
										notifyType.Value.IconColor = oldIconTextColor;
								}

								break;
							}
						}
					}

					NotifyType dailyRewardsNotify;
					if (baseConfig.Types.TryGetValue(2130354, out dailyRewardsNotify))
						_config.Types.TryAdd(2130354, dailyRewardsNotify);

					if (baseConfig.Types.TryGetValue(2130355, out dailyRewardsNotify))
						_config.Types.TryAdd(2130355, dailyRewardsNotify);
				}

				PrintWarning("Config update detected! Updating config values...");
			}

			if (_config.Version != default(VersionNumber))
			{
				if (_config.Version < new VersionNumber(1, 0, 11))
				{
					var enableNewNotify = _config.Types.ContainsKey(2130354) && _config.Types[2130354].Enabled &&
					                      _config.Types.ContainsKey(2130355) && _config.Types[2130355].Enabled;

					_config.Types.TryAdd(2130356, new NotifyType
					{
						Enabled = enableNewNotify,
						BackgroundImage = "https://i.ibb.co/x1npBZr/image.png",
						BackgroundColor = new IColor("#FFFFFF", 100),
						EnableGradient = false,
						GradientColor = new IColor("#202224", 80),
						Sprite = string.Empty,
						Material = string.Empty,
						IconColor = new IColor("#EF5125", 100),
						IconText = "!",
						TitleKey = "AwardReceived",
						FadeIn = 0.1f,
						FadeOut = 1f,
						Effect = "assets/bundled/prefabs/fx/notice/item.select.fx.prefab",
						Image = new ImageSettings
						{
							AnchorMin = "0 0.5", AnchorMax = "0 0.5",
							OffsetMin = "12.5 -12.5",
							OffsetMax = "37.5 12.5",
							Enabled = false,
							Image = string.Empty
						},
						UseCustomWidth = true,
						CustomWidth = 280,
						UseCustomHeight = true,
						CustomHeight = 60,
						UseCommand = true,
						Command = "daily",
						CloseAfterUsingCommand = true,
						IconSettings = new TextSettings
						{
							AnchorMin = "0 0.5",
							AnchorMax = "0 0.5",
							OffsetMin = "12.5 -16",
							OffsetMax = "44.5 16",
							FontSize = 16,
							IsBold = false,
							Align = TextAnchor.MiddleCenter,
							Color = new IColor("#FFFFFF", 100),
						},
						TitleSettings = new TextSettings
						{
							AnchorMin = "0 0.5",
							AnchorMax = "1 1",
							OffsetMin = "47.5 0",
							OffsetMax = "-20 0",
							FontSize = 18,
							IsBold = true,
							Align = TextAnchor.LowerRight,
							Color = new IColor("#DCDCDC", 100)
						},
						TextSettings = new TextSettings
						{
							AnchorMin = "0 0",
							AnchorMax = "1 0.5",
							OffsetMin = "47.5 0",
							OffsetMax = "-20 0",
							FontSize = 14,
							IsBold = true,
							Align = TextAnchor.UpperRight,
							Color = new IColor("#DCDCDC", 100)
						},
						UseCustomCooldown = true,
						Cooldown = 60
					});
				}
			}

			_config.Version = Version;
			PrintWarning("Config update completed!");
		}

		private class TextSettings : InterfacePosition
		{
			[JsonProperty(PropertyName = "fontSize")]
			public int FontSize;

			[JsonProperty(PropertyName = "Is Bold?")]
			public bool IsBold;

			[JsonProperty(PropertyName = "Align")] [JsonConverter(typeof(StringEnumConverter))]
			public TextAnchor Align;

			[JsonProperty(PropertyName = "Color")] public IColor Color;
		}

		private class NotifyType
		{
			#region Fields

			[JsonProperty(PropertyName = "Enabled")]
			public bool Enabled;

			[JsonProperty(PropertyName = "Background Image")]
			public string BackgroundImage;

			[JsonProperty(PropertyName = "Background Color")]
			public IColor BackgroundColor;

			[JsonProperty(PropertyName = "Enable Gradient?")]
			public bool EnableGradient;

			[JsonProperty(PropertyName = "Gradient Color")]
			public IColor GradientColor;

			[JsonProperty(PropertyName = "Sprite")]
			public string Sprite;

			[JsonProperty(PropertyName = "Material")]
			public string Material;

			[JsonProperty(PropertyName = "Icon Color")]
			public IColor IconColor;

			[JsonProperty(PropertyName = "Icon Text")]
			public string IconText;

			[JsonProperty(PropertyName = "Title Key (lang)")]
			public string TitleKey;

			[JsonProperty(PropertyName = "Fade Out")]
			public float FadeOut;

			[JsonProperty(PropertyName = "Fade In")]
			public float FadeIn;

			[JsonProperty(PropertyName = "Sound Effect (empty - disable)")]
			public string Effect;

			[JsonProperty(PropertyName = "Image Settings")]
			public ImageSettings Image;

			[JsonProperty(PropertyName = "Use custom width")]
			public bool UseCustomWidth;

			[JsonProperty(PropertyName = "Custom width")]
			public float CustomWidth;

			[JsonProperty(PropertyName = "Use custom height")]
			public bool UseCustomHeight;

			[JsonProperty(PropertyName = "Custom height")]
			public float CustomHeight;

			[JsonProperty(PropertyName = "Use command")]
			public bool UseCommand;

			[JsonProperty(PropertyName = "Command")]
			public string Command;

			[JsonProperty(PropertyName = "Close after using the command?")]
			public bool CloseAfterUsingCommand;

			[JsonProperty(PropertyName = "Icon Settings")]
			public TextSettings IconSettings;

			[JsonProperty(PropertyName = "Title Settings")]
			public TextSettings TitleSettings;

			[JsonProperty(PropertyName = "Text Settings")]
			public TextSettings TextSettings;

			[JsonProperty(PropertyName = "Use cus