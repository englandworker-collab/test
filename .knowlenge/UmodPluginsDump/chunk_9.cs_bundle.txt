tom cooldown")]
			public bool UseCustomCooldown;

			[JsonProperty(PropertyName = "Cooldown")]
			public float Cooldown;

			#endregion

			public float Get(BasePlayer player,
				ref CuiElementContainer container,
				NotifyData data,
				float ySwitch)
			{
				var width = UseCustomWidth ? CustomWidth : _config.Width;
				var height = UseCustomHeight ? CustomHeight : _config.Height;

				var layer = BackgroundUI(ref container, data.Uid, ySwitch, width, height);

				if (EnableGradient)
					GradientUI(ref container, layer);

				IconUI(ref container, layer);

				TitleUI(player, ref container, layer);

				MessageUI(ref container, data.Message, layer);

				if (UseCommand) ButtonUI(ref container, layer, CloseAfterUsingCommand ? layer : string.Empty);

				return height;
			}

			#region UI.Components

			private void ButtonUI(ref CuiElementContainer container,
				string parent, string closeLayer)
			{
				var button = new CuiButtonComponent
				{
					Color = "0 0 0 0",
					Command = Command
				};

				if (!string.IsNullOrEmpty(closeLayer))
					button.Close = closeLayer;

				container.Add(new CuiElement
				{
					Parent = parent,
					Components =
					{
						button,
						new CuiRectTransformComponent()
					}
				});
			}

			private void MessageUI(ref CuiElementContainer container, string message, string parent)
			{
				container.Add(new CuiLabel
				{
					RectTransform =
					{
						AnchorMin = TextSettings.AnchorMin,
						AnchorMax = TextSettings.AnchorMax,
						OffsetMin = TextSettings.OffsetMin,
						OffsetMax = TextSettings.OffsetMax
					},
					Text =
					{
						Text = $"{message}",
						Align = TextSettings.Align,
						Font = TextSettings.IsBold ? "robotocondensed-bold.ttf" : "robotocondensed-regular.ttf",
						FontSize = TextSettings.FontSize,
						Color = TextSettings.Color.Get(),
						FadeIn = FadeIn
					},
					FadeOut = FadeOut
				}, parent);
			}

			private void TitleUI(BasePlayer player, ref CuiElementContainer container, string parent)
			{
				container.Add(new CuiLabel
				{
					RectTransform =
					{
						AnchorMin = TitleSettings.AnchorMin,
						AnchorMax = TitleSettings.AnchorMax,
						OffsetMin = TitleSettings.OffsetMin,
						OffsetMax = TitleSettings.OffsetMax
					},
					Text =
					{
						Text = _instance.Msg(player, TitleKey),
						Align = TitleSettings.Align,
						Font = TitleSettings.IsBold ? "robotocondensed-bold.ttf" : "robotocondensed-regular.ttf",
						FontSize = TitleSettings.FontSize,
						Color = TitleSettings.Color.Get(),
						FadeIn = FadeIn
					},
					FadeOut = FadeOut
				}, parent);
			}

			private void IconUI(ref CuiElementContainer container, string parent)
			{
				if (Image?.Enabled == true && !string.IsNullOrEmpty(Image.Image))
				{
					container.Add(new CuiElement
					{
						Name = parent + ".Icon",
						Parent = parent,
						Components =
						{
							new CuiRawImageComponent
							{
								Png = _instance.ImageLibrary.Call<string>("GetImage", Image.Image)
							},
							new CuiRectTransformComponent
							{
								AnchorMin = Image.AnchorMin,
								AnchorMax = Image.AnchorMax,
								OffsetMin = Image.OffsetMin,
								OffsetMax = Image.OffsetMax
							}
						}
					});
				}
				else
				{
					container.Add(new CuiPanel
					{
						RectTransform =
						{
							AnchorMin = IconSettings.AnchorMin,
							AnchorMax = IconSettings.AnchorMax,
							OffsetMin = IconSettings.OffsetMin,
							OffsetMax = IconSettings.OffsetMax
						},
						Image =
						{
							Color = IconColor.Get(),
							FadeIn = FadeIn
						},
						FadeOut = FadeOut
					}, parent, parent + ".Icon");

					container.Add(new CuiLabel
					{
						RectTransform =
						{
							AnchorMin = "0 0", AnchorMax = "1 1"
						},
						Text =
						{
							Text = $"{IconText}",
							Align = IconSettings.Align,
							Font = IconSettings.IsBold ? "robotocondensed-bold.ttf" : "robotocondensed-regular.ttf",
							FontSize = IconSettings.FontSize,
							Color = IconSettings.Color.Get(),
							FadeIn = FadeIn
						},
						FadeOut = FadeOut
					}, parent + ".Icon");
				}
			}

			private void GradientUI(ref CuiElementContainer container, string parent)
			{
				container.Add(new CuiPanel
				{
					RectTransform =
					{
						AnchorMin = "0 0", AnchorMax = "1 1"
					},
					Image =
					{
						Color = GradientColor.Get(),
						Sprite = Sprite,
						Material = Material,
						FadeIn = FadeIn
					},
					FadeOut = FadeOut
				}, parent);
			}

			private string BackgroundUI(ref CuiElementContainer container, string uid,
				float ySwitch,
				float width,
				float height)
			{
				var name = Layer + $".Notify.{uid}";

				if (!string.IsNullOrEmpty(BackgroundImage))
				{
					container.Add(new CuiElement
					{
						Name = name,
						Parent = Layer,
						DestroyUi = name,
						Components =
						{
							new CuiRawImageComponent
							{
								Png = _instance.ImageLibrary.Call<string>("GetImage", BackgroundImage),
								Color = BackgroundColor.Get(),
								FadeIn = FadeIn
							},
							new CuiRectTransformComponent
							{
								AnchorMin = _config.IsUpperRight ? "1 1" : "0 0",
								AnchorMax = _config.IsUpperRight ? "1 1" : "0 0",
								OffsetMin = _config.IsUpperRight
									? $"{-width - _config.XMargin} {ySwitch - height}"
									: $"{_config.XMargin} {ySwitch - height}",
								OffsetMax = _config.IsUpperRight
									? $"{-_config.XMargin} {ySwitch}"
									: $"{_config.XMargin + width} {ySwitch}"
							}
						}
					});
				}
				else
				{
					container.Add(new CuiPanel
					{
						RectTransform =
						{
							AnchorMin = _config.IsUpperRight ? "1 1" : "0 0",
							AnchorMax = _config.IsUpperRight ? "1 1" : "0 0",
							OffsetMin = _config.IsUpperRight
								? $"{-width - _config.XMargin} {ySwitch - height}"
								: $"{_config.XMargin} {ySwitch - height}",
							OffsetMax = _config.IsUpperRight
								? $"{-_config.XMargin} {ySwitch}"
								: $"{_config.XMargin + width} {ySwitch}"
						},
						Image =
						{
							Color = BackgroundColor.Get(),
							FadeIn = FadeIn
						},
						FadeOut = FadeOut
					}, Layer, name, name);
				}

				return name;
			}

			#endregion
		}

		private class InterfacePosition
		{
			public string AnchorMin;

			public string AnchorMax;

			public string OffsetMin;

			public string OffsetMax;
		}

		private class ImageSettings : InterfacePosition
		{
			[JsonProperty(PropertyName = "Enabled")]
			public bool Enabled;

			[JsonProperty(PropertyName = "Image")] public string Image;
		}

		private class IColor
		{
			[JsonProperty(PropertyName = "HEX")] public string Hex;

			[JsonProperty(PropertyName = "Opacity (0 - 100)")]
			public float Alpha;

			public string Get()
			{
				if (string.IsNullOrEmpty(Hex)) Hex = "#FFFFFF";

				var str = Hex.Trim('#');
				if (str.Length != 6) throw new Exception(Hex);
				var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
				var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
				var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);

				return $"{(double) r / 255} {(double) g / 255} {(double) b / 255} {Alpha / 100}";
			}

			public IColor(string hex, float alpha)
			{
				Hex = hex;
				Alpha = alpha;
			}
		}

		protected override void SaveConfig()
		{
			Config.WriteObject(_config);
		}

		protected override void LoadDefaultConfig()
		{
			_config = new Configuration();
		}

		#endregion

		#region Hooks

		private void OnServerInitialized()
		{
			_instance = this;

			LoadImages();

			RegisterPermissions();

			RegisterCommands();
		}

		private void Unload()
		{
			_notifications.Values.ToList().ForEach(notify =>
			{
				if (notify != null)
					notify.Kill();
			});

			foreach (var player in BasePlayer.activePlayerList)
				CuiHelper.DestroyUi(player, Layer);

			_instance = null;
			_config = null;
		}

		#endregion

		#region Commands

		private void CmdShowNotify(IPlayer cov, string command, string[] args)
		{
			if (!cov.IsServer && !cov.HasPermission(PermNotify)) return;

			var player = cov.Object as BasePlayer;
			if (player == null) return;

			int type;
			if (args.Length < 2 || !int.TryParse(args[0], out type))
			{
				cov.Reply(Msg(cov.Id, SyntaxNotify, command));
				return;
			}

			var message = string.Join(" ", args.Skip(1));
			if (string.IsNullOrEmpty(message)) return;

			SendNotify(player, type, message);
		}

		private void CmdShowPlayerNotify(IPlayer cov, string command, string[] args)
		{
			if (!cov.IsServer && !cov.HasPermission(PermPlayerNotify)) return;

			int type;
			if (args.Length < 3 || !int.TryParse(args[1], out type))
			{
				cov.Reply(Msg(cov.Id, SyntaxPlayerNotify, command));
				return;
			}

			var target = covalence.Players.FindPlayer(args[0])?.Object as BasePlayer;
			if (target == null)
			{
				cov.Reply(Msg(cov.Id, NotFound, args[0]));
				return;
			}

			var message = string.Join(" ", args.Skip(2));
			if (string.IsNullOrEmpty(message)) return;

			SendNotify(target, type, message);
		}

		private void CmdShowAllPlayerNotify(IPlayer cov, string command, string[] args)
		{
			if (!cov.IsServer && !cov.HasPermission(PermAllPlayersNotify)) return;

			int type;
			if (args.Length < 2 || !int.TryParse(args[0], out type))
			{
				cov.Reply(Msg(cov.Id, SyntaxAllPlayerNotify, command));
				return;
			}

			var message = string.Join(" ", args.Skip(1));
			if (string.IsNullOrEmpty(message)) return;

			SendNotifyAllPlayers(type, message);
		}

		#endregion

		#region Component

		private class NotifyComponent : FacepunchBehaviour
		{
			#region Fields

			private BasePlayer _player;

			private readonly List<NotifyData> _notifies = new List<NotifyData>();

			private CuiElementContainer container = new CuiElementContainer();

			#endregion

			#region Main

			private void Awake()
			{
				_player = GetComponent<BasePlayer>();

				_instance._notifications[_player.userID] = this;

				Invoke(NotificationsController, 1);
			}

			private void OnDestroy()
			{
				CancelInvoke();

				if (_player != null)
				{
					CuiHelper.DestroyUi(_player, Layer);

					_instance?._notifications.Remove(_player.userID);
				}
			}

			public void Kill()
			{
				DestroyImmediate(this);
			}

			#endregion

			#region Utils

			private void MainUi()
			{
				var ySwitch = _config.ConstYSwitch;

				container.Clear();

				container.Add(new CuiPanel
				{
					RectTransform = {AnchorMin = "0 1", AnchorMax = "1 1"},
					Image = {Color = "0 0 0 0"}
				}, _config.DisplayType, Layer, Layer);

				_notifies.Take(_config.MaxNotificationsOnScreen).ForEach(notify =>
				{
					var height = NotifyUi(ref container, notify, ySwitch);

					ySwitch = ySwitch - height - _config.YMargin;
				});

				CuiHelper.AddUi(_player, container);
			}

			private float NotifyUi(ref CuiElementContainer cont, NotifyData data, float ySwitch)
			{
				return _config.Types[data.Type]?.Get(_player, ref cont, data, ySwitch) ?? 0f;
			}

			public void AddNotify(NotifyData data)
			{
				NotifyType notifyType;
				if (!_config.Types.TryGetValue(data.Type, out notifyType) ||
				    notifyType == null ||
				    notifyType.Enabled == false) return;

				_notifies.Add(data);

				if (_notifies.Count == 1)
					_notifies[0].StartTime = Time.time;

				MainUi();

				if (!string.IsNullOrEmpty(notifyType.Effect))
					SendEffect(notifyType.Effect);
			}

			private void RemoveNotify(int index = 0)
			{
				_notifies.RemoveAt(index);

				if (_notifies.Count == 0)
				{
					Kill();
					return;
				}

				_notifies[0].StartTime = Time.time;

				MainUi();
			}

			private void NotificationsController()
			{
				CancelInvoke(NotificationsController);
				if (_notifies.Count == 0)
				{
					Kill();
					return;
				}

				var notify = _notifies[0];

				var cooldown = _config.Types[notify.Type].UseCustomCooldown
					? _config.Types[notify.Type].Cooldown
					: _config.Cooldown;

				if (Time.time - notify.StartTime >= cooldown)
					RemoveNotify();

				Invoke(NotificationsController, 1);
			}

			private void SendEffect(string effect)
			{
				EffectNetwork.Send(new Effect(effect, _player, 0, new Vector3(), new Vector3()), _player.Connection);
			}

			#endregion
		}

		#endregion

		#region Utils

		private void LoadImages()
		{
			if (ImageLibrary == null || !ImageLibrary.IsLoaded)
			{
				PrintError("IMAGE LIBRARY IS NOT INSTALLED!");
			}
			else
			{
				var imagesList = new Dictionary<string, string>();

				foreach (var notifyType in _config.Types.Values)
				{
					if (!string.IsNullOrEmpty(notifyType.BackgroundImage))
						imagesList.TryAdd(notifyType.BackgroundImage, notifyType.BackgroundImage);

					if (notifyType.Image?.Enabled == true && !string.IsNullOrEmpty(notifyType.Image.Image))
						imagesList.TryAdd(notifyType.Image.Image, notifyType.Image.Image);
				}

				ImageLibrary?.Call("ImportImageList", Title, imagesList, 0UL, true);
			}
		}

		private void RegisterCommands()
		{
			AddCovalenceCommand("uinotify.show", nameof(CmdShowNotify));

			AddCovalenceCommand("uinotify.player", nameof(CmdShowPlayerNotify));

			AddCovalenceCommand("uinotify.allplayers", nameof(CmdShowAllPlayerNotify));
		}

		private void RegisterPermissions()
		{
			permission.RegisterPermission(PermSeeNotify, this);
			permission.RegisterPermission(PermNotify, this);
			permission.RegisterPermission(PermPlayerNotify, this);
			permission.RegisterPermission(PermAllPlayersNotify, this);
		}

		#endregion

		#region API

		private void SendNotifyAllPlayers(int type, string message)
		{
			foreach (var player in BasePlayer.activePlayerList)
				SendNotify(player, type, message);
		}

		private void SendNotify(string userId, int type, string message)
		{
			SendNotify(BasePlayer.FindByID(ulong.Parse(userId)), type, message);
		}

		private void SendNotify(ulong userId, int type, string message)
		{
			SendNotify(BasePlayer.FindByID(userId), type, message);
		}

		private void SendNotify(BasePlayer player, int type, string message)
		{
			if (player == null) return;

			if (!permission.UserHasPermission(player.UserIDString, PermSeeNotify))
			{
				if (_config.SendTextMessageOnDontHavePermission)
					player.ChatMessage(message);
				return;
			}

			var notify = GetComponent(player);
			if (notify == null) return;

			var data = new NotifyData
			{
				Type = type,
				Message = message
			};

			notify.AddNotify(data);
		}

		private NotifyComponent GetComponent(BasePlayer player)
		{
			NotifyComponent component;
			return _notifications.TryGetValue(player.userID, out component)
				? component
				: player.gameObject.AddComponent<NotifyComponent>();
		}

		#endregion

		#region API

		private bool TryToggleType(int type, bool newValue)
		{
			NotifyType notifyNotifyType;
			if (!_config.Types.TryGetValue(type, out notifyNotifyType) || notifyNotifyType.Enabled == newValue)
				return false;

			notifyNotifyType.Enabled = newValue;
			SaveConfig();
			return true;
		}

		#endregion

		#region Lang

		private const string
			NotFound = "NotFound",
			SyntaxAllPlayerNotify = "SyntaxAllPlayerNotify",
			SyntaxPlayerNotify = "SyntaxPlayerNotify",
			SyntaxNotify = "SyntaxNotify";

		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["Notification"] = "Notification",
				["Error"] = "Error",
				["AwardAvailable"] = "NEW AWARD AVAILABLE!",
				["AwardCooldown"] = "AWARD WILL BE AVAILABLE",
				["AwardReceived"] = "REWARD RECEIVED",
				[SyntaxNotify] = "Error syntax! Use: /{0} [type] [message]",
				[SyntaxPlayerNotify] = "Error syntax! Use: /{0} [steamid] [type] [message]",
				[SyntaxAllPlayerNotify] = "Error syntax! Use: /{0} [type] [message]",
				[NotFound] = "Player '{0}' not found!"
			}, this);

			lang.RegisterMessages(new Dictionary<string, string>
			{
				["Notification"] = "Оповещение",
				["Error"] = "Ошибка",
				["AwardAvailable"] = "ДОСТУПНА НОВАЯ НАГРАДА!",
				["AwardCooldown"] = "НАГРАДА БУДЕТ ДОСТУПНА",
				["AwardReceived"] = "НАГРАДА ПОЛУЧЕНА",
				[SyntaxNotify] = "Ошибка синтаксиса! Используйте: /{0} [type] [message]",
				[SyntaxPlayerNotify] = "Ошибка синтаксиса! Используйте: /{0} [steamid] [type] [message]",
				[SyntaxAllPlayerNotify] = "Ошибка синтаксиса! Используйте: /{0} [type] [message]",
				[NotFound] = "Игрок '{0}' не найден!"
			}, this, "ru");
		}

		private string Msg(BasePlayer player, string key, params object[] obj)
		{
			return string.Format(lang.GetMessage(key, this, player.UserIDString), obj);
		}

		private string Msg(string player, string key, params object[] obj)
		{
			return string.Format(lang.GetMessage(key, this, player), obj);
		}

		#endregion
	}
}

#region Extension Methods

namespace Oxide.Plugins.UINotifyExtensionMethods
{
	// ReSharper disable ForCanBeConvertedToForeach
	// ReSharper disable LoopCanBeConvertedToQuery
	public static class ExtensionMethods
	{
		public static List<T> Take<T>(this List<T> source, int count)
		{
			return source.GetRange(0, Mathf.Min(count, source.Count));
		}
	}
}

#endregion Extension Methods

// --- End of file: UINotify.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/upgrade-workbenches ---
// --- Original File Path: U/UpgradeWorkbenches/UpgradeWorkbenches.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("UpgradeWorkbenches", "MJSU", "2.1.3")]
    [Description("Lets players upgrade workbenches")]
    public class UpgradeWorkbenches : RustPlugin
    {
        #region Class Fields
        private PluginConfig _pluginConfig; //Plugin Config
        
        private readonly List<int> _workbenchItemIds = new List<int>();

        private const string UpgradePermission = "upgradeworkbenches.upgrade";
        private const string DowngradePermission = "upgradeworkbenches.downgrade";
        private const string RefundPermission = "upgradeworkbenches.refund";
        private const string AccentColor = "#de8732";
        #endregion

        #region Setup & Loading
        private void Init()
        {
            permission.RegisterPermission(UpgradePermission, this);
            permission.RegisterPermission(DowngradePermission, this);
            permission.RegisterPermission(RefundPermission, this);

            if (!_pluginConfig.DisplayPlacementMessage)
            {
                Unsubscribe(nameof(OnEntityBuilt));
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Chat] = $"<color=#bebebe>[<color={AccentColor}>{Title}</color>] {{0}}</color>",
                [LangKeys.InfoMessage] = $"Workbenches can be upgraded!\nTo upgrade type <color={AccentColor}>/{{0}}</color> while looking at a workbench and drag a workbench item into the workbench's inventory!",
                [LangKeys.UpgradeNotAllowed] = "You're not allowed to upgrade the workbench",
                [LangKeys.DowngradeNotAllow] = "You're not allowed to downgrade the workbench",
                [LangKeys.NotAllowed] = "You do not have permission to use this command",
                [LangKeys.NotLookingAt] = "You're not looking at a workbench",
                [LangKeys.ChatCommand] = "wbu",
            }, this);
        }
        
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }

        public PluginConfig AdditionalConfig(PluginConfig config)
        {
            return config;
        }

        private void OnServerInitialized()
        {
            List<string> commands = Pool.GetList<string>();
            foreach (string language in lang.GetLanguages())
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                if (messages != null && messages.ContainsKey(LangKeys.ChatCommand))
                {
                    string command = messages[LangKeys.ChatCommand].ToLower();
                    if (!commands.Contains(command))
                    {
                        cmd.AddChatCommand(command, this, WorkbenchUpgradeChatCommand);
                        commands.Add(command);
                    }
                }
            }
            
            Pool.FreeList(ref commands);
            
            _workbenchItemIds.Add(ItemManager.itemDictionaryByName["workbench1"].itemid);
            _workbenchItemIds.Add(ItemManager.itemDictionaryByName["workbench2"].itemid);
            _workbenchItemIds.Add(ItemManager.itemDictionaryByName["workbench3"].itemid);
        }
        #endregion
        
        #region Chat Command
        private void WorkbenchUpgradeChatCommand(BasePlayer player, string cmd, string[] args)
        {
            if (!HasPermission(player, UpgradePermission) && !HasPermission(player, DowngradePermission))
            {
                Chat(player, LangKeys.NotAllowed);
                return;
            }

            Workbench wb = RaycastAll<Workbench>(player, 5f);
            if (wb == null)
            {
                Chat(player, LangKeys.NotLookingAt);
                return;
            }

            timer.In(.25f, () =>
            {
                wb.PlayerOpenLoot(player, "lantern");
            });
        }
        #endregion

        #region Hooks
        private object CanMoveItem(Item movedItem, PlayerInventory playerInventory, ItemContainerId targetContainerId)
        {
            if (!_workbenchItemIds.Contains(movedItem.info.itemid))
            {
                return null;
            }

            Workbench oldBench = playerInventory.FindContainer(targetContainerId)?.entityOwner as Workbench;
            if (oldBench == null)
            {
                return null;
            }
            
            int newBenchLevel = int.Parse(movedItem.info.shortname.Replace("workbench", ""));
            if (newBenchLevel == oldBench.Workbenchlevel)
            {
                return null;
            }

            BasePlayer player = playerInventory._baseEntity;
            if (newBenchLevel > oldBench.Workbenchlevel && !HasPermission(player, UpgradePermission))
            {
                Chat(player, LangKeys.UpgradeNotAllowed);
                return null;
            }

            if (newBenchLevel < oldBench.Workbenchlevel && !HasPermission(player, DowngradePermission))
            {
                Chat(player, LangKeys.DowngradeNotAllow);
                return null;
            }

            Planner planner = movedItem.GetHeldEntity() as Planner;
            Deployable deployable = planner?.GetDeployable();
            if (deployable == null)
            {
                return null;
            }

            Workbench newBench = GameManager.server.CreateEntity(deployable.fullName, oldBench.transform.position, oldBench.transform.rotation) as Workbench;
            if (newBench == null)
            {
                return null;
            }

            newBench.OwnerID = oldBench.OwnerID;
            newBench.Spawn();
            newBench.AttachToBuilding(oldBench.buildingID);

            if (deployable.placeEffect.isValid)
            {
                Effect.server.Run(deployable.placeEffect.resourcePath, newBench.transform.position, Vector3.up);
            }

            movedItem.UseItem();

            if (HasPermission(player, RefundPermission))
            {
                player.GiveItem(ItemManager.CreateByName($"workbench{oldBench.Workbenchlevel}"));
            }

            player.EndLooting();
            oldBench.Kill();
            newBench.PlayerOpenLoot(player);
            return true;
        }

        private void OnEntityBuilt(Planner planner, GameObject go)
        {
            BasePlayer player = planner.GetOwnerPlayer();
            if (player == null)
            {
                return;
            }

            if (!HasPermission(player, UpgradePermission) && !HasPermission(player, DowngradePermission))
            {
                return;
            }

            Workbench workbench = go.GetComponent<Workbench>();
            if (workbench == null)
            {
                return;
            }

            Chat(player, LangKeys.InfoMessage, Lang(LangKeys.ChatCommand, player));
        }
        #endregion

        #region Helper Methods
        private T RaycastAll<T>(BasePlayer player, float distance) where T : BaseEntity
        {
            RaycastHit[] hits = Physics.RaycastAll(player.eyes.HeadRay(), distance);
            GamePhysics.Sort(hits);
            return hits
                .Where(h => h.GetEntity() is T)
                .Select(h => h.GetEntity() as T)
                .FirstOrDefault();
        }
        
        private void Chat(BasePlayer player, string key, params object[] args) => PrintToChat(player, Lang(LangKeys.Chat, player, Lang(key, player, args)));

        private string Lang(string key, BasePlayer player = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, player?.UserIDString), args);
            }
            catch (Exception ex)
            {
                PrintError($"Lang Key '{key}' threw exception:\n{ex}");
                throw;
            }
        }

        private bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);
        #endregion

        #region Classes
        public class PluginConfig
        {
            [DefaultValue(true)]
            [JsonProperty(PropertyName = "Display Placement Message")]
            public bool DisplayPlacementMessage { get; set; }
        }
        
        private class LangKeys
        {
            public const string Chat = nameof(Chat);
            public const string InfoMessage =  nameof(InfoMessage) + "V1";
            public const string UpgradeNotAllowed =  nameof(UpgradeNotAllowed);
            public const string DowngradeNotAllow =  nameof(DowngradeNotAllow);
            public const string NotAllowed =  nameof(NotAllowed);
            public const string NotLookingAt =  nameof(NotLookingAt);
            public const string ChatCommand =  nameof(ChatCommand);
        }
        #endregion
    }
}

// --- End of file: UpgradeWorkbenches.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/unburnable-meat ---
// --- Original File Path: U/UnburnableMeat/UnburnableMeat.cs ---

using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Unburnable Meat", "S642667", "1.0.1")]
    [Description("Prevent cooked meats from burning")]
    class UnburnableMeat : RustPlugin
    {
        public static readonly string[] CookedItems = new string[]
        {
            "bearmeat.cooked",
            "chicken.cooked",
            "deermeat.cooked",
            "horsemeat.cooked",
            "humanmeat.cooked",
            "meat.pork.cooked",
            "wolfmeat.cooked",
            "fish.cooked"
        };

        private Dictionary<string, int> lowTemps = new Dictionary<string, int>();
        private Dictionary<string, int> highTemps = new Dictionary<string, int>();

        ItemModCookable GetCookable (string shortname)
        {
            var definition = ItemManager.FindItemDefinition(shortname);
            if (definition == null)
            {
                Puts($"Unknown definition for {shortname}");
                return null;
            }
            var cookable = definition.GetComponent<ItemModCookable>();
            if (cookable == null)
            {
                Puts($"Unknown cookable for {shortname}");
                return null;
            }
            return cookable;
        }

        void OnServerInitialized()
        {
            foreach (var shortname in CookedItems)
            {
                var cookable = GetCookable(shortname);
                if (cookable == null)
                {
                    continue;
                }
                lowTemps.Add(shortname, cookable.lowTemp);
                highTemps.Add(shortname, cookable.highTemp);
                cookable.lowTemp = -1;
                cookable.highTemp = -1;
            }
        }

        void Unload()
        {
            foreach (KeyValuePair<string, int> item in lowTemps)
            {
                var cookable = GetCookable(item.Key);
                if (cookable == null)
                {
                    continue;
                }
                cookable.lowTemp = item.Value;
                cookable.highTemp = highTemps[item.Key];
            }
        }
    }
}


// --- End of file: UnburnableMeat.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/usable-to-belt ---
// --- Original File Path: U/UsableToBelt/UsableToBelt.cs ---

namespace Oxide.Plugins
{
    [Info("Usable to Belt", "Wulf", "1.2.2")]
    [Description("Any usable item will be moved to your belt if there is space")]
    public class UsableToBelt : RustPlugin
    {
        private const string permAllow = "usabletobelt.allow";

        private void Init() => permission.RegisterPermission(permAllow, this);

        private void HandleItem(Item item, BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, permAllow))
            {
                return;
            }

            bool alreadyHasStack = false;
            ItemContainer belt = player.inventory.containerBelt;
            ItemContainer main = player.inventory.containerMain;

            foreach (Item invItem in main.itemList)
            {
                if (item.info.itemid == invItem.info.itemid)
                {
                    if (invItem.info.stackable > 1)
                    {
                        alreadyHasStack = true;
                    }
                }
            }

            if (alreadyHasStack)
            {
                return;
            }

            if (item.info.category != ItemCategory.Weapon && item.info.category != ItemCategory.Tool &&
                item.info.category != ItemCategory.Medical && item.info.category != ItemCategory.Food &&
                item.info.category != ItemCategory.Construction)
            {
                return;
            }

            for (int i = 0; i < PlayerBelt.MaxBeltSlots; i++)
            {
                if (!belt.SlotTaken(item, i))
                {
                    timer.Once(0.1f, () => item.MoveToContainer(belt, i));
                    break;
                }

                continue;
            }
        }

        private void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            BasePlayer player = container.GetOwnerPlayer();
            if (player != null && !container.HasFlag(ItemContainer.Flag.Belt))
            {
                HandleItem(item, player);
            }
        }
    }
}


// --- End of file: UsableToBelt.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/underwater-vehicles ---
// --- Original File Path: U/UnderwaterVehicles/UnderwaterVehicles.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Linq;
using System.Collections.Generic;
using System.Reflection;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Underwater Vehicles", "WhiteThunder", "1.6.0")]
    [Description("Allows modular cars, snowmobiles, magnet cranes, and helicopters to be used underwater.")]
    internal class UnderwaterVehicles : CovalencePlugin
    {
        #region Fields

        private Configuration _config;
        private VehicleInfoManager _vehicleInfoManager;

        public UnderwaterVehicles()
        {
            _vehicleInfoManager = new VehicleInfoManager(this);
        }

        #endregion

        #region Hooks

        private void OnServerInitialized()
        {
            _vehicleInfoManager.OnServerInitialized();

            NextTick(() =>
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    var seat = player.GetMounted() as BaseVehicleSeat;
                    if (seat == null)
                        continue;

                    OnEntityMounted(seat);
                }
            });
        }

        private void Unload()
        {
            foreach (var networkable in BaseNetworkable.serverEntities)
            {
                var vehicle = networkable as BaseVehicle;
                if ((object)vehicle == null)
                    continue;

                var vehicleInfo = _vehicleInfoManager.GetVehicleInfo(vehicle);
                if (vehicleInfo == null || !vehicleInfo.Config.Enabled)
                    continue;

                UnderwaterVehicleComponent.RemoveFromVehicle(vehicle);
            }
        }

        private void OnEntityMounted(BaseVehicleSeat seat)
        {
            HandleSeatMountedChanged(seat);
        }

        private void OnEntityDismounted(BaseVehicleSeat seat)
        {
            HandleSeatMountedChanged(seat);
        }

        #endregion

        #region Exposed Hooks

        private static class ExposedHooks
        {
            public static object OnVehicleUnderwaterEnable(BaseEntity vehicle)
            {
                return Interface.CallHook("OnVehicleUnderwaterEnable", vehicle);
            }
        }

        #endregion

        #region Helper Methods

        private static string[] FindPrefabsOfType<T>() where T : BaseEntity
        {
            var prefabList = new List<string>();

            foreach (var assetPath in GameManifest.Current.entities)
            {
                var entity = GameManager.server.FindPrefab(assetPath)?.GetComponent<T>();
                if (entity == null)
                    continue;

                prefabList.Add(entity.PrefabName);
            }

            return prefabList.ToArray();
        }

        private static BaseVehicle GetParentVehicle(BaseEntity entity)
        {
            var parent = entity.GetParentEntity();
            if (parent == null)
                return null;

            var vehicleModule = parent as BaseVehicleModule;
            if (vehicleModule != null)
                return vehicleModule.Vehicle;

            return parent as BaseVehicle;
        }

        private bool VehicleHasPermission(BaseVehicle vehicle, IVehicleInfo vehicleInfo)
        {
            if (!vehicleInfo.Config.RequireOccupantPermission)
                return true;

            if (!vehicle.AnyMounted())
                return false;

            foreach (var mountPointInfo in vehicle.allMountPoints)
            {
                var player = mountPointInfo.mountable?.GetMounted();
                if (player == null)
                    continue;

                if (permission.UserHasPermission(player.UserIDString, vehicleInfo.Permission))
                    return true;
            }

            return false;
        }

        private void RefreshUnderwaterCapability(BaseVehicle vehicle, IVehicleInfo vehicleInfo)
        {
            var vehicleHasPermission = VehicleHasPermission(vehicle, vehicleInfo);

            var component = UnderwaterVehicleComponent.GetForVehicle(vehicle);
            if (component == null)
            {
                if (!vehicleHasPermission)
                    return;

                component = UnderwaterVehicleComponent.AddToVehicle(vehicle, vehicleInfo);
            }

            if (vehicleHasPermission)
            {
                if (!component.IsUnderwaterCapable)
                {
                    component.EnableUnderwater();
                }
                else if (vehicle.AnyMounted())
                {
                    component.EnableCustomDrag();
                }
            }
            else if (component.IsUnderwaterCapable)
            {
                component.DisableUnderwater();
            }
        }

        private void HandleSeatMountedChanged(BaseVehicleSeat seat)
        {
            var vehicle = GetParentVehicle(seat);
            if (vehicle == null)
                return;

            var vehicleInfo = _vehicleInfoManager.GetVehicleInfo(vehicle);
            if (vehicleInfo == null || !vehicleInfo.Config.Enabled)
                return;

            RefreshUnderwaterCapability(vehicle, vehicleInfo);
        }

        #endregion

        #region Helper Classes

        private class UnderwaterVehicleComponent : FacepunchBehaviour
        {
            public static UnderwaterVehicleComponent AddToVehicle(BaseVehicle vehicle, IVehicleInfo vehicleInfo)
            {
                var component = vehicle.gameObject.AddComponent<UnderwaterVehicleComponent>();
                component._vehicleInfo = vehicleInfo;
                component._vehicle = vehicle;

                var waterLoggedPoint = vehicleInfo.GetWaterLoggedPoint(vehicle);
                component._waterLoggedPoint = waterLoggedPoint;
                component._waterLoggedPointParent = waterLoggedPoint.parent;
                component._waterLoggedPointLocalPosition = waterLoggedPoint.localPosition;

                var groundVehicle = vehicle as GroundVehicle;
                var groundVehicleConfig = vehicleInfo.Config as GroundVehicleConfig;
                if ((object)groundVehicle != null && groundVehicleConfig != null)
                {
                    var component2 = component;
                    var groundVehicle2 = groundVehicle;
                    var dragMultiplier = groundVehicleConfig.DragMultiplier;
                    component._customDragCheck = () => component2.CustomDragCheck(groundVehicle2, dragMultiplier);
                }

                return component;
            }

            public static UnderwaterVehicleComponent GetForVehicle(BaseEntity vehicle)
            {
                return vehicle.gameObject.GetComponent<UnderwaterVehicleComponent>();
            }

            public static void RemoveFromVehicle(BaseEntity vehicle)
            {
                DestroyImmediate(GetForVehicle(vehicle));
            }

            public bool IsUnderwaterCapable { get; private set; }
            private IVehicleInfo _vehicleInfo;
            private BaseVehicle _vehicle;
            private Transform _waterLoggedPoint;
            private Transform _waterLoggedPointParent;
            private Vector3 _waterLoggedPointLocalPosition;
            private Action _customDragCheck;

            public void EnableUnderwater()
            {
                if (IsUnderwaterCapable
                    || _waterLoggedPoint == null
                    || _waterLoggedPoint.parent == null)
                    return;

                var hookResult = ExposedHooks.OnVehicleUnderwaterEnable(_vehicle);
                if (hookResult is bool && !(bool)hookResult)
                    return;

                _waterLoggedPoint.SetParent(null);
                _waterLoggedPoint.position = new Vector3(0, 1000, 0);
                IsUnderwaterCapable = true;

                EnableCustomDrag();
            }

            public void DisableUnderwater()
            {
                if (!IsUnderwaterCapable
                    || _waterLoggedPoint == null
                    || _waterLoggedPoint.parent == _waterLoggedPointParent)
                    return;

                _waterLoggedPoint.SetParent(_waterLoggedPointParent);
                _waterLoggedPoint.transform.localPosition = _waterLoggedPointLocalPosition;
                IsUnderwaterCapable = false;

                DisableCustomDrag();
            }

            public void EnableCustomDrag()
            {
                if (_customDragCheck == null
                    || IsInvoking(_customDragCheck))
                    return;

                _vehicleInfo.SetTimeSinceWaterCheck(_vehicle, float.MinValue);
                InvokeRandomized(_customDragCheck, 0.25f, 0.25f, 0.05f);
            }

            private void DisableCustomDrag()
            {
                if (_customDragCheck == null
                    || !IsInvoking(_customDragCheck))
                    return;

                _vehicleInfo.SetTimeSinceWaterCheck(_vehicle, UnityEngine.Random.Range(0f, 0.25f));
                CancelInvoke(_customDragCheck);
            }

            private void CustomDragCheck(GroundVehicle groundVehicle, float dragMultiplier)
            {
                // Most of this code is identical to the vanilla drag computation
                var throttleInput = groundVehicle.IsOn() ? groundVehicle.GetThrottleInput() : 0;
                var waterFactor = groundVehicle.WaterFactor() * dragMultiplier;
                var drag = 0f;
                TriggerVehicleDrag triggerResult;
                if (groundVehicle.FindTrigger(out triggerResult))
                {
                    drag = triggerResult.vehicleDrag;
                }
                var throttleDrag = (throttleInput != 0) ? 0 : 0.25f;
                drag = Mathf.Max(waterFactor, drag);
                drag = Mathf.Max(drag, groundVehicle.GetModifiedDrag());
                groundVehicle.rigidBody.drag = Mathf.Max(throttleDrag, drag);
                groundVehicle.rigidBody.angularDrag = drag * 0.5f;
            }

            private void OnDestroy()
            {
                if (_vehicle != null && !_vehicle.IsDestroyed)
                {
                    DisableUnderwater();

                    var groundVehicle = _vehicle as GroundVehicle;
                    if ((object)groundVehicle != null)
                    {
                        DisableCustomDrag();
                    }
                }
                else if (_waterLoggedPoint != null)
                {
                    Destroy(_waterLoggedPoint.gameObject);
                }
            }
        }

        #endregion

        #region Vehicle Info

        private interface IVehicleInfo
        {
            VehicleConfig Config { get; }
            uint[] PrefabIds { get; }
            string Permission { get; }

            void OnServerInitialized(UnderwaterVehicles plugin);
            bool IsCorrectType(BaseEntity entity);
            Transform GetWaterLoggedPoint(BaseEntity entity);
            void SetTimeSinceWaterCheck(BaseEntity entity, float deltaTime);
        }

        private class VehicleInfo<T> : IVehicleInfo where T : BaseEntity
        {
            public VehicleConfig Config { get; set; }
            public uint[] PrefabIds { get; private set; }
            public string Permission { get; private set; }

            public string VehicleName { get; set; }
            public string[] PrefabPaths { get; set; }
            public Func<T, Transform> FindWaterLoggedPoint { private get; set; } = entity => null;
            public Action<T, float> ApplyTimeSinceWaterCheck { private get; set; } = (entity, deltaTime) => {};

            public void OnServerInitialized(UnderwaterVehicles plugin)
            {
                Permission = $"{nameof(UnderwaterVehicles)}.occupant.{VehicleName}".ToLower();
                plugin.permission.RegisterPermission(Permission, plugin);

                var prefabIds = new List<uint>(PrefabPaths.Length);

                foreach (var prefabName in PrefabPaths)
                {
                    var prefab = GameManager.server.FindPrefab(prefabName)?.GetComponent<T>();
                    if (prefab == null)
                    {
                        plugin.LogError($"Invalid or incorrect prefab. Please alert the plugin maintainer -- {prefabName}");
                        continue;
                    }

                    prefabIds.Add(prefab.prefabID);
                }

                PrefabIds = prefabIds.ToArray();
            }

            public bool IsCorrectType(BaseEntity entity)
            {
                return entity is T;
            }

            public Transform GetWaterLoggedPoint(BaseEntity entity)
            {
                var entityOfType = entity as T;
                if ((object)entityOfType == null)
                    return null;

                return FindWaterLoggedPoint(entityOfType);
            }

            public void SetTimeSinceWaterCheck(BaseEntity entity, float deltaTime)
            {
                var entityOfType = entity as T;
                if ((object)entityOfType == null)
                    return;

                ApplyTimeSinceWaterCheck(entityOfType, deltaTime);
            }
        }

        private class VehicleInfoManager
        {
            private static readonly FieldInfo BikeCarPhysicsField = typeof(Bike).GetField("carPhysics",
                BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

            private readonly UnderwaterVehicles _plugin;

            private readonly Dictionary<uint, IVehicleInfo> _prefabIdToVehicleInfo = new Dictionary<uint, IVehicleInfo>();
            private IVehicleInfo[] _allVehicles;

            private Configuration _config => _plugin._config;

            public VehicleInfoManager(UnderwaterVehicles plugin)
            {
                _plugin = plugin;
            }

            public void OnServerInitialized()
            {
                _allVehicles = new IVehicleInfo[]
                {
                    new VehicleInfo<ModularCar>
                    {
                        VehicleName = "modularcar",
                        PrefabPaths = FindPrefabsOfType<ModularCar>(),
                        Config = _config.ModularCar,
                        FindWaterLoggedPoint = vehicle => vehicle.waterloggedPoint,
                        ApplyTimeSinceWaterCheck = (car, deltaTime) => car.carPhysics.timeSinceWaterCheck = deltaTime,
                    },
                    new VehicleInfo<Snowmobile>
                    {
                        VehicleName = "snowmobile",
                        PrefabPaths = new[] { "assets/content/vehicles/snowmobiles/snowmobile.prefab" },
                        Config = _config.Snowmobile,
                        FindWaterLoggedPoint = vehicle => vehicle.waterloggedPoint,
                        ApplyTimeSinceWaterCheck = (vehicle, deltaTime) => vehicle.carPhysics.timeSinceWaterCheck = deltaTime,
                    },
                    new VehicleInfo<Snowmobile>
                    {
                        VehicleName = "tomaha",
                        PrefabPaths = new[] { "assets/content/vehicles/snowmobiles/tomahasnowmobile.prefab" },
                        Config = _config.Tomaha,
                        FindWaterLoggedPoint = vehicle => vehicle.waterloggedPoint,
                        ApplyTimeSinceWaterCheck = (vehicle, deltaTime) => vehicle.carPhysics.timeSinceWaterCheck = deltaTime,
                    },
                    new VehicleInfo<Bike>
                    {
                        VehicleName = "motorbike.sidecar",
                        PrefabPaths = new[] { "assets/content/vehicles/bikes/motorbike_sidecar.prefab" },
                        Config = _config.MotorBikeSidecar,
                        FindWaterLoggedPoint = vehicle => vehicle.waterloggedPoint,
                        ApplyTimeSinceWaterCheck = (vehicle, deltaTime) => ((CarPhysics<Bike>)BikeCarPhysicsField.GetValue(vehicle)).timeSinceWaterCheck = deltaTime,
                    },
                    new VehicleInfo<Bike>
                    {
                        VehicleName = "motorbike",
                        PrefabPaths = new[] { "assets/content/vehicles/bikes/motorbike.prefab" },
                        Config = _config.MotorBike,
                        FindWaterLoggedPoint = vehicle => vehicle.waterloggedPoint,
                        ApplyTimeSinceWaterCheck = (vehicle, deltaTime) => ((CarPhysics<Bike>)BikeCarPhysicsField.GetValue(vehicle)).timeSinceWaterCheck = deltaTime,
                    },
                    new VehicleInfo<Bike>
                    {
                        VehicleName = "pedalbike",
                        PrefabPaths = new[] { "assets/content/vehicles/bikes/pedalbike.prefab" },
                        Config = _config.PedalBike,
                        FindWaterLoggedPoint = vehicle => vehicle.waterloggedPoint,
                        ApplyTimeSinceWaterCheck = (vehicle, deltaTime) => ((CarPhysics<Bike>)BikeCarPhysicsField.GetValue(vehicle)).timeSinceWaterCheck = deltaTime,
                    },
                    new VehicleInfo<Bike>
                    {
                        VehicleName = "pedaltrike",
                        PrefabPaths = new[] { "assets/content/vehicles/bikes/pedaltrike.prefab" },
                        Config = _config.PedalTrike,
                        FindWaterLoggedPoint = vehicle => vehicle.waterloggedPoint,
                        ApplyTimeSinceWaterCheck = (vehicle, deltaTime) => ((CarPhysics<Bike>)BikeCarPhysicsField.GetValue(vehicle)).timeSinceWaterCheck = deltaTime,
                    },
                    new VehicleInfo<MagnetCrane>
                    {
                        VehicleName = "magnetcrane",
                        PrefabPaths = new[] { "assets/content/vehicles/crane_magnet/magnetcrane.entity.prefab" },
                        Config = _config.MagnetCrane,
                        FindWaterLoggedPoint = vehicle => vehicle.waterloggedPoint,
                        ApplyTimeSinceWaterCheck = (vehicle, deltaTime) => vehicle.carPhysics.timeSinceWaterCheck = deltaTime,
                    },
                    new VehicleInfo<Minicopter>
                    {
                        VehicleName = "minicopter",
                        PrefabPaths = new[] { "assets/content/vehicles/minicopter/minicopter.entity.prefab" },
                        Config = _config.Minicopter,
                        FindWaterLoggedPoint = vehicle => vehicle.engineController.waterloggedPoint,
                    },
                    new VehicleInfo<ScrapTransportHelicopter>
                    {
                        VehicleName = "scraptransport",
                        PrefabPaths = new[] { "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab" },
                        Config = _config.ScrapTransportHelicopter,
                        FindWaterLoggedPoint = vehicle => vehicle.engineController.waterloggedPoint,
                    },
                    new VehicleInfo<AttackHelicopter>
                    {
                        VehicleName = "attackhelicopter",
                        PrefabPaths = new[] { "assets/content/vehicles/attackhelicopter/attackhelicopter.entity.prefab" },
                        Config = _config.AttackHelicopter,
                        FindWaterLoggedPoint = vehicle => vehicle.engineController.waterloggedPoint,
                    },
                };

                foreach (var vehicleInfo in _allVehicles)
                {
                    vehicleInfo.OnServerInitialized(_plugin);

                    foreach (var prefabId in vehicleInfo.PrefabIds)
                    {
                        _prefabIdToVehicleInfo[prefabId] = vehicleInfo;
                    }
                }
            }

            public IVehicleInfo GetVehicleInfo(BaseEntity entity)
            {
                IVehicleInfo vehicleInfo;
                return _prefabIdToVehicleInfo.TryGetValue(entity.prefabID, out vehicleInfo) && vehicleInfo.IsCorrectType(entity)
                    ? vehicleInfo
                    : null;
            }
        }

        #endregion

        #region Configuration

        [JsonObject(MemberSerialization.OptIn)]
        private class VehicleConfig
        {
            [JsonProperty("Enabled", Order = -4)]
            public bool Enabled;

            [JsonProperty("RequireOccupantPermission", Order = -3)]
            public bool RequireOccupantPermission;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class GroundVehicleConfig : VehicleConfig
        {
            [JsonProperty("DragMultiplier", Order = -2)]
            public float DragMultiplier = 1;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : SerializableConfiguration
        {
            [JsonProperty("ModularCar")]
            public GroundVehicleConfig ModularCar = new GroundVehicleConfig();

            [JsonProperty("Snowmobile")]
            public GroundVehicleConfig Snowmobile = new GroundVehicleConfig();

            [JsonProperty("Tomaha")]
            public GroundVehicleConfig Tomaha = new GroundVehicleConfig();

            [JsonProperty("MotorBikeSidecar")]
            public GroundVehicleConfig MotorBikeSidecar = new GroundVehicleConfig();

            [JsonProperty("MotorBike")]
            public GroundVehicleConfig MotorBike = new GroundVehicleConfig();

            [JsonProperty("PedalBike")]
            public GroundVehicleConfig PedalBike = new GroundVehicleConfig();

            [JsonProperty("PedalTrike")]
            public GroundVehicleConfig PedalTrike = new GroundVehicleConfig();

            [JsonProperty("MagnetCrane")]
            public GroundVehicleConfig MagnetCrane = new GroundVehicleConfig();

            [JsonProperty("Minicopter")]
            public VehicleConfig Minicopter = new VehicleConfig();

            [JsonProperty("ScrapTransportHelicopter")]
            public VehicleConfig ScrapTransportHelicopter = new VehicleConfig();

            [JsonProperty("AttackHelicopter")]
            public VehicleConfig AttackHelicopter = new VehicleConfig();
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #region Configuration Helpers

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion
    }
}


// --- End of file: UnderwaterVehicles.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ui-builder-library ---
// --- Original File Path: U/UiBuilderLibrary/UiBuilderLibrary.cs ---

#define DEBUG

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using static Oxide.Plugins.UiBuilderLibrary.Element.Instance;

namespace Oxide.Plugins
{
  [Info("UI Builder Library", "BlueBeka", "0.0.1")]
  [Description("Allows for easily creating complex UIs.")]
  public class UiBuilderLibrary : RustPlugin
  {
    private static UiBuilderLibrary SelfRef;

    private PluginConfig config;
    private PluginData data;

    #region Hooks

    private void Init()
    {
#if DEBUG
      if (SelfRef != null)
        throw new Exception("Self already defined.");
#endif
      SelfRef = this;
      config = new PluginConfig(this);
      data = new PluginData(this);
    }

    private void Loaded()
    {
      LoadConfig();
      data.Load();
    }

    private void OnServerSave()
    {
      data.Save();
    }

    private void Unload()
    {
      data.Save();
      foreach (var ui in UI.GetAllUis())
        ui.CloseAll();
    }

    private void OnUserDisconnected(IPlayer player)
    {
      foreach (var ui in UI.GetAllUis())
        ui.Clear((BasePlayer)player.Object);
    }

    protected override void SaveConfig()
    {
      base.SaveConfig();
      config.Save();
    }

    protected override void LoadConfig()
    {
      base.LoadConfig();
      config.Load();
    }

    #endregion Hooks

    #region Config and Data

    /// <summary>
    /// The config for this plugin.
    /// </summary>
    private class PluginConfig
    {
      // The plugin.
      private readonly UiBuilderLibrary plugin;

      public Data data;

      public PluginConfig(UiBuilderLibrary plugin)
      {
        this.plugin = plugin;
      }

      /// <summary>
      /// Save the config data.
      /// </summary>
      public void Save()
      {
        SaveSerializable(data);
      }

      /// <summary>
      /// Load the config data.
      /// </summary>
      public void Load()
      {
        data = LoadSerializable<Data>();
      }

      /// <summary>
      /// Save a serializable config object to a file.
      /// </summary>
      private void SaveSerializable<T>(T sData)
      {
        SaveSerializable(null, sData);
      }

      /// <summary>
      /// Save a serializable config object to a file.
      /// </summary>
      private void SaveSerializable<T>(string file, T sData)
      {
        Interface.Oxide.LogDebug("Saving");
        plugin.Config.WriteObject(sData, false, string.IsNullOrEmpty(file) ? $"oxide/config/{plugin.Name}.json" : $"oxide/config/{plugin.Name}/{file}.json");
      }

      /// <summary>
      /// Load a serializable config object from a file.
      /// </summary>
      private T LoadSerializable<T>()
      {
        return LoadSerializable<T>(null);
      }

      /// <summary>
      /// Load a serializable config object from a file.
      /// </summary>
      private T LoadSerializable<T>(string file)
      {
        return plugin.Config.ReadObject<T>(string.IsNullOrEmpty(file) ? $"oxide/config/{plugin.Name}.json" : $"oxide/config/{plugin.Name}/{file}.json");
      }

      /// <summary>
      /// The config data for this plugin.
      /// </summary>
      public class Data
      {
        public double DefaultScreenAspectRatio = 16.0 / 9.0;
        public double DefaultRenderScale = 1.0;
      }
    }

    /// <summary>
    /// Everything related to the data that this plugin stores.
    /// </summary>
    private class PluginData
    {
      // The filename to save to.
      private readonly string Filename;

      // The actual data.
      public Dictionary<ulong, Structure> PlayerData { get; protected set; }

      public PluginData(UiBuilderLibrary plugin, string file = null)
      {
        Filename = string.IsNullOrEmpty(file) ? plugin.Name : $"{plugin.Name}/{file}";
      }

      /// <summary>
      /// The data structure this plugin stores.
      /// </summary>
      public class Structure
      {
        public double ScreenAspectRatio;
        public double RenderScale;
      }

      /// <summary>
      /// Save the data.
      /// </summary>
      public void Save()
      {
        Interface.Oxide.DataFileSystem.WriteObject(Filename, PlayerData);
      }

      /// <summary>
      /// Load the data.
      /// </summary>
      public void Load()
      {
        PlayerData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, Structure>>(Filename);
        if (PlayerData == null)
          PlayerData = new Dictionary<ulong, Structure>();
      }
    }

    /// <summary>
    /// Get the player data for the given player.
    /// This data can then be mutated.
    /// </summary>
    /// <param name="player"></param>
    /// <returns></returns>
    private PluginData.Structure GetPlayerData(BasePlayer player)
    {
      if (data.PlayerData.ContainsKey(player.userID))
        return data.PlayerData[player.userID];

      return data.PlayerData[player.userID] = new PluginData.Structure()
      {
        RenderScale = config.data.DefaultRenderScale,
        ScreenAspectRatio = config.data.DefaultScreenAspectRatio,
      };
    }

    #endregion Config and Data

    #region API methods

    /// <summary>
    /// Get the Screen Aspect Ratio for the given player.
    /// </summary>
    /// <param name="player"></param>
    /// <returns></returns>
    public double GetScreenAspectRatio(BasePlayer player)
    {
      var playerData = GetPlayerData(player);
      return playerData.ScreenAspectRatio;
    }

    /// <summary>
    /// Sets the Screen Aspect Ratio for the given player.
    /// </summary>
    /// <param name="player"></param>
    /// <param name="value"></param>
    public void SetScreenAspectRatio(BasePlayer player, double value)
    {
      var playerData = GetPlayerData(player);
      playerData.ScreenAspectRatio = value;
    }

    /// <summary>
    /// Get the Render Scale for the given player.
    /// </summary>
    /// <param name="player"></param>
    /// <returns></returns>
    public double GetRenderScale(BasePlayer player)
    {
      var playerData = GetPlayerData(player);
      return playerData.RenderScale;
    }

    /// <summary>
    /// Sets the Render Scale for the given player.
    /// </summary>
    /// <param name="player"></param>
    /// <param name="value"></param>
    public void SetRenderScale(BasePlayer player, double value)
    {
      var playerData = GetPlayerData(player);
      playerData.RenderScale = value;
    }

    #endregion API methods

    #region API classes

    public class UI
    {
      private static readonly List<WeakReference<UI>> AllUis = new List<WeakReference<UI>>();

      public static readonly string FontBold = "robotocondensed-bold.ttf";
      public static readonly string FontRegular = "robotocondensed-regular.ttf";
      public static readonly string FontMono = "droidsansmono.ttf";
      public static readonly string FontMarker = "permanentmarker.ttf";

      private RootElement Root { get; }

      /// <summary>
      /// Create a new UI.
      /// </summary>
      /// <param name="parentId">The parent of this UI. For top-level UIs, one of: "Overlay", "Hud.Menu", "Hud" or "Under"</param>
      /// <param name="rootBuilder">Callback function that builds the UI.</param>
      public UI(string parentId, RootElement.RenderUi rootBuilder)
      {
        Root = new RootElement(parentId, rootBuilder);
        AllUis.Add(new WeakReference<UI>(this));
      }

      /// <summary>
      /// Get a collection of all the UIs that exist.
      /// </summary>
      /// <returns></returns>
      internal static IEnumerable<UI> GetAllUis()
      {
        var foundUis = new List<UI>();
        var missingUis = new HashSet<WeakReference<UI>>();

        foreach (var uiRef in AllUis)
        {
          UI ui;
          if (uiRef.TryGetTarget(out ui))
            foundUis.Add(ui);
          else
            missingUis.Add(uiRef);
        }

        if (missingUis.Count > 0)
          AllUis.RemoveAll(ui => missingUis.Contains(ui));

        return foundUis;
      }

      /// <summary>
      /// Open this UI for the given player.
      /// </summary>
      /// <param name="player"></param>
      public void Open(BasePlayer player)
      {
        var updatedElements = new List<Element.Instance>();
        Root.Build(player, updatedElements, false);
        var root = Root.GetInstance<RootElement.Instance>(player);

        var roots = GetRootElements(updatedElements);
        var jsonObjects = updatedElements.SelectMany(element => ToJson(element, roots)).ToArray();
        if (jsonObjects.Length == 0)
        {
          Interface.Oxide.LogDebug("Nothing to display/remove.");
          return;
        }

        var json = $"[{string.Join(",", jsonObjects)}]";
        CuiHelper.AddUi(player, json);
        root.Open = true;
      }

      /// <summary>
      /// Close this UI for the given player.
      /// </summary>
      /// <param name="player"></param>
      public void Close(BasePlayer player)
      {
        var root = Root.GetInstance<RootElement.Instance>(player);
        if (root == null)
          return;

        root.Clear();
        CuiHelper.DestroyUi(player, root.Id);
        root.Open = false;
      }

      /// <summary>
      /// Close this UI for all players.
      /// </summary>
      public void CloseAll()
      {
        foreach (BasePlayer player in BasePlayer.activePlayerList)
        {
          Close(player);
        }
      }

      /// <summary>
      /// Clear any internally stored UI data for this player.
      /// </summary>
      /// <param name="player"></param>
      internal void Clear(BasePlayer player)
      {
        Root.Clear(player);
      }

      /// <summary>
      /// Get the Screen Aspect Ratio for the given player.
      /// </summary>
      /// <param name="player"></param>
      /// <returns></returns>
      public static double GetScreenAspectRatio(BasePlayer player)
      {
        return SelfRef.GetScreenAspectRatio(player);
      }

      /// <summary>
      /// Set the Screen Aspect Ratio for the given player.
      /// </summary>
      /// <param name="player"></param>
      /// <param name="value"></param>
      /// <returns></returns>
      public static void SetScreenAspectRatio(BasePlayer player, double value)
      {
        SelfRef.SetScreenAspectRatio(player, value);
      }

      /// <summary>
      /// Get the Render Scale for the given player.
      /// </summary>
      /// <param name="player"></param>
      /// <returns></returns>
      public static double GetRenderScale(BasePlayer player)
      {
        return SelfRef.GetRenderScale(player);
      }

      /// <summary>
      /// Set the Render Scale for the given player.
      /// </summary>
      /// <param name="player"></param>
      /// <param name="value"></param>
      /// <returns></returns>
      public static void SetRenderScale(BasePlayer player, double value)
      {
        SelfRef.SetRenderScale(player, value);
      }

      /// <summary>
      /// Get a JSON representation of the given Element.
      /// </summary>
      /// <param name="element">What to encode.</param>
      /// <param name="roots">List of the root element ids.</param>
      /// <returns></returns>
      private static IEnumerable<string> ToJson(Element.Instance element, HashSet<string> roots)
      {
        var cuiElements = element.GetCuiElements();

        var settings = new JsonSerializerSettings();
        settings.DefaultValueHandling = DefaultValueHandling.Ignore;

        return cuiElements.Select(cuiElement =>
        {
          if (element.Visible)
          {
            var json = JsonConvert.SerializeObject(cuiElement, Formatting.None, settings).Replace("\\n", "\n");
            if (roots.Contains(cuiElement.Name))
              return $"{{\"destroyUi\":\"{cuiElement.Name}\",{json.Substring(1)}";
            return json;
          }

          return $"{{\"destroyUi\":\"{cuiElement.Name}\",\"name\":\"{cuiElement.Name}\"}}";
        });
      }

      /// <summary>
      /// Get a collection of the root element ids from the given collection of elements.
      /// </summary>
      /// <param name="elements"></param>
      /// <returns></returns>
      private static HashSet<string> GetRootElements(IEnumerable<Element.Instance> elements)
      {
        var names = new HashSet<string>(elements.Select(element => element.Id));
        return new HashSet<string>(elements.Where(element => !names.Contains(element.GetParentId())).Select(element => element.Id));
      }
    }

    /// <summary>
    /// The base class of all elements.
    /// </summary>
    public abstract class Element
    {
      protected readonly Dictionary<ulong, Instance> InstanceCache = new Dictionary<ulong, Instance>();

      // `Parent` should be null if `ParentId` is set.
      private readonly string ParentId;

      private readonly Element Parent;

      internal Element(Element parent)
      {
        Parent = parent;
        ParentId = null;
      }

      internal Element(string parentId)
      {
        Parent = null;
        ParentId = parentId;
      }

      /// <summary>
      /// Get the instance of this element for the given player.
      /// </summary>
      /// <param name="player"></param>
      /// <returns></returns>
      public T GetInstance<T>(BasePlayer player) where T : Instance
      {
        Instance instance = null;
        return InstanceCache.TryGetValue(player.userID, out instance) ? (T)instance : null;
      }

      /// <summary>
      /// Build this element for the given player.
      /// </summary>
      /// <param name="player"></param>
      /// <param name="updatedElements"></param>
      /// <param name="parentHasUpdates"></param>
      /// <exception cref="Exception"></exception>
      public abstract void Build(BasePlayer player, List<Instance> updatedElements, bool parentHasUpdates);

      /// <summary>
      /// Clear any internally stored data for this player.
      /// </summary>
      /// <param name="player"></param>
      public void Clear(BasePlayer player)
      {
        if (!InstanceCache.ContainsKey(player.userID))
          return;

        InstanceCache[player.userID].Clear();
        InstanceCache.Remove(player.userID);
      }

      /// <summary>
      /// An instance of the element for an indiviual player.
      /// </summary>
      public abstract class Instance
      {
        /// <summary>
        /// Build an Element for the given player.
        /// </summary>
        /// <typeparam name="T">The type of instance being rendered.</typeparam>
        /// <param name="instance">The instance being rendered.</param>
        /// <returns>True iff the UI element needs to be refreshed on player's screen.</returns>
        public delegate bool RenderUi<in T>(T instance) where T : Instance;

        public string Id { get; }

        protected readonly Element Element;
        protected readonly Instance Parent;
        public BasePlayer Player { get; private set; }
        public BoundingBox Bounds { get; private set; }
        public bool Visible { get; set; } = true;

        protected readonly List<Element> Children = new List<Element>();
        private int BuildingChildIndex = 0;
        internal bool Initialized;

        public Instance(Element element, BasePlayer player)
        {
          Id = CuiHelper.GetGuid();
          Element = element;
          Player = player;
          Parent = Element.Parent == null ? null : Element.Parent.GetInstance<Instance>(Player);
          Bounds = new BoundingBox(Parent);
          Initialized = false;
        }

        /// <summary>
        /// Get the id of this element's parent.
        /// </summary>
        /// <returns></returns>
        public string GetParentId()
        {
          return Parent?.Id ?? Element.ParentId;
        }

        public bool IsOpen()
        {
          return IsOpen(this);
        }

        private bool IsOpen(Instance instance)
        {
          if (instance == null)
            return false;

          if (instance.GetType() != typeof(RootElement.Instance))
            return IsOpen(instance.Element.Parent.GetInstance<Instance>(Player));

          var root = (RootElement.Instance)instance;
          return root.Open;
        }

        /// <summary>
        /// Build this element instance and its children.
        /// </summary>
        /// <param name="player"></param>
        /// <param name="updatedElements"></param>
        /// <param name="parentHasUpdates"></param>
        /// <exception cref="Exception"></exception>
        public void Build(List<Instance> updatedElements, bool parentHasUpdates)
        {
          BuildingChildIndex = 0;
          var hasUpdates = Render() || parentHasUpdates || !IsOpen();

          if (hasUpdates)
            updatedElements.Add(this);

#if DEBUG
          if (Initialized && Visible && BuildingChildIndex != Children.Count)
            throw new Exception($"[{GetType().FullName}] Different number of children after update ({Children.Count} => {BuildingChildIndex}).");
#endif

          if (Visible)
            foreach (var child in Children)
              child.Build(Player, updatedElements, hasUpdates);

          Initialized = true;
        }

        /// <summary>
        /// Render this element.
        /// </summary>
        /// <param name="player"></param>
        /// <returns></returns>
        public abstract bool Render();

        /// <summary>
        /// Clear any internally stored data.
        /// </summary>
        public void Clear()
        {
          foreach (var child in Children)
            child.Clear(Player);
        }

        /// <summary>
        /// Add a child to this element.
        /// If the element has already been initialized, use the other version of this function.
        /// </summary>
        /// <param name="element"></param>
        protected T AddChild<T>(T element) where T : Element
        {
#if DEBUG
          if (Initialized)
            throw new Exception("Cannot add child once initialized.");
          if (element == null)
            throw new Exception("Cannot add null as child.");
#endif

          Children.Add(element);
          return element;
        }

        /// <summary>
        /// Mark that a child has been added to this element.
        /// If the element has not yet been initialized, use the other version of this function.
        /// </summary>
        /// <typeparam name="T">The type of the child.</typeparam>
        /// <returns>The child.</returns>
        protected T AddChild<T>() where T : Element
        {
#if DEBUG
          if (!Initialized)
            throw new Exception("Not yet initialized.");
#endif

          var element = (T)Children[BuildingChildIndex];
          BuildingChildIndex++;
          return element;
        }

        /// <summary>
        /// Get all the CuiElements for this element.
        /// </summary>
        /// <returns></returns>
        public abstract IEnumerable<CuiElement> GetCuiElements();
      }

      public class BoundingBox
      {
        private readonly Instance Parent;

        public double MinX { get; set; } = 0;
        public double MinY { get; set; } = 0;
        public double MaxX { get; set; } = 1;
        public double MaxY { get; set; } = 1;

        public BoundingBox(Instance parent)
        {
          Parent = parent;
        }

        /// <summary>
        /// Gets the aspect ratio of this element on the given player's screen.
        /// </summary>
        /// <param name="player"></param>
        /// <returns></returns>
        public double GetAspectRatio(BasePlayer player)
        {
          return GetRelativeWidth(player) / GetRelativeHeight(player);
        }

        /// <summary>
        /// Get the width of this element (as a percentage of its parent's width).
        /// </summary>
        /// <returns></returns>
        public double GetWidth()
        {
          return MaxX - MinX;
        }

        /// <summary>
        /// Get the height of this element (as a percentage of its parent's height).
        /// </summary>
        /// <returns></returns>
        public double GetHeight()
        {
          return MaxY - MinY;
        }

        /// <summary>
        /// Get the width of this element as a percentage of the player's screen width.
        /// </summary>
        /// <param name="player"></param>
        /// <returns></returns>
        public double GetRelativeWidth(BasePlayer player)
        {
          if (Parent == null)
          {
            return GetWidth();
          }
          return GetWidth() * Parent.Bounds.GetRelativeWidth(player);
        }

        /// <summary>
        /// Get the height of this element as a percentage of the player's screen **width** (not height).
        /// </summary>
        /// <param name="player"></param>
        /// <returns></returns>
        public double GetRelativeHeight(BasePlayer player)
        {
          if (Parent == null)
          {
            return GetHeight() / UI.GetScreenAspectRatio(player);
          }
          return GetHeight() * Parent.Bounds.GetRelativeHeight(player);
        }

        /// <summary>
        /// Get the `CuiRectTransformComponent` this object represents.
        /// </summary>
        /// <returns></returns>
        public CuiRectTransformComponent GetCuiComponent()
        {
          return new CuiRectTransformComponent()
          {
            AnchorMin = $"{MinX} {MinY}",
            AnchorMax = $"{MaxX} {MaxY}",
          };
        }
      }
    }

    /// <summary>
    /// The top level element.
    /// </summary>
    public class RootElement : PanelElement
    {
      public delegate bool RenderUi(Instance panel, BasePlayer player);

      protected internal RenderUi Renderer;

      internal RootElement(string parentId, RenderUi renderer) : base(parentId)
      {
        Renderer = renderer;
      }

      public Instance GetOrCreateInstance(BasePlayer player)
      {
        return GetInstance<Instance>(player) ?? new Instance(this, player);
      }

      /// <summary>
      /// Build this element for the given player.
      /// </summary>
      /// <param name="player"></param>
      /// <param name="updatedElements"></param>
      /// <param name="parentHasUpdates"></param>
      /// <exception cref="Exception"></exception>
      public override void Build(BasePlayer player, List<Element.Instance> updatedElements, bool parentHasUpdates)
      {
        InstanceCache[player.userID] = GetOrCreateInstance(player);
        InstanceCache[player.userID].Build(updatedElements, parentHasUpdates);
      }

      public new class Instance : PanelElement.Instance
      {
        internal bool Open = false;

        internal Instance(Element element, BasePlayer player) : base(element, player, null)
        {
        }

        public override bool Render()
        {
          var renderer = ((RootElement)Element).Renderer;
          return renderer(this, Player);
        }
      }
    }

    /// <summary>
    /// A Panel.
    /// </summary>
    public class PanelElement : Element
    {
      internal PanelElement(Element parent) : base(parent)
      {
      }

      internal PanelElement(string parentId) : base(parentId)
      {
      }

      public Instance GetOrCreateInstance(BasePlayer player, RenderUi<Instance> renderer)
      {
        var instance = GetInstance<Instance>(player);
        if (instance == null)
          instance = new Instance(this, player, renderer);
        else
          instance.Renderer = renderer;

        InstanceCache[player.userID] = instance;
        return instance;
      }

      /// <summary>
      /// Build this element for the given player.
      /// </summary>
      /// <param name="player"></param>
      /// <param name="updatedElements"></param>
      /// <param name="parentHasUpdates"></param>
      /// <exception cref="Exception"></exception>
      public override void Build(BasePlayer player, List<Element.Instance> updatedElements, bool parentHasUpdates)
      {
        InstanceCache[player.userID].Build(updatedElements, parentHasUpdates);
      }

      public new class Instance : Element.Instance
      {
        public readonly CuiImageComponent Image = new CuiImageComponent();
        public bool CursorEnabled = false;
        public bool KeyboardEnabled = false;

        protected internal RenderUi<Instance> Renderer { get; set; }

        internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer) : base(element, player)
        {
          Renderer = renderer;
        }

        public override bool Render()
        {
          return Renderer(this);
        }

        public override IEnumerable<CuiElement> GetCuiElements()
        {
          CuiElement cuiElement = new CuiElement()
          {
            Name = Id,
            Parent = GetParentId(),
          };

          cuiElement.Components.Add(Image);
          cuiElement.Components.Add(Bounds.GetCuiComponent());

          if (CursorEnabled)
            cuiElement.Components.Add(new CuiNeedsCursorComponent());

          if (KeyboardEnabled)
            cuiElement.Components.Add(new CuiNeedsKeyboardComponent());

          return new CuiElement[] { cuiElement };
        }

        public void AddPanel(RenderUi<Instance> renderer)
        {
          PanelElement element = Initialized ? AddChild<PanelElement>() : AddChild(new PanelElement(Element));
          element.GetOrCreateInstance(Player, renderer);
        }

        public void AddLabel(RenderUi<LabelElement.Instance> renderer)
        {
          LabelElement element = Initialized ? AddChild<LabelElement>() : AddChild(new LabelElement(Element));
          element.GetOrCreateInstance(Player, renderer);
        }

        public void AddButton(RenderUi<ButtonElement.Instance> renderer)
        {
          ButtonElement element = Initialized ? AddChild<ButtonElement>() : AddChild(new ButtonElement(Element));
          element.GetOrCreateInstance(Player, renderer);
        }

        public void AddGameImage(RenderUi<GameImageElement.Instance> renderer)
        {
          GameImageElement element = Initialized ? AddChild<GameImageElement>() : AddChild(new GameImageElement(Element));
          element.GetOrCreateInstance(Player, renderer);
        }

        public void AddRawImage(RenderUi<RawImageElement.Instance> renderer)
        {
          RawImageElement element = Initialized ? AddChild<RawImageElement>() : AddChild(new RawImageElement(Element));
          element.GetOrCreateInstance(Player, renderer);
        }

        public void AddTabs(RenderUi<TabsElement.Instance> renderer)
        {
          TabsElement element = Initialized ? AddChild<TabsElement>() : AddChild(new TabsElement(Element));
          element.GetOrCreateInstance(Player, renderer);
        }

        public void AddGrid(RenderUi<GridElement.Instance> renderer)
        {
          GridElement element = Initialized ? AddChild<GridElement>() : AddChild(new GridElement(Element));
          element.GetOrCreateInstance(Player, renderer);
        }
      }
    }

    /// <summary>
    /// A Label
    /// </summary>
    public class LabelElement : Element
    {
      internal LabelElement(Element parent) : base(parent)
      {
      }

      public Instance GetOrCreateInstance(BasePlayer player, RenderUi<Instance> renderer)
      {
        var instance = GetInstance<Instance>(player);
        if (instance == null)
          instance = new Instance(this, player, renderer);
        else
          instance.Renderer = renderer;

        InstanceCache[player.userID] = instance;
        return instance;
      }

      /// <summary>
      /// Build this element for the given player.
      /// </summary>
      /// <param name="player"></param>
      /// <param name="updatedElements"></param>
      /// <param name="parentHasUpdates"></param>
      /// <exception cref="Exception"></exception>
      public override void Build(BasePlayer player, List<Element.Instance> updatedElements, bool parentHasUpdates)
      {
        InstanceCache[player.userID].Build(updatedElements, parentHasUpdates);
      }

      public new class Instance : Element.Instance
      {
        public readonly CuiTextComponent Text = new CuiTextComponent();

        protected internal RenderUi<Instance> Renderer { get; set; }

        internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer) : base(element, player)
        {
          Renderer = renderer;
        }

        public override bool Render()
        {
          return Renderer(this);
        }

        public override IEnumerable<CuiElement> GetCuiElements()
        {
          CuiElement cuiElement = new CuiElement()
          {
            Name = Id,
            Parent = GetParentId(),
          };

          if (!string.IsNullOrEmpty(Text?.Text))
            cuiElement.Components.Add(Text);

          cuiElement.Components.Add(Bounds.GetCuiComponent());

          return new CuiElement[] { cuiElement };
        }
      }
    }

    /// <summary>
    /// A Text Button
    /// </summary>
    public class ButtonElement : Element
    {
      internal ButtonElement(Element parent) : base(parent)
      {
      }

      public Instance GetOrCreateInstance(BasePlayer player, RenderUi<Instance> renderer)
      {
        var instance = GetInstance<Instance>(player);
        if (instance == null)
          instance = new Instance(this, player, renderer);
        else
          instance.Renderer = renderer;

        InstanceCache[player.userID] = instance;
        return instance;
      }

      /// <summary>
      /// Build this element for the given player.
      /// </summary>
      /// <param name="player"></param>
      /// <param name="updatedElements"></param>
      /// <param name="parentHasUpdates"></param>
      /// <exception cref="Exception"></exception>
      public override void Build(BasePlayer player, List<Element.Instance> updatedElements, bool parentHasUpdates)
      {
        InstanceCache[player.userID].Build(updatedElements, parentHasUpdates);
      }

      public new class Instance : Element.Instance
      {
        public readonly CuiButtonComponent Button = new CuiButtonComponent();
        public readonly CuiTextComponent Text = new CuiTextComponent();

        protected internal RenderUi<Instance> Renderer { get; set; }

        internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer) : base(element, player)
        {
          Renderer = renderer;
        }

        public override bool Render()
        {
          return Renderer(this);
        }

        public override IEnumerable<CuiElement> GetCuiElements()
        {
          var cuiElements = new List<CuiElement>
          {
            new CuiElement()
            {
              Name = Id,
              Parent = GetParentId(),
              Components =
              {
                Button,
                Bounds.GetCuiComponent()
              }
            }
          };

          if (!string.IsNullOrEmpty(Text?.Text))
          {
            cuiElements.Add(new CuiElement
            {
              Name = CuiHelper.GetGuid(),
              Parent = Id,
              Components = {
                Text,
                new CuiRectTransformComponent()
              }
            });
          }

          return cuiElements;
        }
      }
    }

    /// <summary>
    /// A raw image.
    /// </summary>
    public class RawImageElement : Element
    {
      internal RawImageElement(Element parent) : base(parent)
      {
      }

      public Instance GetOrCreateInstance(BasePlayer player, RenderUi<Instance> renderer)
      {
        var instance = GetInstance<Instance>(player);
        if (instance == null)
          instance = new Instance(this, player, renderer);
        else
          instance.Renderer = renderer;

        InstanceCache[player.userID] = instance;
        return instance;
      }

      /// <summary>
      /// Build this element for the given player.
      /// </summary>
      /// <param name="player"></param>
      /// <param name="updatedElements"></param>
      /// <param name="parentHasUpdates"></param>
      /// <exception cref="Exception"></exception>
      public override void Build(BasePlayer player, List<Element.Instance> updatedElements, bool parentHasUpdates)
      {
        InstanceCache[player.userID].Build(updatedElements, parentHasUpdates);
      }

      public new class Instance : Element.Instance
      {
        public readonly CuiRawImageComponent Image = new CuiRawImageComponent();

        protected internal RenderUi<Instance> Renderer { get; set; }

        internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer) : base(element, player)
        {
          Renderer = renderer;
        }

        public override bool Render()
        {
          return Renderer(this);
        }

        public override IEnumerable<CuiElement> GetCuiElements()
        {
          CuiElement cuiElement = new CuiElement()
          {
            Name = Id,
            Parent = GetParentId(),
            Components = {
              Image,
              Bounds.GetCuiComponent()
            }
          };

          return new CuiElement[] { cuiElement };
        }
      }
    }

    /// <summary>
    /// An game image.
    /// </summary>
    public class GameImageElement : Element
    {
      internal GameImageElement(Element parent) : base(parent)
      {
      }

      public Instance GetOrCreateInstance(BasePlayer player, RenderUi<Instance> renderer)
      {
        var instance = GetInstance<Instance>(player);
        if (instance == null)
          instance = new Instance(this, player, renderer);
        else
          instance.Renderer = renderer;

        InstanceCache[player.userID] = instance;
        return instance;
      }

      /// <summary>
      /// Build this element for the given player.
      /// </summary>
      /// <param name="player"></param>
      /// <param name="updatedElements"></param>
      /// <param name="parentHasUpdates"></param>
      /// <exception cref="Exception"></exception>
      public override void Build(BasePlayer player, List<Element.Instance> updatedElements, bool parentHasUpdates)
      {
        InstanceCache[player.userID].Build(updatedElements, parentHasUpdates);
      }

      public new class Instance : Element.Instance
      {
        public readonly CuiImageComponent Image = new CuiImageComponent();
        protected internal RenderUi<Instance> Renderer { get; set; }

        internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer) : base(element, player)
        {
          Renderer = renderer;
        }

        public override bool Render()
        {
          return Renderer(this);
        }

        public override IEnumerable<CuiElement> GetCuiElements()
        {
          CuiElement cuiElement = new CuiElement()
          {
            Name = Id,
            Parent = GetParentId(),
            Components = {
              Image,
              Bounds.GetCuiComponent()
            }
          };

          return new CuiElement[] { cuiElement };
        }
      }
    }

    /// <summary>
    /// Text Tabs
    /// </summary>
    public class TabsElement : PanelElement
    {
      internal TabsElement(Element parent) : base(parent)
      {
      }

      public Instance GetOrCreateInstance(BasePlayer player, RenderUi<Instance> renderer)
      {
        var instance = GetInstance<Instance>(player);
        if (instance == null)
          instance = new Instance(this, player, renderer);
        else
          instance.Renderer = renderer;

        InstanceCache[player.userID] = instance;
        return instance;
      }

      public new class Instance : PanelElement.Instance
      {
        public bool Vertical = false;
        public double Gap = 0;
        public double MaxButtonSize = 0;

        private int _BuildingTabIndex = 0;
        private int TabsCount = 0;

        protected internal new RenderUi<Instance> Renderer { get; set; }

        internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer) : base(element, player, null)
        {
          Renderer = renderer;
        }

        public override bool Render()
        {
          _BuildingTabIndex = 0;
          return Renderer(this);
        }

        public void AddTab(RenderUi<ButtonElement.Instance> renderer)
        {
          if (!Initialized)
          {
            TabsCount++;
          }

          AddButton((button) =>
          {
            SetTabDefaults(button);
            _BuildingTabIndex++;
            return renderer(button);
          });
        }

        private void SetTabDefaults(ButtonElement.Instance button)
        {
          var gapSize = Gap;
          var buttonSize = 1.0 / TabsCount - gapSize * (TabsCount - 1) / TabsCount;
          buttonSize = MaxButtonSize > 0 ? Math.Min(buttonSize, MaxButtonSize) : buttonSize;
          var offset = (double)_BuildingTabIndex / TabsCount * (1 + gapSize);

          if (Vertical)
          {
            button.Bounds.MinX = 0;
            button.Bounds.MaxX = 1;
            button.Bounds.MinY = 1 - offset - buttonSize;
            button.Bounds.MaxY = 1 - offset;
          }
          else
          {
            button.Bounds.MinX = offset;
            button.Bounds.MaxX = offset + buttonSize;
            button.Bounds.MinY = 0;
            button.Bounds.MaxY = 1;
          }
        }
      }
    }

    /// <summary>
    /// A Grid of panels
    /// </summary>
    public class GridElement : PanelElement
    {
      internal GridElement(Element parent) : base(parent)
      {
      }

      public Instance GetOrCreateInstance(BasePlayer player, RenderUi<Instance> renderer)
      {
        var instance = GetInstance<Instance>(player);
        if (instance == null)
          instance = new Instance(this, player, renderer);
        else
          instance.Renderer = renderer;

        InstanceCache[player.userID] = instance;
        return instance;
      }

      public new class Instance : PanelElement.Instance
      {
        public double GapX = 0;
        public double GapY = 0;

        public int Rows = 2;
        public int Columns = 2;

        private int _BuildingCellIndex = 0;

        protected internal new RenderUi<Instance> Renderer { get; set; }

        internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer) : base(element, player, null)
        {
          Renderer = renderer;
        }

        public override bool Render()
        {
          _BuildingCellIndex = 0;
          return Renderer(this);
        }

        public void AddCell(RenderUi<PanelElement.Instance> renderer)
        {
          AddPanel((cell) =>
          {
            SetCellDefaults(cell);
            _BuildingCellIndex++;
            return renderer(cell);
          });
        }

        private void SetCellDefaults(PanelElement.Instance cell)
        {
          var column = _BuildingCellIndex % Columns;
          var width = 1.0 / Columns - GapX * (Columns - 1) / Columns;
          var offsetX = (double)column / Columns * (1 + GapX);

          var row = _BuildingCellIndex / Columns;
          var height = 1.0 / Rows - GapY * (Rows - 1) / Rows;
          var offsetY = (double)row / Rows * (1 + GapY);

          cell.Bounds.MinX = offsetX;
          cell.Bounds.MaxX = offsetX + width;
          cell.Bounds.MinY = 1 - offsetY - height;
          cell.Bounds.MaxY = 1 - offsetY;
        }
      }
    }

    #endregion API classes
  }
}


// --- End of file: UiBuilderLibrary.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ui-plus ---
// --- Original File Path: U/UiPlus/UiPlus.cs ---

// Requires: ImageLibrary

//#define UNITY_ASSERTIONS
//#define DEBUG

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;

using Newtonsoft.Json;

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;

using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.UI;

namespace Oxide.Plugins
{
    [Info("UiPlus", "2CHEVSKII", "2.1.0")]
    [Description("Adds various custom elements to the user interface")]
    class UiPlus : CovalencePlugin
    {
        const string ICON_CLOCK            = "https://i.imgur.com/K53fjzg.png",
                     ICON_ACTIVE_PLAYERS   = "https://i.imgur.com/r7L4jW2.png",
                     ICON_SLEEPING_PLAYERS = "https://i.imgur.com/D0JFYfe.png",
                     ICON_SERVER_REWARDS   = "https://i.imgur.com/tpSErWL.png",
                     ICON_ECONOMICS        = "https://i.imgur.com/KH9NcrC.png";

        const string PERMISSION_SEE = "uiplus.see";

        static UiPlus Instance;
        static ulong  ImageId = unchecked((ulong)nameof(UiPlus).GetHashCode() + 13);

        [PluginReference] Plugin ImageLibrary;
        [PluginReference] Plugin ServerRewards;
        [PluginReference] Plugin Economics;

        PluginSettings settings;
        bool           iconsReady;

        [Conditional("DEBUG")]
        static void DebugLog(string format, params object[] args)
        {
            Interface.Oxide.LogDebug("[UiPlus] " + format, args);
        }

        void Init()
        {
            Instance = this;

            permission.RegisterPermission(PERMISSION_SEE, this);
        }

        void OnServerInitialized()
        {
            CacheIcons();
        }

        void OnUserConnected(IPlayer player)
        {
            UiPlusComponent.OnPlayerConnected((BasePlayer)player.Object);
        }

        void OnUserDisconnected(IPlayer player)
        {
            UiPlusComponent.OnPlayerDisconnected((BasePlayer)player.Object);
        }

        void Unload()
        {
            UiPlusComponent.Dispose();
            Instance = null;
        }

        void CacheIcons()
        {
            ImageLibrary.Call(
                "ImportImageList",
                nameof(UiPlus),
                new Dictionary<string, string> {
                    { "Clock", settings.Clock.IconUrl },
                    { "ActivePlayers", settings.ActivePlayers.IconUrl },
                    { "SleepingPlayers", settings.SleepingPlayers.IconUrl },
                    { "ServerRewards", settings.ServerRewards.IconUrl },
                    { "Economics", settings.Economics.IconUrl }
                },
                ImageId,
                false,
                new Action(
                    () =>
                    {
                        iconsReady = true;
                        UiPlusComponent.Initialize(settings);
                    }
                )
            );
        }

        #region Configuration load

        protected override void LoadDefaultConfig()
        {
            settings = PluginSettings.Default;
            SaveConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                bool hasChanged = false;
                settings = Config.ReadObject<PluginSettings>();

                if (settings == null)
                {
                    LogWarning("Plugin settings appear to be null: resetting to default...");
                    settings = PluginSettings.Default;
                    hasChanged = true;
                }

                if (settings.Clock == null)
                {
                    LogWarning("Clock settings appear to be null: resetting to default...");
                    settings.Clock = PluginSettings.Default.Clock;
                    hasChanged = true;
                }

                if (settings.ActivePlayers == null)
                {
                    LogWarning("ActivePlayers settings appear to be null: resetting to default...");
                    settings.ActivePlayers = PluginSettings.Default.ActivePlayers;
                    hasChanged = true;
                }

                if (settings.SleepingPlayers == null)
                {
                    LogWarning("SleepingPlayers settings appear to be null: resetting to default...");
                    settings.SleepingPlayers = PluginSettings.Default.SleepingPlayers;
                    hasChanged = true;
                }

                if (settings.ServerRewards == null)
                {
                    LogWarning("ServerRewards settings appear to be null: resetting to default...");
                    settings.ServerRewards = PluginSettings.Default.ServerRewards;
                    hasChanged = true;
                }

                if (settings.Economics == null)
                {
                    LogWarning("Economics settings appear to be null: resetting to default...");
                    settings.Economics = PluginSettings.Default.Economics;
                    hasChanged = true;
                }

                if (settings.Clock.IconUrl == null)
                {
                    LogWarning("Clock icon appears to be null: resetting to default...");
                    settings.Clock.IconUrl = ICON_CLOCK;
                    hasChanged = true;
                }

                if (settings.ActivePlayers.IconUrl == null)
                {
                    LogWarning("Active players icon appears to be null: resetting to default...");
                    settings.ActivePlayers.IconUrl = ICON_ACTIVE_PLAYERS;
                    hasChanged = true;
                }

                if (settings.SleepingPlayers.IconUrl == null)
                {
                    LogWarning("Sleeping players icon appears to be null: resetting to default...");
                    settings.SleepingPlayers.IconUrl = ICON_SLEEPING_PLAYERS;
                    hasChanged = true;
                }

                if (settings.ServerRewards.IconUrl == null)
                {
                    LogWarning("ServerRewards icon appears to be null: resetting to default...");
                    settings.ServerRewards.IconUrl = ICON_SERVER_REWARDS;
                    hasChanged = true;
                }

                if (settings.Economics.IconUrl == null)
                {
                    LogWarning("Economics icon appears to be null: resetting to default...");
                    settings.Economics.IconUrl = ICON_ECONOMICS;
                    hasChanged = true;
                }

                if (hasChanged)
                {
                    LogWarning("Configuration was updated, saving...");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError("Configuration failed to load: {0}", e.Message);
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(settings);
        }

        #endregion

        class UiPlusComponent : FacepunchBehaviour
        {
            const string PANEL_MATERIAL = "assets/content/ui/uibackgroundblur.mat";

            const string NAME_CLOCK_PANEL = "uiplus.ui::clock-panel",
                         NAME_CLOCK_TEXT  = "uiplus.ui::clock-text",
                         NAME_CLOCK_ICON  = "uiplus.ui::clock-icon",
                         NAME_AP_PANEL    = "uiplus.ui::activeplayers-panel",
                         NAME_AP_TEXT     = "uiplus.ui::activeplayers-text",
                         NAME_AP_ICON     = "uiplus.ui::activeplayers-icon",
                         NAME_SP_PANEL    = "uiplus.ui::sleepingplayers-panel",
                         NAME_SP_TEXT     = "uiplus.ui::sleepingplayers-text",
                         NAME_SP_ICON     = "uiplus.ui::sleepingplayers-icon",
                         NAME_SR_PANEL    = "uiplus.ui::serverrewards-panel",
                         NAME_SR_TEXT     = "uiplus.ui::serverrewards-text",
                         NAME_SR_ICON     = "uiplus.ui::serverrewards-icon",
                         NAME_ECO_PANEL   = "uiplus.ui::economics-panel",
                         NAME_ECO_TEXT    = "uiplus.ui::economics-text",
                         NAME_ECO_ICON    = "uiplus.ui::economics-icon";

            const string COLOR_PANEL = "0.6 0.6 0.6 0.1",
                         COLOR_ICON  = "1 1 1 0.9",
                         COLOR_TEXT  = "0.9 0.9 0.9 0.75";

            const string TEXT_PLACEHOLDER = "__text__";

            static HashSet<UiPlusComponent> AllComponents;

            static string ClockPanel,
                          ActivePlayersPanel,
                          SleepingPlayersPanel,
                          ServerRewardsPanel,
                          EconomicsPanel,
                          ClockIcon,
                          ActivePlayersIcon,
                          SleepingPlayersIcon,
                          ServerRewardsIcon,
                          EconomicsIcon,
                          ClockText,
                          ActivePlayersText,
                          SleepingPlayersText,
                          ServerRewardsText,
                          EconomicsText;

            static string RecentClockText,
                          RecentApText,
                          RecentSpText;

            static int lastActivePlayers,
                       lastSleepingPlayers;

            static float lastClockUpdate;

            static StringBuilder Builder;

            int lastSrPts, lastEcoPts;

            bool isSRLoaded,
                 isEcoLoaded,
                 isVisible;

            BasePlayer     player;
            PluginSettings Settings;

            bool IsVisible
            {
                get { return isVisible; }
                set
                {
                    if (value == isVisible)
                    {
                        return;
                    }

                    SetVisible(value);
                }
            }

            #region Public API

            public static void Initialize(PluginSettings settings)
            {
                Assert.IsNull(AllComponents, "Calling Initialize while AllComponents is not null!");

                AllComponents = new HashSet<UiPlusComponent>();

                Builder = new StringBuilder();

                BuildUi();

                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    OnPlayerConnected(player);
                }
            }

            public static void Dispose()
            {
                AllComponents?.ToList()?.ForEach(Destroy);

                AllComponents = null;
                Builder = null;

                ClockPanel = ClockIcon = ClockText = ActivePlayersPanel = ActivePlayersIcon =
                    ActivePlayersText = SleepingPlayersPanel = SleepingPlayersIcon = SleepingPlayersText = null;

                RecentClockText = RecentApText = RecentSpText = null;

                lastClockUpdate = 0;
                lastActivePlayers = 0;
                lastSleepingPlayers = 0;
            }

            public static void OnPlayerConnected(BasePlayer player)
            {
                if (AllComponents != null && player.IPlayer.HasPermission(PERMISSION_SEE))
                {
                    player.gameObject.AddComponent<UiPlusComponent>();
                }
            }

            public static void OnPlayerDisconnected(BasePlayer player)
            {
                Destroy(player.gameObject.GetComponent<UiPlusComponent>());
            }

            #endregion

            #region Ui building helpers

            static void BuildUi()
            {
                Assert.IsNull(ClockPanel, "Using BuildUi while ClockPanel is not null!");
                Assert.IsNull(ActivePlayersPanel, "Using BuildUi while ActivePlayersPanel is not null!");
                Assert.IsNull(SleepingPlayersPanel, "Using BuildUi while SleepingPlayersPanel is not null!");

                DebugLog("Building UI...");

                CuiElementContainer reusableContainer = new CuiElementContainer();

                reusableContainer.Add(
                    new CuiElement {
                        Name = NAME_CLOCK_PANEL,
                        Parent = "Hud",
                        Components = {
                            new CuiImageComponent {
                                Color = COLOR_PANEL,
                                ImageType = Image.Type.Simple,
                                Material = PANEL_MATERIAL
                            },
                            GetPanelTransform(
                                Instance.settings.Clock.PosX,
                                Instance.settings.Clock.PosY,
                                Instance.settings.Clock.Scale
                            )
                        }
                    }
                );

                ClockPanel = CuiHelper.ToJson(reusableContainer);

                reusableContainer.Clear();

                reusableContainer.Add(
                    new CuiElement {
                        Name = NAME_CLOCK_ICON,
                        Parent = NAME_CLOCK_PANEL,
                        Components = {
                            new CuiRawImageComponent {
                                Color = COLOR_ICON,
                                Png = Instance.ImageLibrary.Call<string>("GetImage", "Clock", ImageId)
                            },
                            GetIconTransform()
                        }
                    }
                );

                ClockIcon = CuiHelper.ToJson(reusableContainer);

                reusableContainer.Clear();

                reusableContainer.Add(
                    new CuiElement {
                        Name = NAME_CLOCK_TEXT,
                        Parent = NAME_CLOCK_PANEL,
                        Components = {
                            new CuiTextComponent {
                                Color = COLOR_TEXT,
                                Align = TextAnchor.MiddleCenter,
                                Text = TEXT_PLACEHOLDER,
                                FontSize = Instance.settings.Clock.FontSize
                            },
                            new CuiRectTransformComponent {
                                AnchorMin = "0.4 0",
                                AnchorMax = "1 1"
                            }
                        }
                    }
                );

                ClockText = CuiHelper.ToJson(reusableContainer);

                reusableContainer.Clear();

                reusableContainer.Add(
                    new CuiElement {
                        Name = NAME_AP_PANEL,
                        Parent = "Hud",
                        Components = {
                            new CuiImageComponent {
                                Color = COLOR_PANEL,
                                ImageType = Image.Type.Simple,
                                Material = PANEL_MATERIAL
                            },
                            GetPanelTransform(
                                Instance.settings.ActivePlayers.PosX,
                                Instance.settings.ActivePlayers.PosY,
                                Instance.settings.ActivePlayers.Scale
                            )
                        }
                    }
                );

                ActivePlayersPanel = CuiHelper.ToJson(reusableContainer);

                reusableContainer.Clear();

                reusableContainer.Add(
                    new CuiElement {
                        Name = NAME_AP_ICON,
                        Parent = NAME_AP_PANEL,
                        Components = {
                            new CuiRawImageComponent {
                                Color = COLOR_ICON,
                                Png = Instance.ImageLibrary.Call<string>("GetImage", "ActivePlayers", ImageId)
                            },
                            GetIconTransform()
                        }
                    }
                );

                ActivePlayersIcon = CuiHelper.ToJson(reusableContainer);

                reusableContainer.Clear();

                reusableContainer.Add(
                    new CuiElement {
                        Name = NAME_AP_TEXT,
                        Parent = NAME_AP_PANEL,
                        Components = {
                            new CuiTextComponent {
                                Color = COLOR_TEXT,
                                Align = TextAnchor.MiddleCenter,
                                Text = TEXT_PLACEHOLDER,
                                FontSize = Instance.settings.ActivePlayers.FontSize
                            },
                            new CuiRectTransformComponent {
                                AnchorMin = "0.4 0",
                                AnchorMax = "1 1"
                            }
                        }
                    }
                );

                ActivePlayersText = CuiHelper.ToJson(reusableContainer);

                reusableContainer.Clear();

                reusableContainer.Add(
                    new CuiElement {
                        Name = NAME_SP_PANEL,
                        Parent = "Hud",
                        Components = {
                            new CuiImageComponent {
                                Color = COLOR_PANEL,
                                ImageType = Image.Type.Simple,
                                Material = PANEL_MATERIAL
                            },
                            GetPanelTransform(
                                Instance.settings.SleepingPlayers.PosX,
                                Instance.settings.SleepingPlayers.PosY,
                                Instance.settings.SleepingPlayers.Scale
                            )
                        }
                    }
                );

                SleepingPlayersPanel = CuiHelper.ToJson(reusableContainer);

                reusableContainer.Clear();

                reusableContainer.Add(
                    new CuiElement {
                        Name = NAME_SP_ICON,
                        Parent = NAME_SP_PANEL,
                        Components = {
                            new CuiRawImageComponent {
                                Color = COLOR_ICON,
                                Png = Instance.ImageLibrary.Call<string>("GetImage", "SleepingPlayers", ImageId)
                            },
                            GetIconTransform()
                        }
                    }
                );

                SleepingPlayersIcon = CuiHelper.ToJson(reusableContainer);

                reusableContainer.Clear();

                reusableContainer.Add(
                    new CuiElement {
                        Name = NAME_SP_TEXT,
                        Parent = NAME_SP_PANEL,
                        Components = {
                            new CuiTextComponent {
                                Color = COLOR_TEXT,
                                Align = TextAnchor.MiddleCenter,
                                Text = TEXT_PLACEHOLDER,
                                FontSize = Instance.settings.SleepingPlayers.FontSize
                            },
                            new CuiRectTransformComponent {
                                AnchorMin = "0.4 0",
                                AnchorMax = "1 1"
                            }
                        }
                    }
                );

                SleepingPlayersText = CuiHelper.ToJson(reusableContainer);

                reusableContainer.Clear();

                reusableContainer.Add(
                    new CuiElement {
                        Name = NAME_SR_PANEL,
                        Parent = "Hud",
                        Components = {
                            new CuiImageComponent {
                                Color = COLOR_PANEL,
                                ImageType = Image.Type.Simple,
                                Material = PANEL_MATERIAL
                            },
                            GetPanelTransform(
                                Instance.settings.ServerRewards.PosX,
                                Instance.settings.ServerRewards.PosY,
                                Instance.settings.ServerRewards.Scale
                            )
                        }
                    }
                );

                ServerRewardsPanel = CuiHelper.ToJson(reusableContainer);

                reusableContainer.Clear();

                reusableContainer.Add(
                    new CuiElement {
                        Name = NAME_SR_ICON,
                        Parent = NAME_SR_PANEL,
                        Components = {
                            new CuiRawImageComponent {
                                Color = COLOR_ICON,
                                Png = Instance.ImageLibrary.Call<string>("GetImage", "ServerRewards", ImageId)
                            },
                            GetIconTransform()
                        }
                    }
                );

                ServerRewardsIcon = CuiHelper.ToJson(reusableContainer);

                reusableContainer.Clear();

                reusableContainer.Add(
                    new CuiElement {
                        Name = NAME_SR_TEXT,
                        Parent = NAME_SR_PANEL,
                        Components = {
                            new CuiTextComponent {
                                Color = COLOR_TEXT,
                                Align = TextAnchor.MiddleCenter,
                                Text = TEXT_PLACEHOLDER,
                                FontSize = Instance.settings.ServerRewards.FontSize
                            },
                            new CuiRectTransformComponent {
                                AnchorMin = "0.4 0",
                                AnchorMax = "1 1"
                            }
                        }
                    }
                );

                ServerRewardsText = CuiHelper.ToJson(reusableContainer);

                reusableContainer.Clear();

                reusableContainer.Add(
                    new CuiElement {
                        Name = NAME_ECO_PANEL,
                        Parent = "Hud",
                        Components = {
                            new CuiImageComponent {
                                Color = COLOR_PANEL,
                                ImageType = Image.Type.Simple,
                                Material = PANEL_MATERIAL
                            },
                            GetPanelTransform(
                                Instance.settings.Economics.PosX,
                                Instance.settings.Economics.PosY,
                                Instance.settings.Economics.Scale
                            )
                        }
                    }
                );

                EconomicsPanel = CuiHelper.ToJson(reusableContainer);

                reusableContainer.Clear();

                reusableContainer.Add(
                    new CuiElement {
                        Name = NAME_ECO_ICON,
                        Parent = NAME_ECO_PANEL,
                        Components = {
                            new CuiRawImageComponent {
                                Color = COLOR_ICON,
                                Png = Instance.ImageLibrary.Call<string>("GetImage", "Economics", ImageId)
                            },
                            GetIconTransform()
                        }
                    }
                );

                EconomicsIcon = CuiHelper.ToJson(reusableContainer);

                reusableContainer.Clear();

                reusableContainer.Add(
                    new CuiElement {
                        Name = NAME_ECO_TEXT,
                        Parent = NAME_ECO_PANEL,
                        Components = {
                            new CuiTextComponent {
                                Color = COLOR_TEXT,
                                Align = TextAnchor.MiddleCenter,
                                Text = TEXT_PLACEHOLDER,
                                FontSize = Instance.settings.Economics.FontSize
                            },
                            new CuiRectTransformComponent {
                                AnchorMin = "0.4 0",
                                AnchorMax = "1 1"
                            }
                        }
                    }
                );

                EconomicsText = CuiHelper.ToJson(reusableContainer);

                UpdateClockText();
                UpdateActivePlayersText();
                UpdateSleepingPlayersText();

                DebugLog("UI building done");
            }

            static CuiRectTransformComponent GetPanelTransform(float x, float y, float scale)
            {
                return new CuiRectTransformComponent {
                    AnchorMin = $"{x} {y}",
                    AnchorMax = $"{x} {y}",
                    OffsetMin = $"{-35 * scale} {-15 * scale}",
                    OffsetMax = $"{35 * scale} {15 * scale}"
                };
            }

            static CuiRectTransformComponent GetIconTransform()
            {
                return new CuiRectTransformComponent {
                    AnchorMin = "0.05 0.1",
                    AnchorMax = "0.4 0.9"
                };
            }

            static string ReplaceText(string ui, string newText)
            {
                DebugLog("Replacing text with {0}", newText);

                return ui.Replace(TEXT_PLACEHOLDER, newText);
            }

            static string FormatTime(TimeSpan time, string format)
            {
                if (format.StartsWith("24::"))
                {
                    return FormatTime(time, format.Substring(4), true);
                }

                if (format.StartsWith("12::"))
                {
                    return FormatTime(time, format.Substring(4), false);
                }

                throw new FormatException($"Unknown time format: {format}");
            }

            static string FormatTime(TimeSpan time, string format, bool _24)
            {
                Builder.Append(format);

                Builder.Replace("hh", _24 ? time.Hours.ToString("00") : (time.Hours % 12.00001).ToString("00"))
                       .Replace("mm", time.Minutes.ToString("00"))
                       .Replace("ss", time.Seconds.ToString("00"));

                Builder.Replace("h", _24 ? time.Hours.ToString("0") : (time.Hours % 12.00001).ToString("0"))
                       .Replace("m", time.Minutes.ToString("0"))
                       .Replace("s", time.Seconds.ToString("0"));

                if (Instance.settings.UiClockFormatAppendAmPm && !_24)
                {
                    Builder.Append(time.Hours > 11 ? "PM" : "AM");
                }

                string str = Builder.ToString();

                DebugLog("Done formatting time: {0}", str);

                Builder.Clear();

                return str;
            }

            static TimeSpan GetServerTime()
            {
                return TOD_Sky.Instance.Cycle.DateTime.TimeOfDay;
            }

            static void UpdateClockText()
            {
                RecentClockText = ReplaceText(ClockText, FormatTime(GetServerTime(), Instance.settings.UiClockFormat));

                DebugLog("New Clock text:\n{0}", RecentClockText);

                lastClockUpdate = Time.realtimeSinceStartup;
            }

            static void UpdateActivePlayersText()
            {
                lastActivePlayers = BasePlayer.activePlayerList.Count;
                RecentApText = ReplaceText(ActivePlayersText, lastActivePlayers.ToString());
            }

            static void UpdateSleepingPlayersText()
            {
                lastSleepingPlayers = BasePlayer.sleepingPlayerList.Count;
                RecentSpText = ReplaceText(SleepingPlayersText, lastSleepingPlayers.ToString());
            }

            #endregion

            #region Unity Messages

            void Awake()
            {
                Assert.IsTrue(Instance.iconsReady, "Initializing component before icons were cached!");
                Assert.IsNotNull(AllComponents, "Initializing component while AllComponents is null!");

                player = GetComponent<BasePlayer>();

                Assert.IsNotNull(player, "Player is null in Awake!");

                AllComponents.Add(this);

                Settings = Instance.settings;

                isSRLoaded = Instance.ServerRewards && Instance.ServerRewards.IsLoaded;
                isEcoLoaded = Instance.Economics && Instance.Economics.IsLoaded;

                ResetMyPts();

                InvokeRepeating(UiTick, Settings.UiUpdateInterval, Settings.UiUpdateInterval);
            }

            void OnDestroy()
            {
                CancelInvoke(UiTick);
                IsVisible = false;

                if (AllComponents != null)
                {
                    AllComponents.Remove(this);
                }
            }

            #endregion

            void ResetMyPts()
            {
                lastSrPts = -1;
                lastEcoPts = -1;
            }

            int GetMySrPts()
            {
                object points = Instance.ServerRewards.Call("CheckPoints", player.userID);

                if (points is int)
                {
                    return (int)points;
                }

                return 0;
            }

            int GetMyEcoPts()
            {
                object balance = Instance.Economics.Call("Balance", player.userID);

                return (int)(double)balance;
            }

            void SetVisible(bool wantsVisible)
            {
                Assert.IsFalse(isVisible == wantsVisible, "Using SetVisible to set the same value!!!");

                DebugLog("Setting panels visible to {0} for player: {1}", wantsVisible, player.displayName);

                if (Settings.Clock.Enable)
                {
                    if (wantsVisible)
                    {
                        CuiHelper.AddUi(player, ClockPanel);
                        CuiHelper.AddUi(player, ClockIcon);
                    }
                    else
                    {
                        CuiHelper.DestroyUi(player, NAME_CLOCK_PANEL);
                    }
                }

                if (Settings.ActivePlayers.Enable)
                {
                    if (wantsVisible)
                    {
                        CuiHelper.AddUi(player, ActivePlayersPanel);
                        CuiHelper.AddUi(player, ActivePlayersIcon);
                    }
                    else
                    {
                        CuiHelper.DestroyUi(player, NAME_AP_PANEL);
                    }
                }

                if (Settings.SleepingPlayers.Enable)
                {
                    if (wantsVisible)
                    {
                        CuiHelper.AddUi(player, SleepingPlayersPanel);
                        CuiHelper.AddUi(player, SleepingPlayersIcon);
                    }
                    else
                    {
                        CuiHelper.DestroyUi(player, NAME_SP_PANEL);
                    }
                }

                if (Settings.ServerRewards.Enable && isSRLoaded)
                {
                    if (wantsVisible)
                    {
                        CuiHelper.AddUi(player, ServerRewardsPanel);
                        CuiHelper.AddUi(player, ServerRewardsIcon);
                    }
                    else
                    {
                        CuiHelper.DestroyUi(player, NAME_SR_PANEL);
                        ResetMyPts();
                    }
                }

                if (Settings.Economics.Enable && isEcoLoaded)
                {
                    if (wantsVisible)
                    {
                        CuiHelper.AddUi(player, EconomicsPanel);
                        CuiHelper.AddUi(player, EconomicsIcon);
                    }
                    else
                    {
                        CuiHelper.DestroyUi(player, NAME_ECO_PANEL);
                        ResetMyPts();
                    }
                }

                isVisible = wantsVisible;
            }

            void UiTick()
            {
                if (!player.IsDead() && !player.IsSleeping())
                {
                    DebugLog(
                        "Ui tick on player {0}",
                        player.displayName
                    );

                    IsVisible = true;
                    UpdateText(
                        Settings.Clock.Enable,
                        Settings.ActivePlayers.Enable,
                        Settings.SleepingPlayers.Enable,
                        Settings.ServerRewards.Enable && isSRLoaded,
                        Settings.Economics.Enable && isEcoLoaded
                    );
                }
            }

            void UpdateText(
                bool updateClock,
                bool updateActivePlayers,
                bool updateSleepingPlayers,
                bool updateServerRewards,
                bool updateEconomics
            )
            {
                if (updateClock)
                {
                    if (Time.realtimeSinceStartup - lastClockUpdate > Settings.UiUpdateInterval)
                    {
                        DebugLog("Calling UpdateClockText");
                        UpdateClockText();
                    }

                    DebugLog("Re-Rendering clock text");
                    CuiHelper.DestroyUi(player, NAME_CLOCK_TEXT);

                    DebugLog("Sending clock text to player {0}:\n{1}", player.displayName, ClockText);

                    CuiHelper.AddUi(player, RecentClockText);
                }

                if (updateActivePlayers)
                {
                    if (BasePlayer.activePlayerList.Count != lastActivePlayers)
                    {
                        UpdateActivePlayersText();
                    }

                    CuiHelper.DestroyUi(player, NAME_AP_TEXT);
                    CuiHelper.AddUi(player, RecentApText);
                }

                if (updateSleepingPlayers)
                {
                    if (BasePlayer.sleepingPlayerList.Count != lastSleepingPlayers)
                    {
                        UpdateSleepingPlayersText();
                    }

                    CuiHelper.DestroyUi(player, NAME_SP_TEXT);
                    CuiHelper.AddUi(player, RecentSpText);
                }

                if (updateServerRewards)
                {
                    int newPts = GetMySrPts();

                    if (newPts != lastSrPts)
                    {
                        CuiHelper.DestroyUi(player, NAME_SR_TEXT);
                        CuiHelper.AddUi(player, ReplaceText(ServerRewardsText, newPts.ToString()));
                        lastSrPts = newPts;
                    }
                }

                if (updateEconomics)
                {
                    int newPts = GetMyEcoPts();

                    if (newPts != lastEcoPts)
                    {
                        CuiHelper.DestroyUi(player, NAME_ECO_TEXT);
                        CuiHelper.AddUi(player, ReplaceText(EconomicsText, newPts.ToString()));
                        lastEcoPts = newPts;
                    }
                }
            }
        }

        class PluginSettings
        {
            public static PluginSettings Default => new PluginSettings {
                Clock = new PanelSettings {
                    Enable = true,
                    PosX = 0.04f,
                    PosY = 0.046f,
                    Scale = 1f,
                    IconUrl = ICON_CLOCK,
                    FontSize = 15
                },
                ActivePlayers = new PanelSettings {
                    Enable = true,
                    PosX = 0.097f,
                    PosY = 0.046f,
                    Scale = 1f,
                    IconUrl = ICON_ACTIVE_PLAYERS,
                    FontSize = 15
                },
                SleepingPlayers = new PanelSettings {
                    Enable = true,
                    PosX = 0.154f,
                    PosY = 0.046f,
                    Scale = 1f,
                    IconUrl = ICON_SLEEPING_PLAYERS,
                    FontSize = 15
                },
                ServerRewards = new PanelSettings {
                    Enable = false,
                    PosX = 0.211f,
                    PosY = 0.046f,
                    Scale = 1f,
                    IconUrl = ICON_SERVER_REWARDS,
                    FontSize = 15
                },
                Economics = new PanelSettings {
                    Enable = false,
                    PosX = 0.268f,
                    PosY = 0.046f,
                    Scale = 1f,
                    IconUrl = ICON_ECONOMICS,
                    FontSize = 15
                },
                UiUpdateInterval = 2f,
                UiClockFormat = "24::hh:mm", // 12::/24::, (hh):(mm):(ss) (h|m|s)
                UiClockFormatAppendAmPm = false
            };

            [JsonProperty("Clock")] public PanelSettings Clock { get; set; }
            [JsonProperty("Active players")] public PanelSettings ActivePlayers { get; set; }
            [JsonProperty("Sleeping players")] public PanelSettings SleepingPlayers { get; set; }
            [JsonProperty("Server rewards")] public PanelSettings ServerRewards { get; set; }
            [JsonProperty("Economics")] public PanelSettings Economics { get; set; }

            [JsonProperty("Ui update interval")] public float UiUpdateInterval { get; set; }
            [JsonProperty("Ui time format")] public string UiClockFormat { get; set; }

            [JsonProperty("Append AM/PM to 12 hr time format")]
            public bool UiClockFormatAppendAmPm { get; set; }

            public class PanelSettings
            {
                [JsonProperty("Enable")] public bool Enable { get; set; }
                [JsonProperty("Position X")] public float PosX { get; set; }
                [JsonProperty("Position Y")] public float PosY { get; set; }
                [JsonProperty("Scale")] public float Scale { get; set; }
                [JsonProperty("Icon URL")] public string IconUrl { get; set; }
                [JsonProperty("Font size")] public int FontSize { get; set; }
            }
        }
    }
}


// --- End of file: UiPlus.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/unlootable ---
// --- Original File Path: U/Unlootable/Unlootable.cs ---

﻿using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Unlootable", "Oranger", "1.1.1")]
    [Description("Give player/group a permission so they can't open any boxes or anything with loot in")]
    public class Unlootable : RustPlugin
    {
        #region Oxide Hooks

        private void Init()
        {
            OnStart();
        }

        private object CanLootEntity(BasePlayer player, DroppedItemContainer container)
        {
            return CanLoot(container.ShortPrefabName, player);
        }
        
        private object CanLootEntity(BasePlayer player, LootableCorpse corpse)
        {
            return CanLoot(corpse.ShortPrefabName, player);
        }

        private object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            return CanLoot(container.ShortPrefabName, player);
        }

        #endregion
        
        #region Helpers

        private void OnStart()
        {
            foreach (var perm in config.containers.Keys)
            {
                permission.RegisterPermission(perm, this);
            }
        }

        private object CanLoot(string container, BasePlayer player)
        {
            foreach (var key in config.containers.Keys)
            {
                if (!permission.UserHasPermission(player.UserIDString, key))
                {
                    continue;
                }

                if (!config.containers.ContainsKey(container))
                {
                    continue;
                }

                if (!config.containers[key].Contains(container))
                {
                    continue;
                }

                return false;
            }

            return null;
        }

        #endregion

        #region Configuration
        
        private ConfigData config;
        
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Permission - List of containers (shortname)")]
            public Dictionary<string, List<string>> containers;
        }
        
        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                containers = new Dictionary<string, List<string>>
                {
                    ["permission.example"] = new List<string>
                    {
                        "box1.example",
                        "box2.example",
                        "box3.example"
                    },
                    ["unlootable.bags"] = new List<string>
                    {
                        "murderer_corpse",
                        "player_corpse",
                        "etc, etc, etc"
                    },
                }
            };
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
   
            try
            {
                config = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: Unlootable.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/unreliable-vehicles ---
// --- Original File Path: U/UnreliableVehicles/UnreliableVehicles.cs ---

﻿using Newtonsoft.Json;
using System.Collections.Generic;

namespace Oxide.Plugins
{
	[Info("Unreliable Vehicles", "bearr", "1.0.0")]
	[Description("Vehicles have a chance of exploding when turned on.")]
	class UnreliableVehicles : RustPlugin
	{
		#region Init Config
		private GameConfig config;
		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				config = Config.ReadObject<GameConfig>();
				if (config == null)
					PrintToConsole("Couldn't read config");

				Config.WriteObject(config);
			}
			catch
			{
				LoadDefaultConfig();
			}
		}
		#endregion

		#region Messages
		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["ExplosionText"] = "{0}'s vehicle exploded!"
			}, this);
		}
		#endregion

		#region Core/Hook/Oxide/The Code/The Good Stuff/What Does The Thing
		object OnEngineStart(BaseVehicle vehicle)
		{
			int number = UnityEngine.Random.Range(1, 101);
			if (number <= config.chanceofexploding && vehicle.gameObject != null && vehicle.GetDriver() != null)
			{
				FlameExplosive rocket = GameManager.server.CreateEntity("assets/prefabs/ammo/rocket/rocket_fire.prefab", vehicle.transform.position, vehicle.transform.rotation) as FlameExplosive;
				rocket.transform.position = new UnityEngine.Vector3(vehicle.transform.position.x, vehicle.transform.position.y, vehicle.transform.position.z);
				BasePlayer player = vehicle.GetDriver();
				vehicle.SetHealth(0.0f);
				vehicle.SetMaxHealth(0.0f);
				rocket.Explode();
				if (config.dobroadcastmessage == true)
				{
					PrintToChat(config.chatprefix + lang.GetMessage("ExplosionText", this), player.displayName);
				}
			}
			return null;
		}
		#endregion

		#region Config
		private class GameConfig
		{
			[JsonProperty("Chance Of Exploding")] public int chanceofexploding { get; set; }
			[JsonProperty("Broadcast Message To Chat")] public bool dobroadcastmessage { get; set; }
			[JsonProperty("Chat Prefix")] public string chatprefix { get; set; }
		}

		private GameConfig GetDefaultConfig()
		{
			return new GameConfig
			{
				chanceofexploding = 10,
				dobroadcastmessage = true,
				chatprefix = "<color=#ADFF2F>[Unreliable Vehicles]: </color>"
			};
		}

		protected override void LoadDefaultConfig()
		{
			Config.WriteObject(GetDefaultConfig(), true);
		}
		#endregion
	}
}


// --- End of file: UnreliableVehicles.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/upgrade-permissions ---
// --- Original File Path: U/UpgradePermissions/UpgradePermissions.cs ---

using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Upgrade Permissions", "Wulf", "2.0.0")]
    [Description("Allows players to upgrade structures based on permissions")]
    class UpgradePermissions : CovalencePlugin
    {
        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Not allowed to upgrade"] = "You are not allowed to upgrade this structure to {0}",
            }, this);
        }

        #endregion Localization

        #region Handling

        private void Init()
        {
            foreach (BuildingGrade.Enum grade in Enum.GetValues(typeof(BuildingGrade.Enum)))
            {
                permission.RegisterPermission($"{Name}.{grade}", this);
            }
        }

        private object CanChangeGrade(BasePlayer basePlayer, BuildingBlock block, BuildingGrade.Enum grade)
        {
            IPlayer player = basePlayer.IPlayer;
            if (!player.HasPermission($"{Name.ToLower()}.{grade}"))
            {
                Message(player, "Not allowed to upgrade", grade);
                return false;
            }

            return null;
        }

        #endregion Handling

        #region Helpers

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string textOrLang, params object[] args)
        {
            if (player.IsConnected)
            {
                string message = GetLang(textOrLang, player.Id, args);
                player.Reply(message != textOrLang ? message : textOrLang);
            }
        }

        #endregion Helpers
    }
}


// --- End of file: UpgradePermissions.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/upkeep-display-fix ---
// --- Original File Path: U/UpkeepDisplayFix/UpkeepDisplayFix.cs ---

﻿namespace Oxide.Plugins
{
    [Info("Upkeep Display Fix", "WhiteThunder", "1.0.1")]
    [Description("Fixes display bug where Tool Cupboard upkeep doesn't factor in decay scale.")]
    internal class UpkeepDisplayFix : CovalencePlugin
    {
        private const int DisplayMinutesWhenNoDecay = 43200; // 30 days

        private void OnEntitySaved(BuildingPrivlidge buildingPrivilege, BaseNetworkable.SaveInfo saveInfo)
        {
            var decayScale = ConVar.Decay.scale;
            var tcSaveInfo = saveInfo.msg.buildingPrivilege;

            if (decayScale == 0)
            {
                var originalProtectedMinutes = tcSaveInfo.protectedMinutes;
                tcSaveInfo.protectedMinutes = DisplayMinutesWhenNoDecay;
                if (originalProtectedMinutes != 0)
                    tcSaveInfo.upkeepPeriodMinutes *= (DisplayMinutesWhenNoDecay / originalProtectedMinutes);
            }
            else
            {
                tcSaveInfo.protectedMinutes /= decayScale;
                tcSaveInfo.upkeepPeriodMinutes /= decayScale;
            }
        }
    }
}


// --- End of file: UpkeepDisplayFix.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/unlimited-drone-range ---
// --- Original File Path: U/UnlimitedDroneRange/UnlimitedDroneRange.cs ---

﻿using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Unlimited Drone Range", "WhiteThunder", "1.0.1")]
    [Description("Removes the range limit when remote-controlling drones from a computer station.")]
    internal class UnlimitedDroneRange : CovalencePlugin
    {
        private void OnServerInitialized()
        {
            LogWarning("This plugin is no longer necessary. Facepunch fixed the RC drone range issue in the March 2021 update. You may uninstall this plugin.");
        }

        private void Unload()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var drone = entity as Drone;
                if (drone != null && !(drone is DeliveryDrone))
                {
                    var component = drone.GetComponent<DroneNetworkGroupUpdater>();
                    if (component != null)
                        UnityEngine.Object.Destroy(component);
                }
            }
        }

        private void OnBookmarkControl(ComputerStation station, BasePlayer player, string bookmarkName, Drone drone)
        {
            // Without a delay, we can't know whether another plugin blocked the entity from being controlled.
            NextTick(() =>
            {
                if (station == null || station.currentlyControllingEnt.uid != drone.net.ID || station._mounted != player)
                    return;

                // Check if there's already a component for some unknown reason, just in case.
                var component = drone.gameObject.GetComponent<DroneNetworkGroupUpdater>();
                if (component == null)
                    component = drone.gameObject.AddComponent<DroneNetworkGroupUpdater>();

                component.Controller = player;
            });
        }

        private void OnBookmarkControlEnd(ComputerStation station, BasePlayer player, Drone drone)
        {
            var component = drone.gameObject.GetComponent<DroneNetworkGroupUpdater>();
            if (component != null)
                UnityEngine.Object.Destroy(component);
        }

        private class DroneNetworkGroupUpdater : MonoBehaviour
        {
            private Drone _drone;
            private Network.Visibility.Group _networkGroup;

            public BasePlayer Controller;

            private void Awake()
            {
                _drone = GetComponent<Drone>();
                _networkGroup = _drone.net.group;
            }

            private void Update()
            {
                if (Controller == null)
                    return;

                var currentGroup = _drone.net.group;
                if (currentGroup != _networkGroup)
                {
                    Controller.net.SwitchSecondaryGroup(currentGroup);
                    _networkGroup = currentGroup;
                }
            }
        }
    }
}


// --- End of file: UnlimitedDroneRange.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ufilter ---
// --- Original File Path: U/UFilter/UFilter.cs ---

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("UFilter", "Wulf/lukespragg", "5.1.2")]
    [Description("Prevents advertising and/or profanity and optionally punishes player")]
    public class UFilter : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty("Check for advertising (true/false)")]
            public bool CheckForAdvertising = true;

            [JsonProperty("Check for profanity (true/false)")]
            public bool CheckForProfanity = true;

            [JsonProperty("Check player chat (true/false)")]
            public bool CheckChat = true;

            [JsonProperty("Check player names (true/false)")]
            public bool CheckNames = true;

            [JsonProperty("Log advertising (true/false)")]
            public bool LogAdvertising = false;

            [JsonProperty("Log profanity (true/false)")]
            public bool LogProfanity = false;

            [JsonProperty("Log to console (true/false)")]
            public bool LogToConsole = false;

            [JsonProperty("Log to file (true/false)")]
            public bool LogToFile = false;

            [JsonProperty("Warn player in chat (true/false)")]
            public bool WarnInChat = true;

            [JsonProperty("Action for advertising")]
            public string ActionForAdvertising = "block";

            [JsonProperty("Action for profanity")]
            public string ActionForProfanity = "censor";

            [JsonProperty("Word or symbol to use for censoring")]
            public string CensorText = "*";

            [JsonProperty("Allowed advertisements")]
            public List<string> AllowedAds = new List<string>();

            [JsonProperty("Allowed profanity")]
            public List<string> AllowedProfanity = new List<string>();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            string configPath = $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Name}.json";
            LogWarning($"Could not load a valid configuration file, creating a new configuration file at {configPath}");
            config = new Configuration();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion Configuration

        #region Localization

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandUsage"] = "Usage:\n{0} <add/remove> <word or phrase>\n{0} <list> shows profanity list",
                ["NoAdvertising"] = "Advertising is not allowed on this server",
                ["NoData"] = "The profanity list is empty",
                ["NoProfanity"] = "Profanity is not allowed on this server",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["WordAdded"] = "Word '{0}' was added to the profanity list",
                ["WordListed"] = "Word '{0}' is already in the profanity list",
                ["WordNotListed"] = "Word '{0}' is not in the profanity list",
                ["WordRemoved"] = "Word '{0}' was removed from the profanity list",
            }, this);
        }

        #endregion Localization

        #region Initialization

        [PluginReference]
        private readonly Plugin BetterChat, Slap;

        private const string permAdmin = "ufilter.admin";
        private const string permBypass = "ufilter.bypass";

        private static readonly Regex ipRegex = new Regex(@"(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}(:\d{2,5})?)");
        private static readonly Regex domainRegex = new Regex(@"(\w{2,}\.\w{2,3}\.\w{2,3}|\w{2,}\.\w{2,3}(:\d{2,5})?)$");

        #region Blocked Words

        private StoredData storedData;

        private class StoredData
        {
            public readonly HashSet<string> Profanities = new HashSet<string>();
        }

        #endregion Blocked Words

        private void OnServerInitialized()
        {
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);

            permission.RegisterPermission(permAdmin, this);
            permission.RegisterPermission(permBypass, this);

            if (BetterChat != null && BetterChat.IsLoaded)
            {
#if RUST
                Unsubscribe(nameof(OnPlayerChat));
#else
                Unsubscribe(nameof(OnUserChat));
#endif
            }

            if (!config.CheckNames)
            {
                Unsubscribe(nameof(OnUserRespawned));
                Unsubscribe(nameof(OnUserSpawned));
            }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);

        #endregion Initialization

        #region Filter Matching

        private string[] Advertisements(string text)
        {
            IEnumerable<string> ips = ipRegex.Matches(text).OfType<Match>().Select(m => m.Value);
            IEnumerable<string> domains = domainRegex.Matches(text.ToLower()).OfType<Match>().Select(m => m.Value.ToLower());
            return ips.Concat(domains).Where(a => !config.AllowedAds.Contains(a)).ToArray();
        }

        private string[] Profanities(string text)
        {
            return Regex.Split(text, @"\W").Where(w => storedData.Profanities.Contains(w.ToLower()) && !config.AllowedProfanity.Contains(w.ToLower())).ToArray();
        }

        #endregion Filter Matching

        #region Text Processing

        private string ProcessText(string text, IPlayer player)
        {
            if (player.HasPermission(permBypass))
            {
                return text;
            }

            string[] profanities = Profanities(text);
            string[] advertisements = Advertisements(text);

            if (config.CheckForProfanity && profanities.Length > 0)
            {
                if (config.WarnInChat)
                {
                    Message(player, "NoProfanity", player.Id);
                }

                if (config.LogProfanity)
                {
                    foreach (string profanity in profanities)
                    {
                        Log($"{player.Name} ({player.Id}) {DateTime.Now}: {profanity}", "profanity");
                    }
                }

                return TakeAction(player, text, profanities, config.ActionForProfanity, GetLang("NoProfanity", player.Id));
            }

            if (config.CheckForAdvertising && advertisements.Length > 0)
            {
                if (config.WarnInChat)
                {
                    Message(player, "NoAdvertising", player.Id);
                }

                if (config.LogAdvertising)
                {
                    foreach (string advertisement in advertisements)
                    {
                        Log($"{player.Name} ({player.Id}) {DateTime.Now}: {advertisement}", "ads");
                    }
                }

                return TakeAction(player, text, advertisements, config.ActionForAdvertising, GetLang("NoAdvertising", player.Id));
            }

            return text;
        }

        #endregion Text Processing

        #region Action Processing

        private string TakeAction(IPlayer player, string text, string[] list, string action, string reason)
        {
            if (string.IsNullOrEmpty(action))
            {
                return string.Empty;
            }

            switch (action.ToLower().Trim())
            {
                case "ban":
                    player.Ban(reason);
                    return string.Empty;

                case "censor":
                    foreach (string word in list)
                    {
                        text = text.Replace(word, config.CensorText.Length == 1 ? new string(config.CensorText[0], word.Length) : config.CensorText);
                    }
                    return text;

                case "kick":
                    player.Kick(reason);
                    return string.Empty;

                case "kill":
                    player.Kill();
                    return string.Empty;

                case "slap":
                    if (Slap != null && Slap.IsLoaded)
                    {
                        Slap.Call("SlapPlayer", player);
                    }
                    else
                    {
                        LogWarning("Slap plugin is not installed; slap action will not work");
                    }
                    return string.Empty;

                default:
                    return string.Empty;
            }
        }

        #endregion Action Processing

        #region Chat Handling

        private string HandleChat(IPlayer player, string message)
        {
            if (player == null || string.IsNullOrEmpty(message))
            {
                return null;
            }

            string processed = ProcessText(message, player);
            if (processed == string.Empty)
            {
                return processed;
            }

            if (!string.Equals(message, processed))
            {
                if (BetterChat != null && BetterChat.IsLoaded)
                {
                    return processed;
                }

                // Rust colors: Admin/moderator = #aaff55, Developer = #ffaa55, Player = #55aaff
                string prefix = covalence.FormatText($"[{(player.IsAdmin ? "#aaff55" : "#55aaff")}]{player.Name}[/#]");
                return $"{prefix}: {processed}";
            }

            return null;
        }

        private object OnBetterChat(Dictionary<string, object> data)
        {
            string processed = HandleChat(data["Player"] as IPlayer, data["Message"] as string);

            if (!Equals(data["Message"] as string, processed) && !string.IsNullOrEmpty(processed))
            {
                data["Message"] = processed;
                return data;
            }

            if (processed == string.Empty)
            {
                data["CancelOption"] = 2;
                return data;
            }

            return null;
        }

#if RUST
        private object OnPlayerChat(BasePlayer basePlayer, string message, ConVar.Chat.ChatChannel channel)
        {
            string processed = HandleChat(basePlayer.IPlayer, message);

            if (!string.IsNullOrEmpty(processed))
            {
                Broadcast(basePlayer.IPlayer, processed, (int)channel);
                return true;
            }

            if (processed == string.Empty)
            {
                return true;
            }

            return null;
        }
#else
        private object OnUserChat(IPlayer player, string message)
        {
            if (BetterChat == null || !BetterChat.IsLoaded)
            {
                string processed = HandleChat(player, message);

                if (!string.IsNullOrEmpty(processed))
                {
                    Broadcast(player, processed);
                    return true;
                }

                if (processed == string.Empty)
                {
                    return true;
                }
            }

            return null;
        }
#endif

        #endregion Chat Handling

        #region Name Handling

        private void ProcessName(IPlayer player)
        {
            string processed = ProcessText(player.Name, player);

            if (player.Name != processed)
            {
                player.Rename(processed);
            }
            else if (string.IsNullOrEmpty(processed))
            {
                player.Rename("Unnamed" + new System.Random()); // TODO: Config option
            }
        }

        private void OnUserRespawned(IPlayer player) => ProcessName(player);

        private void OnUserSpawned(IPlayer player) => ProcessName(player);

        #endregion Name Handling

        #region API

        private string[] GetProfanities() => storedData?.Profanities.ToArray();
        private string[] GetAllowedProfanity() => config?.AllowedProfanity.ToArray();

        private bool AddProfanity(string profanity)
        {
            if (storedData == null || storedData.Profanities.Contains(profanity))
            {
                return false;
            }

            storedData.Profanities.Add(profanity);
            Interface.CallHook("OnProfanityAdded", profanity);
            return true;
        }

        private bool RemoveProfanity(string profanity)
        {
            if (storedData == null || storedData.Profanities.Contains(profanity))
            {
                return false;
            }

            storedData.Profanities.Remove(profanity);
            Interface.CallHook("OnProfanityRemoved", profanity);
            return true;
        }

        #endregion API

        #region Commands

        [Command("ufilter")] // TODO: Localization
        private void FilterCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args.Length < 1 || args.Length < 2 && args[0].ToLower() != "list")
            {
                Message(player, "CommandUsage", command);
                return;
            }

            string argList = string.Join(" ", args.Skip(1).ToArray());
            switch (args[0].ToLower())
            {
                case "+":
                case "add":
                    if (!AddProfanity(argList))
                    {
                        Message(player, "WordListed", argList);
                        break;
                    }

                    Message(player, "WordAdded", argList);
                    break;

                case "-":
                case "del":
                case "delete":
                case "remove":
                    if (!RemoveProfanity(argList))
                    {
                        Message(player, "WordNotListed", argList);
                        break;
                    }

                    Message(player, "WordRemoved", argList);
                    break;

                case "list":
                    string message = string.Join(", ", storedData.Profanities);
                    Message(player, string.IsNullOrEmpty(message) ? "NoData" : message);
                    break;

                default:
                    Message(player, "CommandUsage", command);
                    break;
            }
        }

        #endregion Commands

        #region Helpers

        private void AddLocalizedCommand(string key, string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages.Where(m => m.Key.Equals(key)))
                {
                    if (!string.IsNullOrEmpty(message.Value))
                    {
                        AddCovalenceCommand(message.Value, command);
                    }
                }
            }
        }

        private void Broadcast(IPlayer sender, string text, int channel = 0)
        {
#if RUST
            foreach (IPlayer target in players.Connected)
            {
                target.Command("chat.add", channel, sender.Id, text);
            }
#else
            server.Broadcast(text);
#endif
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string textOrLang, params object[] args)
        {
            if (player.IsConnected)
            {
                string message = GetLang(textOrLang, player.Id, args);
                player.Reply(message != textOrLang ? message : textOrLang);
            }
        }

        private void Log(string text, string filename)
        {
            if (config.LogToConsole)
            {
                Puts(text);
            }

            if (config.LogToFile)
            {
                LogToFile(filename, $"[{DateTime.Now}] {text}", this);
            }
        }

        #endregion Helpers
    }
}

// --- End of file: UFilter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/update-notice ---
// --- Original File Path: U/UpdateNotice/UpdateNotice.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using static ConsoleSystem;

namespace Oxide.Plugins
{
    [Info("Update Notice", "Psystec", "3.2.2", ResourceId = 2837)]
    [Description("Notifies you when new Rust updates are released.")]
    internal sealed class UpdateNotice : RustPlugin
    {
        //DO NOT EDIT. Please ask for permission or notify me should you require changes.
        //Check out our API host sponser YaMang's plugins at codefling.com: https://codefling.com/yamang-w
        #region Fields

        private Configuration _configuration;
        private UpdateInfo _updateInfo;

        private const string AdminPermission = "updatenotice.admin";
        private const string ApiUrl = "http://api.yamang.xyz:2095/rustapi";

        private bool _initLoad = true;
        private int _checkingInterval = 180;

        private readonly Dictionary<string, string> _properNames = new Dictionary<string, string>
        {
            {"carbon", "Carbon"},
            {"uMod", "Oxide"},
            {"rustClient", "Client"},
            {"rustClientStaging", "ClientStaging"},
            {"rustServer", "Server"},
            {"newsgid", "DevBlog"},
        };

        private readonly Dictionary<string, string> _properCommands = new Dictionary<string, string>
        {
            {"carbon", "carbon"},
            {"uMod", "umod"},
            {"rustClient", "client"},
            {"rustClientStaging", "clientstaging"},
            {"rustServer", "server"},
            {"newsgid", "devblog"},
        };

        #endregion Fields

        #region Classes

        private sealed class UpdateInfo
        {
            public string carbon { get; set; }
            public string uMod { get; set; }
            public string rustClient { get; set; }
            public string rustClientStaging { get; set; }
            public string rustServer { get; set; }
            public string newsgid { get; set; }
            public string newsurl { get; set; }
            public string newsdate { get; set; }
        }

        #region Discord Message
        private sealed class DiscordMessageEmbeds
        {
            /// <summary>
            /// if used, it overrides the default username of the webhook
            /// </summary>
            public string username { get; set; }
            /// <summary>
            /// if used, it overrides the default avatar of the webhook
            /// </summary>
            public string avatar_url { get; set; }
            /// <summary>
            /// simple message, the message contains (up to 2000 characters)
            /// </summary>
            public string content { get; set; }
            /// <summary>
            /// array of embed objects. That means, you can use more than one in the same body
            /// </summary>
            public Embed[] embeds { get; set; }
        }
        private sealed class Embed
        {
            /// <summary>
            /// embed author object
            /// </summary>
            public Author author { get; set; }
            /// <summary>
            /// title of embed
            /// </summary>
            public string title { get; set; }
            /// <summary>
            /// url of embed. If title was used, it becomes hyperlink
            /// </summary>
            public string url { get; set; }
            /// <summary>
            /// description text
            /// </summary>
            public string description { get; set; }
            /// <summary>
            /// color code of the embed. You have to use Decimal numeral system, not Hexadecimal. Use color picker and converter: https://htmlcolorcodes.com/color-picker/ and https://www.binaryhexconverter.com/hex-to-decimal-converter
            /// </summary>
            public int color { get; set; }
            /// <summary>
            /// rray of embed field objects
            /// </summary>
            public Field[] fields { get; set; }
            /// <summary>
            /// embed thumbnail object
            /// </summary>
            public Thumbnail thumbnail { get; set; }
            /// <summary>
            /// embed image object
            /// </summary>
            public Image image { get; set; }
            /// <summary>
            /// embed footer object
            /// </summary>
            public Footer footer { get; set; }
        }
        private sealed class Author
        {
            /// <summary>
            /// name of author
            /// </summary>
            public string name { get; set; }
            /// <summary>
            /// url of author. If name was used, it becomes a hyperlink
            /// </summary>
            public string url { get; set; }
            /// <summary>
            /// url of author icon
            /// </summary>
            public string icon_url { get; set; }
        }
        private sealed class Thumbnail
        {
            /// <summary>
            /// url of thumbnail
            /// </summary>
            public string url { get; set; }
        }
        private sealed class Image
        {
            /// <summary>
            /// url of image
            /// </summary>
            public string url { get; set; }
        }
        private sealed class Footer
        {
            /// <summary>
            /// footer text, doesn't support Markdown
            /// </summary>
            public string text { get; set; }
            /// <summary>
            /// url of footer icon
            /// </summary>
            public string icon_url { get; set; }
        }
        private sealed class Field
        {
            /// <summary>
            /// name of the field
            /// </summary>
            public string name { get; set; }
            /// <summary>
            /// alue of the field
            /// </summary>
            public string value { get; set; }
            /// <summary>
            /// if true, fields will be displayed in same line, but there can only be 3 max in same line or 2 max if you used thumbnail
            /// </summary>
            public bool inline { get; set; }
        }
        #endregion Discord Message

        #endregion Classes

        #region Configuration

        private sealed class Configuration
        {
            [JsonProperty("Only Notify Admin")]
            public bool OnlyNotifyAdmins { get; set; } = false;

            [JsonProperty("Enable Discord Notifications")]
            public bool EnableDiscordNotify { get; set; } = false;

            [JsonProperty("Discord role id to mention (0 = no mention)")]
            public ulong DiscordRoleId { get; set; } = 0;

            [JsonProperty("Discord Webhook URL")]
            public string DiscordWebhookURL { get; set; } = "https://support.discordapp.com/hc/en-us/articles/228383668";

            [JsonProperty("Enable GUI Notifications (Needs GUIAnnouncements)")]
            public bool EnableGuiNotifications { get; set; } = true;

            [JsonProperty("Enable Chat Notifications")]
            public bool EnableChatNotifications { get; set; } = true;

            [JsonProperty("GUI Notifications Tint Color")]
            public string GUINotificationsTintColor { get; set; } = "Purple";

            [JsonProperty("GUI Notifications Text Color")]
            public string GUINotificationsTextColor { get; set; } = "Yellow";

            [JsonProperty("Enable Server Version Notifications")]
            public bool EnableServer { get; set; } = true;

            [JsonProperty("Enable DevBlog Notifications")]
            public bool EnableDevBlog { get; set; } = true;

            [JsonProperty("Enable Client Version Notifications")]
            public bool EnableClient { get; set; } = true;

            [JsonProperty("Enable Staging Version Notifications")]
            public bool EnableStaging { get; set; } = false;

            [JsonProperty("Enable UMod Version Notifications")]
            public bool EnableUMod { get; set; } = false;

            [JsonProperty("Enable Carbon Version Notifications")]
            public bool EnableCarbon { get; set; } = false;
        }

        protected override void SaveConfig() => Config.WriteObject(_configuration);
        private void LoadNewConfig() => _configuration = Config.ReadObject<Configuration>();
        protected override void LoadDefaultConfig() => _configuration = new Configuration();
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _configuration = Config.ReadObject<Configuration>();
        }

        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ServerUpdated"] = "Server Update Released!",
                ["DevBlogUpdated"] = "DevBlog Update Released!",
                ["ClientUpdated"] = "Client Update Released!",
                ["ClientStagingUpdated"] = "Client Staging Update Released!",
                ["UModUpdated"] = "UMod Update Released!",
                ["CarbonUpdated"] = "Carbon Update Released!",
                ["FailedToCheckUpdates"] = "Failed to check for RUST updates, if this keeps happening please contact the developer.",
                ["PluginNotFoundGuiAnnouncements"] = "GUIAnnouncements plugin was not found. GUI Announcements disabled.",
                ["NoPermission"] = "You do not have permission to use this command.",
                ["DiscordWebhookURLNotConfigured"] = "Discord Webhook URL is not configured.",
                ["IntervalCheck"] = "Checking interval must be 180 seconds or greater! Setting this lower may get your server banned. Auto adjusted to 300.",
                ["Help.Command"] = "COMMAND",
                ["Help.Description"] = "DESCRIPTION",
                ["Help.Gui"] = "Tests GUI notification (Needs GUIAnnouncements Plugin)",
                ["Help.Discord"] = "Tests Discord notification",
                ["Help.Current"] = "Display's all current versions",
                ["Help.Server"] = "Simulate Server update release",
                ["Help.DevBlog"] = "Simulate DevBlog update release",
                ["Help.Client"] = "Simulate Client update release",
                ["Help.Staging"] = "Simulate Staging update release",
                ["Help.Oxide"] = "Simulate Oxide update release",
                ["Help.Carbon"] = "Simulate Carbon update release",
                ["Help.All"] = "Simulate all updates released (depends on config)",
                ["Help.ForceCheck"] = "Forces a version check",
                ["Help.LoadConfig"] = "Reload the config file",
                ["Chat.Prefix"] = "<size=20><color=#ff0000>Update Notice</color></size>",
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ServerUpdated"] = "Mise à jour du Serveur disponible !",
                ["DevBlogUpdated"] = "Mise à jour du \"DevBlog\" disponible !",
                ["ClientUpdated"] = "Mise à jour du Client disponible !",
                ["ClientStagingUpdated"] = "Mise à jour de la branche \"Staging\" du Client disponible !",
                ["UModUpdated"] = "Mise à jour de UMod disponible !",
                ["CarbonUpdated"] = "Mise à jour de Carbon disponible !",
                ["FailedToCheckUpdates"] = "Récupération des mises à jour de RUST impossible, si cela se reproduit veuillez contacter le développeur.",
                ["PluginNotFoundGuiAnnouncements"] = "Le plugin GUIAnnouncements n'a pas été trouvé. GUI Announcements désactivé.",
                ["NoPermission"] = "Vous n'avez pas la permission d'utiliser cette commande",
                ["DiscordWebhookURLNotConfigured"] = "L'URL du Discord Webhook n'est pas configuré.",
                ["IntervalCheck"] = "L'interval de vérification doit être de 180 secondes ou plus ! Configurer une valeur inférieure pourrait voir votre serveur banni. Ajustement automatique à 300.",
                ["Help.Command"] = "COMMANDE",
                ["Help.Description"] = "DESCRIPTION",
                ["Help.Gui"] = "Simule la notification par GUI (Requiert le plugin GUIAnnouncements)",
                ["Help.Discord"] = "Simule la notification Discord",
                ["Help.Current"] = "Affiche toutes les versions actuelles",
                ["Help.Server"] = "Simule la notification de la mise à jour du Server",
                ["Help.DevBlog"] = "Simule la notification de la mise à jour \"DevBlog\"",
                ["Help.Client"] = "Simule la notification de la mise à jour du Client",
                ["Help.Staging"] = "Simule la notification de la mise à jour de la branche \"Staging\"",
                ["Help.Oxide"] = "Simule la notification de la mise à jour d'Oxide",
                ["Help.Carbon"] = "Simule la notification de la mise à jour de Carbon",
                ["Help.All"] = "Simule toutes les notifications de mise à jour (dépend de la config)",
                ["Help.ForceCheck"] = "Force l'actualisation des données",
                ["Help.LoadConfig"] = "Recharge la configuration",
                ["Chat.Prefix"] = "<size=20><color=#ff0000>Avis de mise à jour</color></size>",
            }, this, "fr");
        }

        #endregion Localization

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(AdminPermission, this);
        }

        private void Loaded()
        {
            if (GUIAnnouncements == null)
            {
                PrintWarning(Lang("PluginNotFoundGuiAnnouncements"));
                _configuration.EnableGuiNotifications = false;
            }

            if (_checkingInterval < 180)
            {
                PrintWarning(Lang("IntervalCheck"));
                _checkingInterval = 300;
            }

            timer.Every(_checkingInterval, CompareVersions);
        }

        #endregion Hooks

        #region Testing

        [ConsoleCommand("updatenotice")]
        private void AdvertCommands(Arg arg)
        {
            if (arg.IsClientside && !HasPermission(arg.Player(), AdminPermission))
            {
                SendReply(arg, Lang("NoPermission"));
                return;
            }
            if (arg.Args.IsNullOrEmpty())
            {
                SendHelp(arg);
                return;
            }

            if (_updateInfo == null)
            {
                CompareVersions();
            }

            var command = arg.Args[0].ToLower();

            switch (command)
            {
                case "gui":
                    TestNotification("GUI", GUIAnnouncements, "Test message from Update Notice by Psystec", SendtoGui);
                    break;

                case "discord":
                    TestNotification("Discord", !string.IsNullOrEmpty(_configuration.DiscordWebhookURL), "Test message from Update Notice by Psystec", SendToDiscord);
                    break;

                case "current":
                    DisplayCurrentVersions(arg);
                    break;

                case "server":
                case "devblog":
                case "client":
                case "clientstaging":
                case "umod":
                case "carbon":
                    TestUpdate(command, true);
                    break;

                case "all":
                    TestAllUpdates();
                    break;

                case "forcecheck":
                    Puts("Forcing Version Check");
                    CompareVersions();
                    break;

                case "loadconfig":
                    Puts("Loading Configuration File");
                    LoadNewConfig();
                    break;

                default:
                    SendHelp(arg);
                    break;
            }
        }

        private void TestNotification(string type, bool condition, string message, Action<string> notificationMethod)
        {
            if (!condition)
            {
                PrintWarning(Lang($"PluginNotFound{type}Announcements"));
                return;
            }

            Puts($"Testing {type} Messages: {message}");
            notificationMethod.Invoke(message);
        }

        private void TestUpdate(string type, bool isCmd)
        {
            Puts($"Testing {type} Update");

            Interface.CallHook($"On{type}Update", "TestUpdate");

            // Yeah that's reflexion but fuck infernal switch case
            if (isCmd)
            {
                typeof(UpdateInfo).GetProperty(_properCommands.FirstOrDefault(x => x.Value == type).Key)?.SetValue(_updateInfo, $"Simulating {type} Update");
                return;
            }
            typeof(UpdateInfo).GetProperty(_properNames.FirstOrDefault(x => x.Value == type).Key)?.SetValue(_updateInfo, $"Simulating {type} Update");
        }

        private void TestAllUpdates()
        {
            Puts("Testing All Updates");

            foreach (var keyValuePair in _properNames)
            {
                TestUpdate(keyValuePair.Value, false);
            }
        }

        private void DisplayCurrentVersions(Arg arg)
        {
            SendReply(arg, $"Update Notice by Psystec\n" +
                           $"Server: {_updateInfo.rustServer}\n" +
                           $"DevBlog: {_updateInfo.newsgid}\n" +
                           $"Client: {_updateInfo.rustClient}\n" +
                           $"Staging: {_updateInfo.rustClientStaging}\n" +
                           $"UMod: {_updateInfo.uMod}\n" +
                           $"Carbon: {_updateInfo.carbon}");
        }

        private void SendHelp(Arg arg)
        {
            var width = 30;
            SendReply(arg, (Lang("Help.Command")).PadRight(width) + Lang("Help.Description"));
            SendReply(arg, ("updatenotice gui").PadRight(width) + Lang("Help.Gui"));
            SendReply(arg, ("updatenotice discord").PadRight(width) + Lang("Help.Discord"));
            SendReply(arg, ("updatenotice current").PadRight(width) + Lang("Help.Current"));
            SendReply(arg, ("updatenotice server").PadRight(width) + Lang("Help.Server"));
            SendReply(arg, ("updatenotice devblog").PadRight(width) + Lang("Help.DevBlog"));
            SendReply(arg, ("updatenotice client").PadRight(width) + Lang("Help.Client"));
            SendReply(arg, ("updatenotice staging").PadRight(width) + Lang("Help.Staging"));
            SendReply(arg, ("updatenotice oxide").PadRight(width) + Lang("Help.Oxide"));
            SendReply(arg, ("updatenotice carbon").PadRight(width) + Lang("Help.Carbon"));
            SendReply(arg, ("updatenotice all").PadRight(width) + Lang("Help.All"));
            SendReply(arg, ("updatenotice forcecheck").PadRight(width) + Lang("Help.ForceCheck"));
            SendReply(arg, ("updatenotice loadconfig").PadRight(width) + Lang("Help.LoadConfig"));
        }

        #endregion Testing

        #region Version Comparison

        private void CompareVersions()
        {
            webrequest.Enqueue(ApiUrl, null, (code, response) =>
            {
                if (code != 200 || response == null)
                {
                    PrintWarning($"API: {Lang("FailedToCheckUpdates")}\nError Code: {code} | Message: {response}");
                    return;
                }

                var nVData = JsonConvert.DeserializeObject<UpdateInfo>(response);

                if (_initLoad)
                {
                    _updateInfo = nVData;
                    _initLoad = false;
                }

                UpdateCheck("Carbon", nVData.carbon, _updateInfo.carbon, _configuration.EnableCarbon);
                UpdateCheck("Client", nVData.rustClient, _updateInfo.rustClient, _configuration.EnableClient);
                UpdateCheck("ClientStaging", nVData.rustClientStaging, _updateInfo.rustClientStaging, _configuration.EnableStaging);
                UpdateCheck("DevBlog", nVData.newsgid, _updateInfo.newsgid, _configuration.EnableDevBlog, _updateInfo.newsurl);
                UpdateCheck("Oxide", nVData.uMod, _updateInfo.uMod, _configuration.EnableUMod);
                UpdateCheck("Server", nVData.rustServer, _updateInfo.rustServer, _configuration.EnableServer);

                _updateInfo = nVData;

            }, this);
        }

        private void UpdateCheck(string type, string newData, string oldData, bool enableFeature, string additionalInfo = null)
        {
            if (newData == oldData) return;

            Interface.CallHook($"On{type}Update", newData);

            if (!enableFeature) return;

            Puts(Lang($"{type}Updated"));

            if (_configuration.EnableChatNotifications)
                SendToChat(Lang($"{type}Updated"));
            if (_configuration.EnableGuiNotifications)
                SendtoGui(Lang($"{type}Updated"));
            if (_configuration.EnableDiscordNotify)
                SendToDiscord(Lang($"{type}Updated") + (additionalInfo != null ? $": {additionalInfo}" : ""));
        }

        #endregion Version Comparison

        #region Helpers

        private string Lang(string key, string id = null, params object[] args)
            => string.Format(lang.GetMessage(key, this, id), args);

        private bool HasPermission(BasePlayer player, string perm)
        {
            if (permission.UserHasPermission(player.userID.ToString(), perm)) return true;

            PrintWarning("UserID: " + player.UserIDString + " | UserName: " + player.displayName + " | " + Lang("NoPermission"));
            return false;
        }

        private void SendtoGui(string message)
        {
            if (GUIAnnouncements == null)
            {
                PrintWarning(Lang("PluginNotFoundGuiAnnouncements"));
                return;
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                if (_configuration.OnlyNotifyAdmins)
                {
                    if (!_configuration.OnlyNotifyAdmins || !HasPermission(player, AdminPermission)) continue;

                    GUIAnnouncements?.Call("CreateAnnouncement", message, _configuration.GUINotificationsTintColor, _configuration.GUINotificationsTextColor, player);
                    Puts($"Announcement created for: {player.displayName}: {message}");
                }
                else
                {
                    GUIAnnouncements?.Call("CreateAnnouncement", message, _configuration.GUINotificationsTintColor, _configuration.GUINotificationsTextColor, player);
                    Puts($"Announcement created for: {player.displayName}: {message}");
                }
            }
        }

        private void SendToChat(string message)
        {
            rust.BroadcastChat(null, $"{Lang("Chat.Prefix")}\n{message}");
        }

        private void SendToDiscord(string message)
        {
            var headers = new Dictionary<string, string> { { "Content-Type", "application/json" } };

            var dc = new DiscordMessageEmbeds
            {
                content = _configuration.DiscordRoleId == 0
                    ? message
                    : $"<@&{_configuration.DiscordRoleId}> {message}",
                embeds = new[]
                {
                    new Embed
                    {
                        title = "Update Notice",
                        description = $"Alert Time: {DateTime.Now:yyyy-MM-dd HH:mm:ss}\nVisit [Umod](https://umod.org/plugins/update-notice) for more information or [Discord](https://discord.gg/EyRgFdA) for any assistance.",
                        url = "https://discord.gg/EyRgFdA",
                        color = 16711686,
                        thumbnail = new Thumbnail { url = "https://assets.umod.org/images/icons/plugin/5ea987f1379b2.png" },
                        footer = new Footer { icon_url = "https://assets.umod.org/user/7O3gGkDgaP/14G1myUYST6LEi2.png", text = "Created by Psystec" }
                    }
                }
            };

            var payload = JsonConvert.SerializeObject(dc);
            webrequest.Enqueue(_configuration.DiscordWebhookURL, payload, (code, response) =>
            {
                if (code == 200 || code == 204) return;
                if (response == null)
                {
                    PrintWarning($"Discord didn't respond. Error Code: {code}");
                }
                else
                {
                    Puts($"Discord respond with: {response} Payload: {payload}");
                }
            }, this, Core.Libraries.RequestMethod.POST, headers);
        }

        #endregion Helpers

        #region Internal API

        public string GetServerVersion() => _updateInfo?.rustServer;
        public string GetDevBlogVersion() => _updateInfo?.newsgid;
        public string GetClientVersion() => _updateInfo?.rustClient;
        public string GetStagingVersion() => _updateInfo?.rustClientStaging;
        public string GetUModVersion() => _updateInfo?.uMod;
        public string GetCarbonVersion() => _updateInfo?.carbon;
        public string GetDevBlogLink() => _updateInfo?.newsurl;

        #endregion Internal API

        #region External API

        [PluginReference]
        Plugin GUIAnnouncements;

        #endregion External API
    }
}

// --- End of file: UpdateNotice.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ui-scale-manager ---
// --- Original File Path: U/UIScaleManager/UIScaleManager.cs ---

﻿using System;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("UI Scale Manager", "noname", "2.2.2")]
    [Description("User's UIScale data is stored and provided by API")]
    class UIScaleManager : CovalencePlugin
    {
        #region Field

        private delegate string LangDelegate(string key, string id = null, params object[] args);
        private static LangDelegate _langGlobal;
        private static VersionNumber _pluginVersion;

        private const float _defaultUIScale = 1.0f;
        private const int _defaultAspectRatioIndicator = 2;
        private static AspectRatioRaw[] _ratioPresets;
        private static int _defaultAspectRatioX;
        private static int _defaultAspectRatioY;

        private DataManager _dataManager;
        private UIController _uiController;
        private UIGenerator.UIScaler _uiScaler;

        private Dictionary<string, float[]> _playerUIInfoCache;

        private struct AspectRatioRaw
        {
            public int X { get; set; }
            public int Y { get; set; }

            public AspectRatioRaw(int x, int y)
            {
                X = x;
                Y = y;
            }
        }

        #endregion

        #region Hooks

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");

            Config.WriteObject(GetDefaultConfig(), true);
        }

        private void Init()
        {
            _langGlobal = Lang;
            _pluginVersion = this.Version;

            _ratioPresets = new AspectRatioRaw[]
            {
                new AspectRatioRaw(4,3),
                new AspectRatioRaw(5,4),
                new AspectRatioRaw(16,9),
                new AspectRatioRaw(17,9),
                new AspectRatioRaw(16,10),
                new AspectRatioRaw(21,9),
                new AspectRatioRaw(32,9),
                new AspectRatioRaw(32,10)
            };

            _defaultAspectRatioX = _ratioPresets[_defaultAspectRatioIndicator].X;
            _defaultAspectRatioY = _ratioPresets[_defaultAspectRatioIndicator].Y;

            _dataManager = new DataManager();
            _uiController = new UIController();
            _uiScaler = _uiController.UIScaler;

            _playerUIInfoCache = new Dictionary<string, float[]>();

            LoadConfig();

            var Result = _dataManager.LoadPlayersData();
            if (Result == DataManager.LoadResult.Updated)
                Puts("DataFile version has been updated");
        }

        private void OnServerInitialized()
        {
            if (config.InitPlayer)
            {
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    if (!_dataManager.Data.Players.ContainsKey(player.UserIDString))
                        _uiController.OpenUI(player, _defaultAspectRatioX, _defaultAspectRatioY, _defaultUIScale);
                }
            }
        }

        void OnServerSave()
        {
            _dataManager.SavePlayersData();
            Puts("Saving UIScaleManager PlayersDataFile...");
        }

        void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                _uiController.CloseUI(player);

            _dataManager.SavePlayersData();
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            if (config.InitPlayer)
            {
                timer.Once(1f, () =>
                {
                    if (!_dataManager.Data.Players.ContainsKey(player.UserIDString))
                        _uiController.OpenUI(player, _defaultAspectRatioX, _defaultAspectRatioY, _defaultUIScale);
                });
            }
        }

        private void OnUserDisconnected(IPlayer player)
        {
            _uiController.CloseUI(player.Object as BasePlayer);
        }

        #endregion

        #region ConfigManage

        private PluginConfig config;

        private void LoadConfig()
        {
            config = Config.ReadObject<PluginConfig>();

            if (config == null)
                config = GetDefaultConfig();

            VersionUpdate(config);
        }

        private void VersionUpdate(PluginConfig config)
        {
            //    if (config.ConfigVersion < new VersionNumber(2, 1, 0))
            //    {
            //        config.ConsoleFilter = GetDefaultConsoleFilter();
            //    }

            if (config.ConfigVersion < this.Version)
            {
                config.ConfigVersion = this.Version;
                Config.WriteObject(config, true);
                Puts("Config version has been updated");
            }
        }

        private class PluginConfig
        {
            public bool InitPlayer;
            public VersionNumber ConfigVersion;
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                InitPlayer = true,
                ConfigVersion = _pluginVersion
            };
        }

        #endregion

        #region LangManage

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["UI Scale Data Changed"] = "Your UI data is setted to {0} {1}:{2}.",
                ["Cancel"] = "Canceled.",
                ["Error"] = "Unexpected Parameter.",
                ["YourCurrentAspectRatio"] = "Your Current Aspect Ratio Is",
                ["YourCurrentUISize"] = "Your Current UI Size Is",
                ["FitBelt"] = "<color=yellow>Please fit this rectangle to the item belt</color>",
                ["FitStatusW"] = "<color=yellow>Please fit this rectangle to the status window</color>"
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["UI Scale Data Changed"] = "UI 데이터가 사이즈 {0}, 화면비율 {1}:{2} 로 저장되었습니다.",
                ["Cancel"] = "취소되었습니다.",
                ["Error"] = "예상치 못한 파라미터입니다.",
                ["YourCurrentAspectRatio"] = "화면비율 설정",
                ["YourCurrentUISize"] = "UI 사이즈 설정",
                ["FitBelt"] = "<color=yellow>이 사각형을 아이템벨트에 맞춰주세요</color>",
                ["FitStatusW"] = "<color=yellow>이 사각형을 상태창에 맞춰주세요</color>"
            }, this, "ko");
        }

        private string Lang(string key, string id = null, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        #endregion

        #region DataManage

        public class DataManager
        {
            public DataFile Data;
            private DynamicConfigFile _dynamicConfigFile;

            public DataManager()
            {
                _dynamicConfigFile = Interface.Oxide.DataFileSystem.GetDatafile("UIScaleManagerPlayerData");
            }

            public LoadResult LoadPlayersData()
            {
                Data = _dynamicConfigFile.ReadObject<DataFile>();

                if (Data == null)
                    Data = new DataFile();

                return VersionUpdate();
            }

            public void SavePlayersData()
            {
                _dynamicConfigFile.WriteObject<DataFile>(Data);
            }

            private LoadResult VersionUpdate()
            {
                if (Data.DataVersion < _pluginVersion)
                {
                    Data = new DataFile();
                    _dynamicConfigFile.WriteObject<DataFile>(Data);
                    return LoadResult.Updated;
                }
                return LoadResult.Ok;
            }

            public enum LoadResult
            {
                Ok,
                Updated
            }

            public class DataFile
            {
                public Dictionary<string, UIStatus> Players;//is readonly but Jsonserialize...
                public VersionNumber DataVersion;

                public DataFile()
                {
                    Players = new Dictionary<string, UIStatus>();
                    Players = Players;
                    DataVersion = _pluginVersion;
                }

                public void AddPlayerData(IPlayer player)
                {
                    var uiStatus = new UIStatus(player);
                    Players.Add(player.Id, uiStatus);
                }

                public void AddPlayerData(IPlayer player, float uiscale, int RatioIndicator)
                {
                    var uiStatus = new UIStatus(player, uiscale, RatioIndicator);
                    Players.Add(player.Id, uiStatus);
                }

                public class UIStatus
                {
                    public string Name { get; set; }

                    [JsonIgnore]
                    public float UIScale
                    {
                        get { return _uiScale; }
                        set
                        {
                            if (value < 0.5)
                                value = 0.5f;
                            else if (1.0f < value)
                                value = 1.0f;

                            value = (float)Math.Round(value, 7);
                            _uiScale = value;
                        }
                    }
                    /// <summary>
                    /// DO NOT USE IT
                    /// </summary>
                    [JsonProperty("UIScale")]
                    public float _uiScale;

                    [JsonProperty("AspectRatio")]
                    public AspectRatio Ratio { get; set; }

                    /// <summary>
                    /// DO NOT USE IT
                    /// </summary>
                    public UIStatus()
                    {
                        //for json serialize
                    }

                    public UIStatus(IPlayer player)
                    {
                        Name = player.Name;
                        UIScale = _defaultUIScale;
                        Ratio = new AspectRatio(_defaultAspectRatioIndicator);
                    }

                    public UIStatus(IPlayer player, float uiscale, int AspectRatioIndicator)
                    {
                        Name = player.Name;
                        UIScale = uiscale;
                        Ratio = new AspectRatio(AspectRatioIndicator);
                    }

                    public class AspectRatio
                    {
                        [JsonIgnore]
                        public int Indicator
                        {
                            get { return _indicator; }
                            set
                            {
                                if (value < 0)
                                {
                                    value = Mathf.Abs(value) % _ratioPresets.Length;
                                    value = _ratioPresets.Length - 1;
                                    if (value == _ratioPresets.Length)
                                        value -= 1;
                                }
                                else
                                    value %= _ratioPresets.Length;
                                _indicator = value;
                                AspectRatioRaw aspectRatioRaw = _ratioPresets[_indicator];
                                X = aspectRatioRaw.X;
                                Y = aspectRatioRaw.Y;
                            }
                        }
                        /// <summary>
                        /// DO NOT USE IT
                        /// </summary>
                        [JsonProperty("Indicator")]
                        public int _indicator;

                        /// <summary>
                        /// DO NOT SET IT
                        /// </summary>
                        public int X;
                        /// <summary>
                        /// DO NOT SET IT
                        /// </summary>
                        public int Y;

                        public AspectRatio()
                        {
                            Indicator = _defaultAspectRatioIndicator;
                        }

                        public AspectRatio(int indicator)
                        {
                            Indicator = indicator;
                        }
                    }
                }
            }
        }

        #endregion

        #region Command

        [Command("UIScaleManager.control")]
        void SetUIScaleCommand(IPlayer player, string command, string[] args)
        {
            if (player.IsServer) return;

            var bPlayer = player.Object as BasePlayer;

            if (args.Length >= 1)
            {
                if (args[0] == "ratio")
                {
                    if (args.Length >= 2)
                    {
                        int parsedResult;
                        if (int.TryParse(args[1], out parsedResult) == false)
                            player.Message(Lang("Error", player.Id));
                        else
                        {
                            DataManager.DataFile.UIStatus playerinfo;
                            if (!_dataManager.Data.Players.ContainsKey(player.Id))
                            {
                                _dataManager.Data.AddPlayerData(player, _defaultUIScale, _defaultAspectRatioIndicator + parsedResult);
                                playerinfo = _dataManager.Data.Players[player.Id];
                            }
                            else
                            {
                                playerinfo = _dataManager.Data.Players[player.Id];
                                playerinfo.Ratio.Indicator += parsedResult;
                            }
                            _uiController.UpdateDisplayAspectRatio(bPlayer, playerinfo.Ratio.X, playerinfo.Ratio.Y, playerinfo.UIScale);
                            player.Message(Lang("UI Scale Data Changed", player.Id, playerinfo.UIScale, playerinfo.Ratio.X, playerinfo.Ratio.Y));
                            if (_playerUIInfoCache.ContainsKey(player.Id))
                                _playerUIInfoCache.Remove(player.Id);
                            Interface.CallHook("OnUIScaleChanged", player, playerinfo.UIScale, playerinfo.Ratio.X, playerinfo.Ratio.Y);
                        }
                    }
                    else
                        player.Message(Lang("Error", player.Id));
                }
                else if (args[0] == "size")
                {
                    if (args.Length >= 2)
                    {
                        float parsedResult;

                        if (float.TryParse(args[1], out parsedResult) == false)
                        {
                            player.Message(Lang("Error", player.Id));
                        }
                        else
                        {
                            DataManager.DataFile.UIStatus playerinfo;
                            if (!_dataManager.Data.Players.ContainsKey(player.Id))
                            {
                                _dataManager.Data.AddPlayerData(player, _defaultUIScale + parsedResult, _defaultAspectRatioIndicator);
                                playerinfo = _dataManager.Data.Players[player.Id];
                            }
                            else
                            {
                                playerinfo = _dataManager.Data.Players[player.Id];
                                playerinfo.UIScale += parsedResult;
                            }
                            _uiController.UpdateDisplayUISize(bPlayer, playerinfo.Ratio.X, playerinfo.Ratio.Y, playerinfo.UIScale);
                            player.Message(Lang("UI Scale Data Changed", player.Id, playerinfo.UIScale, playerinfo.Ratio.X, playerinfo.Ratio.Y));
                            if (_playerUIInfoCache.ContainsKey(player.Id))
                                _playerUIInfoCache.Remove(player.Id);
                            Interface.CallHook("OnUIScaleChanged", player, playerinfo.UIScale, playerinfo.Ratio.X, playerinfo.Ratio.Y);
                        }
                    }
                    else
                        player.Message(Lang("Error", player.Id));
                }
                else
                    player.Message(Lang("Error", player.Id));
            }
            else
            {
                if (!_dataManager.Data.Players.ContainsKey(player.Id))
                {
                    _dataManager.Data.AddPlayerData(player);
                    player.Message(Lang("UI Scale Data Changed", player.Id, _defaultUIScale, _defaultAspectRatioX, _defaultAspectRatioY));
                    if (_playerUIInfoCache.ContainsKey(player.Id))
                        _playerUIInfoCache.Remove(player.Id);
                    Interface.CallHook("OnUIScaleChanged", player, _defaultUIScale, _defaultAspectRatioX, _defaultAspectRatioY);
                    _uiController.CloseUI(bPlayer);
                }
                else
                {
                    _uiController.CloseUI(bPlayer);
                }
            }
        }

        [Command("setui")]
        void SetUIScaleOpenCommand(IPlayer player, string command, string[] args)
        {
            if (player.IsServer) return;

            var bPlayer = player.Object as BasePlayer;
            if (!_dataManager.Data.Players.ContainsKey(player.Id))
                _uiController.OpenUI(bPlayer, _defaultAspectRatioX, _defaultAspectRatioY, _defaultUIScale);
            else
            {
                var playerinfo = _dataManager.Data.Players[player.Id];
                _uiController.OpenUI(bPlayer, playerinfo.Ratio.X, playerinfo.Ratio.Y, playerinfo.UIScale);
            }
        }

        #endregion

        #region API

        private float[] API_CheckPlayerUIInfo(string playerID)
        {
            if (_playerUIInfoCache.ContainsKey(playerID))
                return _playerUIInfoCache[playerID];
            else if (_dataManager.Data.Players.ContainsKey(playerID))
            {
                var uIStatus = _dataManager.Data.Players[playerID];
                float[] playerinfo =  new float[] {
                    uIStatus.Ratio.X,
                    uIStatus.Ratio.Y,
                    uIStatus.UIScale
                };
                _playerUIInfoCache.Add(playerID, playerinfo);
                return playerinfo;
            }
            else
                return null;
        }

        private float[] API_GetItemBeltAnchor(int ratioX, int ratioY, float uiSize)
        {
            var dscalingParameter =  new UIGenerator.UIScaler.DScalingParameter(ratioX, ratioY, uiSize);

            if (_uiController.UIScaler.ItemBeltResultCache.ContainsKey(dscalingParameter))
                return _uiScaler.ItemBeltResultCache[dscalingParameter].Result;
            else
            {
                _uiScaler.ItemBeltScaleCaching(ratioX, ratioY, uiSize);
                return _uiScaler.ItemBeltResultCache[dscalingParameter].Result;
            }
        }
        
        private float[] API_GetItemBeltAnchor(string playerID)
        {
            if (_dataManager.Data.Players.ContainsKey(playerID))
            {
                var uIStatus = _dataManager.Data.Players[playerID];
                return API_GetItemBeltAnchor(uIStatus.Ratio.X, uIStatus.Ratio.Y, uIStatus.UIScale);
            }
            else
                return null;
        }

        private float[] API_GetStatusWindowAnchor(int ratioX, int ratioY, float uiSize)
        {
            var dscalingParameter = new UIGenerator.UIScaler.DScalingParameter(ratioX, ratioY, uiSize);

            if (_uiController.UIScaler.StatusWindowResultCache.ContainsKey(dscalingParameter))
                return _uiScaler.StatusWindowResultCache[dscalingParameter].Result;
            else
            {
                _uiScaler.StatusWindowScaleCaching(ratioX, ratioY, uiSize);
                return _uiScaler.StatusWindowResultCache[dscalingParameter].Result;
            }
        }

        private float[] API_GetStatusWindowAnchor(string playerID)
        {
            if (_dataManager.Data.Players.ContainsKey(playerID))
            {
                var uIStatus = _dataManager.Data.Players[playerID];
                return API_GetStatusWindowAnchor(uIStatus.Ratio.X, uIStatus.Ratio.Y, uIStatus.UIScale);
            }
            else
                return null;
        }

        private float[] API_AutoAnchorScaling(float anchorMinX, float anchorMinY, float anchorMaxX, float anchorMaxY, int center, int parent, int ratioX, int ratioY, float uiSize)
        {
            var scalingResult = _uiScaler.UniversalPanelScaling(new UIGenerator.StackRectAnchor(anchorMinX, anchorMinY, anchorMaxX, anchorMaxY), (UIGenerator.RootRectAnchor.RectCenter)center, (UIGenerator.UIScaler.ScalingParent)parent, ratioX, ratioY, uiSize);
            return scalingResult.Result;
        }

        private float[] API_AutoAnchorScaling(float anchorMinX, float anchorMinY, float anchorMaxX, float anchorMaxY, int center, int parent, string playerID)
        {
            if (_dataManager.Data.Players.ContainsKey(playerID))
            {
                var uiStatus = _dataManager.Data.Players[playerID];
                return API_AutoAnchorScaling(anchorMinX, anchorMinY, anchorMaxX, anchorMaxY, center, parent, uiStatus.Ratio.X, uiStatus.Ratio.Y, uiStatus.UIScale);
            }
            else
                return null;
        }

        #endregion

        #region UI

        public class UIController
        {
            public UIGenerator.UIScaler UIScaler { get { return _uiGenerator.Scaler; } }

            private UIGenerator _uiGenerator;
            private List<string> _uiUsers;

            public UIController()
            {
                _uiGenerator = new UIGenerator();
                _uiUsers = new List<string>();
            }

            public void OpenUI(BasePlayer player, int ratioX, int ratioY, float uiSize)
            {
                if (_uiUsers.Contains(player.UserIDString))
                    return;

                _uiUsers.Add(player.UserIDString);
                _uiGenerator.UIInit(player);
                _uiGenerator.DrawAspectRatioLabel(player, ratioX, ratioY);
                _uiGenerator.DrawSizeLabel(player, uiSize);
                _uiGenerator.DrawUIGuidePanel(player, ratioX, ratioY, uiSize);
            }

            public void CloseUI(BasePlayer player)
            {
                if (!_uiUsers.Contains(player.UserIDString))
                    return;

                _uiGenerator.DestroyMainUI(player);
                _uiUsers.Remove(player.UserIDString);
            }

            public void UpdateDisplayAspectRatio(BasePlayer player, int ratioX, int ratioY, float uiSize)
            {
                if (!_uiUsers.Contains(player.UserIDString))
                    return;

                _uiGenerator.DestroyAspectRatioLabel(player);
                _uiGenerator.DrawAspectRatioLabel(player, ratioX, ratioY);
                _uiGenerator.DestoryUIGuidePanel(player);
                _uiGenerator.DrawUIGuidePanel(player, ratioX, ratioY, uiSize);
            }

            public void UpdateDisplayUISize(BasePlayer player, int ratioX, int ratioY, float uiSize)
            {
                if (!_uiUsers.Contains(player.UserIDString))
                    return;

                _uiGenerator.DestroySizeLabel(player);
                _uiGenerator.DrawSizeLabel(player, uiSize);
                _uiGenerator.DestoryUIGuidePanel(player);
                _uiGenerator.DrawUIGuidePanel(player, ratioX, ratioY, uiSize);
            }
        }

        public class UIGenerator
        {
            public UIScaler Scaler;

            private const string _main = "USM_Main";
            private const string _mainInner = "USM_MainInner";
            private const string _innerUp = "USM_InnerUp";
            private const string _innerDown = "USM_InnerDown";
            private const string _ratioLabel = "USM_RatioLabel";
            private const string _sizeLabel = "USM_SizeLabel";
            private const string _rButtonRatioPanel = "USM_RButtonRatioPanel";
            private const string _lButtonRatioPanel = "USM_LButtonRatioPanel";
            private const string _rButtonSizePanel = "USM_RButtonSizePanel";
            private const string _lButtonSizePanel = "USM_LButtonSizePanel";
            private const string _itemBeltPanel = "USM_ItemBeltPanel";
            private const string _statusWindowPanel = "USM_StatusWindowPanel";

            public const float UnitCorrection = 0.0031f;
            private static float _xunit;
            private static float _yunit;
            private readonly UniversalRectAnchor _mainInnerPanelAnchor;
            private readonly UniversalRectAnchor _innerUpPanelAnchor;
            private readonly UniversalRectAnchor _innerDownPanelAnchor;
            private readonly UniversalRectAnchor _cLabelAnchor;
            private readonly UniversalRectAnchor _valueLabelAnchor;
            private readonly UniversalRectAnchor _rButtonPanel;
            private readonly UniversalRectAnchor _lButtonPanel;
            private readonly UniversalRectAnchor _buttonAnchor;

            private static UniversalRectAnchor _itemBeltAnchor;
            private static UniversalRectAnchor _statusWindowAnchor;
            private readonly UniversalRectAnchor _textPadding;

            public UIGenerator()
            {
                Scaler = new UIScaler();

                _xunit = _defaultAspectRatioY * 0.01f;
                _yunit = _defaultAspectRatioX * 0.01f;

                _mainInnerPanelAnchor = new UniversalRectAnchor((_xunit * 5) - UnitCorrection, (_yunit * 4) - UnitCorrection);
                _mainInnerPanelAnchor.AlignCenterX();
                _mainInnerPanelAnchor.AlignCenterY();
                _mainInnerPanelAnchor.MoveY(_yunit / 2);
                
                _innerUpPanelAnchor = new UniversalRectAnchor(0,                  0.5f,
                                                              1 - UnitCorrection, 1.0f - UnitCorrection);
                _innerDownPanelAnchor = new UniversalRectAnchor(0,                  0,
                                                              1 - UnitCorrection, 0.5f - UnitCorrection);

                _cLabelAnchor = new UniversalRectAnchor(0, 0, 1, 0.2f - UnitCorrection);
                _cLabelAnchor.MoveYEnd();

                _valueLabelAnchor = new UniversalRectAnchor(0, 0, 0.601f, 0.8f - UnitCorrection);
                _valueLabelAnchor.AlignCenterX();

                _rButtonPanel = new UniversalRectAnchor(0, 0, 0.2f - UnitCorrection, 0.8f - UnitCorrection);
                _rButtonPanel.MoveXEnd();
                _lButtonPanel = new UniversalRectAnchor(0, 0, 0.2f - UnitCorrection, 0.8f - UnitCorrection);

                _buttonAnchor = new UniversalRectAnchor(0.9f, 0.9f);
                _buttonAnchor.AlignCenterX();
                _buttonAnchor.AlignCenterY();

                _itemBeltAnchor = new UniversalRectAnchor(0.312f, 0.082f);
                _statusWindowAnchor = new UniversalRectAnchor(0.149f, 0.112f);

                _textPadding = new UniversalRectAnchor(0.9f, 0.9f);
                _textPadding.AlignCenterX();
                _textPadding.AlignCenterY();
            }

            public void UIInit(BasePlayer player)
            {
                CuiElementContainer UIInstance = new CuiElementContainer();
                string CRatio = _langGlobal("YourCurrentAspectRatio", player.UserIDString);
                string CUISize = _langGlobal("YourCurrentUISize", player.UserIDString);

                //////////////////////////////////////////////////////////mainUI

                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "0 0 0 0"
                        },

                    RectTransform =
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1"
                        },
                }, "Overlay", _main);

                UIInstance.Add(new CuiButton
                {
                    RectTransform =
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1"
                        },
                    Button =
                        {
                            Color = "0 0 0 0",
                            Command = "UIScaleManager.control"
                        },
                    Text =
                        {
                            Text = "",
                            FontSize = 13,
                            Align = TextAnchor.MiddleCenter
                        }
                }, _main);
                
                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "0 0 0 0.5"
                        },

                    RectTransform =
                        {
                            AnchorMin = _mainInnerPanelAnchor.AnchorMin,
                            AnchorMax = _mainInnerPanelAnchor.AnchorMax
                        },
                }, _main, _mainInner);

                ////////////////////////////////////////InnerUp
                
                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "0 0 0 0"
                        },

                    RectTransform =
                        {
                            AnchorMin = _innerUpPanelAnchor.AnchorMin,
                            AnchorMax = _innerUpPanelAnchor.AnchorMax
                        },
                }, _mainInner, _innerUp);

                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "0 0 0 0.5"
                        },

                    RectTransform =
                        {
                            AnchorMin = _cLabelAnchor.AnchorMin,
                            AnchorMax = _cLabelAnchor.AnchorMax
                        },
                }, _innerUp);

                UIInstance.Add(new CuiLabel
                {
                    Text =
                        {
                            Text = CRatio,
                            FontSize = 25,
                            Align = TextAnchor.MiddleCenter
                        },
                    RectTransform =
                        {
                            AnchorMin = _cLabelAnchor.AnchorMin,
                            AnchorMax = _cLabelAnchor.AnchorMax
                        }
                }, _innerUp);

                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "0 0 0 0"
                        },

                    RectTransform =
                        {
                            AnchorMin = _lButtonPanel.AnchorMin,
                            AnchorMax = _lButtonPanel.AnchorMax
                        },
                }, _innerUp, _lButtonRatioPanel);
                
                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "0 0 0 0"
                        },

                    RectTransform =
                        {
                            AnchorMin = _rButtonPanel.AnchorMin,
                            AnchorMax = _rButtonPanel.AnchorMax
                        },
                }, _innerUp, _rButtonRatioPanel);

                UIInstance.Add(new CuiButton
                {
                    RectTransform =
                        {
                            AnchorMin = _buttonAnchor.AnchorMin,
                            AnchorMax = _buttonAnchor.AnchorMax
                        },
                    Button =
                        {
                            Color = "0 0 0 0",
                            Command = "UIScaleManager.control ratio -1"
                        },
                    Text =
                        {
                            Text = "<",
                            FontSize = 50,
                            Align = TextAnchor.MiddleCenter
                        }
                }, _lButtonRatioPanel);

                UIInstance.Add(new CuiButton
                {
                    RectTransform =
                        {
                            AnchorMin = _buttonAnchor.AnchorMin,
                            AnchorMax = _buttonAnchor.AnchorMax
                        },
                    Button =
                        {
                            Color = "0 0 0 0",
                            Command = "UIScaleManager.control ratio 1"
                        },
                    Text =
                        {
                            Text = ">",
                            FontSize = 50,
                            Align = TextAnchor.MiddleCenter
                        }
                }, _rButtonRatioPanel);

                ////////////////////////////////////////InnerUp

                ////////////////////////////////////////InnerDown

                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "0 0 0 0"
                        },

                    RectTransform =
                        {
                            AnchorMin = _innerDownPanelAnchor.AnchorMin,
                            AnchorMax = _innerDownPanelAnchor.AnchorMax
                        },
                }, _mainInner, _innerDown);

                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "0 0 0 0.5"
                        },

                    RectTransform =
                        {
                            AnchorMin = _cLabelAnchor.AnchorMin,
                            AnchorMax = _cLabelAnchor.AnchorMax
                        },
                }, _innerDown);

                UIInstance.Add(new CuiLabel
                {
                    Text =
                        {
                            Text = CUISize,
                            FontSize = 25,
                            Align = TextAnchor.MiddleCenter
                        },
                    RectTransform =
                        {
                            AnchorMin = _cLabelAnchor.AnchorMin,
                            AnchorMax = _cLabelAnchor.AnchorMax
                        }
                }, _innerDown);

                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "0 0 0 0"
                        },

                    RectTransform =
                        {
                            AnchorMin = _lButtonPanel.AnchorMin,
                            AnchorMax = _lButtonPanel.AnchorMax
                        },
                }, _innerDown, _lButtonSizePanel);

                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "0 0 0 0"
                        },

                    RectTransform =
                        {
                            AnchorMin = _rButtonPanel.AnchorMin,
                            AnchorMax = _rButtonPanel.AnchorMax
                        },
                }, _innerDown, _rButtonSizePanel);

                UIInstance.Add(new CuiButton
                {
                    RectTransform =
                        {
                            AnchorMin = _buttonAnchor.AnchorMin,
                            AnchorMax = _buttonAnchor.AnchorMax
                        },
                    Button =
                        {
                            Color = "0 0 0 0",
                            Command = "UIScaleManager.control size -0.1"
                        },
                    Text =
                        {
                            Text = "<",
                            FontSize = 50,
                            Align = TextAnchor.MiddleCenter
                        }
                }, _lButtonSizePanel);

                UIInstance.Add(new CuiButton
                {
                    RectTransform =
                        {
                            AnchorMin = _buttonAnchor.AnchorMin,
                            AnchorMax = _buttonAnchor.AnchorMax
                        },
                    Button =
                        {
                            Color = "0 0 0 0",
                            Command = "UIScaleManager.control size 0.1"
                        },
                    Text =
                        {
                            Text = ">",
                            FontSize = 50,
                            Align = TextAnchor.MiddleCenter
                        }
                }, _rButtonSizePanel);

                ////////////////////////////////////////InnerDown

                ////////////////////////////////////////////////////////mainUI

                CuiHelper.AddUi(player, UIInstance);
            }

            public void DestroyMainUI(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, _main);
            }

            public void DrawAspectRatioLabel(BasePlayer player, int ratioX, int ratioY)
            {
                CuiElementContainer UIInstance = new CuiElementContainer();

                UIInstance.Add(new CuiLabel
                {
                    Text =
                        {
                            Text = $"{ratioX}:{ratioY}",
                            FontSize = 140,
                            Align = TextAnchor.MiddleCenter
                        },
                    RectTransform =
                        {
                            AnchorMin = _valueLabelAnchor.AnchorMin,
                            AnchorMax = _valueLabelAnchor.AnchorMax
                        }
                }, _innerUp, _ratioLabel);

                CuiHelper.AddUi(player, UIInstance);
            }

            public void DestroyAspectRatioLabel(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, _ratioLabel);
            }

            public void DrawSizeLabel(BasePlayer player, float uiSize)
            {
                CuiElementContainer UIInstance = new CuiElementContainer();

                UIInstance.Add(new CuiLabel
                {
                    Text =
                        {
                            Text = uiSize.ToString("0.0"),
                            FontSize = 140,
                            Align = TextAnchor.MiddleCenter
                        },
                    RectTransform =
                        {
                            AnchorMin = _valueLabelAnchor.AnchorMin,
                            AnchorMax = _valueLabelAnchor.AnchorMax
                        }
                }, _innerDown, _sizeLabel);

                CuiHelper.AddUi(player, UIInstance);
            }

            public void DestroySizeLabel(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, _sizeLabel);
            }

            public void DrawUIGuidePanel(BasePlayer player, int ratioX, int ratioY, float uiSize)
            {
                string fitBelt = _langGlobal("FitBelt", player.UserIDString);
                string fitWindow = _langGlobal("FitStatusW", player.UserIDString);

                CuiElementContainer uiInstance = new CuiElementContainer();

                UniversalRectAnchor scaledBeltAnchor = _itemBeltAnchor.Clone();
                Scaler.ItemBeltScaling(ref scaledBeltAnchor, ratioX, ratioY, uiSize);

                uiInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "0 0 0 0.5"
                        },

                    RectTransform =
                        {
                            AnchorMin = scaledBeltAnchor.AnchorMin,
                            AnchorMax = scaledBeltAnchor.AnchorMax
                        },
                }, _main, _itemBeltPanel);

                uiInstance.Add(new CuiLabel
                {
                    Text =
                        {
                            Text = fitBelt,
                            FontSize = (int)(18 * uiSize),
                            Align = TextAnchor.MiddleCenter
                        },
                    RectTransform =
                        {
                            AnchorMin = _textPadding.AnchorMin,
                            AnchorMax = _textPadding.AnchorMax
                        }
                }, _itemBeltPanel);
                uiInstance.AddRange(GetOutline(_itemBeltPanel, 0.009f, 0.06f));

                UniversalRectAnchor ScaledWindowAnchor = _statusWindowAnchor.Clone();
                Scaler.StatusWindowScaling(ref ScaledWindowAnchor, ratioX, ratioY, uiSize);

                uiInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "0 0 0 0.5"
                        },

                    RectTransform =
                        {
                            AnchorMin = ScaledWindowAnchor.AnchorMin,
                            AnchorMax = ScaledWindowAnchor.AnchorMax
                        },
                }, _main, _statusWindowPanel);

                uiInstance.Add(new CuiLabel
                {
                    Text =
                        {
                            Text = fitWindow,
                            FontSize = (int)(18 * uiSize),
                            Align = TextAnchor.MiddleCenter
                        },
                    RectTransform =
                        {
                            AnchorMin = _textPadding.AnchorMin,
                            AnchorMax = _textPadding.AnchorMax
                        }
                }, _statusWindowPanel);
                uiInstance.AddRange(GetOutline(_statusWindowPanel, 0.015f, 0.049f));

                #region test code
                /*
                CuiHelper.DestroyUi(player, "TestPanel");
                StackRectAnchor TestPanelAnchor = new StackRectAnchor(0.1f, 0.12f, 0.34f, 0.2f);
                UIScaler.ScalingResult scalingResult = uiScaler.UniversalPanelScaling(TestPanelAnchor, RootRectAnchor.RectCenter.LowerRight, UIScaler.ScalingParent.ItemBeltUpperLeft, RatioX, RatioY, UISize);

                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "1 1 0 1"
                        },

                    RectTransform =
                        {
                            AnchorMin = scalingResult.AnchorMinX + " " + scalingResult.AnchorMinY,
                            AnchorMax = scalingResult.AnchorMaxX + " " + scalingResult.AnchorMaxY
                        },
                }, Main, "TestPanel");

                CuiHelper.DestroyUi(player, "TestPanel2");
                StackRectAnchor TestPanelAnchor2 = new StackRectAnchor(0.65f, 0.12f, 0.8f, 0.2f);
                UIScaler.ScalingResult scalingResult2 = uiScaler.UniversalPanelScaling(TestPanelAnchor2, RootRectAnchor.RectCenter.LowerLeft, UIScaler.ScalingParent.ItemBeltUpperRight, RatioX, RatioY, UISize);

                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "1 1 0 1"
                        },

                    RectTransform =
                        {
                            AnchorMin = scalingResult2.AnchorMinX + " " + scalingResult2.AnchorMinY,
                            AnchorMax = scalingResult2.AnchorMaxX + " " + scalingResult2.AnchorMaxY
                        },
                }, Main, "TestPanel2");
                CuiHelper.DestroyUi(player, "TestPanel3");
                StackRectAnchor TestPanelAnchor3 = new StackRectAnchor(0.4f, 0.11f, 0.6f, 0.2f);
                UIScaler.ScalingResult scalingResult3 = uiScaler.UniversalPanelScaling(TestPanelAnchor3, RootRectAnchor.RectCenter.LowerCenter, UIScaler.ScalingParent.ItemBeltUpperCenter, RatioX, RatioY, UISize);

                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "1 1 0 1"
                        },

                    RectTransform =
                        {
                            AnchorMin = scalingResult3.AnchorMinX + " " + scalingResult3.AnchorMinY,
                            AnchorMax = scalingResult3.AnchorMaxX + " " + scalingResult3.AnchorMaxY
                        },
                }, Main, "TestPanel3");
                CuiHelper.DestroyUi(player, "TestPanel4");
                StackRectAnchor TestPanelAnchor4 = new StackRectAnchor(0.1f, 0.04f, 0.32f, 0.09f);
                UIScaler.ScalingResult scalingResult4 = uiScaler.UniversalPanelScaling(TestPanelAnchor4, RootRectAnchor.RectCenter.MiddleRight, UIScaler.ScalingParent.ItemBeltMiddleLeft, RatioX, RatioY, UISize);

                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "1 1 0 1"
                        },

                    RectTransform =
                        {
                            AnchorMin = scalingResult4.AnchorMinX + " " + scalingResult4.AnchorMinY,
                            AnchorMax = scalingResult4.AnchorMaxX + " " + scalingResult4.AnchorMaxY
                        },
                }, Main, "TestPanel4");
                CuiHelper.DestroyUi(player, "TestPanel5");
                StackRectAnchor TestPanelAnchor5 = new StackRectAnchor(0.45f, 0.04f, 0.556f, 0.09f);
                UIScaler.ScalingResult scalingResult5 = uiScaler.UniversalPanelScaling(TestPanelAnchor5, RootRectAnchor.RectCenter.MiddleCenter, UIScaler.ScalingParent.ItemBeltMiddleCenter, RatioX, RatioY, UISize);

                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "1 1 0 1"
                        },

                    RectTransform =
                        {
                            AnchorMin = scalingResult5.AnchorMinX + " " + scalingResult5.AnchorMinY,
                            AnchorMax = scalingResult5.AnchorMaxX + " " + scalingResult5.AnchorMaxY
                        },
                }, Main, "TestPanel5");
                CuiHelper.DestroyUi(player, "TestPanel6");
                StackRectAnchor TestPanelAnchor6 = new StackRectAnchor(0.7f, 0.04f, 0.8f, 0.09f);
                UIScaler.ScalingResult scalingResult6 = uiScaler.UniversalPanelScaling(TestPanelAnchor6, RootRectAnchor.RectCenter.MiddleLeft, UIScaler.ScalingParent.ItemBeltMiddleRight, RatioX, RatioY, UISize);

                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "1 1 0 1"
                        },

                    RectTransform =
                        {
                            AnchorMin = scalingResult6.AnchorMinX + " " + scalingResult6.AnchorMinY,
                            AnchorMax = scalingResult6.AnchorMaxX + " " + scalingResult6.AnchorMaxY
                        },
                }, Main, "TestPanel6");

                CuiHelper.DestroyUi(player, "TestPanel7");
                StackRectAnchor TestPanelAnchor7 = new StackRectAnchor(0.1f, 0.01f, 0.32f, 0.02f);
                UIScaler.ScalingResult scalingResult7 = uiScaler.UniversalPanelScaling(TestPanelAnchor7, RootRectAnchor.RectCenter.UpperRight, UIScaler.ScalingParent.ItemBeltMiddleLeft, RatioX, RatioY, UISize);

                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "1 1 0 1"
                        },

                    RectTransform =
                        {
                            AnchorMin = scalingResult7.AnchorMinX + " " + scalingResult7.AnchorMinY,
                            AnchorMax = scalingResult7.AnchorMaxX + " " + scalingResult7.AnchorMaxY
                        },
                }, Main, "TestPanel7");
                CuiHelper.DestroyUi(player, "TestPanel8");
                StackRectAnchor TestPanelAnchor8 = new StackRectAnchor(0.45f, 0.01f, 0.556f, 0.02f);
                UIScaler.ScalingResult scalingResult8 = uiScaler.UniversalPanelScaling(TestPanelAnchor8, RootRectAnchor.RectCenter.UpperCenter, UIScaler.ScalingParent.ItemBeltMiddleCenter, RatioX, RatioY, UISize);

                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "1 1 0 1"
                        },

                    RectTransform =
                        {
                            AnchorMin = scalingResult8.AnchorMinX + " " + scalingResult8.AnchorMinY,
                            AnchorMax = scalingResult8.AnchorMaxX + " " + scalingResult8.AnchorMaxY
                        },
                }, Main, "TestPanel8");
                CuiHelper.DestroyUi(player, "TestPanel9");
                StackRectAnchor TestPanelAnchor9 = new StackRectAnchor(0.7f, 0.01f, 0.8f, 0.02f);
                UIScaler.ScalingResult scalingResult9 = uiScaler.UniversalPanelScaling(TestPanelAnchor9, RootRectAnchor.RectCenter.UpperLeft, UIScaler.ScalingParent.ItemBeltMiddleRight, RatioX, RatioY, UISize);

                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "1 1 0 1"
                        },

                    RectTransform =
                        {
                            AnchorMin = scalingResult9.AnchorMinX + " " + scalingResult9.AnchorMinY,
                            AnchorMax = scalingResult9.AnchorMaxX + " " + scalingResult9.AnchorMaxY
                        },
                }, Main, "TestPanel9");

                CuiHelper.DestroyUi(player, "TestPanel10");
                StackRectAnchor TestPanelAnchor10 = new StackRectAnchor(0 + 0.42f, 0 + 0.22f, Xunit + 0.42f, Yunit + 0.22f);
                UIScaler.ScalingResult scalingResult10 = uiScaler.UniversalPanelScaling(TestPanelAnchor10, RootRectAnchor.RectCenter.LowerLeft, UIScaler.ScalingParent.MainMiddleLeft, RatioX, RatioY, UISize);

                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "1 1 0 1"
                        },

                    RectTransform =
                        {
                            AnchorMin = scalingResult10.AnchorMinX + " " + scalingResult10.AnchorMinY,
                            AnchorMax = scalingResult10.AnchorMaxX + " " + scalingResult10.AnchorMaxY
                        },
                }, Main, "TestPanel10");
                */
                #endregion

                CuiHelper.AddUi(player, uiInstance);
            }

            public void DestoryUIGuidePanel(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, _itemBeltPanel);
                CuiHelper.DestroyUi(player, _statusWindowPanel);
            }

            public CuiElementContainer GetOutline(string parent, float xsize, float ysize)
            {
                CuiElementContainer UIInstance = new CuiElementContainer();

                UniversalRectAnchor LeftBarRectAnchor = new UniversalRectAnchor( 0,         0,         xsize - UnitCorrection, 1 - 0.02f);
                UniversalRectAnchor RightBarRectAnchor = new UniversalRectAnchor(1 - xsize, 0,         1 - UnitCorrection,     1 - 0.02f);
                UniversalRectAnchor UpBarRectAnchor = new UniversalRectAnchor(   0,         1 - ysize, 1 - 0.003f,             1 - 0.02f);
                UniversalRectAnchor DownBarRectAnchor = new UniversalRectAnchor( 0,         0,         1 - 0.003f,             ysize - 0.02f);

                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "1 1 0 1"
                        },

                    RectTransform =
                        {
                            AnchorMin = LeftBarRectAnchor.AnchorMin,
                            AnchorMax = LeftBarRectAnchor.AnchorMax
                        },
                }, parent);

                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "1 1 0 1"
                        },

                    RectTransform =
                        {
                            AnchorMin = RightBarRectAnchor.AnchorMin,
                            AnchorMax = RightBarRectAnchor.AnchorMax
                        },
                }, parent);

                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "1 1 0 1"
                        },

                    RectTransform =
                        {
                            AnchorMin = UpBarRectAnchor.AnchorMin,
                            AnchorMax = UpBarRectAnchor.AnchorMax
                        },
                }, parent);

                UIInstance.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    Image =
                        {
                            Color = "1 1 0 1"
                        },

                    RectTransform =
                        {
                            AnchorMin = DownBarRectAnchor.AnchorMin,
                            AnchorMax = DownBarRectAnchor.AnchorMax
                        },
                }, parent);

                return UIInstance;
            }

            public class UniversalRectAnchor
            {
                public float AnchorCenterX { get { return AnchorMinX + ((AnchorMaxX - AnchorMinX) / 2); } }
                public float AnchorCenterY { get { return AnchorMinY + ((AnchorMaxY - AnchorMinY) / 2); } }

                public float AnchorMinX { get; set; }
                public float AnchorMinY { get; set; }
                public float AnchorMaxX { get; set; }
                public float AnchorMaxY { get; set; }

                public string AnchorMin { get { return $"{AnchorMinX} {AnchorMinY}"; } }

                public string AnchorMax { get { return $"{AnchorMaxX} {AnchorMaxY}"; } }

                public UniversalRectAnchor(float maxX, float maxY)
                {
                    AnchorMinX = 0;
                    AnchorMinY = 0;
                    AnchorMaxX = maxX;
                    AnchorMaxY = maxY;
                }

                public UniversalRectAnchor(float minX, float minY, float maxX, float maxY)
                {
                    AnchorMinX = minX;
                    AnchorMinY = minY;
                    AnchorMaxX = maxX;
                    AnchorMaxY = maxY;
                }

                public UniversalRectAnchor(UIScaler.ScalingResult scalingResult)
                {
                    AnchorMinX = scalingResult.AnchorMinX;
                    AnchorMinY = scalingResult.AnchorMinY;
                    AnchorMaxX = scalingResult.AnchorMaxX;
                    AnchorMaxY = scalingResult.AnchorMaxY;
                }

                public void MoveX(float value)
                {
                    AnchorMinX += value;
                    AnchorMaxX += value;
                }

                public void MoveY(float value)
                {
                    AnchorMinY += value;
                    AnchorMaxY += value;
                }

                public void MoveXStart()
                {
                    MoveX(AnchorMinX * -1f);
                }

                public void MoveXEnd()
                {
                    MoveX(AnchorMinX * -1f);
                    MoveX(1.0f - AnchorMaxX - AnchorMinX);
                }

                public void MoveYStart()
                {
                    MoveY(AnchorMinY * -1f);
                }

                public void MoveYEnd()
                {
                    MoveY(AnchorMinY * -1f);
                    MoveY(1.0f - AnchorMaxY - AnchorMinY);
                }

                public void AlignCenterX()
                {
                    float MoveValue = (1.0f - (AnchorMaxX - AnchorMinX)) / 2;
                    MoveX(MoveValue);
                }

                public void AlignCenterY()
                {
                    float MoveValue = (1.0f - (AnchorMaxY - AnchorMinY)) / 2;
                    MoveY(MoveValue);
                }

                public UniversalRectAnchor Clone() => new UniversalRectAnchor(AnchorMinX, AnchorMinY, AnchorMaxX, AnchorMaxY);
            }

            public class RootRectAnchor
            {
                public float AnchorMinX
                {
                    get
                    {
                        switch (rectCenterPreset)
                        {
                            case RectCenter.UpperLeft:
                                return PositionX;
                            case RectCenter.UpperCenter:
                                return PositionX - ScaleX / 2;
                            case RectCenter.UpperRight:
                                return PositionX - ScaleX;

                            case RectCenter.MiddleLeft:
                                return PositionX;
                            case RectCenter.MiddleCenter:
                                return PositionX - ScaleX / 2;
                            case RectCenter.MiddleRight:
                                return PositionX - ScaleX;

                            case RectCenter.LowerLeft:
                                return PositionX;
                            case RectCenter.LowerCenter:
                                return PositionX - ScaleX / 2;
                            case RectCenter.LowerRight:
                                return PositionX - ScaleX;

                            default:
                                return PositionX;
                        }
                    }
                }
                public float AnchorMinY 
                {
                    get
                    {
                        switch (rectCenterPreset)
                        {
                            case RectCenter.UpperLeft:
                                return PositionY - ScaleY;
                            case RectCenter.UpperCenter:
                                return PositionY - ScaleY;
                            case RectCenter.UpperRight:
                                return PositionY - ScaleY;

                            case RectCenter.MiddleLeft:
                                return PositionY - ScaleY / 2;
                            case RectCenter.MiddleCenter:
                                return PositionY - ScaleY / 2;
                            case RectCenter.MiddleRight:
                                return PositionY - ScaleY / 2;

                            case RectCenter.LowerLeft:
                                return PositionY;
                            case RectCenter.LowerCenter:
                                return PositionY;
                            case RectCenter.LowerRight:
                                return PositionY;

                            default:
                                return PositionY;
                        }
                    }
                }
                public float AnchorMaxX
                {
                    get
                    {
                        switch (rectCenterPreset)
                        {
                            case RectCenter.UpperLeft:
                                return PositionX + ScaleX;
                            case RectCenter.UpperCenter:
                                return PositionX + ScaleX / 2;
                            case RectCenter.UpperRight:
                                return PositionX;

                            case RectCenter.MiddleLeft:
                                return PositionX + ScaleX;
                            case RectCenter.MiddleCenter:
                                return PositionX + ScaleX / 2;
                            case RectCenter.MiddleRight:
                                return PositionX;

                            case RectCenter.LowerLeft:
                                return PositionX + ScaleX;
                            case RectCenter.LowerCenter:
                                return PositionX + ScaleX / 2;
                            case RectCenter.LowerRight:
                                return PositionX;

                            default:
                                return PositionX;
                        }
                    }
                }
                public float AnchorMaxY
                {
                    get
                    {
                        switch (rectCenterPreset)
                        {
                            case RectCenter.UpperLeft:
                                return PositionY;
                            case RectCenter.UpperCenter:
                                return PositionY;
                            case RectCenter.UpperRight:
                                return PositionY;

                            case RectCenter.MiddleLeft:
                                return PositionY + ScaleY / 2;
                            case RectCenter.MiddleCenter:
                                return PositionY + ScaleY / 2;
                            case RectCenter.MiddleRight:
                                return PositionY + ScaleY / 2;

                            case RectCenter.LowerLeft:
                                return PositionY + ScaleY;
                            case RectCenter.LowerCenter:
                                return PositionY + ScaleY;
                            case RectCenter.LowerRight:
                                return PositionY + ScaleY;

                            default:
                                return PositionY;
                        }
                    }
                }

                public RectCenter rectCenterPreset { get; private set; }
                public float PositionX { get; set; }
                public float PositionY { get; set; }
                public float ScaleX { get; set; }
                public float ScaleY { get; set; }

                public RootRectAnchor(float minX, float minY, float maxX, float maxY, RectCenter rectcenterPreset)
                {
                    ScaleX = maxX - minX;
                    ScaleY = maxY - minY;
                    rectCenterPreset = rectcenterPreset;
                    PositionX = minX;
                    PositionY = minY;

                    switch (rectcenterPreset)
                    {
                        case RectCenter.UpperLeft:
                            PositionY += ScaleY;
                            break;
                        case RectCenter.UpperCenter:
                            PositionX += ScaleX / 2;
                            PositionY += ScaleY;
                            break;
                        case RectCenter.UpperRight:
                            PositionX += ScaleX;
                            PositionY += ScaleY;
                            break;
                        case RectCenter.MiddleLeft:
                            PositionY += ScaleY / 2;
                            break;
                        case RectCenter.MiddleCenter:
                            PositionX += ScaleX / 2;
                            PositionY += ScaleY / 2;
                            break;
                        case RectCenter.MiddleRight:
                            PositionX += ScaleX;
                            PositionY += ScaleY / 2;
                            break;
                        case RectCenter.LowerLeft:
                            //default
                            break;
                        case RectCenter.LowerCenter:
                            PositionX += ScaleX / 2;
                            break;
                        case RectCenter.LowerRight:
                            PositionX += ScaleX;
                            break;
                        default:
                            break;
                    }
                }

                public enum RectCenter
                {
                    UpperLeft,
                    UpperCenter,
                    UpperRight,
                    MiddleLeft,
                    MiddleCenter,
                    MiddleRight,
                    LowerLeft,
                    LowerCenter,
                    LowerRight
                }
            }

            public struct StackRectAnchor : IEquatable<StackRectAnchor>
            {
                public float AnchorMinX { get; set; }
                public float AnchorMinY { get; set; }
                public float AnchorMaxX { get; set; }
                public float AnchorMaxY { get; set; }

                public StackRectAnchor(float minX, float minY, float maxX, float maxY)
                {
                    AnchorMinX = minX;
                    AnchorMinY = minY;
                    AnchorMaxX = maxX;
                    AnchorMaxY = maxY;
                }

                public bool Equals(StackRectAnchor other)
                {
                    return (AnchorMinX == other.AnchorMinX) &&
                        (AnchorMinY == other.AnchorMinY) && 
                        (AnchorMaxX == other.AnchorMaxX) && 
                        (AnchorMaxY == other.AnchorMaxY);
                }

                public static bool operator ==(StackRectAnchor a, StackRectAnchor b) => a.Equals(b);

                public static bool operator !=(StackRectAnchor a, StackRectAnchor b) => !(a.Equals(b));
            }

            public class UIScaler
            {
                public IReadOnlyDictionary<DScalingParameter, ScalingResult> ItemBeltResultCache => itemBeltResultCache;
                public IReadOnlyDictionary<DScalingParameter, ScalingResult> StatusWindowResultCache => statusWindowResultCache;
                public IReadOnlyDictionary<ScalingParameter, ScalingResult> UniversalResultCache => universalResultCache;
                private Dictionary<DScalingParameter, ScalingResult> itemBeltResultCache;
                private Dictionary<DScalingParameter, ScalingResult> statusWindowResultCache;
                private Dictionary<ScalingParameter, ScalingResult> universalResultCache;

                public UIScaler()
                {
                    itemBeltResultCache = new Dictionary<DScalingParameter, ScalingResult>();
                    statusWindowResultCache = new Dictionary<DScalingParameter, ScalingResult>();
                    universalResultCache = new Dictionary<ScalingParameter, ScalingResult>();
                }

                public void ItemBeltScaling(ref UniversalRectAnchor rectAnchor, int ratioX, int ratioY, float uiSize)
                {
                    DScalingParameter dScalingParameter = new DScalingParameter(ratioX, ratioY, uiSize);
                    if (itemBeltResultCache.ContainsKey(dScalingParameter))
                    {
                        ScalingResult scalingResult = itemBeltResultCache[dScalingParameter];
                        rectAnchor.AnchorMaxX = scalingResult.AnchorMaxX;
                        rectAnchor.AnchorMinX = scalingResult.AnchorMinX;
                        rectAnchor.AnchorMaxY = scalingResult.AnchorMaxY;
                        rectAnchor.AnchorMinY = scalingResult.AnchorMinY;
                        return;
                    }

                    float ratioXf = ratioX;
                    float ratioYf = ratioY;

                    rectAnchor.AnchorMaxX *= uiSize;
                    rectAnchor.AnchorMaxY *= uiSize;

                    if (ratioX * _defaultAspectRatioY > ratioY * _defaultAspectRatioX)
                    {
                        float gap = _defaultAspectRatioX / ratioXf;
                        ratioXf *= gap;
                        ratioYf *= gap;
                    }
                    else if (ratioX * _defaultAspectRatioY < ratioY * _defaultAspectRatioX)
                    {
                        float gap = _defaultAspectRatioY / ratioYf;
                        ratioXf *= gap;
                        ratioYf *= gap;
                    }

                    rectAnchor.AnchorMaxX /= _xunit;
                    rectAnchor.AnchorMaxY /= _yunit;
                    rectAnchor.AnchorMaxX *= ratioYf * 0.01f;
                    rectAnchor.AnchorMaxY *= ratioXf * 0.01f;

                    rectAnchor.AlignCenterX();
                    float moveYpos = 0.025f * uiSize;
                    moveYpos /= _yunit;
                    moveYpos *= ratioXf * 0.01f;
                    rectAnchor.MoveY(moveYpos);
                    float AnchorMaxXScaleValue = 0.0163f * uiSize;
                    AnchorMaxXScaleValue /= _xunit;
                    AnchorMaxXScaleValue *= ratioYf * 0.01f;
                    rectAnchor.AnchorMaxX -= AnchorMaxXScaleValue;

                    itemBeltResultCache.Add(dScalingParameter, new ScalingResult(rectAnchor.AnchorMinX, rectAnchor.AnchorMinY, rectAnchor.AnchorMaxX, rectAnchor.AnchorMaxY));
                }

                public void StatusWindowScaling(ref UniversalRectAnchor rectAnchor, int ratioX, int ratioY, float uiSize)
                {
                    DScalingParameter dScalingParameter = new DScalingParameter(ratioX, ratioY, uiSize);
                    if (statusWindowResultCache.ContainsKey(dScalingParameter))
                    {
                        ScalingResult scalingResult = statusWindowResultCache[dScalingParameter];
                        rectAnchor.AnchorMaxX = scalingResult.AnchorMaxX;
                        rectAnchor.AnchorMinX = scalingResult.AnchorMinX;
                        rectAnchor.AnchorMaxY = scalingResult.AnchorMaxY;
                        rectAnchor.AnchorMinY = scalingResult.AnchorMinY;
                        return;
                    }

                    float ratioXf = ratioX;
                    float ratioYf = ratioY;

                    rectAnchor.AnchorMaxX *= uiSize;
                    rectAnchor.AnchorMaxY *= uiSize;

                    if (ratioX * _defaultAspectRatioY > ratioY * _defaultAspectRatioX)
                    {
                        float gap = _defaultAspectRatioX / ratioXf;
                        ratioXf *= gap;
                        ratioYf *= gap;
                    }
                    else if (ratioX * _defaultAspectRatioY < ratioY * _defaultAspectRatioX)
                    {
                        float gap = _defaultAspectRatioY / ratioYf;
                        ratioXf *= gap;
                        ratioYf *= gap;
                    }

                    rectAnchor.AnchorMaxX /= _xunit;
                    rectAnchor.AnchorMaxY /= _yunit;
                    rectAnchor.AnchorMaxX *= ratioYf * 0.01f;
                    rectAnchor.AnchorMaxY *= ratioXf * 0.01f;

                    rectAnchor.MoveXEnd();
                    float moveXpos = -0.0141f * uiSize;
                    moveXpos /= _xunit;
                    moveXpos *= ratioYf * 0.01f;
                    rectAnchor.MoveX(moveXpos);
                    float moveYpos = 0.022f * uiSize;
                    moveYpos /= _yunit;
                    moveYpos *= ratioXf * 0.01f;
                    rectAnchor.MoveY(moveYpos);

                    statusWindowResultCache.Add(dScalingParameter, new ScalingResult(rectAnchor.AnchorMinX, rectAnchor.AnchorMinY, rectAnchor.AnchorMaxX, rectAnchor.AnchorMaxY));
                }

                public ScalingResult UniversalPanelScaling(StackRectAnchor rectAnchor, RootRectAnchor.RectCenter rectCenter, ScalingParent scalingParent, int ratioX, int ratioY, float uiSize)
                {
                    ScalingParameter scalingParameter = new ScalingParameter(rectAnchor, ratioX, ratioY, uiSize);
                    if (universalResultCache.ContainsKey(scalingParameter))
                        return universalResultCache[scalingParameter];

                    RootRectAnchor rootRectAnchor = new RootRectAnchor(rectAnchor.AnchorMinX, rectAnchor.AnchorMinY, rectAnchor.AnchorMaxX, rectAnchor.AnchorMaxY, rectCenter);

                    float ratioXf = ratioX;
                    float ratioYf = ratioY;

                    rootRectAnchor.ScaleX *= uiSize;
                    rootRectAnchor.ScaleY *= uiSize;

                    if (ratioX * _defaultAspectRatioY > ratioY * _defaultAspectRatioX)
                    {
                        float gap = _defaultAspectRatioX / ratioXf;
                        ratioXf *= gap;
                        ratioYf *= gap;
                    }
                    else if (ratioX * _defaultAspectRatioY < ratioY * _defaultAspectRatioX)
                    {
                        float gap = _defaultAspectRatioY / ratioYf;
                        ratioXf *= gap;
                        ratioYf *= gap;
                    }

                    rootRectAnchor.ScaleX /= _xunit;
                    rootRectAnchor.ScaleY /= _yunit;
                    rootRectAnchor.ScaleX *= ratioYf * 0.01f;
                    rootRectAnchor.ScaleY *= ratioXf * 0.01f;

                    DScalingParameter defaultDScalingParameter = new DScalingParameter(_defaultAspectRatioX, _defaultAspectRatioY, _defaultUIScale);
                    DScalingParameter dScalingParameter = new DScalingParameter(ratioX, ratioY, uiSize);
                    float moveXValue;
                    float moveYValue;
                    UniversalRectAnchor defaultResult;
                    UniversalRectAnchor parameterResult;

                    float distanceX;
                    float distanceY;

                    switch (scalingParent)
                    {
                        case ScalingParent.MainUpperLeft:
                            distanceX = rootRectAnchor.PositionX;
                            distanceX = distanceX / _xunit * ratioYf * 0.01f;
                            distanceX = distanceX * uiSize;
                            rootRectAnchor.PositionX = distanceX;
                            distanceY = 1.0f - rootRectAnchor.PositionY;
                            distanceY = distanceY / _yunit * ratioXf * 0.01f;
                            distanceY = distanceY * uiSize;
                            rootRectAnchor.PositionY = 1.0f - distanceY;
                            break;

                        case ScalingParent.MainUpperCenter:
                            distanceX = 0.5f - rootRectAnchor.PositionX;
                            distanceX = distanceX / _xunit * ratioYf * 0.01f;
                            distanceX = distanceX * uiSize;
                            rootRectAnchor.PositionX = 0.5f - distanceX;
                            distanceY = 1.0f - rootRectAnchor.PositionY;
                            distanceY = distanceY / _yunit * ratioXf * 0.01f;
                            distanceY = distanceY * uiSize;
                            rootRectAnchor.PositionY = 1.0f - distanceY;
                            break;

                        case ScalingParent.MainUpperRight:
                            distanceX = 1.0f - rootRectAnchor.PositionX;
                            distanceX = distanceX / _xunit * ratioYf * 0.01f;
                            distanceX = distanceX * uiSize;
                            rootRectAnchor.PositionX = 1.0f - distanceX;
                            distanceY = 1.0f - rootRectAnchor.PositionY;
                            distanceY = distanceY / _yunit * ratioXf * 0.01f;
                            distanceY = distanceY * uiSize;
                            rootRectAnchor.PositionY = 1.0f - distanceY;
                            break;

                        case ScalingParent.MainMiddleLeft:
                            distanceX = rootRectAnchor.PositionX;
                            distanceX = distanceX / _xunit * ratioYf * 0.01f;
                            distanceX = distanceX * uiSize;
                            rootRectAnchor.PositionX = distanceX;
                            distanceY = 0.5f - rootRectAnchor.PositionY;
                            distanceY = distanceY / _yunit * ratioXf * 0.01f;
                            distanceY = distanceY * uiSize;
                            rootRectAnchor.PositionY = 0.5f - distanceY;
                            break;

                        case ScalingParent.MainMiddleCenter:
                            distanceX = 0.5f - rootRectAnchor.PositionX;
                            distanceX = distanceX / _xunit * ratioYf * 0.01f;
                            distanceX = distanceX * uiSize;
                            rootRectAnchor.PositionX = 0.5f - distanceX;
                            distanceY = 0.5f - rootRectAnchor.PositionY;
                            distanceY = distanceY / _yunit * ratioXf * 0.01f;
                            distanceY = distanceY * uiSize;
                            rootRectAnchor.PositionY = 0.5f - distanceY;
                            break;

                        case ScalingParent.MainMiddleRight:
                            distanceX = 1.0f - rootRectAnchor.PositionX;
                            distanceX = distanceX / _xunit * ratioYf * 0.01f;
                            distanceX = distanceX * uiSize;
                            rootRectAnchor.PositionX = 1.0f - distanceX;
                            distanceY = 0.5f - rootRectAnchor.PositionY;
                            distanceY = distanceY / _yunit * ratioXf * 0.01f;
                            distanceY = distanceY * uiSize;
                            rootRectAnchor.PositionY = 0.5f - distanceY;
                            break;

                        case ScalingParent.MainLowerLeft:
                            distanceX = rootRectAnchor.PositionX;
                            distanceX = distanceX / _xunit * ratioYf * 0.01f;
                            distanceX = distanceX * uiSize;
                            rootRectAnchor.PositionX = distanceX;
                            distanceY = rootRectAnchor.PositionY;
                            distanceY = distanceY / _yunit * ratioXf * 0.01f;
                            distanceY = distanceY * uiSize;
                            rootRectAnchor.PositionY = distanceY;
                            break;

                        case ScalingParent.MainLowerCenter:
                            distanceX = 0.5f - rootRectAnchor.PositionX;
                            distanceX = distanceX / _xunit * ratioYf * 0.01f;
                            distanceX = distanceX * uiSize;
                            rootRectAnchor.PositionX = 0.5f - distanceX;
                            distanceY = rootRectAnchor.PositionY;
                            distanceY = distanceY / _yunit * ratioXf * 0.01f;
                            distanceY = distanceY * uiSize;
                            rootRectAnchor.PositionY = distanceY;
                            break;

                        case ScalingParent.MainLowerRight:
                            distanceX = 1.0f - rootRectAnchor.PositionX;
                            distanceX = distanceX / _xunit * ratioYf * 0.01f;
                            distanceX = distanceX * uiSize;
                            rootRectAnchor.PositionX = 1.0f - distanceX;
                            distanceY = rootRectAnchor.PositionY;
                            distanceY = distanceY / _yunit * ratioXf * 0.01f;
                            distanceY = distanceY * uiSize;
                            rootRectAnchor.PositionY = distanceY;
                            break;

                        case ScalingParent.ItemBeltUpperLeft:
                            if (!ItemBeltResultCache.ContainsKey(defaultDScalingParameter))
                                ItemBeltScaleCaching(_defaultAspectRatioX, _defaultAspectRatioX, _defaultUIScale);
                            if (!ItemBeltResultCache.ContainsKey(dScalingParameter))
                                ItemBeltScaleCaching(ratioX, ratioY, uiSize);
                            defaultResult = new UniversalRectAnchor(ItemBeltResultCache[defaultDScalingParameter]);
                            parameterResult = new UniversalRectAnchor(ItemBeltResultCache[dScalingParameter]);
                            moveXValue = parameterResult.AnchorMinX - defaultResult.AnchorMinX;
                            rootRectAnchor.PositionX += moveXValue;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMinX - rootRectAnchor.PositionX) - (parameterResult.AnchorMinX - rootRectAnchor.PositionX) / _xunit * ratioYf * 0.01f;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMinX - rootRectAnchor.PositionX) - (parameterResult.AnchorMinX - rootRectAnchor.PositionX) * uiSize;
                            moveYValue = parameterResult.AnchorMaxY - defaultResult.AnchorMaxY;
                            rootRectAnchor.PositionY += moveYValue;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) - (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) / _yunit * ratioXf * 0.01f;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) - (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) * uiSize;
                            break;

                        case ScalingParent.ItemBeltUpperCenter:
                            if (!ItemBeltResultCache.ContainsKey(defaultDScalingParameter))
                                ItemBeltScaleCaching(_defaultAspectRatioX, _defaultAspectRatioX, _defaultUIScale);
                            if (!ItemBeltResultCache.ContainsKey(dScalingParameter))
                                ItemBeltScaleCaching(ratioX, ratioY, uiSize);
                            defaultResult = new UniversalRectAnchor(ItemBeltResultCache[defaultDScalingParameter]);
                            parameterResult = new UniversalRectAnchor(ItemBeltResultCache[dScalingParameter]);
                            moveXValue = parameterResult.AnchorCenterX - defaultResult.AnchorCenterX;
                            rootRectAnchor.PositionX += moveXValue;
                            rootRectAnchor.PositionX += (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) - (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) / _xunit * ratioYf * 0.01f;
                            rootRectAnchor.PositionX += (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) - (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) * uiSize;
                            moveYValue = parameterResult.AnchorMaxY - defaultResult.AnchorMaxY;
                            rootRectAnchor.PositionY += moveYValue;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) - (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) / _yunit * ratioXf * 0.01f;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) - (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) * uiSize;
                            break;

                        case ScalingParent.ItemBeltUpperRight:
                            if (!ItemBeltResultCache.ContainsKey(defaultDScalingParameter))
                                ItemBeltScaleCaching(_defaultAspectRatioX, _defaultAspectRatioX, _defaultUIScale);
                            if (!ItemBeltResultCache.ContainsKey(dScalingParameter))
                                ItemBeltScaleCaching(ratioX, ratioY, uiSize);
                            defaultResult = new UniversalRectAnchor(ItemBeltResultCache[defaultDScalingParameter]);
                            parameterResult = new UniversalRectAnchor(ItemBeltResultCache[dScalingParameter]);
                            moveXValue = parameterResult.AnchorMaxX - defaultResult.AnchorMaxX;
                            rootRectAnchor.PositionX += moveXValue;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) - (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) / _xunit * ratioYf * 0.01f;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) - (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) * uiSize;
                            moveYValue = parameterResult.AnchorMaxY - defaultResult.AnchorMaxY;
                            rootRectAnchor.PositionY += moveYValue;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) - (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) / _yunit * ratioXf * 0.01f;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) - (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) * uiSize;
                            break;

                        case ScalingParent.ItemBeltMiddleLeft:
                            if (!ItemBeltResultCache.ContainsKey(defaultDScalingParameter))
                                ItemBeltScaleCaching(_defaultAspectRatioX, _defaultAspectRatioX, _defaultUIScale);
                            if (!ItemBeltResultCache.ContainsKey(dScalingParameter))
                                ItemBeltScaleCaching(ratioX, ratioY, uiSize);
                            defaultResult = new UniversalRectAnchor(ItemBeltResultCache[defaultDScalingParameter]);
                            parameterResult = new UniversalRectAnchor(ItemBeltResultCache[dScalingParameter]);
                            moveXValue = parameterResult.AnchorMinX - defaultResult.AnchorMinX;
                            rootRectAnchor.PositionX += moveXValue;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMinX - rootRectAnchor.PositionX) - (parameterResult.AnchorMinX - rootRectAnchor.PositionX) / _xunit * ratioYf * 0.01f;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMinX - rootRectAnchor.PositionX) - (parameterResult.AnchorMinX - rootRectAnchor.PositionX) * uiSize;
                            moveYValue = parameterResult.AnchorCenterY - defaultResult.AnchorCenterY;
                            rootRectAnchor.PositionY += moveYValue;
                            rootRectAnchor.PositionY += (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) - (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) / _yunit * ratioXf * 0.01f;
                            rootRectAnchor.PositionY += (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) - (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) * uiSize;
                            break;

                        case ScalingParent.ItemBeltMiddleCenter:
                            if (!ItemBeltResultCache.ContainsKey(defaultDScalingParameter))
                                ItemBeltScaleCaching(_defaultAspectRatioX, _defaultAspectRatioX, _defaultUIScale);
                            if (!ItemBeltResultCache.ContainsKey(dScalingParameter))
                                ItemBeltScaleCaching(ratioX, ratioY, uiSize);
                            defaultResult = new UniversalRectAnchor(ItemBeltResultCache[defaultDScalingParameter]);
                            parameterResult = new UniversalRectAnchor(ItemBeltResultCache[dScalingParameter]);
                            moveXValue = parameterResult.AnchorCenterX - defaultResult.AnchorCenterX;
                            rootRectAnchor.PositionX += moveXValue;
                            rootRectAnchor.PositionX += (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) - (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) / _xunit * ratioYf * 0.01f;
                            rootRectAnchor.PositionX += (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) - (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) * uiSize;
                            moveYValue = parameterResult.AnchorCenterY - defaultResult.AnchorCenterY;
                            rootRectAnchor.PositionY += moveYValue;
                            rootRectAnchor.PositionY += (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) - (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) / _yunit * ratioXf * 0.01f;
                            rootRectAnchor.PositionY += (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) - (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) * uiSize;
                            break;

                        case ScalingParent.ItemBeltMiddleRight:
                            if (!ItemBeltResultCache.ContainsKey(defaultDScalingParameter))
                                ItemBeltScaleCaching(_defaultAspectRatioX, _defaultAspectRatioX, _defaultUIScale);
                            if (!ItemBeltResultCache.ContainsKey(dScalingParameter))
                                ItemBeltScaleCaching(ratioX, ratioY, uiSize);
                            defaultResult = new UniversalRectAnchor(ItemBeltResultCache[defaultDScalingParameter]);
                            parameterResult = new UniversalRectAnchor(ItemBeltResultCache[dScalingParameter]);
                            moveXValue = parameterResult.AnchorMaxX - defaultResult.AnchorMaxX;
                            rootRectAnchor.PositionX += moveXValue;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) - (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) / _xunit * ratioYf * 0.01f;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) - (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) * uiSize;
                            moveYValue = parameterResult.AnchorCenterY - defaultResult.AnchorCenterY;
                            rootRectAnchor.PositionY += moveYValue;
                            rootRectAnchor.PositionY += (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) - (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) / _yunit * ratioXf * 0.01f;
                            rootRectAnchor.PositionY += (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) - (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) * uiSize;
                            break;

                        case ScalingParent.ItemBeltLowerLeft:
                            if (!ItemBeltResultCache.ContainsKey(defaultDScalingParameter))
                                ItemBeltScaleCaching(_defaultAspectRatioX, _defaultAspectRatioX, _defaultUIScale);
                            if (!ItemBeltResultCache.ContainsKey(dScalingParameter))
                                ItemBeltScaleCaching(ratioX, ratioY, uiSize);
                            defaultResult = new UniversalRectAnchor(ItemBeltResultCache[defaultDScalingParameter]);
                            parameterResult = new UniversalRectAnchor(ItemBeltResultCache[dScalingParameter]);
                            moveXValue = parameterResult.AnchorMinX - defaultResult.AnchorMinX;
                            rootRectAnchor.PositionX += moveXValue;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMinX - rootRectAnchor.PositionX) - (parameterResult.AnchorMinX - rootRectAnchor.PositionX) / _xunit * ratioYf * 0.01f;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMinX - rootRectAnchor.PositionX) - (parameterResult.AnchorMinX - rootRectAnchor.PositionX) * uiSize;
                            moveYValue = parameterResult.AnchorMinY - defaultResult.AnchorMinY;
                            rootRectAnchor.PositionY += moveYValue;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMinY - rootRectAnchor.PositionY) - (parameterResult.AnchorMinY - rootRectAnchor.PositionY) / _yunit * ratioXf * 0.01f;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMinY - rootRectAnchor.PositionY) - (parameterResult.AnchorMinY - rootRectAnchor.PositionY) * uiSize;
                            break;

                        case ScalingParent.ItemBeltLowerCenter:
                            if (!ItemBeltResultCache.ContainsKey(defaultDScalingParameter))
                                ItemBeltScaleCaching(_defaultAspectRatioX, _defaultAspectRatioX, _defaultUIScale);
                            if (!ItemBeltResultCache.ContainsKey(dScalingParameter))
                                ItemBeltScaleCaching(ratioX, ratioY, uiSize);
                            defaultResult = new UniversalRectAnchor(ItemBeltResultCache[defaultDScalingParameter]);
                            parameterResult = new UniversalRectAnchor(ItemBeltResultCache[dScalingParameter]);
                            moveXValue = parameterResult.AnchorCenterX - defaultResult.AnchorCenterX;
                            rootRectAnchor.PositionX += moveXValue;
                            rootRectAnchor.PositionX += (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) - (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) / _xunit * ratioYf * 0.01f;
                            rootRectAnchor.PositionX += (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) - (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) * uiSize;
                            moveYValue = parameterResult.AnchorMinY - defaultResult.AnchorMinY;
                            rootRectAnchor.PositionY += moveYValue;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMinY - rootRectAnchor.PositionY) - (parameterResult.AnchorMinY - rootRectAnchor.PositionY) / _yunit * ratioXf * 0.01f;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMinY - rootRectAnchor.PositionY) - (parameterResult.AnchorMinY - rootRectAnchor.PositionY) * uiSize;
                            break;

                        case ScalingParent.ItemBeltLowerRight:
                            if (!ItemBeltResultCache.ContainsKey(defaultDScalingParameter))
                                ItemBeltScaleCaching(_defaultAspectRatioX, _defaultAspectRatioX, _defaultUIScale);
                            if (!ItemBeltResultCache.ContainsKey(dScalingParameter))
                                ItemBeltScaleCaching(ratioX, ratioY, uiSize);
                            defaultResult = new UniversalRectAnchor(ItemBeltResultCache[defaultDScalingParameter]);
                            parameterResult = new UniversalRectAnchor(ItemBeltResultCache[dScalingParameter]);
                            moveXValue = parameterResult.AnchorMaxX - defaultResult.AnchorMaxX;
                            rootRectAnchor.PositionX += moveXValue;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) - (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) / _xunit * ratioYf * 0.01f;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) - (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) * uiSize;
                            moveYValue = parameterResult.AnchorMinY - defaultResult.AnchorMinY;
                            rootRectAnchor.PositionY += moveYValue;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMinY - rootRectAnchor.PositionY) - (parameterResult.AnchorMinY - rootRectAnchor.PositionY) / _yunit * ratioXf * 0.01f;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMinY - rootRectAnchor.PositionY) - (parameterResult.AnchorMinY - rootRectAnchor.PositionY) * uiSize;
                            break;

                        case ScalingParent.StatusWindowUpperLeft:
                            if (!StatusWindowResultCache.ContainsKey(defaultDScalingParameter))
                                StatusWindowScaleCaching(_defaultAspectRatioX, _defaultAspectRatioX, _defaultUIScale);
                            if (!StatusWindowResultCache.ContainsKey(dScalingParameter))
                                StatusWindowScaleCaching(ratioX, ratioY, uiSize);
                            defaultResult = new UniversalRectAnchor(StatusWindowResultCache[defaultDScalingParameter]);
                            parameterResult = new UniversalRectAnchor(StatusWindowResultCache[dScalingParameter]);
                            moveXValue = parameterResult.AnchorMinX - defaultResult.AnchorMinX;
                            rootRectAnchor.PositionX += moveXValue;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMinX - rootRectAnchor.PositionX) - (parameterResult.AnchorMinX - rootRectAnchor.PositionX) / _xunit * ratioYf * 0.01f;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMinX - rootRectAnchor.PositionX) - (parameterResult.AnchorMinX - rootRectAnchor.PositionX) * uiSize;
                            moveYValue = parameterResult.AnchorMaxY - defaultResult.AnchorMaxY;
                            rootRectAnchor.PositionY += moveYValue;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) - (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) / _yunit * ratioXf * 0.01f;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) - (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) * uiSize;
                            break;

                        case ScalingParent.StatusWindowUpperCenter:
                            if (!StatusWindowResultCache.ContainsKey(defaultDScalingParameter))
                                StatusWindowScaleCaching(_defaultAspectRatioX, _defaultAspectRatioX, _defaultUIScale);
                            if (!StatusWindowResultCache.ContainsKey(dScalingParameter))
                                StatusWindowScaleCaching(ratioX, ratioY, uiSize);
                            defaultResult = new UniversalRectAnchor(StatusWindowResultCache[defaultDScalingParameter]);
                            parameterResult = new UniversalRectAnchor(StatusWindowResultCache[dScalingParameter]);
                            moveXValue = parameterResult.AnchorCenterX - defaultResult.AnchorCenterX;
                            rootRectAnchor.PositionX += moveXValue;
                            rootRectAnchor.PositionX += (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) - (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) / _xunit * ratioYf * 0.01f;
                            rootRectAnchor.PositionX += (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) - (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) * uiSize;
                            moveYValue = parameterResult.AnchorMaxY - defaultResult.AnchorMaxY;
                            rootRectAnchor.PositionY += moveYValue;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) - (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) / _yunit * ratioXf * 0.01f;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) - (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) * uiSize;
                            break;

                        case ScalingParent.StatusWindowUpperRight:
                            if (!StatusWindowResultCache.ContainsKey(defaultDScalingParameter))
                                StatusWindowScaleCaching(_defaultAspectRatioX, _defaultAspectRatioX, _defaultUIScale);
                            if (!StatusWindowResultCache.ContainsKey(dScalingParameter))
                                StatusWindowScaleCaching(ratioX, ratioY, uiSize);
                            defaultResult = new UniversalRectAnchor(StatusWindowResultCache[defaultDScalingParameter]);
                            parameterResult = new UniversalRectAnchor(StatusWindowResultCache[dScalingParameter]);
                            moveXValue = parameterResult.AnchorMaxX - defaultResult.AnchorMaxX;
                            rootRectAnchor.PositionX += moveXValue;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) - (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) / _xunit * ratioYf * 0.01f;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) - (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) * uiSize;
                            moveYValue = parameterResult.AnchorMaxY - defaultResult.AnchorMaxY;
                            rootRectAnchor.PositionY += moveYValue;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) - (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) / _yunit * ratioXf * 0.01f;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) - (parameterResult.AnchorMaxY - rootRectAnchor.PositionY) * uiSize;
                            break;

                        case ScalingParent.StatusWindowMiddleLeft:
                            if (!StatusWindowResultCache.ContainsKey(defaultDScalingParameter))
                                StatusWindowScaleCaching(_defaultAspectRatioX, _defaultAspectRatioX, _defaultUIScale);
                            if (!StatusWindowResultCache.ContainsKey(dScalingParameter))
                                StatusWindowScaleCaching(ratioX, ratioY, uiSize);
                            defaultResult = new UniversalRectAnchor(StatusWindowResultCache[defaultDScalingParameter]);
                            parameterResult = new UniversalRectAnchor(StatusWindowResultCache[dScalingParameter]);
                            moveXValue = parameterResult.AnchorMinX - defaultResult.AnchorMinX;
                            rootRectAnchor.PositionX += moveXValue;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMinX - rootRectAnchor.PositionX) - (parameterResult.AnchorMinX - rootRectAnchor.PositionX) / _xunit * ratioYf * 0.01f;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMinX - rootRectAnchor.PositionX) - (parameterResult.AnchorMinX - rootRectAnchor.PositionX) * uiSize;
                            moveYValue = parameterResult.AnchorCenterY - defaultResult.AnchorCenterY;
                            rootRectAnchor.PositionY += moveYValue;
                            rootRectAnchor.PositionY += (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) - (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) / _yunit * ratioXf * 0.01f;
                            rootRectAnchor.PositionY += (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) - (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) * uiSize;
                            break;

                        case ScalingParent.StatusWindowMiddleCenter:
                            if (!StatusWindowResultCache.ContainsKey(defaultDScalingParameter))
                                StatusWindowScaleCaching(_defaultAspectRatioX, _defaultAspectRatioX, _defaultUIScale);
                            if (!StatusWindowResultCache.ContainsKey(dScalingParameter))
                                StatusWindowScaleCaching(ratioX, ratioY, uiSize);
                            defaultResult = new UniversalRectAnchor(StatusWindowResultCache[defaultDScalingParameter]);
                            parameterResult = new UniversalRectAnchor(StatusWindowResultCache[dScalingParameter]);
                            moveXValue = parameterResult.AnchorCenterX - defaultResult.AnchorCenterX;
                            rootRectAnchor.PositionX += moveXValue;
                            rootRectAnchor.PositionX += (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) - (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) / _xunit * ratioYf * 0.01f;
                            rootRectAnchor.PositionX += (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) - (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) * uiSize;
                            moveYValue = parameterResult.AnchorCenterY - defaultResult.AnchorCenterY;
                            rootRectAnchor.PositionY += moveYValue;
                            rootRectAnchor.PositionY += (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) - (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) / _yunit * ratioXf * 0.01f;
                            rootRectAnchor.PositionY += (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) - (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) * uiSize;
                            break;

                        case ScalingParent.StatusWindowMiddleRight:
                            if (!StatusWindowResultCache.ContainsKey(defaultDScalingParameter))
                                StatusWindowScaleCaching(_defaultAspectRatioX, _defaultAspectRatioX, _defaultUIScale);
                            if (!StatusWindowResultCache.ContainsKey(dScalingParameter))
                                StatusWindowScaleCaching(ratioX, ratioY, uiSize);
                            defaultResult = new UniversalRectAnchor(StatusWindowResultCache[defaultDScalingParameter]);
                            parameterResult = new UniversalRectAnchor(StatusWindowResultCache[dScalingParameter]);
                            moveXValue = parameterResult.AnchorMaxX - defaultResult.AnchorMaxX;
                            rootRectAnchor.PositionX += moveXValue;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) - (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) / _xunit * ratioYf * 0.01f;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) - (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) * uiSize;
                            moveYValue = parameterResult.AnchorCenterY - defaultResult.AnchorCenterY;
                            rootRectAnchor.PositionY += moveYValue;
                            rootRectAnchor.PositionY += (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) - (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) / _yunit * ratioXf * 0.01f;
                            rootRectAnchor.PositionY += (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) - (parameterResult.AnchorCenterY - rootRectAnchor.PositionY) * uiSize;
                            break;

                        case ScalingParent.StatusWindowLowerLeft:
                            if (!StatusWindowResultCache.ContainsKey(defaultDScalingParameter))
                                StatusWindowScaleCaching(_defaultAspectRatioX, _defaultAspectRatioX, _defaultUIScale);
                            if (!StatusWindowResultCache.ContainsKey(dScalingParameter))
                                StatusWindowScaleCaching(ratioX, ratioY, uiSize);
                            defaultResult = new UniversalRectAnchor(StatusWindowResultCache[defaultDScalingParameter]);
                            parameterResult = new UniversalRectAnchor(StatusWindowResultCache[dScalingParameter]);
                            moveXValue = parameterResult.AnchorMinX - defaultResult.AnchorMinX;
                            rootRectAnchor.PositionX += moveXValue;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMinX - rootRectAnchor.PositionX) - (parameterResult.AnchorMinX - rootRectAnchor.PositionX) / _xunit * ratioYf * 0.01f;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMinX - rootRectAnchor.PositionX) - (parameterResult.AnchorMinX - rootRectAnchor.PositionX) * uiSize;
                            moveYValue = parameterResult.AnchorMinY - defaultResult.AnchorMinY;
                            rootRectAnchor.PositionY += moveYValue;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMinY - rootRectAnchor.PositionY) - (parameterResult.AnchorMinY - rootRectAnchor.PositionY) / _yunit * ratioXf * 0.01f;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMinY - rootRectAnchor.PositionY) - (parameterResult.AnchorMinY - rootRectAnchor.PositionY) * uiSize;
                            break;

                        case ScalingParent.StatusWindowLowerCenter:
                            if (!StatusWindowResultCache.ContainsKey(defaultDScalingParameter))
                                StatusWindowScaleCaching(_defaultAspectRatioX, _defaultAspectRatioX, _defaultUIScale);
                            if (!StatusWindowResultCache.ContainsKey(dScalingParameter))
                                StatusWindowScaleCaching(ratioX, ratioY, uiSize);
                            defaultResult = new UniversalRectAnchor(StatusWindowResultCache[defaultDScalingParameter]);
                            parameterResult = new UniversalRectAnchor(StatusWindowResultCache[dScalingParameter]);
                            moveXValue = parameterResult.AnchorCenterX - defaultResult.AnchorCenterX;
                            rootRectAnchor.PositionX += moveXValue;
                            rootRectAnchor.PositionX += (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) - (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) / _xunit * ratioYf * 0.01f;
                            rootRectAnchor.PositionX += (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) - (parameterResult.AnchorCenterX - rootRectAnchor.PositionX) * uiSize;
                            moveYValue = parameterResult.AnchorMinY - defaultResult.AnchorMinY;
                            rootRectAnchor.PositionY += moveYValue;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMinY - rootRectAnchor.PositionY) - (parameterResult.AnchorMinY - rootRectAnchor.PositionY) / _yunit * ratioXf * 0.01f;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMinY - rootRectAnchor.PositionY) - (parameterResult.AnchorMinY - rootRectAnchor.PositionY) * uiSize;
                            break;

                        case ScalingParent.StatusWindowLowerRight:
                            if (!StatusWindowResultCache.ContainsKey(defaultDScalingParameter))
                                StatusWindowScaleCaching(_defaultAspectRatioX, _defaultAspectRatioX, _defaultUIScale);
                            if (!StatusWindowResultCache.ContainsKey(dScalingParameter))
                                StatusWindowScaleCaching(ratioX, ratioY, uiSize);
                            defaultResult = new UniversalRectAnchor(StatusWindowResultCache[defaultDScalingParameter]);
                            parameterResult = new UniversalRectAnchor(StatusWindowResultCache[dScalingParameter]);
                            moveXValue = parameterResult.AnchorMaxX - defaultResult.AnchorMaxX;
                            rootRectAnchor.PositionX += moveXValue;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) - (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) / _xunit * ratioYf * 0.01f;
                            rootRectAnchor.PositionX += (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) - (parameterResult.AnchorMaxX - rootRectAnchor.PositionX) * uiSize;
                            moveYValue = parameterResult.AnchorMinY - defaultResult.AnchorMinY;
                            rootRectAnchor.PositionY += moveYValue;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMinY - rootRectAnchor.PositionY) - (parameterResult.AnchorMinY - rootRectAnchor.PositionY) / _yunit * ratioXf * 0.01f;
                            rootRectAnchor.PositionY += (parameterResult.AnchorMinY - rootRectAnchor.PositionY) - (parameterResult.AnchorMinY - rootRectAnchor.PositionY) * uiSize;
                            break;

                        default:
                            break;
                    }

                    ScalingResult scalingResult = new ScalingResult(rootRectAnchor.AnchorMinX, rootRectAnchor.AnchorMinY, rootRectAnchor.AnchorMaxX, rootRectAnchor.AnchorMaxY);
                    universalResultCache.Add(scalingParameter, scalingResult);
                    return scalingResult;
                }

                public void ItemBeltScaleCaching(int ratioX, int ratioY, float uiSize)
                {
                    UniversalRectAnchor scaledBeltAnchor = _itemBeltAnchor.Clone();
                    ItemBeltScaling(ref scaledBeltAnchor, ratioX, ratioY, uiSize);
                }
                
                public void StatusWindowScaleCaching(int ratioX, int ratioY, float uiSize)
                {
                    UniversalRectAnchor ScaledWindowAnchor = _statusWindowAnchor.Clone();
                    ItemBeltScaling(ref ScaledWindowAnchor, ratioX, ratioY, uiSize);
                }

                public struct DScalingParameter : IEquatable<DScalingParameter>
                {
                    public int RatioX { get; set; }
                    public int RatioY { get; set; }
                    public float UISize { get; set; }

                    public DScalingParameter(int ratioX, int ratioY, float uiSize)
                    {
                        RatioX = ratioX;
                        RatioY = ratioY;
                        UISize = uiSize;
                    }

                    public bool Equals(DScalingParameter other) => (RatioX == other.RatioX) && (RatioY == other.RatioY) && (UISize == other.UISize);

                    public static bool operator ==(DScalingParameter a, DScalingParameter b) => a.Equals(b);

                    public static bool operator !=(DScalingParameter a, DScalingParameter b) => !(a.Equals(b));
                }

                public struct ScalingParameter : IEquatable<ScalingParameter>
                {
                    public StackRectAnchor StackRectAnchor { get; set; }
                    public int RatioX { get; set; }
                    public int RatioY { get; set; }
                    public float UISize { get; set; }

                    public ScalingParameter(StackRectAnchor stackRectAnchor, int ratioX, int ratioY, float uiSize)
                    {
                        StackRectAnchor = stackRectAnchor;
                        RatioX = ratioX;
                        RatioY = ratioY;
                        UISize = uiSize;
                    }

                    public bool Equals(ScalingParameter other)
                    {
                        return (StackRectAnchor == other.StackRectAnchor) &&
                            (RatioX == other.RatioX) && 
                            (RatioY == other.RatioY) && 
                            (UISize == other.UISize);
                    }

                    public static bool operator ==(ScalingParameter a, ScalingParameter b) => a.Equals(b);

                    public static bool operator !=(ScalingParameter a, ScalingParameter b) => !(a.Equals(b));
                }

                public struct ScalingResult
                {
                    public float[] Result { get; private set; }
                    public float AnchorMinX
                    {
                        get { return Result[0]; }
                        set { Result[0] = value; }
                    }
                    public float AnchorMinY
                    {
                        get { return Result[1]; }
                        set { Result[1] = value; }
                    }
                    public float AnchorMaxX
                    {
                        get { return Result[2]; }
                        set { Result[2] = value; }
                    }
                    public float AnchorMaxY
                    {
                        get { return Result[3]; }
                        set { Result[3] = value; }
                    }
                    
                    public ScalingResult(float minX, float minY, float maxX, float maxY)
                    {
                        Result = new float[4];

                        AnchorMinX = minX;
                        AnchorMinY = minY;
                        AnchorMaxX = maxX;
                        AnchorMaxY = maxY;
                    }
                }

                public enum ScalingParent
                {
                    MainUpperLeft,
                    MainUpperCenter,
                    MainUpperRight,
                    MainMiddleLeft,
                    MainMiddleCenter,
                    MainMiddleRight,
                    MainLowerLeft,
                    MainLowerCenter,
                    MainLowerRight,

                    ItemBeltUpperLeft,
                    ItemBeltUpperCenter,
                    ItemBeltUpperRight,
                    ItemBeltMiddleLeft,
                    ItemBeltMiddleCenter,
                    ItemBeltMiddleRight,
                    ItemBeltLowerLeft,
                    ItemBeltLowerCenter,
                    ItemBeltLowerRight,

                    StatusWindowUpperLeft,
                    StatusWindowUpperCenter,
                    StatusWindowUpperRight,
                    StatusWindowMiddleLeft,
                    StatusWindowMiddleCenter,
                    StatusWindowMiddleRight,
                    StatusWindowLowerLeft,
                    StatusWindowLowerCenter,
                    StatusWindowLowerRight
                }
            }
        }

        #endregion
    }
}

// --- End of file: UIScaleManager.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/unlimited-elevators ---
// --- Original File Path: U/UnlimitedElevators/UnlimitedElevators.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Unlimited Elevators", "k1lly0u", "0.1.3")]
    [Description("Allow players to extend elevators past the 6 high limit")]
    class UnlimitedElevators : RustPlugin
    {
        #region Fields
        private int _elevatorItemId;
        private RaycastHit raycastHit;

        private RaycastHit[] _rayBuffer = new RaycastHit[256];

        private const string USE_PERM = "unlimitedelevators.use";
        private const string SOCKET_FEMALE = "elevator/sockets/elevator-female";
        private const string SOCKET_MALE = "elevator/sockets/elevator-male";

        private const int RAYCAST_LAYERS = 1 << 8 | 1 << 10 | 1 << 13 | 1 << 15 | 1 << 16 | 1 << 17 | 1 << 21 | 1 << 23;
        #endregion

        #region Oxide Hooks        
        private void OnServerInitialized()
        {
            permission.RegisterPermission(USE_PERM, this);

            _elevatorItemId = ItemManager.FindItemDefinition("elevator").itemid;
        }

        protected override void LoadDefaultMessages() => lang.RegisterMessages(Messages, this);
        #endregion

        #region Functions
        private Elevator FindEntity(BasePlayer player)
        {
            if (Physics.Raycast(player.eyes.position, Quaternion.Euler(player.serverInput.current.aimAngles) * Vector3.forward, out raycastHit, 3f))            
                return raycastHit.GetEntity() as Elevator;
            
            return null;
        }

        private int CountFloorDifference(Elevator topFloor, int targetFloors)
        {
            int currentFloors = CountFloorsToGround(topFloor);

            return targetFloors - currentFloors;
        }

        private bool HasEnoughItems(BasePlayer player, int extensions) => player.inventory.GetAmount(_elevatorItemId) >= extensions;

        private void TakeItems(BasePlayer player, int extensions) => player.inventory.Take(null, _elevatorItemId, extensions);

        private void RefundItems(BasePlayer player, int subtractions)
        {
            for (int i = 0; i < subtractions; i++)
            {
                player.GiveItem(ItemManager.CreateByItemID(_elevatorItemId));
            }
        }

        private Elevator FindTopFloor(Elevator root)
        {
            Elevator previousFloor = root;
            for (int i = 0; i < int.MaxValue; i++)
            {
                List<EntityLink> list = previousFloor.FindLink(SOCKET_FEMALE)?.connections;
                if (list.Count > 0 && (list[0].owner as Elevator) != null)
                    previousFloor = list[0].owner as Elevator;
                else return previousFloor;
            }

            return previousFloor;
        }

        private int CountFloorsToGround(Elevator topFloor)
        {
            Elevator previousFloor = topFloor;
            for (int i = 0; i < int.MaxValue; i++)
            {
                List<EntityLink> list = previousFloor.FindLink(SOCKET_MALE)?.connections;
                if (list.Count > 0 && (list[0].owner as Elevator) != null)
                    previousFloor = list[0].owner as Elevator;
                else return i + 1;
            }
            return 1;
        }

        private Elevator GetNextFloor(Elevator currentFloor, Elevator.Direction direction)
        {
            List<EntityLink> list = currentFloor.FindLink(direction == Elevator.Direction.Down ? SOCKET_MALE : SOCKET_FEMALE)?.connections;
            if (list.Count > 0 && (list[0].owner as Elevator) != null)
                return list[0].owner as Elevator;

            return null;
        }

        private void AddFloors(Elevator topFloor, int extensions)
        {
            Elevator lastFloor = topFloor;
            lastFloor.SetFlag(BaseEntity.Flags.Reserved1, false, false, true);

            for (int i = 0; i < extensions; i++)
            {
                Elevator floor = GameManager.server.CreateEntity(lastFloor.PrefabName, lastFloor.transform.position + lastFloor.transform.up * 3f, lastFloor.transform.rotation) as Elevator;
                floor.OwnerID = topFloor.OwnerID;
                floor.GetEntityLinks(true);
                floor.Spawn();
                
                floor.OnDeployed(null, null, null);

                lastFloor = floor;
            }

            lastFloor.SetFlag(BaseEntity.Flags.Reserved1, true, false, true);
        }

        private void SubtractFloors(Elevator topFloor, int subtractions)
        {
            Elevator nextFloor = topFloor;

            for (int i = 0; i < subtractions; i++)
            {
                if (nextFloor == null)
                    return;

                Elevator currentFloor = nextFloor;

                nextFloor = GetNextFloor(nextFloor, Elevator.Direction.Down);
                nextFloor?.SetFlag(BaseEntity.Flags.Reserved1, true, false, true);

                currentFloor.Kill(BaseNetworkable.DestroyMode.None);
            }
        }
        #endregion

        #region Commands
        [ChatCommand("setfloors")]
        private void cmdSetFloors(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, USE_PERM))
            {
                player.ChatMessage(msg("Error.NoPermissions", player));
                return;
            }

            if (args.Length == 0)
            {
                player.ChatMessage(msg("Message.Title", player));
                player.ChatMessage(msg("Chat.Help1", player));
                return;
            }

            int floors;
            if (!int.TryParse(args[0], out floors))
            {
                player.ChatMessage(msg("Error.NoNumberEntered", player));
                return;
            }

            if (floors > configData.Limit)
            {
                player.ChatMessage(string.Format(msg("Error.PastMaximum", player), configData.Limit));
                return;
            }

            Elevator elevator = FindEntity(player);
            if (elevator == null)
            {
                player.ChatMessage(msg("Error.NoElevator", player));
                return;
            }

            Elevator topFloor = FindTopFloor(elevator);

            int difference = CountFloorDifference(topFloor, floors);

            if (difference == 0)
            {
                player.ChatMessage(msg("Error.NoDifference", player));
                return;
            }

            if (difference > 0)
            {
                if (Physics.BoxCastNonAlloc(topFloor.transform.position + (Vector3.up * 4.35f), Vector3.one * 1.25f, Vector3.up, _rayBuffer, topFloor.transform.rotation, (difference - 1) * 3f, RAYCAST_LAYERS, QueryTriggerInteraction.Ignore) > 0)
                {

                    player.ChatMessage(msg("Error.NotEnoughSpace", player));
                    return;
                }

                if (configData.RequireItem && !HasEnoughItems(player, difference))
                {
                    player.ChatMessage(msg("Error.NotEnoughItems", player));
                    return;
                }
                else TakeItems(player, difference);

                AddFloors(topFloor, difference);
                
                player.ChatMessage(string.Format(msg("Success.Extended", player), difference));
            }
            else
            {
                difference = Mathf.Abs(difference);
                SubtractFloors(topFloor, difference);

                if (configData.RefundIfSubtracting)
                    RefundItems(player, difference);

                player.ChatMessage(string.Format(msg("Success.Subtracted", player), difference));
            }
        }

        #endregion

        #region Config        
        private ConfigData configData;
        private class ConfigData
        {            
            [JsonProperty(PropertyName = "Maximum number of floors allowed")]
            public int Limit { get; set; }

            [JsonProperty(PropertyName = "Require the user has the correct number of elevator items in their inventory to pay for the extension")]
            public bool RequireItem { get; set; }

            [JsonProperty(PropertyName = "Refund items if setting floors to a number lower than what currently exists")]
            public bool RefundIfSubtracting { get; set; }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                RequireItem = true,
                Limit = 20,
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Localization
        public string msg(string key, BasePlayer player) => lang.GetMessage(key, this, player.UserIDString);

        private Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Message.Title"] = "<color=#ce422b>[ Unlimited Elevators ]</color> ",

            ["Chat.Help1"] = "<color=#ce422b>/setfloors <number></color> - Set the number of floors for the elevator you are looking at",

            ["Error.NoPermissions"] = "<color=#ce422b>You do not have permission to use this command</color>",
            ["Error.NoNumberEntered"] = "You must enter a number of floors!",
            ["Error.PastMaximum"] = "You are only allowed to set a max of <color=#ce422b>{0}</color> floors!",
            ["Error.NoElevator"] = "<color=#ce422b>No elevator found!</color>",
            ["Error.NoDifference"] = "<color=#ce422b>This elevator already has that number of floors</color>",
            ["Error.NotEnoughItems"] = "<color=#ce422b>You do not have enough elevators in your inventory to build that high!</color>",
            ["Error.NotEnoughSpace"] = "<color=#ce422b>There is not enough space to build that high</color>",

            ["Success.Extended"] = "You have extended this elevator by <color=#ce422b>{0} floor(s)</color>",
            ["Success.Subtracted"] = "You have removed <color=#ce422b>{0} floor(s)</color> from this elevator",
        };
        #endregion
    }
}

// --- End of file: UnlimitedElevators.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ultimate-gamble ---
// --- Original File Path: U/UltimateGamble/UltimateGamble.cs ---

﻿using UnityEngine;
using System.Collections.Generic;
using System;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Ultimate Gamble", "ColdUnwanted", "0.2.5")]
    [Description("A all-in-one gambling system with in game time timer.")]

    public class UltimateGamble : RustPlugin
    {
        // Configuration
        private bool ConfigChanged;

        // Configuration variables
        // Raffle
        private bool raffleActive;
        private float raffleNextStartTime;
        private List<string> raffleStartTime;
        private int raffleJoinAmount;
        private int raffleRewardAmount;
        private int rafflePlayersNeeded;
        private string raffleReward;
        private string raffleJoin;
        private int raffleDaysSkip;
        private bool raffleUseServerTime;

        // Blackjack
        private string blackjackFee;
        private int blackjackMinimumFee;
        private float blackjackMultiplier;
        private int blackjackCooldown; // ToDo
        private int blackjackTimeout;

        // Variables declaration
        // General 
        private int neededAuthLevel;
        private List<DisconnectData> disconnectedPlayers;

        // Raffle
        private bool isRaffleTime = false;
        private List<ulong> joinedPlayersId;
        private string raffleJoinName;
        private string raffleRewardName;
        private bool raffleHasError = false;
        private bool customStart = false;

        // Blackjack
        private List<BlackjackData> blackjackDatas;
        private string blackjackFeeName;
        private bool blackjackHasError = false;
        private string[] cardName = { "A", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "K", "Q", "J" };

        #region Configuration
        private static List<object> defaultRaffleStartTime()
        {
            List<object> thisList = new List<object>();
            thisList.Add("10:00");
            thisList.Add("20:30");

            return thisList;
        }

        protected override void LoadDefaultConfig()
        {
            LoadVariables();
        }

        private void LoadVariables()
        {
            // General settings
            neededAuthLevel = Convert.ToInt32(GetConfig("General", "Authentication Level Required To Used Admin Command", "2"));
            raffleActive = Convert.ToBoolean(GetConfig("General", "Raffle Activated", "true"));

            // Raffle
            raffleUseServerTime = Convert.ToBoolean(GetConfig("Raffle", "Use Game Time? If False, It Will Use Real Time", true));
            List<object> objectList = (List<object>)GetConfig("Raffle", "Starting Time Of The Raffle (24-Hours Format)", defaultRaffleStartTime());
            raffleStartTime = new List<string>();
            foreach (object obj in objectList)
            {
                raffleStartTime.Add(Convert.ToString(obj));
            }
            raffleDaysSkip = Convert.ToInt32(GetConfig("Raffle", "Days To Skip After Raffle Is Ran On The Day", "0"));
            raffleJoin = Convert.ToString(GetConfig("Raffle", "Join Item (Item Shortname https://www.corrosionhour.com/rust-item-list/)", "scrap"));
            raffleJoinAmount = Convert.ToInt32(GetConfig("Raffle", "Amount Needed To Join", "20"));
            raffleReward = Convert.ToString(GetConfig("Raffle", "Reward Item (Item Shortname https://www.corrosionhour.com/rust-item-list/)", "supply.signal"));
            raffleRewardAmount = Convert.ToInt32(GetConfig("Raffle", "Reward Amount", "1"));
            rafflePlayersNeeded = Convert.ToInt32(GetConfig("Raffle", "How Many People Is Needed To Calculate The Winner", "3"));

            // Blackjack
            blackjackFee = Convert.ToString(GetConfig("Blackjack", "The Reward/Join Item (Item Shortname https://www.corrosionhour.com/rust-item-list/)", "scrap"));
            blackjackMinimumFee = Convert.ToInt32(GetConfig("Blackjack", "The Minimum Amount Required To Join The Blackjack", "5"));
            blackjackMultiplier = Convert.ToSingle(GetConfig("Blackjack", "The Multiplying Amount For When The User Wins The Blackjack", "2"));
            blackjackCooldown = Convert.ToInt32(GetConfig("Blackjack", "The Cooldown Amount Between Each Blackjack (Seconds)", "30"));
            blackjackTimeout = Convert.ToInt32(GetConfig("Blackjack", "The Timeout Time For The Blackjack If User Did Not Respond", "30"));

            if (!ConfigChanged)
            {
                return;
            }

            SaveConfig();
            ConfigChanged = false;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                ConfigChanged = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                ConfigChanged = true;
            }
            return value;
        }
        #endregion

        #region Messages
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                // General
                ["CannotUseCommand"] = "You Are Not Allowed To Used This Command!",

                // Short Name Item Not Found Error Text
                ["RaffleJoinNotFound"] = "Raffle Join Item '{0}' Short Name Not Found! Raffle Has Been Disabled!",
                ["RaffleRewardNotFound"] = "Raffle Reward Item '{0}' Short Name Not Found! Raffle Has Been Disabled!",
                ["BlackjackRewardNotFound"] = "Blackjack Reward/Join item '{0}' Short Name Not Found! Blackjack Has Been Disabled!",

                // Compensate Text
                ["Compensate"] = "{0} {1} Has Been Compensated Due To Disconnect!",

                // Raffle Text
                ["RaffleStart"] = "Raffle Time! Join With {0} {1} To Stand A Chance To Win {2} {3}. Join With /raffle",
                ["RaffleFail"] = "Insufficient Players Joined, {0} Will Be Refunded!",
                ["RaffleEnd"] = "Raffle Has Ended! Congratulations {0} For Winning The Raffle!",
                ["RaffleHaventStart"] = "The Raffle Has Not Started Yet! Next Raffle Begins In {0} Minutes.",
                ["RaffleAlreadyJoined"] = "You Already Joined The Raffle!",
                ["RaffleInsufficient"] = "Insufficient {0}! Please Make Sure You Have {1} {0} In Your Inventory!",
                ["RaffleJoinedPlayer"] = "Successfully Joined The Raffle!",
                ["RaffleJoinedGloabl"] = "{0} Has Joined The Raffle!",
                ["RaffleFailStart"] = "Insufficient Player Online, Raffle Will Not Start This Round!",
                ["RaffleCustomStart"] = "Raffle Was Force Started!",
                ["RaffleCustomFail"] = "Raffle Could Not Be Started Due To Active Raffle!",

                // Blackjack Text
                ["BlackjackNoArgs"] = "Blackjack Usage: /backjack <amount of {0}>",
                ["BlackjackArgNotNumber"] = "'/blackjack <amount>' Requires The Amount To Be A Number!",
                ["BlackjackArgChoose"] = "Choose Between '/blackjack hit' Or '/blackjack stand'",
                ["BlackjackMinimumFail"] = "Minimum Of {0} {1} Is Required To Play Blackjack!",
                ["BlackjackInsufficient"] = "Insufficient {0}! Please Make Sure You Have {1} {0} In Your Inventory!",
                ["BlackjackNoSession"] = "You Have No Blackjack Session Currently Running!",
                ["BlackjackUserCard"] = "Your Cards: {0}. Value: {1}.",
                ["BlackjackBotCard"] = "Bot Cards: {0}. Value: {1}.",
                ["BlackjackUserWon"] = "Congratulation, You Have Won {0} {1}!",
                ["BlackjackUserLost"] = "Aww, You Lost {0} {1}!",
                ["BlackjackUserTied"] = "Aww, You Tied And Got Back {0} {1}!",

            }, this, "en"); ;
        }
        #endregion

        #region Player Disconnect / Connect Handler
        private class DisconnectData
        {
            public ulong userId;
            public string itemShortName;
            public int amount;

            public DisconnectData(ulong userId, string shortName, int amount)
            {
                this.userId = userId;
                this.itemShortName = shortName;
                this.amount = amount;
            }
        }

        void OnUserDisconnected(IPlayer player)
        {
            // Check if user got join the raffle
            bool didJoinRaffle = false;
            ulong thisPlayerId = Convert.ToUInt64(player.Id);

            foreach (ulong playerId in joinedPlayersId)
            {
                if (playerId == thisPlayerId)
                {
                    // User is in the list
                    didJoinRaffle = true;
                }
            }

            if (didJoinRaffle)
            {
                // Create the data then add the data into the list to compensate them when they connect later on
                DisconnectData data = new DisconnectData(thisPlayerId, raffleJoinName, raffleJoinAmount);
                disconnectedPlayers.Add(data);

                // Remove them from the list
                joinedPlayersId.Remove(thisPlayerId);
            }

            bool didJoinBlackjack = false;
            BlackjackData thisData = null;
            
            foreach (BlackjackData bjData in blackjackDatas)
            {
                if (bjData.thisPlayer.userID == thisPlayerId)
                {
                    // User is in the list
                    didJoinBlackjack = true;
                    thisData = bjData;
                }
            }

            if (didJoinBlackjack)
            {
                // Create the data then add the data into the list to compensate them when they connect later on
                DisconnectData data = new DisconnectData(thisPlayerId, thisData.item, thisData.amount);
                disconnectedPlayers.Add(data);

                // Remove them from the list
                blackjackDatas.Remove(thisData);
            }
        }

        void OnUserConnected(IPlayer player)
        {
            // Check if user is in the list of disconnected player 
            bool playerInList = false;
            ulong thisPlayerId = Convert.ToUInt64(player.Id);
            DisconnectData thisPlayerData = null;

            foreach (DisconnectData data in disconnectedPlayers)
            {
                if (data.userId == thisPlayerId)
                {
                    playerInList = true;
                    thisPlayerData = data;
                }
            }

            // Player is in the list
            if (playerInList && thisPlayerData != null)
            {
                // Compensate the player
                ItemDefinition theItem = ItemManager.FindItemDefinition(thisPlayerData.itemShortName);
                Item item = ItemManager.CreateByItemID(theItem.itemid, thisPlayerData.amount);
                BasePlayer thisPlayer = player.Object as BasePlayer;
                thisPlayer.GiveItem(item);

                // Generate message
                string message = lang.GetMessage("Compensate", this, thisPlayer.UserIDString);
                thisPlayer.ChatMessage(string.Format(message, thisPlayerData.amount, theItem.displayName));

                // Remove user from list
                disconnectedPlayers.Remove(thisPlayerData);
            }
        }
        #endregion

        #region Initialization
        private void Init()
        {
            // Initialize the lists
            joinedPlayersId = new List<ulong>();
            disconnectedPlayers = new List<DisconnectData>();
            blackjackDatas = new List<BlackjackData>();

            // Load configuration
            LoadVariables();

            // Permission 
            permission.RegisterPermission("ultimategamble.start", this);

            #region Raffle
            // Check and set the cost name and reward name for raffle
            ItemDefinition join = ItemManager.FindItemDefinition(raffleJoin);
            ItemDefinition reward = ItemManager.FindItemDefinition(raffleReward);

            if (join == null)
            {
                string message = lang.GetMessage("RaffleJoinNotFound", this);
                PrintError(string.Format(message, raffleJoin));

                raffleHasError = true;
            }

            if (reward == null)
            {
                string message = lang.GetMessage("RaffleRewardNotFound", this);
                PrintError(string.Format(message, raffleReward));

                raffleHasError = true;
            }

            if (join != null && reward != null)
            {
                raffleJoinName = ItemManager.FindItemDefinition(raffleJoin).displayName.english;
                raffleRewardName = ItemManager.FindItemDefinition(raffleReward).displayName.english;
            }

            // Initialize the Raffle if there's no error
            if (!raffleHasError && raffleActive)
            {
                // Run it after 5min
                timer.Once(300, () =>
                {
                    NextRaffleTime();
                    StartRaffleTimer();
                });
            }
            #endregion

            #region Blackjack
            ItemDefinition fee = ItemManager.FindItemDefinition(blackjackFee);

            if (fee == null)
            {
                string message = lang.GetMessage("BlackjackRewardNotFound", this);
                PrintError(string.Format(message, blackjackFee));

                blackjackHasError = true;
            }
            else
            {
                blackjackFeeName = fee.displayName.english;
            }
            #endregion
        }

        private float SecondsTillTime(float time)
        {
            if (raffleUseServerTime)
            {
                // Using Time Curve since there is no way to determine the seconds per minute except for using the curve.
                // Create a reversing Time Curve
                AnimationCurve TimeCurve = TOD_Sky.Instance.Components.Time.TimeCurve;
                AnimationCurve reverseTimeCurve = new AnimationCurve();
                float thisAmount = 0;
                while (thisAmount <= 24)
                {
                    reverseTimeCurve.AddKey(TimeCurve.Evaluate(thisAmount), thisAmount);
                    thisAmount += 0.1f;
                    thisAmount = Convert.ToSingle(Math.Round(thisAmount, 1));
                }

                // Find the time diff between the time we want and the current game time
                float diff = reverseTimeCurve.Evaluate(time) - reverseTimeCurve.Evaluate(ConVar.Env.time);
                // Get the day length, this is auto in real time minutes
                float dayLength = TOD_Sky.Instance.Components.Time.DayLengthInMinutes;

                // If negative, it means that the time has already pass so just loop it around with the day length
                if (diff < 0)
                {
                    diff = 24 + diff;
                }

                if (time >= 0 && time <= ConVar.Env.time)
                {
                    diff += 24 * raffleDaysSkip;
                }

                // Find the multiplier that will convert the game time from that hour to our seconds
                // Take it as 
                // 60 minutes our time = 24 hours in game time
                // 2.5 minutes our time = 1 hour in game time
                // 150 seconds our time = 1 hour in game time <- this is what we need
                // Note: diff returns in hours format
                float multiplier = dayLength * 60 / 24;
                float seconds = diff * multiplier;
                return seconds; // This will return our seconds needed to reach the next time
            }
            else
            {
                // Convert the time to hours & minutes
                int hours = (int)time;
                int minutes = (int)((time - hours) * 60);

                DateTime currentTime = DateTime.Now;
                DateTime targetTime = new DateTime(0, 0, 0, hours, minutes, 0);

                int nowSeconds = currentTime.Hour * 60 * 60 + currentTime.Minute * 60 + currentTime.Second;
                int targetSeconds = targetTime.Second * 60 * 60 + targetTime.Minute * 60 + targetTime.Second;

                int diff = targetSeconds - nowSeconds;

                return diff; // Return out seconds needed to reach the next time
            }
        }
        #endregion

        #region Raffle
        // Randomly choose a player that has joined the raffle session
        private void NextRaffleTime()
        {
            float diff = -1;

            // Extract each start time
            foreach(string time in raffleStartTime)
            {
                // Split the time
                string[] splitedTime = time.Split(':');

                // Convert it to float
                float thisTime = float.Parse(splitedTime[0]);

                // Convert the minutes to hours
                if (splitedTime.Length > 1)
                {
                    float thisMinutes = float.Parse(splitedTime[1]) / 60;
                    thisTime += thisMinutes;
                }

                // Get current time
                float currentTime = ConVar.Env.time;

                // Find the diff
                float thisDiff = thisTime - currentTime;
                
                // Check if negative, if it is change it to positive and add 24 hours to it
                if (thisDiff < 0)
                {
                    thisDiff += 24;
                }

                // Store the time for the nearest to the time
                if (diff == -1)
                {
                    diff = thisDiff;
                    raffleNextStartTime = thisTime;
                }
                else
                {
                    // Check if the current diff is shorter than the previous diff
                    if (thisDiff < diff && thisDiff > 0.25)
                    {
                        diff = thisDiff;
                        raffleNextStartTime = thisTime;
                    }
                }
            }
        }

        private void StartRaffleTimer()
        {
            timer.Once(SecondsTillTime(raffleNextStartTime), () =>
            {
                StartRaffle();
            });
        }

        private void EndRaffleTimer()
        {
            timer.Once(30f, () =>
            {
                EndRaffle();
            });
        }

        private void StartRaffle()
        {
            isRaffleTime = true;

            // Log the raffle start
            Puts("Raffle Started!");

            // Cancel it if there's not enough player in the server
            if (BasePlayer.activePlayerList.Count < rafflePlayersNeeded)
            {
                string message = lang.GetMessage("RaffleFailStart", this);
                Puts(message);

                isRaffleTime = false;
                
                if (!customStart)
                {
                    NextRaffleTime();
                    StartRaffleTimer();
                }

                return;
            }

            EndRaffleTimer();

            // Give Instructions
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                // Generate message
                string message = lang.GetMessage("RaffleStart", this, player.UserIDString);
                player.ChatMessage(string.Format(message, raffleJoinAmount, raffleJoinName, raffleRewardAmount, raffleRewardName));
            }
        }
        
        private void EndRaffle()
        {
            isRaffleTime = false;

            if (!customStart)
            {
                NextRaffleTime();
                StartRaffleTimer();
            }

            // Check the player needed
            if (joinedPlayersId.Count <= rafflePlayersNeeded)
            {
                // Not enough players, return scrap
                foreach (ulong playerID in joinedPlayersId)
                {
                    BasePlayer player = BasePlayer.FindByID(playerID);
                    Item item = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(raffleJoin).itemid, raffleRewardAmount);
                    player.GiveItem(item);

                    // Generate message
                    string message = lang.GetMessage("RaffleFail", this, player.UserIDString);
                    player.ChatMessage(string.Format(message, raffleJoinName));
                }

                // Clear the list
                joinedPlayersId.Clear();

                // Log that the raffle ended and no one won due to insufficient player
                Puts("Raffle Ended Due To Insufficient Players!");

                return;
            }
            else
            {
                // Randomly choose a person
                int random = UnityEngine.Random.Range(0, joinedPlayersId.Count - 1);

                // Give the winner a an award
                BasePlayer winner = BasePlayer.FindByID(joinedPlayersId[random]);
                Item item = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(raffleReward).itemid);
                winner.GiveItem(item);

                // Annouce Winner
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    string message = lang.GetMessage("RaffleEnd", this, player.UserIDString);
                    player.ChatMessage(string.Format(message, winner.displayName));
                }

                // Clear the list
                joinedPlayersId.Clear();

                // Log that the raffle ended and someone won
                Puts("Raffle Ended And Someone Won It!");

                return;
            }
        }

        [ChatCommand("raffle")]
        private void RaffleCommand(BasePlayer player, string command, string[] args)
        {
            // Check if they're using the command even tho it haven't start
            if (!isRaffleTime)
            {
                // Get the time till the next raffle
                float secondsTillNext = SecondsTillTime(raffleNextStartTime);
                int minutesTillNext = Mathf.CeilToInt(secondsTillNext / 60);

                string message = lang.GetMessage("RaffleHaventStart", this, player.UserIDString);
                player.ChatMessage(string.Format(message, minutesTillNext.ToString()));
                return;
            }

            // Check if they already joined
            if (joinedPlayersId.Contains(player.userID))
            {
                string message = lang.GetMessage("RaffleAlreadyJoined", this, player.UserIDString);
                player.ChatMessage(message);

                return;
            }

            // Check if they have the item to join in their inventory
            int itemId = ItemManager.FindItemDefinition(raffleJoin).itemid;
            int itemAmount = player.inventory.GetAmount(itemId);
            
            if (itemAmount < raffleRewardAmount)
            {
                string message = lang.GetMessage("RaffleInsufficient", this, player.UserIDString);
                player.ChatMessage(string.Format(message, raffleJoinName, raffleJoinAmount));

                return;
            }

            // By right here player should meet all the requirements
            // Add player to the list of players and remove their scrap
            joinedPlayersId.Add(player.userID);

            player.inventory.Take(null, itemId, raffleJoinAmount);

            // Successful message
            foreach (BasePlayer otherPlayers in BasePlayer.activePlayerList)
            {
                if (otherPlayers.userID == player.userID)
                {
                    string message = lang.GetMessage("RaffleJoinedPlayer", this, otherPlayers.UserIDString);
                    otherPlayers.ChatMessage(message);
                }
                else
                {
                    string message = lang.GetMessage("RaffleJoinedGlobal", this, otherPlayers.UserIDString);
                    otherPlayers.ChatMessage(string.Format(message, player.displayName));
                }
            }
        }

        [ChatCommand("raffle.start")]
        private void RaffleStartCommand(BasePlayer player, string command, string[] args)
        {
            IPlayer thisPlayer = player.IPlayer;

            // This command is to allow admin to straight start the raffle if there is no raffle currently running
            if (player.net.connection.authLevel < neededAuthLevel && !thisPlayer.HasPermission("ultimategamble.start"))
            {
                string message = lang.GetMessage("CannotUseCommand", this, player.UserIDString);
                player.ChatMessage(message);
                return;
            }

            // Check if there's a raffle currently running
            if (isRaffleTime)
            {
                string thisMessage = lang.GetMessage("RaffleCustomFail", this, player.UserIDString);
                player.ChatMessage(thisMessage);
            }
            else
            {
                // Here, user has the permission to use this command.
                customStart = true;

                // Send the user that uses it a message of confirmation
                string thisMessage = lang.GetMessage("RaffleCustomStart", this, player.UserIDString);
                player.ChatMessage(thisMessage);

                // Log in the console
                Puts("Raffle Was Force Started By " + player.displayName + "!");

                // Start the raffle
                StartRaffle();
            }
        }
        #endregion

        #region Blackjack
        // A player vs AI kind, typical 21
        // Class storer for blackjack data
        private class BlackjackData
        {
            public BasePlayer thisPlayer;
            public bool isActive = false;
            public int myCardValue = 0;
            public List<string> mycard;
            public int aiCardValue = 0;
            public List<string> aiCard;
            public float endTime;
            public int amount;
            public string item;
        }

        [ChatCommand("blackjack")]
        private void Blackjack(BasePlayer player, string command, string[] args)
        {
            // This command is split into 3 parts based on the args
            // 1: /blackjack <amount> 
            // 2: /blackjack hit
            // 3: /blackjack stand
            // TODO: Store and check if player hit already then disconnect. If they did then don't refund them.

            // Check if args was not specified or there was more than one args
            if (blackjackHasError)
            {
                return;
            }

            if (args == null || args.Length != 1)
            {
                // Display an error to user
                string message = lang.GetMessage("BlackjackNoArgs", this, player.UserIDString);
                player.ChatMessage(string.Format(message, blackjackFeeName));

                return;
            }

            if (args[0].ToLower() == "hit")
            {
                // Hit
                // Check if user has a datastored
                bool hasData = false;
                BlackjackData thisData = null;

                foreach (BlackjackData data in blackjackDatas)
                {
                    if (data.thisPlayer == player)
                    {
                        hasData = true;
                        thisData = data;
                    }
                }

                if (!hasData)
                {
                    // Display an error
                    string message = lang.GetMessage("BlackjackNoSession", this, player.UserIDString);
                    player.ChatMessage(message);

                    return;
                }

                // So by right here player should have a data stored already means that they already used /blackjack <amount>
                // HIT
                // User's card
                int userCardValue = thisData.myCardValue;
                List<string> userCard = thisData.mycard;

                // Choose a random card and add to the list
                int random = UnityEngine.Random.Range(1, cardName.Length);
                userCardValue = DetermineCardValue(userCard, cardName[random]);
                userCard.Add(cardName[random]);

                // Store then this send a message to the user
                foreach (BlackjackData data in blackjackDatas)
                {
                    if (data.thisPlayer == player)
                    {
                        data.myCardValue = userCardValue;
                        data.mycard = userCard;
                        data.endTime = Time.time;
                        thisData = data;
                    }
                }

                // Check if the value is greater than 21
                if (thisData.myCardValue >= 21 || thisData.mycard.Count >= 5)
                {
                    // End it
                    EndBlackjack(player, thisData);
                }
                else
                {
                    // Send it to user
                    string usermessage = lang.GetMessage("BlackjackUserCard", this, player.UserIDString);
                    player.ChatMessage(string.Format(usermessage, string.Join(", ", thisData.mycard.ToArray()), thisData.myCardValue));

                    string botmesage = lang.GetMessage("BlackjackBotCard", this, player.UserIDString);
                    player.ChatMessage(string.Format(botmesage, string.Join(", ", thisData.aiCard.ToArray()), thisData.aiCardValue));

                    string instruction = lang.GetMessage("BlackjackArgChoose", this, player.UserIDString);
                    player.ChatMessage(instruction);

                    // Start a timer
                    timer.Once(blackjackTimeout, () =>
                    {
                        bool hasUserData = false;
                        BlackjackData currentData = null;

                        foreach (BlackjackData data in blackjackDatas)
                        {
                            if (data.thisPlayer == player)
                            {
                                hasUserData = true;
                                currentData = data;
                            }
                        }

                        if (hasUserData)
                        {
                            if ((Time.time - currentData.endTime) >= blackjackTimeout)
                            {
                                EndBlackjack(player, currentData);
                            }
                        }
                    });
                }
            }
            else if (args[0].ToLower() == "stand")
            {
                // Stand
                // Check if user has a datastored
                bool hasData = false;
                BlackjackData thisData = null;

                foreach (BlackjackData data in blackjackDatas)
                {
                    if (data.thisPlayer == player)
                    {
                        hasData = true;
                        thisData = data;
                    }
                }

                if (!hasData)
                {
                    // Display an error
                    string message = lang.GetMessage("BlackjackNoSession", this, player.UserIDString);
                    player.ChatMessage(message);

                    return;
                }

                // End it
                EndBlackjack(player, thisData);
            }
            else
            {
                // Check if the arg can be converted to amount
                int amount;
                bool tryConvert = int.TryParse(args[0], out amount);

                if (!tryConvert)
                {
                    // Can't convert the string to int so the arg wasn't a number
                    // Display error
                    // Check if they have a blackjack currently running
                    bool hasBjRunning = false;

                    foreach (BlackjackData bjData in blackjackDatas)
                    {
                        if (bjData.thisPlayer == player && bjData.isActive)
                        {
                            hasBjRunning = true;
                        }
                    }

                    if (hasBjRunning)
                    {
                        // Bj was running so by right they should send hit or stand
                        string message = lang.GetMessage("BlackjackArgChoose", this, player.UserIDString);
                        player.ChatMessage(message);

                        return;
                    }
                    else
                    {
                        // Bj was not running so by right they should enter a value
                        string message = lang.GetMessage("BlackjackArgNotNumber", this, player.UserIDString);
                        player.ChatMessage(message);

                        return;
                    }
                }
                else
                {
                    // Check if the input amount meet the minimum requirement
                    if (amount < blackjackMinimumFee)
                    {
                        // Amount did not meet the minimum
                        string message = lang.GetMessage("BlackjackMinimumFail", this, player.UserIDString);
                        player.ChatMessage(string.Format(message, blackjackMinimumFee, blackjackFeeName));

                        return;
                    }

                    // Check if user already joined the blackjack
                    bool joined = false;

                    foreach (BlackjackData bjData in blackjackDatas)
                    {
                        if (bjData.thisPlayer == player && bjData.isActive)
                        {
                            joined = true;
                        }
                        else if (bjData.thisPlayer == player && !bjData.isActive)
                        {
                            // Cooldown...
                            string message = lang.GetMessage("BlackjackCooldown", this, player.UserIDString);
                            player.ChatMessage(string.Format(message)); //TODO
                        }
                    }

                    if (joined)
                    {
                        // User already joined so just give them an error message and end it 
                        string message = lang.GetMessage("BlackjackArgChoose", this, player.UserIDString);
                        player.ChatMessage(message);

                        return;
                    }

                    // Check if user has the required stuff in their inventory to join
                    int itemId = ItemManager.FindItemDefinition(blackjackFee).itemid;
                    int itemAmount = player.inventory.GetAmount(itemId);

                    if (itemAmount < amount)
                    {
                        string message = lang.GetMessage("BlackjackInsufficient", this, player.UserIDString);
                        player.ChatMessage(string.Format(message, blackjackFeeName, amount));

                        return;
                    }

                    // By right here, they should meet all the requirements
                    // Create the data
                    BlackjackData thisData = new BlackjackData();
                    thisData.thisPlayer = player;
                    thisData.isActive = true;

                    // Retrieve the fee
                    player.inventory.Take(null, itemId, amount);

                    // Start the blackjack interaction between user and an ai
                    string[] cardName = { "A", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "K", "Q", "J" };

                    // Bot card
                    int botCardValue = 0;
                    List<string> botCard = new List<string>();

                    // Run a loop twice since they can only get 2 card
                    for (int i = 0; i < 2; i++)
                    {
                        int random = UnityEngine.Random.Range(1, cardName.Length);
                        botCardValue = DetermineCardValue(botCard, cardName[random]);
                        botCard.Add(cardName[random]);
                    }

                    // User's card
                    int userCardValue = 0;
                    List<string> userCard = new List<string>();
                    
                    // Run a loop twice since they can only get 2 card
                    for (int i = 0; i < 2; i++)
                    {
                        int random = UnityEngine.Random.Range(1, cardName.Length);
                        userCardValue = DetermineCardValue(userCard, cardName[random]);
                        userCard.Add(cardName[random]);
                    }

                    // Store the data
                    thisData.aiCard = botCard;
                    thisData.aiCardValue = botCardValue;
                    thisData.mycard = userCard;
                    thisData.myCardValue = userCardValue;
                    thisData.endTime = Time.time;
                    thisData.amount = amount;
                    thisData.item = blackjackFee;
                    blackjackDatas.Add(thisData);

                    // Send a message to user
                    string usermessage = lang.GetMessage("BlackjackUserCard", this, player.UserIDString);
                    player.ChatMessage(string.Format(usermessage, string.Join(", ", userCard.ToArray()), userCardValue));

                    string botmesage = lang.GetMessage("BlackjackBotCard", this, player.UserIDString);
                    player.ChatMessage(string.Format(botmesage, string.Join(", ", botCard.ToArray()), botCardValue));

                    string instruction = lang.GetMessage("BlackjackArgChoose", this, player.UserIDString);
                    player.ChatMessage(instruction);

                    // Start a timer
                    timer.Once(blackjackTimeout, () =>
                    {
                        bool hasUserData = false;
                        BlackjackData currentData = null;

                        foreach (BlackjackData data in blackjackDatas)
                        {
                            if (data.thisPlayer == player)
                            {
                                hasUserData = true;
                                currentData = data;
                            }
                        }

                        if (hasUserData)
                        {
                            if ((Time.time - currentData.endTime) >= blackjackTimeout)
                            {
                                EndBlackjack(player, currentData);
                            }
                        }
                    });
                }
            }
        }

        private void EndBlackjack(BasePlayer player, BlackjackData theData)
        {
            BlackjackData baseData = theData;
            // Check if the player card is below 21 
            if (theData.myCardValue < 21 && theData.mycard.Count < 5)
            {
                // Less than 21, so there's a chance that the bot value is greater
                // Run a loop if the bot's value is less than 17
                for (int i = 0; i < 5; i++)
                {
                    if (theData.aiCardValue < 17 && theData.aiCard.Count != 5)
                    {
                        // Bot card
                        int botCardValue = theData.aiCardValue;
                        List<string> botCard = theData.aiCard;

                        // Run a loop twice since they can only get 2 card
                        int random = UnityEngine.Random.Range(1, cardName.Length);
                        botCardValue = DetermineCardValue(botCard, cardName[random]);
                        botCard.Add(cardName[random]);

                        // Update the data into the data
                        theData.aiCardValue = botCardValue;
                        theData.aiCard = botCard;
                    }
                    else
                    {
                        break;
                    }
                }

                if (theData.aiCardValue > 21)
                {
                    // User wins
                    BlackjackEndMessage(player, theData, 1);
                }
                else if (theData.aiCardValue == 21)
                {
                    // Bot wins
                    BlackjackEndMessage(player, theData, 2);
                }
                else if (theData.aiCardValue < 21 && theData.aiCard.Count == 5)
                {
                    // Bot wins
                    BlackjackEndMessage(player, theData, 2);
                }
                else
                {
                    // Check if the user's card is greater than the bot's card
                    if (theData.myCardValue > theData.aiCardValue)
                    {
                        // User wins
                        BlackjackEndMessage(player, theData, 1);
                    }
                    else if (theData.myCardValue < theData.aiCardValue)
                    {
                        // Bot wins
                        BlackjackEndMessage(player, theData, 2);
                    }
                    else
                    {
                        // Tie
                        BlackjackEndMessage(player, theData, 3);
                    }
                }
            }
            else if (theData.myCardValue == 21)
            {
                // Player wins
                BlackjackEndMessage(player, theData, 1);
            }
            else if  (theData.mycard.Count == 5 && theData.myCardValue < 21)
            {
                // Player wins
                BlackjackEndMessage(player, theData, 1);
            }
            else
            {
                // Bot wins
                BlackjackEndMessage(player, theData, 2);
            }

            blackjackDatas.Remove(baseData);
        }

        private void BlackjackEndMessage(BasePlayer player, BlackjackData theData, int option)
        {
            // Display the base message of the cards
            string usermessage = lang.GetMessage("BlackjackUserCard", this, player.UserIDString);
            player.ChatMessage(string.Format(usermessage, string.Join(", ", theData.mycard.ToArray()), theData.myCardValue));

            string botmesage = lang.GetMessage("BlackjackBotCard", this, player.UserIDString);
            player.ChatMessage(string.Format(botmesage, string.Join(", ", theData.aiCard.ToArray()), theData.aiCardValue));

            string message = "";
            switch (option)
            {
                case 1:
                    // User won
                    Item item = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(theData.item).itemid, (int)(theData.amount * blackjackMultiplier));
                    player.GiveItem(item);

                    // Display user message
                    message = lang.GetMessage("BlackjackUserWon", this, player.UserIDString);
                    player.ChatMessage(string.Format(message, (theData.amount * blackjackMultiplier).ToString(), ItemManager.FindItemDefinition(theData.item).displayName.english));

                    break;
                case 2:
                    // User Lost
                    // Display user message
                    message = lang.GetMessage("BlackjackUserLost", this, player.UserIDString);
                    player.ChatMessage(string.Format(message, theData.amount.ToString(), ItemManager.FindItemDefinition(theData.item).displayName.english));

                    break;
                case 3:
                    // User tied
                    Item thisItem = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(theData.item).itemid, theData.amount);
                    player.GiveItem(thisItem);

                    // Display user message
                    message = lang.GetMessage("BlackjackUserTied", this, player.UserIDString);
                    player.ChatMessage(string.Format(message, theData.amount.ToString(), ItemManager.FindItemDefinition(theData.item).displayName.english));
                    break;

            }
        }

        private int DetermineCardValue(List<string> theCard, string thisCard)
        {
            // Add the card to all card list
            List<string> allCard = new List<string>(theCard);
            allCard.Add(thisCard);

            // Calculate the amount
            int totalAmount = 0;

            List<string> clonedCard = new List<string>(allCard);
            List<string> arrangedCard = new List<string>();
            string[] cardList = { "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "K", "Q", "J", "A" };

            // Rearrange the card
            for (int i = 0; i < allCard.Count; i++)
            {
                // Loop the card list
                foreach (string card in cardList)
                {
                    // If contain the add the arranged one, remove the cloned one and stop it
                    if (clonedCard.Contains(card))
                    {
                        arrangedCard.Add(card);
                        clonedCard.Remove(card);
                        break;
                    }
                }
            }

            foreach (string cards in arrangedCard)
            {
                // Determine the card value
                switch (cards)
                {
                    case "A":
                        if (totalAmount >= 10)
                        {
                            // Change the value to 1
                            totalAmount += 1;
                        }
                        else
                        {
                            // Keep A as 11
                            totalAmount += 11;
                        }

                        break;
                    case "1":
                        totalAmount += 1;
                        break;
                    case "2":
                        totalAmount += 2;
                        break;
                    case "3":
                        totalAmount += 3;
                        break;
                    case "4":
                        totalAmount += 4;
                        break;
                    case "5":
                        totalAmount += 5;
                        break;
                    case "6":
                        totalAmount += 6;
                        break;
                    case "7":
                        totalAmount += 7;
                        break;
                    case "8":
                        totalAmount += 8;
                        break;
                    case "9":
                        totalAmount += 9;
                        break;
                    case "10":
                    case "K":
                    case "Q":
                    case "J":
                        totalAmount += 10;
                        break;
                }
            }
            
            return totalAmount;
        }
        #endregion

        #region Slots
        // A slot system no idea on how to get the specific icon in.
        #endregion

        #region Lottery
        // User select a random number and the system generate a random number, if both number are the same then they win
        #endregion

        #region HOT
        // Heads or tails maybeeee? 50/50 win rate?
        #endregion
    }
}


// --- End of file: UltimateGamble.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/hunt-rpg ---
// --- Original File Path: H/HuntRPG/HuntRPG.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;

using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;

using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Serialization;

using UnityEngine;

using Oxide.Plugins.HuntRPGExt;
using Oxide.Plugins.HuntRPGExt.Keys;
using Random = UnityEngine.Random;
using Time = UnityEngine.Time;

/****************************
 * This update 1.8.2
 * Fixed Furnace Issues
 * Fixed OnPlayerDeath/OnEntity Death issues
 * Removed Experimental features will be posted under a new branch.
 ***************************/

namespace Oxide.Plugins
{
    [Info("Hunt RPG", "Default", "1.8.3")]
    [Description("An RPG system with level, stats, skills, and specializations")]
    public class HuntRPG : RustPlugin
    {
        /*
         * TODO:
         * Implement Economics better
         * Reintroduce increasing max health
         * Patch up the skills.
         * Remove researcher.
         * Make maximum level changeable within the config.
         * Make plugin all UI based.
         * LoOk PrEtTy
         */

        [PluginReference]
        private Plugin Pets, EventManager, PopupNotifications, Economics, MagazinBoost, InstantCraft;
        
        private bool initialized;
        private bool updatePlayerData;
        private readonly DynamicConfigFile huntDataFile;
        private VersionNumber DataVersion;

        private HuntData Data;
        private string ChatPrefix;
        private ulong[] Trainer;
        private Dictionary<HRK, Skill> SkillTable;
        private Dictionary<ResourceDispenser.GatherType, float> ExpRateTable;
        private Dictionary<int, string> TameTable;
        private Dictionary<string, ItemInfo> ItemTable;
        private Dictionary<string, int> ResearchTable;
        private Dictionary<BuildingGrade.Enum, float> UpgradeBuildingTable;
        private string[] AllowedEntites;
        private bool AdminReset;
        private bool ShowHud;
        private bool ShowProfile;
        private uint DefaultHud;
        private float NightXP;
        private float DeleteProfileAfter;
        private float DeathReducer;
        private Dictionary<string, string> itemShortname;

        private readonly Dictionary<ulong, float> PlayerLastPercentChange;
        private readonly Dictionary<ulong, Dictionary<HRK, float>> SkillsCooldowns;
        private readonly Dictionary<ulong, GUIInfo> GUIInfo;
        private readonly int playersMask = LayerMask.GetMask("Player (Server)");
        private readonly int triggerMask = LayerMask.GetMask("Trigger");

        private double EcoBoost;
        private int MaximumLevel;
        private Vector3 position;

        public HuntRPG()
        {
            DataVersion = new VersionNumber(1, 0, 1);

            GUIInfo = new Dictionary<ulong, GUIInfo>();
            PlayerLastPercentChange = new Dictionary<ulong, float>();
            SkillsCooldowns = new Dictionary<ulong, Dictionary<HRK, float>>();
            huntDataFile = Interface.Oxide.DataFileSystem.GetFile(HK.DataFileName);
        }

        #region Hooks

        private void OnServerInitialized()
        {
            if (!initialized) OnTerrainInitialized();
            if (ItemTable == null)
            {
                DefaultItems();
                ItemTable = ReadFromConfig<Dictionary<string, ItemInfo>>(HK.ItemTable);
            }
            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                GUIInfo guiInfo;
                if (!GUIInfo.TryGetValue(player.userID, out guiInfo)) continue;
                DestroyUi(player, guiInfo.LastHud);
                DestroyUi(player, guiInfo.LastMain);
            }
            SaveRpg();
            RPGInfo.OnUnload();
        }

        void OnTerrainInitialized()
        {
            initialized = true;
            var configVersion = new VersionNumber();
            if (Config[HK.ConfigVersion] != null)
                configVersion = ReadFromConfig<VersionNumber>(HK.ConfigVersion);
            var dataVersion = new VersionNumber();
            if (Config[HK.DataVersion] != null)
                dataVersion = ReadFromConfig<VersionNumber>(HK.DataVersion);
            var needDataUpdate = !DataVersion.Equals(dataVersion);
            UpdateLang();
            LoadRpg(dataVersion);
            if (!needDataUpdate)
            {
                PrintToChat(_(HMK.Loaded));
                return;
            }
            updatePlayerData = true;
            UpdateData();
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.Once(2, () => OnPlayerConnected(player));
                return;
            }
            if (updatePlayerData) ChatMessage(player, HMK.DataUpdated);
            var rpgInfo = FindRpgInfo(player);
            if (rpgInfo.Preferences.ShowProfile) ChatMessage(player, Profile(rpgInfo, player));
            var steamId = player.userID;
            if (!PlayerLastPercentChange.ContainsKey(steamId))
                PlayerLastPercentChange.Add(steamId, CurrentPercent(FindRpgInfo(player)));
            UpdateEffectsPlayer(player, rpgInfo);
            if (!ShowHud) return;
            timer.Once(1, () => GuiInit(player));
        }

        private void OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo, BaseCombatEntity entity)
        {
            if (player is NPCPlayer) return;
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L)) return;
            var rpgInfo = FindRpgInfo(player);
            if (rpgInfo == null) return;
            var attacker = hitInfo.Initiator as BasePlayer;
            var victim = hitInfo.Initiator;
            if (victim is BasePlayer)
            {

                if (Random.Range(0f, 1f) <= rpgInfo.GetEvasion())
                {
                    ChatMessage(player, HMK.Dodged);
                    if (!(victim is NPCPlayer))
                    {
                        ChatMessage(attacker, HMK.TargetDodged);
                    }
                    hitInfo.damageTypes.ScaleAll(0);
                }
            }
            if (rpgInfo.GetBlock() <= 1 && rpgInfo.GetBlock() >= 0)
            {
                hitInfo.damageTypes.ScaleAll(1 - rpgInfo.GetBlock());
            }
            //ExpGain(rpgInfo, (int) Math.Ceiling(100.0 * 1.0), attacker);
            //return;
            //TODO Make actually work/Implement better.
        }

        //For reference

        /*var rpgInfo = FindRpgInfo(player);
            if (rpgInfo == null) return;
            if (player.displayName == null) return;
            if (player.userID< 2147483647) return;
            var attacker = hitInfo.Initiator as BasePlayer;
        ExpGain(rpgInfo, (int) Math.Ceiling(100.0 * 1.0), attacker);
            return;*/

        private object OnPlayerAttack(BasePlayer player, HitInfo hitInfo)
        {
            if (player == null || hitInfo?.Weapon?.GetItem() == null || !player.CanBuild()) return null;
            Skill skill;
            if (SkillTable.TryGetValue(HRK.Blinkarrow, out skill) && !skill.Enabled)
                return null;
            if (!hitInfo.Weapon.GetOwnerItemDefinition().shortname.Equals("bow.hunting") && !hitInfo.Weapon.GetOwnerItemDefinition().shortname.Equals("bow.compound"))
                return null;
            var rpgInfo = FindRpgInfo(player);
            int skillPoints;
            if (!rpgInfo.Skills.TryGetValue(HRK.Blinkarrow, out skillPoints))
            {
                ChatMessage(player, HMK.NotLearnedSkill);
                return null;
            }
            var playerCooldowns = PlayerCooldowns(player.userID);
            float availableAt = 0;
            var time = Time.realtimeSinceStartup;
            var isReady = /*player.IsAdmin || */IsSkillReady(playerCooldowns, ref availableAt, time, HRK.Blinkarrow);
            if (!isReady)
            {
                ChatMessage(player, HMK.BlinkedRecently, TimeLeft(availableAt, time));
            }
            if (isReady)
            {
                if (rpgInfo.Preferences.AutoToggleBlinkArrow)
                    rpgInfo.Preferences.UseBlinkArrow = true;
                if (!rpgInfo.Preferences.UseBlinkArrow) return null;
                Vector3 newPos = blinkArrow(hitInfo);
                if (!IsBuildingAllowed(newPos, player))
                {
                    ChatMessage(player, HMK.CantBlinkOther);
                    return null;
                }
                TeleportPlayerTo(player, newPos);
                SetCooldown(skillPoints, time, playerCooldowns, HRK.Blinkarrow);
            }
            if (!rpgInfo.Preferences.UseBlinkArrow) return null;
            if (rpgInfo.Preferences.AutoToggleBlinkArrow)
                rpgInfo.Preferences.UseBlinkArrow = false;
            return null;
        }

        private static Vector3 blinkArrow(HitInfo hitInfo)
        {
            return GetGround(hitInfo.HitPositionWorld);
        }

        void OnEntityKill(BaseNetworkable networkable)
        {
            var oven = networkable as BaseOven;
            if (oven != null)
            {
                Data.Furnaces.Remove(EntityId(oven));
                return;
            }
            var quarry = networkable as MiningQuarry;
            if (quarry != null)
            {
                Data.Quarries.Remove(EntityId(quarry));
                return;
            }
        }
        
        // Replaces the OnPlayerDeath Hook
        private void OnEntityDeath(BasePlayer player, HitInfo hitInfo)
        {
            if (player == null || hitInfo == null) return; // To stop error on peace of shit scarecrow being a player... gg rust
            if (EventManager != null && (bool)EventManager.CallHook("isEventPlayer", player)) return;
            FindRpgInfo(player)?.Died(DeathReducer);
            ChatMessage(player, HMK.Died, DeathReducer);
            //Give Killer XP planned feature update
            var pvpenabled = false;
            if (pvpenabled)
            {
                if (hitInfo.Initiator == null || hitInfo?.damageTypes?.IsConsideredAnAttack() != true) return;
                var attacker = hitInfo?.Initiator as BasePlayer;
                if (attacker == null || attacker.IsNpc) return;
                var rpgInfo2 = FindRpgInfo(attacker);
                if (rpgInfo2 == null) return;
                ExpGain(rpgInfo2, (int) Math.Ceiling(1000.0 * 1.0), attacker);
            }
        }

        /*void OnPlayerDeath(BasePlayer player, HitInfo hitInfo)
        {
            var rpgInfo = FindRpgInfo(player);
            if (rpgInfo == null) return;
            if (player.displayName == null) return;
            if (player.userID < 2147483647) return;
            if (EventManager != null && (bool)EventManager.CallHook("isPlaying", player)) return;
            FindRpgInfo(player).Died(DeathReducer);
            ChatMessage(player, HMK.Died, DeathReducer);
        }*/

        object OnItemCraft(ItemCraftTask task, BasePlayer crafter)
        {
            if (!ItemTable.ContainsKey(task.blueprint.targetItem.shortname))
                return null;

            var rpgInfo = FindRpgInfo(crafter);
            var craftingTime = task.blueprint.time;
            var amountToReduce = craftingTime * rpgInfo.GetCraftingReducer();
            craftingTime -= amountToReduce;
            if (!task.blueprint.name.Contains("(Clone)"))
                task.blueprint = UnityEngine.Object.Instantiate(task.blueprint);
            task.blueprint.time = craftingTime;
            if (rpgInfo.Preferences.ShowCraftMessage)
                ChatMessage(crafter, HMK.CraftingEnd, craftingTime, amountToReduce);
            return null;
        }

        private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            var player = entity.ToPlayer();
            if (player == null) return;
            var rpgInfo = FindRpgInfo(player);
            if (rpgInfo == null) return;
            var gatherType = dispenser.gatherType;
            HRK skillType;
            switch (gatherType)
            {
                case ResourceDispenser.GatherType.Tree:
                    skillType = HRK.Lumberjack;
                    break;
                case ResourceDispenser.GatherType.Ore:
                    skillType = HRK.Miner;
                    break;
                case ResourceDispenser.GatherType.Flesh:
                    skillType = HRK.Hunter;
                    break;
                default:
                    ExpGain(rpgInfo, item.amount, player);
                    return;
            }
            int skillPoints;
            if (rpgInfo.Skills.TryGetValue(skillType, out skillPoints))
                item.amount = GatherModifierInt(skillPoints, skillType, item.amount);
            ExpGain(rpgInfo, (int)Math.Ceiling(item.amount * ExpRateTable[gatherType]), player);
            Economics?.Call("Deposit", player.UserIDString, item.amount * EcoBoost);
            //TODO Patch up and make work better.
        }

        private void OnCollectiblePickup(Item item, BasePlayer player)
        {
            var rpgInfo = FindRpgInfo(player);
            if (rpgInfo == null)
                return;
            int skillPoints;
            if (rpgInfo.Skills.TryGetValue(HRK.Gatherer, out skillPoints))
                item.amount = GatherModifierInt(skillPoints, HRK.Gatherer, item.amount);
            ExpGain(rpgInfo, (int)Math.Ceiling(item.amount * ExpRateTable[ResourceDispenser.GatherType.Ore] * 2), player);
            Economics?.Call("Deposit", player.UserIDString, item.amount * EcoBoost);
        }

        private void OnItemDeployed(Deployer deployer, BaseEntity baseEntity)
        {
            OnEntityDeployedInternal(deployer.GetOwnerPlayer(), baseEntity as BaseOven, Data.Furnaces);
        }

        private void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (container.playerOwner == null) return;
            var rpgInfo = FindRpgInfo(container.playerOwner);
            if (rpgInfo == null) return;
            UpdateMagazin(item, rpgInfo);
            UpdateGather(item, rpgInfo);
        }

        private void OnPlayerHealthChange(BasePlayer player)
        {
            if (player == null)
                return;
            UpdateHud(player, true, false);
        }

        private void OnEntityBuilt(Planner planner, GameObject gameObject)
        {
            var entity = gameObject.GetComponent<BaseEntity>();
            OnEntityDeployedInternal(planner.GetOwnerPlayer(), entity as BaseOven, Data.Furnaces);
            OnEntityDeployedInternal(planner.GetOwnerPlayer(), entity as MiningQuarry, Data.Quarries);
            var buildingBlock = entity as BuildingBlock;
            if (buildingBlock != null) OnStructureUpgrade(buildingBlock, planner.GetOwnerPlayer(), buildingBlock.grade);
        }
        
        private object OnOvenToggle(BaseOven oven, BasePlayer player)
        {
            if (!oven.IsOn())
            {
                OnEntityDeployedInternal(player, oven, Data.Furnaces);
            }
            return null;
        }

        // Make this have config options and increase the default values to be more noticable!
        private void OnFuelConsume(BaseOven oven, Item fuel, ItemModBurnable burnable)
        {
            if (oven == null) return;
            var instanceId = EntityId(oven);
            ulong playerFurnace;
            if (!Data.Furnaces.TryGetValue(instanceId, out playerFurnace))
                return;
            var player = FindPlayer(playerFurnace);
            var rpgInfo = player == null ? FindRpgInfo(playerFurnace) : FindRpgInfo(player);
            if (rpgInfo == null)
                return;
            int skillLevel;
            if (!rpgInfo.Skills.TryGetValue(HRK.Blacksmith, out skillLevel))
                return;
            var skill = SkillTable[HRK.Blacksmith];
            var skillChance = skillLevel * skill.Modifiers[HRK.Chance].Args[0];
            if (Random.Range(0f, 1f) > skillChance)
                return;
            var rate = skillLevel / (float)skill.MaxLevel * skill.Modifiers[HRK.RessRate].Args[0];
            var items = oven.inventory.itemList.ToArray();
            foreach (var item in items)
            {
                var itemModCookable = item.info.GetComponent<ItemModCookable>();
                if (itemModCookable?.becomeOnCooked == null || item.temperature < itemModCookable.lowTemp || item.temperature > itemModCookable.highTemp || itemModCookable.cookTime < 0) continue;
                if (oven.inventory.Take(null, item.info.itemid, 1) != 1) continue;
                var itemToGive = ItemManager.Create(itemModCookable.becomeOnCooked, (int)Math.Ceiling(itemModCookable.amountOfBecome * rate));
                if (!itemToGive.MoveToContainer(oven.inventory))
                    itemToGive.Drop(oven.inventory.dropPosition, oven.inventory.dropVelocity);
            }
        }

        object OnStructureUpgrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum grade)
        {
            NextTick(() =>
            {
                if (buildingBlock == null)
                    return;
                if (buildingBlock.grade != grade) return;
                var items = buildingBlock.blockDefinition.grades[(int)grade].costToBuild;
                var total = 0;
                foreach (var item in items)
                    total += (int)item.amount;
                var experience = (int)Math.Ceiling(UpgradeBuildingTable[grade] * total);
                ExpGain(FindRpgInfo(player), experience, player);
            });
            return null;
        }
        
        private void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            var rpgInfo = FindRpgInfo(player);
            if (rpgInfo == null)
                return;
            var gatherType = dispenser.gatherType;
            HRK skillType;
            switch (gatherType)
            {
                case ResourceDispenser.GatherType.Tree:
                    skillType = HRK.Lumberjack;
                    break;
                case ResourceDispenser.GatherType.Ore:
                    skillType = HRK.Miner;
                    break;
                case ResourceDispenser.GatherType.Flesh:
                    skillType = HRK.Hunter;
                    break;
                default:
                    ExpGain(rpgInfo, item.amount, player);
                    return;
            }

            int skillPoints;
            if (rpgInfo.Skills.TryGetValue(skillType, out skillPoints))
                item.amount = GatherModifierInt(skillPoints, skillType, item.amount);
            ExpGain(rpgInfo, (int)Math.Ceiling(item.amount * ExpRateTable[gatherType]), player);
            if (Economics == null)
                return;
            Economics.Call("Deposit", player.UserIDString, (double)item.amount * EcoBoost);
            return;
        }
        
        private void OnPlayerDisconnected(BasePlayer player)
        {
            GUIInfo.Remove(player.userID);
        }

        private void OnUseNPC(BasePlayer npc, BasePlayer player)
        {
            if (!Trainer.Contains(npc.userID)) return;
            NpcGui(player);
        }

        private void OnServerSave()
        {
            SaveRpg();
        }

        private void OnServerShutdown()
        {
            SaveRpg();
        }

        #region Hooks
        bool GiveEXP(BasePlayer player, int xp)
        {
            if (player == null || xp <= 0) return false;
            ExpGain(FindRpgInfo(player), xp, player);
            return true;
        }
        #endregion

        #region Internal
        private bool OnAttackedInternal(BasePlayer player, HitInfo hitInfo)
        {
            var attacker = hitInfo.Initiator as BasePlayer;
            if (!(hitInfo.Initiator is BaseNpc || attacker != null && player.userID != attacker.userID)) return false;
            var rpgInfo = FindRpgInfo(player);
            if (Random.Range(0f, 1f) <= rpgInfo.GetEvasion())
            {
                ChatMessage(player, HMK.Dodged);
                ChatMessage(attacker, HMK.TargetDodged);
                return true;
            }
            if (player.displayName == null) return false;
            if (player.userID < 700000000) return false;
            hitInfo.damageTypes.ScaleAll(1 - rpgInfo.GetBlock());
            return false;
        }

        private void OnEntityDeployedInternal(BasePlayer player, BaseEntity entity, IDictionary<string, ulong> data)
        {
            if (player == null || entity == null) return;
            if (!AllowedEntites.Contains(EntityName(entity), StringComparer.OrdinalIgnoreCase)) return;
            var instanceId = EntityId(entity);
            if (data.ContainsKey(instanceId))
            {
                //ChatMessage(player, HMK.IdAlreadyExists, instanceId);
                return;
            }
            data.Add(instanceId, player.userID);
        }
        #endregion
        #endregion

        #region Commands
        [ChatCommand("h")]
        void cmdHuntShortcut(BasePlayer player, string command, string[] args)
        {
            HandleChatCommand(player, args);
        }

        [ChatCommand("hunt")]
        void cmdHunt(BasePlayer player, string command, string[] args)
        {
            HandleChatCommand(player, args);
        }

        [ChatCommand("hg")]
        void cmdHuntGui(BasePlayer player, string command, string[] args)
        {
            if (Trainer.Length > 0 && !player.IsAdmin) return;
            ProfileGui(player);
        }

        [ConsoleCommand("hunt.cmd")]
        private void cmdCmd(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            GUIInfo guiInfo;
            if (player == null || !GUIInfo.TryGetValue(player.userID, out guiInfo))
                return;
            if (Trainer.Length > 0 && !IsNPCInRange(player.transform.position) && !IsAdmin(arg))
            {
                DestroyUi(player, guiInfo.LastMain);
                return;
            }
            HandleChatCommand(player, arg.Args, true);
            if (Trainer.Length > 0) NpcGui(player, true);
            else ProfileGui(player, true);
        }

        [ConsoleCommand("hunt.saverpg")]
        private void cmdSaveRPG(ConsoleSystem.Arg arg)
        {
            if (!IsAdmin(arg)) return;
            SaveRpg();
        }

        [ConsoleCommand("hunt.resetrpg")]
        private void cmdResetRPG(ConsoleSystem.Arg arg)
        {
            if (!IsAdmin(arg)) return;
            foreach (var rpgInfoPair in Data.Profiles)
                rpgInfoPair.Value.ResetSkills();
            Data.Profiles.Clear();
            Data.Furnaces.Clear();
            Data.Quarries.Clear();
            SaveRpg();
        }

        [ConsoleCommand("hunt.lvlup")]
        private void cmdLevelUp(ConsoleSystem.Arg arg)
        {
            if (!IsAdmin(arg) || !arg.HasArgs()) return;
            var player = arg.Player();
            int desiredLevel;
            if (arg.HasArgs(2))
            {
                player = FindPlayer(arg.GetString(0));
                desiredLevel = arg.GetInt(1);
            }
            else
                desiredLevel = arg.GetInt(0);
            if (player == null)
            {
                arg.ReplyWith(_(HMK.NotFoundPlayer, arg.Player()));
                return;
            }
            var rpgInfo = FindRpgInfo(player);
            if (desiredLevel == 0 || desiredLevel <= rpgInfo.Level) return;
            rpgInfo.LevelUp(desiredLevel);
            NotifyLevelUp(player, rpgInfo);
            arg.ReplyWith(_(HMK.PlayerLevelUp, arg.Player(), player.displayName, desiredLevel));
        }

        [ConsoleCommand("hunt.lvlreset")]
        private void cmdLvlReset(ConsoleSystem.Arg arg)
        {
            if (AdminReset && !IsAdmin(arg)) return;
            var player = arg.Player();
            if (arg.HasArgs() && IsAdmin(arg))
                player = FindPlayer(arg.GetString(0));
            var rpgInfo = player == null ? FindRpgInfo(Convert.ToUInt64(arg.GetString(0))) : FindRpgInfo(player);
            if (rpgInfo == null)
            {
                arg.ReplyWith(_(HMK.NotFoundPlayer, arg.Player()));
                return;
            }
            rpgInfo.Reset();
            if (player != null) UpdateEffectsPlayer(player, rpgInfo);
            arg.ReplyWith(_(HMK.PlayerLevelUp, arg.Player(), player?.displayName, 0));
        }

        [ConsoleCommand("hunt.statreset")]
        private void cmdStatReset(ConsoleSystem.Arg arg)
        {
            if (AdminReset && !IsAdmin(arg)) return;
            var player = arg.Player();
            if (arg.HasArgs() && IsAdmin(arg))
            {
                var target = arg.GetString(0);
                if (target.Equals("*"))
                {
                    foreach (var rpgInfoPair in Data.Profiles)
                    {
                        rpgInfoPair.Value.ResetStats();
                        player = FindPlayer(rpgInfoPair.Key);
                        if (player != null) UpdateEffectsPlayer(player, rpgInfoPair.Value);
                    }
                    SaveRpg();
                    arg.ReplyWith(_(HMK.StatResetPlayer, arg.Player(), "All players"));
                    return;
                }
                player = FindPlayer(target);
            }
            var rpgInfo = player == null ? FindRpgInfo(Convert.ToUInt64(arg.GetString(0))) : FindRpgInfo(player);
            if (rpgInfo == null)
            {
                arg.ReplyWith(_(HMK.NotFoundPlayer, arg.Player()));
                return;
            }
            rpgInfo.ResetStats();
            if (player != null) UpdateEffectsPlayer(player, rpgInfo);
            arg.ReplyWith(player == arg.Player() ? _(HMK.StatReset, arg.Player()) : _(HMK.StatResetPlayer, arg.Player(), player?.displayName));
        }

        [ConsoleCommand("hunt.skillreset")]
        private void cmdSkillReset(ConsoleSystem.Arg arg)
        {
            if (AdminReset && !IsAdmin(arg)) return;
            var player = arg.Player();
            if (arg.HasArgs() && IsAdmin(arg))
            {
                var target = arg.GetString(0);
                if (target.Equals("*"))
                {
                    foreach (var rpgInfoPair in Data.Profiles)
                    {
                        rpgInfoPair.Value.ResetSkills();
                        player = FindPlayer(rpgInfoPair.Key);
                        if (player != null) UpdateGatherPlayer(player, rpgInfoPair.Value);
                    }
                    SaveRpg();
                    arg.ReplyWith(_(HMK.SkillResetPlayer, arg.Player(), "All players"));
                    return;
                }
                player = FindPlayer(target);
            }
            var rpgInfo = player == null ? FindRpgInfo(Convert.ToUInt64(arg.GetString(0))) : FindRpgInfo(player);
            if (rpgInfo == null)
            {
                arg.ReplyWith(_(HMK.NotFoundPlayer, arg.Player()));
                return;
            }
            rpgInfo.ResetSkills();
            if (player != null) UpdateGatherPlayer(player, rpgInfo);
            arg.ReplyWith(player == arg.Player() ? _(HMK.SkillReset, arg.Player()) : _(HMK.SkillResetPlayer, arg.Player(), player?.displayName));
        }

        [ConsoleCommand("hunt.genxptable")]
        private void cmdGenerateXPTable(ConsoleSystem.Arg arg)
        {
            if (!IsAdmin(arg)) return;
            arg.ReplyWith(_(HMK.GenerateXp, arg.Player()));
            var baseXP = arg.HasArgs() ? arg.GetInt(0) : HKD.BaseXp;
            var levelMultiplier = arg.HasArgs(2) ? arg.GetFloat(1) : HKD.LevelMultiplier;
            var levelModule = arg.HasArgs(3) ? arg.GetInt(2) : HKD.LevelModule;
            var moduleReducer = arg.HasArgs(4) ? arg.GetFloat(3) : HKD.ModuleReducer;
            //TODO merge old levels to new?
            var xpTable = HuntTablesGenerator.GenerateXPTable(HKD.MaximumLevel, baseXP, levelMultiplier, levelModule, moduleReducer);
            Config[HK.XPTable] = xpTable;
            RPGInfo.XPTable = xpTable.Values.ToArray();
            SaveConfig();
        }

        private void HandleChatCommand(BasePlayer player, string[] args, bool npc = false)
        {
            if (args.Length == 0)
            {
                ChatMessage(player, HMK.Help);
                return;
            }
            var rpgInfo = FindRpgInfo(player);
            var cmdArg = args[0].ToLower();
            switch (cmdArg)
            {
                case "about":
                    ChatMessage(player, HMK.About);
                    return;
                case "shortcuts":
                    ChatMessage(player, HMK.Shortcuts);
                    return;
                case "p":
                case "profile":
                    ChatMessage(player, Profile(rpgInfo, player));
                    return;
                case "pp":
                case "profilepreferences":
                    ChatMessage(player, HMK.ProfilePreferences);
                    return;
                case "skill":
                    DisplaySkillCommand(player, args);
                    return;
                case "skilllist":
                    ListSkills(player);
                    return;
                case "lvlup":
                    LevelUpChatHandler(player, args, rpgInfo);
                    return;
                case "xp":
                    ChatMessage(player, XPProgression(player, rpgInfo));
                    return;
                case "xp%":
                    ChangePlayerXPMessagePreference(player, args, rpgInfo);
                    return;
                case "craftmsg":
                    ToggleCraftMessage(player, rpgInfo);
                    return;
                case "ba":
                    ToggleBlinkArrow(player, rpgInfo);
                    return;
                case "aba":
                    ToggleAutoBlinkArrow(player, rpgInfo);
                    return;
                case "sp":
                    ToggleShowProfile(player, rpgInfo);
                    return;
                case "sh":
                    ToggleShowHud(player, rpgInfo);
                    return;
                case "top":
                    ShowTop(player);
                    return;
                case "popup":
                    HMK msgType;
                    try
                    {
                        msgType = (HMK)Enum.Parse(typeof(HMK), args[1], true);
                    }
                    catch (System.Exception)
                    {
                        return;
                    }
                    PopupNotifications?.Call("CreatePopupNotification", _(msgType, player), player);
                    return;
            }
            if (Trainer.Length > 0 && !IsNPCInRange(player.transform.position) && !player.IsAdmin)
            {
                ChatMessage(player, HMK.NeedNpc);
                return;
            }
            switch (cmdArg)
            {
                case "lvlreset":
                    if (AdminReset && !player.IsAdmin)
                    {
                        ChatMessage(player, HMK.NotAnAdmin);
                        return;
                    }
                    rpgInfo.Reset();
                    UpdateEffectsPlayer(player, rpgInfo);
                    return;
                case "sts":
                case "statset":
                    SetStatsCommand(player, args, rpgInfo, npc);
                    return;
                case "statreset":
                    if (AdminReset && !player.IsAdmin)
                    {
                        ChatMessage(player, HMK.NotAnAdmin);
                        return;
                    }
                    rpgInfo.ResetStats();
                    UpdateEffectsPlayer(player, rpgInfo);
                    return;
                case "sks":
                case "skillset":
                    SetSkillsCommand(player, args, rpgInfo, npc);
                    return;
                case "skillreset":
                    if (AdminReset && !player.IsAdmin)
                    {
                        ChatMessage(player, HMK.NotAnAdmin);
                        return;
                    }
                    rpgInfo.ResetSkills();
                    UpdateGatherPlayer(player, rpgInfo);
                    return;
                default:
                    ChatMessage(player, HMK.InvalidCommand, args[0]);
                    return;
            }
        }

        private void ListSkills(BasePlayer player)
        {
            var sb = new StringBuilder();
            foreach (var skill in SkillTable.Values)
            {
                if (!skill.Enabled) continue;
                sb.Clear();
                SkillInfo(player, sb, skill, 100);
                ChatMessage(player, sb.ToString());
            }
        }

        private void SkillInfo(BasePlayer player, StringBuilder sb, Skill skill, int cut = 0)
        {
            sb.AppendLine(_(HMK.SkillInfoHeader, player, skill.Name, skill.RequiredLevel));
            for (var i = 0; i < skill.RequiredSkills.Count; i++)
                sb.AppendLine($"Lvl {i + 1}: " + string.Join(" | ", skill.RequiredSkills[i].Select(s => $"{s.Key} Lvl {s.Value}").ToArray()));
            for (var i = 0; i < skill.RequiredStats.Count; i++)
                sb.AppendLine($"Lvl {i + 1}: " + string.Join(" | ", skill.RequiredStats[i].Select(s => $"{s.Key}: {s.Value}").ToArray()));
            var cost = FindRpgInfo(player).GetSkillPointsCostNext(skill);
            if (cost > 1)
                sb.AppendLine(_(HMK.SkillCost, player, cost));

            var description = skill.Description != HMK.None ? _(skill.Description, player) : string.Empty;
            if (cut > 0)
                sb.Append(description.Length > cut ? $"{description.Substring(0, cut)}..." : description);
            else
                sb.Append(description);
            if (cut <= 0 && skill.Usage != HMK.None)
            {
                sb.AppendLine();
                sb.Append(_(HMK.Usage, player, _(skill.Usage, player)));
            }
        }

        private void ShowTop(BasePlayer player)
        {
            var players = Data.Profiles.Values.ToArray();
            Array.Sort(players, (a, b) =>
            {
                if (a.Level != b.Level) return a.Level > b.Level ? -1 : 1;
                if (a.Experience == b.Experience) return 0;
                return a.Experience > b.Experience ? -1 : 1;
            });
            for (var i = 0; i < 10; i++)
                ChatMessage(player, HMK.TopPlayer, i + 1, players[i].SteamName, players[i].Level);
        }

        private void ToggleAutoBlinkArrow(BasePlayer player, RPGInfo rpgInfo)
        {
            rpgInfo.Preferences.AutoToggleBlinkArrow = !rpgInfo.Preferences.AutoToggleBlinkArrow;
            var toggleBlinkArrowStatus = rpgInfo.Preferences.AutoToggleBlinkArrow ? _(HMK.On, player) : _(HMK.Off, player);
            ChatMessage(player, HMK.BlinkToggle, toggleBlinkArrowStatus);
        }

        private void ToggleBlinkArrow(BasePlayer player, RPGInfo rpgInfo)
        {
            rpgInfo.Preferences.UseBlinkArrow = !rpgInfo.Preferences.UseBlinkArrow;
            var blinkArrowStatus = rpgInfo.Preferences.UseBlinkArrow ? _(HMK.On, player) : _(HMK.Off, player);
            ChatMessage(player, HMK.BlinkStatus, blinkArrowStatus);
        }

        private void ToggleCraftMessage(BasePlayer player, RPGInfo rpgInfo)
        {
            rpgInfo.Preferences.ShowCraftMessage = !rpgInfo.Preferences.ShowCraftMessage;
            var craftMessageStatus = rpgInfo.Preferences.ShowCraftMessage ? _(HMK.On, player) : _(HMK.Off, player);
            ChatMessage(player, HMK.CraftMessage, craftMessageStatus);
        }

        private void ToggleShowProfile(BasePlayer player, RPGInfo rpgInfo)
        {
            rpgInfo.Preferences.ShowProfile = !rpgInfo.Preferences.ShowProfile;
            var showProfileStatus = rpgInfo.Preferences.ShowProfile ? _(HMK.On, player) : _(HMK.Off, player);
            ChatMessage(player, HMK.ProfileMessage, showProfileStatus);
        }

        private void ToggleShowHud(BasePlayer player, RPGInfo rpgInfo)
        {
            rpgInfo.Preferences.ShowHud++;
            if (rpgInfo.Preferences.ShowHud > 2)
                rpgInfo.Preferences.ShowHud = 0;
            if (rpgInfo.Preferences.ShowHud > 0)
                UpdateHud(player);
            else
            {
                GUIInfo guiInfo;
                if (GUIInfo.TryGetValue(player.userID, out guiInfo))
                    DestroyUi(player, guiInfo.LastHud);
            }
        }

        private void DisplaySkillCommand(BasePlayer player, string[] args)
        {
            var commandArgs = args?.Length - 1 ?? 0;
            if (commandArgs != 1)
            {
                ChatMessage(player, HMK.InvalidCommand, args[0]);
                return;
            }
            HRK skillType;
            try
            {
                skillType = (HRK)Enum.Parse(typeof(HRK), args[1], true);
            }
            catch (System.Exception)
            {
                ChatMessage(player, HMK.InvalidSkillName);
                return;
            }
            Skill skill;
            if (!SkillTable.TryGetValue(skillType, out skill) || !skill.Enabled)
            {
                ChatMessage(player, HMK.InvalidSkillName);
                return;
            }
            var sb = new StringBuilder();
            SkillInfo(player, sb, skill);
            ChatMessage(player, sb.ToString());
        }

        private void SetSkillsCommand(BasePlayer player, string[] args, RPGInfo rpgInfo, bool npc = false)
        {
            var commandArgs = args?.Length - 1 ?? 0;
            if (args == null || commandArgs < 2 || commandArgs % 2 != 0)
            {
                ChatMessage(player, HMK.InvalidCommand, args[0]);
                return;
            }
            var pairs = commandArgs / 2 + 1;
            for (var i = 1; i < pairs; i++)
            {
                var index = i * 2 - 1;
                HRK skillType;
                try
                {
                    skillType = (HRK)Enum.Parse(typeof(HRK), args[index], true);
                }
                catch
                {
                    ChatMessage(player, HMK.InvalidCommand, args[0]);
                    continue;
                }
                int level;
                if (!int.TryParse(args[index + 1], out level))
                {
                    ChatMessage(player, HMK.InvalidCommand, args[0]);
                    continue;
                }

                Skill skill;
                if (SkillTable.TryGetValue(skillType, out skill))
                {
                    if (!skill.Enabled)
                    {
                        ChatMessage(player, HMK.SkillDisabled);
                        continue;
                    }
                    HMK reason;
                    var levelsAdded = rpgInfo.AddSkill(skill, level, out reason, Pets);
                    if (levelsAdded > 0)
                    {
                        if (!npc) ChatMessage(player, HMK.SkillUp, skill.Name, levelsAdded);
                        switch (skill.Type)
                        {
                            case HRK.Lumberjack:
                            case HRK.Miner:
                            case HRK.Hunter:
                                UpdateGatherPlayer(player, rpgInfo);
                                break;
                        }
                    }
                    else
                    {
                        if (reason == HMK.NotEnoughPoints)
                            ChatMessage(player, reason, rpgInfo.GetSkillPointsCostNext(skill, level));
                        else
                            ChatMessage(player, reason);
                        ChatMessage(player, HMK.SkillInfo);
                    }
                }
                else
                    ChatMessage(player, HMK.InvalidSkillName);
            }
            UpdateHud(player, true);
        }

        private void SetStatsCommand(BasePlayer player, string[] args, RPGInfo rpgInfo, bool npc = false)
        {
            var commandArgs = args?.Length - 1 ?? 0;
            if (commandArgs < 2 || commandArgs % 2 != 0)
            {
                ChatMessage(player, HMK.InvalidCommand, args[0]);
                return;
            }
            var pairs = commandArgs / 2 + 1;
            for (var i = 1; i < pairs; i++)
            {
                var index = i * 2 - 1;
                int points;
                if (!int.TryParse(args[index + 1], out points))
                {
                    ChatMessage(player, HMK.InvalidCommand, args[index + 1]);
                    continue;
                }
                HRK statType;
                try
                {
                    statType = (HRK)Enum.Parse(typeof(HRK), args[index], true);
                }
                catch
                {
                    ChatMessage(player, HMK.InvalidCommand, args[index]);
                    continue;
                }

                switch (statType)
                {
                    case HRK.Agi:
                    case HRK.Int:
                    case HRK.Str:
                        if (rpgInfo.AddStat(statType, points))
                        {
                            if (!npc) ChatMessage(player, (HMK)Enum.Parse(typeof(HMK), statType + "Color", true), $"+{points}");
                        }
                        else
                            ChatMessage(player, HMK.NotEnoughPoints, rpgInfo.GetStatPointsCost(statType, points));
                        break;
                    default:
                        ChatMessage(player, HMK.InvalidCommand, args[index]);
                        break;
                }
            }
            UpdateHud(player, true);
        }

        private void LevelUpChatHandler(BasePlayer player, string[] args, RPGInfo rpgInfo)
        {
            if (!player.IsAdmin) return;
            var commandArgs = args?.Length - 1 ?? 0;
            if (args == null || commandArgs > 2 || commandArgs < 1)
            {
                ChatMessage(player, HMK.InvalidCommand, args[0]);
                return;
            }
            var callerPlayer = player;
            var levelIndex = 1;
            if (commandArgs == 2)
            {
                levelIndex = 2;
                player = FindPlayer(args[1].ToLower());
                if (player == null)
                {
                    ChatMessage(callerPlayer, HMK.NotFoundPlayer);
                    return;
                }
                rpgInfo = FindRpgInfo(player);
            }
            int desiredLevel;
            if (!int.TryParse(args[levelIndex], out desiredLevel))
            {
                ChatMessage(callerPlayer, HMK.InvalidCommand, args[0]);
                return;
            }
            if (desiredLevel <= rpgInfo.Level) return;
            rpgInfo.LevelUp(desiredLevel);
            NotifyLevelUp(player, rpgInfo);
            if (callerPlayer != player)
                ChatMessage(callerPlayer, HMK.PlayerLevelUp, player.displayName, desiredLevel);
        }

        private void ChangePlayerXPMessagePreference(BasePlayer player, string[] args, RPGInfo rpgInfo)
        {
            var commandArgs = args.Length - 1;
            if (commandArgs != 1)
            {
                ChatMessage(player, HMK.InvalidCommand, args[0]);
                return;
            }
            float xpPercent;
            if (!float.TryParse(args[1], out xpPercent))
            {
                ChatMessage(player, HMK.InvalidCommand, args[0]);
                return;
            }
            rpgInfo.Preferences.ShowXPMessagePercent = xpPercent / 100;
            ChatMessage(player, HMK.XpMessage, rpgInfo.Preferences.ShowXPMessagePercent);
        }

        private bool IsAdmin(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Player().IsAdmin) return true;
            arg.ReplyWith(_(HMK.NotAnAdmin, arg.Player()));
            return false;
        }
        #endregion

        #region Config
        protected override void LoadDefaultConfig() => DefaultConfig();

        private void DefaultConfig()
        {
            //Config.Clear();
            //this will only be called if there is not a config file, or it needs updating
            Config[HK.ConfigVersion] = Version;
            Config[HK.DataVersion] = DataVersion;
            Config[HK.AdminReset] = GetConfig(HK.AdminReset, false);
            Config[HK.MaximumLevel] = GetConfig(HK.MaximumLevel, 200);
            Config[HK.ShowHud] = GetConfig(HK.ShowHud, true);
            Config[HK.ShowProfile] = GetConfig(HK.ShowProfile, false);
            Config[HK.DefaultHud] = GetConfig(HK.DefaultHud, 1);
            Config[HK.NightXP] = GetConfig(HK.NightXP, 2);
            Config[HK.EcoBoost] = GetConfig(HK.EcoBoost, 1);
            Config[HK.DeleteProfileAfterOfflineDays] = GetConfig(HK.DeleteProfileAfterOfflineDays, 0);
            Config[HK.Trainer] = GetConfig(HK.Trainer, new ulong[0]);
            Config[HK.DeathReducerK] = GetConfig(HK.DeathReducerK, HKD.DeathReducer);
            Config[HK.Defaults] = HuntTablesGenerator.GenerateDefaults();
            Config[HK.XPTable] = HuntTablesGenerator.GenerateXPTable(HKD.MaximumLevel, HKD.BaseXp, HKD.LevelMultiplier, HKD.LevelModule, HKD.ModuleReducer).OrderBy(e => e.Key).ToDictionary(e => e.Key, e => e.Value);
            Config[HK.ExpRateTable] = HuntTablesGenerator.GenerateExpRateTable();
            Config[HK.MaxStatsTable] = HuntTablesGenerator.GenerateMaxStatsTable();
            Config[HK.SkillTable] = HuntTablesGenerator.GenerateSkillTable();
            Config[HK.ResearchSkillTable] = HuntTablesGenerator.GenerateResearchTable();
            Config[HK.UpgradeBuildTable] = HuntTablesGenerator.GenerateUpgradeBuildingTable();
            Config[HK.ChatPrefix] = GetConfig(HK.ChatPrefix, "<color=#ADD8E6>Hunt</color>: {0}");
            Config[HK.TameTable] = HuntTablesGenerator.GenerateTameTable();
            Config[HK.AllowedEntities] = HuntTablesGenerator.GenerateAllowedEntites();
            SaveConfig();
        }

        private void DefaultItems()
        {
            Config[HK.ItemTable] = HuntTablesGenerator.GenerateItemTable();
            SaveConfig();
        }

        private void UpdateLang()
        {
            var messagesConfig = new Dictionary<HMK, string>
            {
                {
                    HMK.Help, string.Join("\n", new[]
                    {
                        "To get an overview about the Hunt RPG, type \"/hunt about\"",
                        "To see you available shortcuts commdands, type \"/hunt shortcuts\"",
                        "To see you player profile, type \"/hunt profile\"",
                        "To see you current xp, type \"/hunt xp\"",
                        "To see how to change you profile preferences, type \"/hunt profilepreferences\"",
                        "To use an easy to use GUI to spend point type \"/hg\""
                    })
                },
                {
                    HMK.Shortcuts, string.Join("\n", new[]
                    {
                        "\"/hunt\" = \"/h\"",
                        "\"/hunt profile\" = \"/h p\"",
                        "\"/hunt profilepreferences\" = \"/h pp\"",
                        "\"/hunt statset\" = \"/h sts\".",
                        "You can set multiple stats at a time like this \"/h sts agi 30 str 45\".",
                        "\"/hunt skillset\" = \"/h sks\"",
                        "You can set multiple skillpoints at a time like this \"/h sks lumberjack 3 miner 2\".",
                    })
                },
                {
                    HMK.ProfilePreferences, string.Join("\n", new[]
                    {
                        "To see change the % changed need to show the xp message, type \"/hunt xp% <percentnumber>\"",
                        "To toggle crafting message type \"/hunt craftmsg\"",
                        "To toggle blink arrow skill type \"/hunt ba\"",
                        "To toggle blink arrow skill auto toggle type \"/hunt aba\"",
                        "To toggle auto show profile \"/hunt sp\""
                    })
                },
                {
                    HMK.About, string.Join("\n", new[]
                    {
                        "=================================================",
                        "The Hunt RPG system in development.",
                        "Currently maintained by Default.",
                        "It is consisted of levels, stats atributes, skills and later on specializations.",
                        "Currently there are 3 attributes, each of then give you and specific enhancement.",
                        "Strength reduces the damage you take, and allows for more ammo in magazines.",
                        "Agillity gives you dodge chance",
                        "Intelligence decreases your items crafting time",
                        "Right now you can level up by gathering resources.",
                        "Each level gives you 1 point in each attribute. And 3 more to distribute.",
                        "Each level gives you 1 skill point to distribute",
                        "Each skill have its required level, and later on it will require specific stats.",
                        "To see the all the available skills and its description type \"/hunt skilllist\"",
                        "To learn more about Hunt RPG go to the plugin page at <link>",
                        "================================================="
                    })
                },
                {
                    HMK.DataUpdated, string.Join("\n", new[]
                    {
                        "<color=#FFFF00>Plugin was updated to new version!</color>",
                        "<color=#FFA500>Your profile needed to be reset, but your level was saved. You just need to redistribute.</color>",
                        "<color=#FF0000>Furnaces were not saved though, so build new ones for the blacksmith skill to be applied (If you have, or when you get it)!</color>"
                    })
                },
                {HMK.InvalidCommand, "You ran the \"{0}\" command incorrectly. Type \"/hunt\" to get help"},
                {HMK.SkillInfo, "Type \"/hunt skill <skillname>\" to see the skill info"},
                {HMK.NotEnoughPoints, "<color=#FFA500>You don't have enought points to set! Cost: {0}</color>"},
                {HMK.NotEnoughLevels, "<color=#FFA500>You dont have the minimum level to learn this skill!</color>"},
                {HMK.NotEnoughStrength, "<color=#FFA500>You dont have enough strength to learn this skill!</color>"},
                {HMK.NotEnoughAgility, "<color=#FFA500>You dont have enough agility to learn this skill!</color>"},
                {HMK.NotEnoughIntelligence, "<color=#FFA500>You dont have enough intelligence to learn this skill!</color>"},
                {HMK.NotEnoughSkill, "<color=#FFA500>You dont have the required skill to learn this skill!</color>"},
                {HMK.InvalidSkillName, "<color=#FFA500>There is no such skill! Type \"/hunt skilllist\" to see the available skills</color>"},
                {HMK.SkillDisabled, "<color=#FFA500>This skill is blocked in this server.</color>"},
                {HMK.NotFoundItem, "<color=#FFA500>Item {0} not found.</color>"},
                {HMK.ResearchBlocked, "<color=#FFA500>Item {0} research is blocked by in this server.</color>"},
                {HMK.NotLearnedSkill, "<color=#FFA500>You havent learned this skill yet.</color>"},
                {HMK.AlreadyAtMaxLevel, "<color=#FFA500>You have mastered this skill already!</color>"},
                {HMK.IdAlreadyExists, "<color=#FFFF00>Entity id already exists for {0}!</color>"},
                {HMK.PetsPlugin, "Pets plugin was not found, disabling taming skill"},
                {HMK.BuildingOwnersPlugin, "Building Owners plugin was not found, disabling blink to arrow skill"},
                {HMK.Died, "Oh no man! You just died! You lost {0:P} of XP because of this..."},
                {HMK.CantBlink, "Can't blink there!"},
                {HMK.CantBlinkOther, "Can't blink to other player house!"},
                {HMK.BlinkedRecently, "Blinked recently! You might get dizzy, give it a rest. Time left to blink again: {0}"},
                {HMK.BlinkToggle, "Auto Toggle Blink Arrow is now: {0}"},
                {HMK.BlinkStatus, "Blink Arrow is now: {0}"},
                {HMK.CraftingEnd, "Crafting will end in {0:F} seconds. Reduced in {1:F} seconds"},
                {HMK.CraftMessage, "Craft message is now: {0}"},
                {HMK.NotFoundPlayer, "Player not found."},
                {HMK.NotAnAdmin, "You are not an admin."},
                {HMK.On, "On"},
                {HMK.Off, "Off"},
                {HMK.XpMessage, "XP will be shown at every {0:P} change"},
                {HMK.AvailableSkills, "Available Skills:"},
                {HMK.Dodged, "You <color=#FFOOOO>dodged</color> an attack!"},
                {HMK.TargetDodged, "Your target <color=#FFOOOO>Dodged</color>"},
                {HMK.LevelUp, "<color=#FFFF00>Level Up! You are now level {0}</color>"},
                {HMK.CurrentXp, "Current XP: {0:P}{1}"},
                {HMK.NightXp, " Bonus Night Exp On"},
                {HMK.Level, "Level: {0}"},
                {HMK.LevelShort, "Lvl: {0}"},
                {HMK.DamageBlock, "Damage Block: {0:P}"},
                {HMK.EvasionChance, "Evasion Chance: {0:P}"},
                {HMK.CraftingReducer, "Crafting Reducer: {0:P}"},
                {HMK.StatPoints, "Stat points: {0}"},
                {HMK.SkillPoints, "Skill points: {0}"},
                {HMK.ResearchItem, "In order to research an item you must have it on your inventory"},
                {HMK.ResearchType, "You can't research items of this type"},
                {HMK.ResearchSkill, "Your research skills are not high enough. Required {0}"},
                {HMK.ResearchSuccess, "You managed to reverse enginier the {0}. The blueprint its on your inventory"},
                {HMK.ResearchFail, "OPS! While you were trying to research the {0} you accidently broke it."},
                {HMK.ResearchReuse, "You have tried this moments ago, give it a rest. Time left to research again: {0}"},
                {HMK.PlayerLevelUp, "Player {0} lvlup to {1}"},
                {HMK.AgiColor, "<color=#008000>Agi: {0}</color>"},
                {HMK.StrColor, "<color=#FF0000>Str: {0}</color>"},
                {HMK.IntColor, "<color=#0000FF>Int: {0}</color>"},
                {HMK.Agi, "Agi: {0}"},
                {HMK.Str, "Str: {0}"},
                {HMK.Int, "Int: {0}"},
                {HMK.StatReset, "You reset your stats."},
                {HMK.StatResetPlayer, "{0} stats reset."},
                {HMK.SkillReset, "You reset your skills."},
                {HMK.SkillResetPlayer, "{0} skills reset."},
                {HMK.ProfileMessage, "Auto show profile is now: {0}"},
                {HMK.NeedNpc, "You cannot teach yourself. Go to the next trainer!"},
                {HMK.GenerateXp, "Generating XP table..."},
                {HMK.SkillsHeader, "========<color=#800080>Skills</color>========"},
                {HMK.ProfileHeader, "========{0}========"},
                {
                    HMK.Loaded, string.Join("\n", new[]
                    {
                        "<color=#ADD8E6>Hunt</color>: RPG Loaded!",
                        "<color=#ADD8E6>Hunt</color>: To see the Hunt RPG help type \"/hunt\" or \"/h\"",
                        "<color=#ADD8E6>Hunt</color>: To open the GUI type \"/hg\""
                    })
                },
                {HMK.StatusLoad, "{0} profiles, {1} furnaces, {2} quarries loaded"},
                {HMK.StatusSave, "{0} profiles, {1} furnaces, {2} quarries saved"},
                {HMK.TopPlayer, "{0}. {1} Lvl {2}"},
                {HMK.SkillUp, "<color=#800080>{0}: +{1}</color>"},
                {HMK.SkillCost, "Each skill level costs {0} skillpoints."},
                {HMK.SkillInfoHeader, "<color=#ADD8E6>{0}</color> - Required: Lvl: {1}"},
                {HMK.Usage, "<color=#008080>Usage:</color> {0}"},
                {HMK.LumberjackDesc, "This skill allows you to gather wood faster. Each point gives you more wood per hit."},
                {HMK.MinerDesc, "This skill allows you to gather stones faster. Each point gives you more stones per hit."},
                {HMK.HunterDesc, "This skill allows you to gather resources faster from animals. Each point gives you more resources per hit."},
                {HMK.GathererDesc, "This skill allows you to gather more resources from pickup. Each point gives you more resources."},
                {HMK.ResearcherDesc, "This skill allows you to research items you have. Each level enables a type of type to be researched and decreases 2 minutes of cooldown. Table: Level 1 - Tools (10 min); Level 2 - Clothes (8 min); Level 3 - Construction and Resources (6 min); Level 4 - Ammunition and Medic (4 min); Level 5 - Weapons (2 min)"},
                {HMK.BlacksmithDesc, "This skill allows your furnaces to melt more resources each time. Each level gives increase the productivity by 1."},
                {HMK.BlinkarrowDesc, "This skill allows you to blink to your arrow destination from time to time. Each level deacreases the cooldown in 2 minutes."},
                {HMK.TamerDesc, "This skill allows you to tame a animal as your pet. Level 1 allows chicken, level 2 allows boar, level 3 allows stag, level 4 allows wolf, level 5 allows bear, level 6 allows horse."},
                {HMK.BlinkarrowUsage, "Just shoot an Arrow at desired blink location. To toogle this skill type \"/h ba\" . To change the auto toggle for this skill type \"/h aba\""},
                {HMK.ResearcherUsage, "To research an item type \"/research \"Item Name\"\". In order to research an item, you must have it on your invetory, and have the required skill level for that item tier."},
                {HMK.TamerUsage, "Type \"/pet\" to toggle taming. To tame get close to the animal and press your USE button(E). After tamed press USE looking at something, if its terrain he will move, if its a player or other animal it he will attack. If looking at him it will start following you. To set the pet free type \"/pet free\"."},
                {HMK.ButtonClose, "Close"},
                {HMK.ButtonResetSkills, "Reset Skills"},
                {HMK.ButtonResetStats, "Reset Stats"},
                {HMK.AgiDesc, "Agillity gives you the chance to <colour=#FF0000>dodge</color> an attack!"},
                {HMK.StrDesc, "Strength gives you the ability to hold more ammunition in guns. More on the way!"},
                {HMK.IntDesc, "Intelligence decreases your items crafting time"}
            };
            lang.RegisterMessages(messagesConfig.ToDictionary(m => m.Key.ToString(), m => m.Value), this);
        }

        private void UpdateData()
        {
            if (!updatePlayerData) return;
            // this will only be called if this version requires a data wipe and the config is outdated.
            Puts("This version needs a wipe to data file.");
            Puts("Dont worry levels will be kept! =]");
            var keys = Data.Profiles.Keys.ToArray();
            foreach (var key in keys)
            {
                var value = Data.Profiles[key];
                var displayName = FindPlayer(key)?.displayName ?? value.SteamName;
                var rpgInfo = new RPGInfo(displayName, DefaultHud, ShowProfile);
                rpgInfo.LevelUp(value.Level);
                Data.Profiles[key] = rpgInfo;
            }
            Puts("Data file updated.");
            Config[HK.DataVersion] = DataVersion;
            SaveConfig();
            SaveRpg();
            updatePlayerData = false;
        }

        private void LoadRpg(VersionNumber dataVersion)
        {
            RPGInfo.Perm = permission;
            var defaults = ReadFromConfig<HuntDefaults>(HK.Defaults);
            RPGInfo.XPTable = ReadFromConfig<Dictionary<int, long>>(HK.XPTable).OrderBy(e => e.Key).ToDictionary(e => e.Key, e => e.Value).Values.ToArray();
            RPGInfo.MaxLevel = defaults.MaximumLevel;
            RPGInfo.MaxStatsTable = ReadFromConfig<Dictionary<HRK, HuntRPGExt.Modifier>>(HK.MaxStatsTable);
            RPGInfo.SkillPointsGain = defaults.SkillPointsGain;
            RPGInfo.SkillPointsPerLevel = defaults.SkillPointsPerLevel;
            RPGInfo.StatPointsGain = defaults.StatPointsGain;
            RPGInfo.StatPointsPerLevel = defaults.StatPointsPerLevel;
            RPGInfo.TameTable = ReadFromConfig<Dictionary<int, string>>(HK.TameTable);
            var newStructure = dataVersion < new VersionNumber(0, 9, 3);
            if (newStructure)
                huntDataFile.Settings.ContractResolver = new IgnoreJsonPropertyResolver();
            Data = huntDataFile.ReadObject<HuntData>();
            if (newStructure)
                huntDataFile.Settings.ContractResolver = new DefaultContractResolver();
            ChatPrefix = ReadFromConfig<string>(HK.ChatPrefix);
            ExpRateTable = ReadFromConfig<Dictionary<ResourceDispenser.GatherType, float>>(HK.ExpRateTable);
            SkillTable = ReadFromConfig<Dictionary<HRK, Skill>>(HK.SkillTable);
            ItemTable = ReadFromConfig<Dictionary<string, ItemInfo>>(HK.ItemTable);
            ResearchTable = ReadFromConfig<Dictionary<string, int>>(HK.ResearchSkillTable);
            UpgradeBuildingTable = ReadFromConfig<Dictionary<BuildingGrade.Enum, float>>(HK.UpgradeBuildTable);
            AllowedEntites = ReadFromConfig<string[]>(HK.AllowedEntities);
            AdminReset = ReadFromConfig<bool>(HK.AdminReset);
            ShowHud = ReadFromConfig<bool>(HK.ShowHud);
            ShowProfile = ReadFromConfig<bool>(HK.ShowProfile);
            DefaultHud = ReadFromConfig<uint>(HK.DefaultHud);
            NightXP = ReadFromConfig<float>(HK.NightXP);
            EcoBoost = ReadFromConfig<double>(HK.EcoBoost);
            DeleteProfileAfter = ReadFromConfig<int>(HK.DeleteProfileAfterOfflineDays);
            Trainer = ReadFromConfig<ulong[]>(HK.Trainer);
            DeathReducer = ReadFromConfig<float>(HK.DeathReducerK);
            itemShortname = new Dictionary<string, string>();
            foreach (var item in ItemManager.itemList)
            {
                var itemDisplayName = item.displayName.translated.ToLower();
                if (!itemShortname.ContainsKey(itemDisplayName))
                {
                    itemShortname.Add(itemDisplayName, item.shortname);
                }
            }

            Puts(_(HMK.StatusLoad, Data.Profiles.Count, Data.Furnaces.Count, Data.Quarries.Count));

            if (Pets == null)
            {
                Puts(_(HMK.PetsPlugin));
                SkillTable[HRK.Tamer].Enabled = false;
            }
            SkillTable[HRK.Researcher].Enabled = false;
            if (DeleteProfileAfter <= 0) return;
            var now = Facepunch.Math.Epoch.Current;
            var delTime = now - 86400 * DeleteProfileAfter;
            var toRemove = new List<ulong>();
            foreach (var profile in Data.Profiles)
            {
                if (profile.Value.LastSeen == 0)
                {
                    profile.Value.LastSeen = now;
                    continue;
                }
                if (profile.Value.LastSeen < delTime)
                {
                    toRemove.Add(profile.Key);
                    var data = Data.Furnaces.Where(pair => pair.Value == profile.Key).Select(pair => pair.Key).ToArray();
                    foreach (var key in data)
                        Data.Furnaces.Remove(key);
                    data = Data.Quarries.Where(pair => pair.Value == profile.Key).Select(pair => pair.Key).ToArray();
                    foreach (var key in data)
                        Data.Quarries.Remove(key);
                }
            }
            foreach (var userId in toRemove)
                Data.Profiles.Remove(userId);
        }

        private T ReadFromConfig<T>(string configKey)
        {
            return JsonConvert.DeserializeObject<T>(JsonConvert.SerializeObject(Config[configKey]));
        }

        private object GetConfig(string key, object defaultValue)
        {
            var value = Config[key];
            if (value == null)
                Config[key] = value = defaultValue;
            return value;
        }

        private void SaveRpg(bool showMsgs = true)
        {
            if (Data == null) return;
            //if (showMsgs)
            //    Puts("Data being saved...");
            huntDataFile.WriteObject(Data);
            if (!showMsgs) return;
            Puts(_(HMK.StatusSave, Data.Profiles.Count, Data.Furnaces.Count, Data.Quarries.Count));
        }
        #endregion

        #region CUI
        private void GuiInit(BasePlayer player)
        {
            if (player == null) return;

            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
                timer.Once(1, () => GuiInit(player));
            else
                UpdateHud(player);
        }

        private static CuiLabel CreateLabel(string text, int i, float rowHeight, TextAnchor align = TextAnchor.MiddleLeft, int fontSize = 15, string xMin = "0", string xMax = "1", string color = "1.0 1.0 1.0 1.0")
        {
            return new CuiLabel
            {
                Text =
                {
                    Text = text,
                    FontSize = fontSize,
                    Align = align,
                    Color = color
                },
                RectTransform =
                {
                    AnchorMin = $"{xMin} {1 - rowHeight*i + i * .002f}",
                    AnchorMax = $"{xMax} {1 - rowHeight*(i-1) + i * .002f}"
                }
            };
        }

        private static CuiButton CreateButton(string command, int i, float rowHeight, int fontSize = 15, string content = "+", string xMin = "0", string xMax = "1")
        {
            return new CuiButton
            {
                Button =
                {
                    Command = command,
                    Color = "0.8 0.8 0.8 0.2"
                },
                RectTransform =
                {
                    AnchorMin = $"{xMin} {1 - rowHeight*i + i * .002f}",
                    AnchorMax = $"{xMax} {1 - rowHeight*(i-1) + i * .002f}"
                },
                Text =
                {
                    Text = content,
                    FontSize = fontSize,
                    Align = TextAnchor.MiddleCenter
                }
            };
        }

        private static CuiPanel CreatePanel(string anchorMin, string anchorMax, string color = "0 0 0 0")
        {
            return new CuiPanel
            {
                Image =
                {
                    Color = color
                },
                RectTransform =
                {
                    AnchorMin = anchorMin,
                    AnchorMax = anchorMax
                }
            };
        }

        private void NpcGui(BasePlayer player, bool repaint = false)
        {
            if (player == null) return;
            var rpgInfo = FindRpgInfo(player);
            GUIInfo guiInfo;
            if (!GUIInfo.TryGetValue(player.userID, out guiInfo))
                GUIInfo[player.userID] = guiInfo = new GUIInfo();
            else
            {
                DestroyUi(player, guiInfo.LastInfo);
                DestroyUi(player, guiInfo.LastStats);
                DestroyUi(player, guiInfo.LastSkills);
            }

            const float height = 1 / (6f * 1.5f);
            var heightS = 1f / (Math.Min(6, SkillTable.Count(skill => skill.Value.Enabled)) * 1.75f);
            var elements = new CuiElementContainer();
            if (!repaint || string.IsNullOrEmpty(guiInfo.LastMain))
            {
                guiInfo.LastMain = elements.Add(new CuiPanel
                {
                    Image =
                    {
                        Color = "0.1 0.1 0.1 0.8"
                    },
                    RectTransform =
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    },
                    CursorEnabled = true
                });
                elements.Add(new CuiButton
                {
                    Button =
                {
                    Close = guiInfo.LastMain,
                    Color = "0.8 0.8 0.8 0.2"
                },
                    RectTransform =
                {
                    AnchorMin = "0.45 0.92",
                    AnchorMax = "0.55 0.98"
                },
                    Text =
                {
                    Text = _(HMK.ButtonClose, player),
                    FontSize = 20,
                    Align = TextAnchor.MiddleCenter
                }
                }, guiInfo.LastMain);
                elements.Add(CreateLabel(rpgInfo.SteamName, 3, .06f, TextAnchor.MiddleCenter, 30, "0.3", "0.7"), guiInfo.LastMain);
                var statsButtons = elements.Add(CreatePanel("0.4 0.1", "0.45 0.5"), guiInfo.LastMain);
                elements.Add(CreateButton("hunt.cmd statset agi 1", 3, heightS, 18), statsButtons);
                //elements.Add(CreateButton("hunt.cmd statset agi 10", 4, heightS, 18), statsButtons);
                elements.Add(CreateButton("hunt.cmd statset str 1", 4, heightS, 18), statsButtons);
                elements.Add(CreateButton("hunt.cmd statset int 1", 5, heightS, 18), statsButtons);
                var skillsButtons = elements.Add(CreatePanel("0.8 0.1", "0.85 0.5"), guiInfo.LastMain);
                var i = 3;
                foreach (var skill in SkillTable.Where(skill => skill.Value.Enabled))
                {
                    int level;
                    rpgInfo.Skills.TryGetValue(skill.Key, out level);
                    elements.Add(CreateButton($"hunt.cmd skillset {skill.Key} 1", i++, heightS, 18), skillsButtons);
                }
                if (!AdminReset || player.IsAdmin)
                {
                    elements.Add(CreateButton("hunt.cmd statreset", 25, .04f, 18, _(HMK.ButtonResetStats, player), "0.2", "0.45"), guiInfo.LastMain);
                    elements.Add(CreateButton("hunt.cmd skillreset", 25, .04f, 18, _(HMK.ButtonResetSkills, player), "0.6", "0.85"), guiInfo.LastMain);
                }
            }

            var info = guiInfo.LastInfo = elements.Add(CreatePanel("0.3 0.5", "0.7 0.8"), guiInfo.LastMain);
            elements.Add(CreateLabel(_(HMK.Level, player, rpgInfo.Level), 1, height, TextAnchor.MiddleCenter, 20), info);
            elements.Add(CreateLabel(XPProgression(player, rpgInfo), 2, height, TextAnchor.MiddleCenter, 20), info);
            elements.Add(CreateLabel(_(HMK.DamageBlock, player, rpgInfo.GetBlock()), 4, height, TextAnchor.MiddleCenter, 20), info);
            elements.Add(CreateLabel(_(HMK.EvasionChance, player, rpgInfo.GetEvasion()), 5, height, TextAnchor.MiddleCenter, 20), info);
            elements.Add(CreateLabel(_(HMK.CraftingReducer, player, rpgInfo.GetCraftingReducer()), 6, height, TextAnchor.MiddleCenter, 20), info);

            var stats = guiInfo.LastStats = elements.Add(CreatePanel("0.2 0.1", "0.39 0.5"), guiInfo.LastMain);
            elements.Add(CreateLabel(_(HMK.StatPoints, player, rpgInfo.StatsPoints), 1, heightS, TextAnchor.MiddleLeft, 20), stats);
            //elements.Add(CreateLabel(_(HMK.Agi, player, $"{rpgInfo.Agility} ({rpgInfo.GetStatPointsCost(HRK.Agi)})"), 3, heightS, TextAnchor.MiddleLeft, 18), stats);
            elements.Add(CreateButton($"hunt.cmd popup {HMK.AgiDesc}", 3, heightS, 18, _(HMK.Agi, player, $"{rpgInfo.Agility} ({rpgInfo.GetStatPointsCost(HRK.Agi)})")), stats);
            elements.Add(CreateButton($"hunt.cmd popup {HMK.StrDesc}", 4, heightS, 18, _(HMK.Str, player, $"{rpgInfo.Strength} ({rpgInfo.GetStatPointsCost(HRK.Str)})")), stats);
            elements.Add(CreateButton($"hunt.cmd popup {HMK.IntDesc}", 5, heightS, 18, _(HMK.Int, player, $"{rpgInfo.Intelligence} ({rpgInfo.GetStatPointsCost(HRK.Int)})")), stats);

            var skills = guiInfo.LastSkills = elements.Add(CreatePanel("0.6 0.1", "0.79 0.5"), guiInfo.LastMain);
            elements.Add(CreateLabel(_(HMK.SkillPoints, player, rpgInfo.SkillPoints), 1, heightS, TextAnchor.MiddleLeft, 20), skills);
            var j = 3;
            foreach (var skill in SkillTable.Where(skill => skill.Value.Enabled))
            {
                int level;
                rpgInfo.Skills.TryGetValue(skill.Key, out level);
                //elements.Add(CreateLabel($"{skill.Value.Name}: {level}/{skill.Value.MaxLevel} ({rpgInfo.GetSkillPointsCostNext(skill.Value)})", j++, heightS, TextAnchor.MiddleLeft, 18), skills);
                elements.Add(CreateButton($"hunt.cmd popup {skill.Value.Description}", j++, heightS, 18, $"{skill.Value.Name}: {level}/{skill.Value.MaxLevel} ({rpgInfo.GetSkillPointsCostNext(skill.Value)})"), skills);
            }
            CuiHelper.AddUi(player, elements);
        }

        private void ProfileGui(BasePlayer player, bool repaint = false)
        {
            if (player == null) return;
            var rpgInfo = FindRpgInfo(player);
            GUIInfo guiInfo;
            if (!GUIInfo.TryGetValue(player.userID, out guiInfo))
                GUIInfo[player.userID] = guiInfo = new GUIInfo();
            else
                DestroyUi(player, guiInfo.LastContent);

            var skills = SkillTable.Where(skill => skill.Value.Enabled).ToArray();
            var height = 1f / (9.5f + skills.Length) - .002f;

            var elements = new CuiElementContainer();
            if (!repaint || string.IsNullOrEmpty(guiInfo.LastMain))
            {
                guiInfo.LastMain = elements.Add(new CuiPanel
                {
                    Image =
                    {
                        Color = "0.1 0.1 0.1 0.8"
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.8 0.25",
                        AnchorMax = "0.995 0.845"
                    },
                    CursorEnabled = true
                });
                elements.Add(new CuiButton
                {
                    Button =
                {
                    Close = guiInfo.LastMain,
                    Color = "0.8 0.8 0.8 0.2"
                },
                    RectTransform =
                {
                    AnchorMin = "0.86 0.93",
                    AnchorMax = "0.97 0.99"
                },
                    Text =
                {
                    Text = "X",
                    FontSize = 20,
                    Align = TextAnchor.MiddleCenter
                }
                }, guiInfo.LastMain);
                elements.Add(CreateLabel(rpgInfo.SteamName, 1, height, TextAnchor.MiddleLeft, 18, "0.06", "0.85"), guiInfo.LastMain);
                var buttonsName = elements.Add(CreatePanel("0.86 0", "0.97 0.925"), guiInfo.LastMain);
                elements.Add(CreateButton("hunt.cmd statset agi 1", 6, height), buttonsName);
                elements.Add(CreateButton("hunt.cmd statset str 1", 7, height), buttonsName);
                elements.Add(CreateButton("hunt.cmd statset int 1", 8, height), buttonsName);
                var i = 9;
                foreach (var skill in skills)
                {
                    int level;
                    rpgInfo.Skills.TryGetValue(skill.Key, out level);
                    elements.Add(CreateButton($"hunt.cmd skillset {skill.Key} 1", i++, height), buttonsName);
                }
                if (!AdminReset || player.IsAdmin)
                {
                    elements.Add(CreateButton("hunt.cmd statreset", i++, height, 15, "R"), buttonsName);
                    elements.Add(CreateButton("hunt.cmd skillreset", i, height, 15, "R"), buttonsName);
                }
            }
            var contentName = guiInfo.LastContent = elements.Add(CreatePanel("0.06 0", "0.85 0.925"), guiInfo.LastMain);
            elements.Add(CreateLabel(_(HMK.Level, player, rpgInfo.Level), 1, height), contentName);
            elements.Add(CreateLabel(_(HMK.DamageBlock, player, rpgInfo.GetBlock()), 2, height), contentName);
            elements.Add(CreateLabel(_(HMK.EvasionChance, player, rpgInfo.GetEvasion()), 3, height), contentName);
            elements.Add(CreateLabel(_(HMK.CraftingReducer, player, rpgInfo.GetCraftingReducer()), 4, height), contentName);
            elements.Add(CreateLabel(XPProgression(player, rpgInfo), 5, height), contentName);
            elements.Add(CreateLabel(_(HMK.Agi, player, $"{rpgInfo.Agility} ({rpgInfo.GetStatPointsCost(HRK.Agi)})"), 6, height), contentName);
            elements.Add(CreateLabel(_(HMK.Str, player, $"{rpgInfo.Strength} ({rpgInfo.GetStatPointsCost(HRK.Str)})"), 7, height), contentName);
            elements.Add(CreateLabel(_(HMK.Int, player, $"{rpgInfo.Intelligence} ({rpgInfo.GetStatPointsCost(HRK.Int)})"), 8, height), contentName);
            var j = 9;
            foreach (var skill in skills)
            {
                int level;
                rpgInfo.Skills.TryGetValue(skill.Key, out level);
                elements.Add(CreateLabel($"{skill.Value.Name}: {level}/{skill.Value.MaxLevel} ({rpgInfo.GetSkillPointsCostNext(skill.Value)})", j++, height), contentName);
            }
            elements.Add(CreateLabel(_(HMK.StatPoints, player, rpgInfo.StatsPoints), j++, height), contentName);
            elements.Add(CreateLabel(_(HMK.SkillPoints, player, rpgInfo.SkillPoints), j, height), contentName);
            CuiHelper.AddUi(player, elements);
        }

        private void UpdateHud(BasePlayer player, bool repaint = false, bool points = true)
        {
            if (player == null || !ShowHud) return;
            var rpgInfo = FindRpgInfo(player);
            if (rpgInfo == null || rpgInfo.Preferences.ShowHud == 0) return;
            GUIInfo guiInfo;
            if (!GUIInfo.TryGetValue(player.userID, out guiInfo))
                GUIInfo[player.userID] = guiInfo = new GUIInfo();
            else
            {
                if (guiInfo.LastHudTime > Interface.Oxide.Now)
                {
                    if (guiInfo.LastHudTimer == null) guiInfo.LastHudTimer = timer.Once(1, () => UpdateHud(player, repaint, points));
                    return;
                }
                guiInfo.LastHudTimer?.Destroy();
                guiInfo.LastHudTimer = null;
                guiInfo.LastHudTime = Interface.Oxide.Now + 1;
            }

            var elements = new CuiElementContainer();
            if (!repaint || string.IsNullOrEmpty(guiInfo.LastHud))
            {
                DestroyUi(player, guiInfo.LastHud);
                //elements.Add(CreateLabel($"{_(HMK.Level, player, rpgInfo.Level)}/{XPTable.Length}", 2, 1 / 3f), guiInfo.LastHud);
                //AnchorMin = "0.822 0.045",
                //AnchorMax = "0.9734 0.117"
                if (rpgInfo.Preferences.ShowHud == 1)
                    guiInfo.LastHud = elements.Add(CreatePanel("0.0266 0.045", "0.178 0.117"));
                else
                    guiInfo.LastHud = elements.Add(CreatePanel("0 0", "1 0.03"));
            }

            if (points) DestroyUi(player, guiInfo.LastHudFirst);
            DestroyUi(player, guiInfo.LastHudSecond);

            //TODO Rework entire UI

            if (rpgInfo.Preferences.ShowHud == 1)
            {
                if (points)
                {
                    guiInfo.LastHudFirst = elements.Add(CreatePanel("4.15 0.71", "5.15 1", "0.16 0.16 0.16 0.8"), guiInfo.LastHud);
                    elements.Add(CreateLabel($"{_(HMK.StatPoints, player, rpgInfo.StatsPoints)} {_(HMK.SkillPoints, player, rpgInfo.SkillPoints)}", 1, 1, TextAnchor.MiddleCenter, 15, "0", "1", "1.0 1.0 1.0 0.3"), guiInfo.LastHudFirst);
                }
                guiInfo.LastHudSecond = elements.Add(CreatePanel("4.15 0.21", "5.15 0.70", "0.16 0.16 0.16 0.8"), guiInfo.LastHud);
                elements.Add(CreateLabel($"{rpgInfo.Level}", 1, 1, TextAnchor.MiddleCenter, 15, "0", "0.19", "1.0 1.0 1.0 0.3"), guiInfo.LastHudSecond);
                elements.Add(CreatePanel("0.2 0.1", $"{.2f + .77f * CurrentPercent(rpgInfo)} 0.88", "0.8392156862745098 0.6823529411764706 0 0.5"), guiInfo.LastHudSecond);
                elements.Add(CreateLabel($"{rpgInfo.Experience}/{rpgInfo.RequiredExperience()}", 1, 1, TextAnchor.MiddleCenter, 15, "0.2", "1", "1.0 1.0 1.0 0.3"), guiInfo.LastHudSecond);
                //elements.Add(CreateLabel($"{player._health}/{player._maxHealth}", 1, 1, TextAnchor.MiddleCenter, 15, "1.0", "2.55", "1.0 1.0 1.0 0.3"), guiInfo.LastHudSecond);
            }
            else
            {
                if (points)
                {
                    guiInfo.LastHudFirst = elements.Add(CreatePanel("0.45 0.2", "0.55 1", "0.13 0.13 0.13 0"), guiInfo.LastHud);
                    elements.Add(CreateLabel($"{_(HMK.Level, player, rpgInfo.Level)}", 1, 1, TextAnchor.MiddleCenter, 15, "0", "0.95", "1.0 0.6470588235294118 0.0 0.6"), guiInfo.LastHudFirst);
                }
                guiInfo.LastHudSecond = elements.Add(CreatePanel("0 0", "1 0.2", "0.13 0.13 0.13 0.75"), guiInfo.LastHud);
                elements.Add(CreatePanel("0.0015 0.3", $"{.9985f * CurrentPercent(rpgInfo)} 0.7", "1.0 0.6470588235294118 0.0 0.6"), guiInfo.LastHudSecond);
            }

            //Puts(CuiHelper.ToJson(elements));
            CuiHelper.AddUi(player, elements);
        }


        //TODO Make another UI for maximum health and finish implementing maximum health changes.
        /*private void HealthGui(BasePlayer player, bool repaint = false)
        {
            if (player == null) return;
            var rpgInfo = FindRpgInfo(player);
            if (rpgInfo == null || rpgInfo.Preferences.ShowHud == 0) return;
            GUIInfo guiInfo;
            if (!GUIInfo.TryGetValue(player.userID, out guiInfo))
                GUIInfo[player.userID] = guiInfo = new GUIInfo();
            else
            {
                if (guiInfo.LastHudTime > Interface.Oxide.Now)
                {
                    if (guiInfo.LastHudTimer == null) guiInfo.LastHudTimer = timer.Once(1, () => HealthGui(player, repaint));
                    return;
                }
                guiInfo.LastHudTimer?.Destroy();
                guiInfo.LastHudTimer = null;
                guiInfo.LastHudTime = Interface.Oxide.Now + 1;
            }

            var elements = new CuiElementContainer();



            elements.Add(CreateLabel($"{player._health}/{player._maxHealth}", 1, 1, TextAnchor.MiddleCenter, 15, "1.0", "2.55", "1.0 1.0 1.0 0.3"), guiInfo.LastHudSecond);

        }*/
        
        #endregion

        private void ExpGain(RPGInfo rpgInfo, int experience, BasePlayer player)
        {
            var steamId = player.userID;
            if (IsNight())
                experience = (int)(experience * NightXP);
            if (rpgInfo.AddExperience(experience))
            {
                NotifyLevelUp(player, rpgInfo);
                PlayerLastPercentChange[steamId] = 0;
            }
            else if (!ShowHud)
            {
                var currentPercent = CurrentPercent(rpgInfo);
                float lastPercent;
                if (!PlayerLastPercentChange.TryGetValue(steamId, out lastPercent))
                    PlayerLastPercentChange.Add(steamId, lastPercent = currentPercent);
                var percentChange = currentPercent - lastPercent;
                if (percentChange >= rpgInfo.Preferences.ShowXPMessagePercent)
                {
                    ChatMessage(player, XPProgression(player, rpgInfo));
                    PlayerLastPercentChange[steamId] = currentPercent;
                }
            }
            UpdateHud(player, true, false);
        }

        private void NotifyLevelUp(BasePlayer player, RPGInfo rpgInfo)
        {
            ChatMessage(player, HMK.LevelUp, rpgInfo.Level);
            if (rpgInfo.Preferences.ShowProfile) ChatMessage(player, Profile(rpgInfo, player));
            UpdateHud(player, true);
            //SaveRPG(false);
        }

        private string Profile(RPGInfo rpgInfo, BasePlayer player)
        {
            var sb = new StringBuilder();
            sb.AppendLine();
            sb.AppendLine(_(HMK.ProfileHeader, player, rpgInfo.SteamName));
            sb.AppendLine(_(HMK.Level, player, rpgInfo.Level));
            sb.AppendLine(_(HMK.DamageBlock, player, rpgInfo.GetBlock()));
            sb.AppendLine(_(HMK.EvasionChance, player, rpgInfo.GetEvasion()));
            sb.AppendLine(_(HMK.CraftingReducer, player, rpgInfo.GetCraftingReducer()));
            sb.AppendLine(XPProgression(player, rpgInfo));
            var Agi = _(HMK.AgiColor, player, $"{rpgInfo.Agility} ({rpgInfo.GetStatPointsCost(HRK.Agi)})");
            var Str = _(HMK.StrColor, player, $"{rpgInfo.Strength} ({rpgInfo.GetStatPointsCost(HRK.Str)})");
            var Int = _(HMK.IntColor, player, $"{rpgInfo.Intelligence} ({rpgInfo.GetStatPointsCost(HRK.Int)})");
            sb.AppendLine($"{Agi} | {Str} | {Int}");
            sb.AppendLine(_(HMK.StatPoints, player, rpgInfo.StatsPoints));
            sb.AppendLine(_(HMK.SkillPoints, player, rpgInfo.SkillPoints));
            sb.AppendLine(_(HMK.SkillsHeader, player));
            foreach (var skill in SkillTable.Where(skill => skill.Value.Enabled))
            {
                int level;
                rpgInfo.Skills.TryGetValue(skill.Key, out level);
                sb.AppendLine($"{skill.Value.Name}: {level}/{skill.Value.MaxLevel} ({rpgInfo.GetSkillPointsCostNext(skill.Value)})");
            }
            sb.AppendLine("====================");
            return sb.ToString();
        }

        #region Skill
        private void UpdateGatherPlayer(BasePlayer player, RPGInfo rpgInfo)
        {
            foreach (var item in player.inventory.AllItems())
                UpdateGather(item, rpgInfo);
        }

        private void UpdateMagazinPlayer(BasePlayer player, RPGInfo rpgInfo)
        {
            if (MagazinBoost == true) return;
            foreach (var item in player.inventory.AllItems())
                UpdateMagazin(item, rpgInfo);
        }

        private void UpdateEffectsPlayer(BasePlayer player, RPGInfo rpgInfo)
        {
            foreach (var item in player.inventory.AllItems())
            {
                UpdateGather(item, rpgInfo);
                if (MagazinBoost == true) return;
                UpdateMagazin(item, rpgInfo);
            }
        }

        private void UpdateGather(Item item, RPGInfo rpgInfo)
        {
            var melee = item.GetHeldEntity() as BaseMelee;
            if (melee == null) return;
            var defaultMelee = GameManager.server.FindPrefab(melee.PrefabName).GetComponent<BaseMelee>();
            UpdateGatherPropertyEntry(melee.gathering.Tree, defaultMelee.gathering.Tree, rpgInfo, HRK.Lumberjack);
            //SendReply(item.GetOwnerPlayer(), "Item: {0} G: {1:0.00} C: {2:0.00} D: {3:0.00}", item.info.shortname, defaultMelee.gathering.Tree.gatherDamage, defaultMelee.gathering.Tree.conditionLost, defaultMelee.gathering.Tree.destroyFraction);
            //SendReply(item.GetOwnerPlayer(), "Item: {0} G: {1:0.00} C: {2:0.00} D: {3:0.00}", item.info.shortname, melee.gathering.Tree.gatherDamage, melee.gathering.Tree.conditionLost, melee.gathering.Tree.destroyFraction);
            UpdateGatherPropertyEntry(melee.gathering.Ore, defaultMelee.gathering.Ore, rpgInfo, HRK.Miner);
            UpdateGatherPropertyEntry(melee.gathering.Flesh, defaultMelee.gathering.Flesh, rpgInfo, HRK.Hunter);
        }

        private void UpdateGatherPropertyEntry(ResourceDispenser.GatherPropertyEntry entry, ResourceDispenser.GatherPropertyEntry defaultEntry, RPGInfo rpgInfo, HRK skillType)
        {
            int skillPoints;
            float modifier;
            float reducer;
            if (rpgInfo.Skills.TryGetValue(skillType, out skillPoints))
            {
                modifier = GatherModifier(skillPoints, skillType);
                reducer = Mathf.Lerp(.5f, 1, 1 - modifier / GatherModifier(SkillTable[skillType].MaxLevel, skillType));
            }
            else
            {
                modifier = 1;
                reducer = 1;
            }
            entry.gatherDamage = modifier * defaultEntry.gatherDamage;
            entry.conditionLost = reducer * defaultEntry.conditionLost;
            entry.destroyFraction = reducer * defaultEntry.destroyFraction;
        }

        private void UpdateMagazin(Item item, RPGInfo rpgInfo)
        {
            if (MagazinBoost == true) return;
            var projectile = item.GetHeldEntity() as BaseProjectile;
            if (projectile == null) return;
            var capacity = (int)(projectile.primaryMagazine.definition.builtInSize * (1f + rpgInfo.Strength / (RPGInfo.XPTable.Length * 2.0f)));
            if (projectile.primaryMagazine.capacity == capacity) return;
            projectile.primaryMagazine.contents += capacity - projectile.primaryMagazine.capacity;
            projectile.primaryMagazine.capacity = capacity;
            projectile.SendNetworkUpdateImmediate();
            item.GetOwnerPlayer()?.inventory.ServerUpdate(0f);
        }

        private void SetCooldown(int skillPoints, float time, Dictionary<HRK, float> playerCooldowns, HRK skillKey)
        {
            playerCooldowns[skillKey] = CooldownModifier(skillPoints, skillKey, time);
        }

        private Dictionary<HRK, float> PlayerCooldowns(ulong steamId)
        {
            Dictionary<HRK, float> playerCooldowns;
            if (!SkillsCooldowns.TryGetValue(steamId, out playerCooldowns))
                SkillsCooldowns.Add(steamId, playerCooldowns = new Dictionary<HRK, float>());
            return playerCooldowns;
        }

        private float GatherModifier(int skillpoints, HRK skillType)
        {
            //TODO cache values?
            return (float)Math.Pow(SkillTable[skillType].Modifiers[HRK.Gather].Args[0], skillpoints);
            //var skill = SkillTable[skillType];
            //return 1f + skillpoints / (float)skill.MaxLevel * skill.Modifiers[HRK.Gather].Args[0];
        }

        private int GatherModifierInt(int skillpoints, HRK skillType, int value)
        {
            return (int)Math.Ceiling(GatherModifier(skillpoints, skillType) * value);
        }

        private float CooldownModifier(int skillpoints, HRK skillKey, float currenttime)
        {
            var modifier = SkillTable[skillKey].Modifiers[HRK.Cooldown];
            var baseCooldown = modifier.Args[0] * 60f;
            var timeToReduce = (skillpoints - 1f) * modifier.Args[1] * 60f;
            var finalCooldown = baseCooldown - timeToReduce;
            return finalCooldown + currenttime;
        }
        #endregion

        #region Message
        private string _(HMK key, params object[] args)
        {
            return _(key, (string)null, args);
        }

        private string _(HMK key, BasePlayer player, params object[] args)
        {
            return _(key, player?.UserIDString, args);
        }

        private string _(HMK key, string userid = null, params object[] args)
        {
            var message = lang.GetMessage(key.ToString(), this, userid);
            return message != null ? args.Length > 0 ? string.Format(message, args) : message : string.Empty;
        }

        private void ChatMessage(BasePlayer player, string message)
        {
            if (player?.net == null) return;
            player.ChatMessage(string.Format(ChatPrefix, message));
        }

        private void ChatMessage(BasePlayer player, HMK key, params object[] args)
        {
            if (player?.net == null) return;
            ChatMessage(player, _(key, player.UserIDString, args));
        }
        #endregion

        #region Util
        private RPGInfo FindRpgInfo(BasePlayer player)
        {
            if (Data == null) return null;
            var userId = player.userID;
            RPGInfo config;
            if (Data.Profiles.TryGetValue(userId, out config))
            {
                config.SetUserId(userId);
                config.SteamName = player.displayName;
                config.LastSeen = Facepunch.Math.Epoch.Current;
                return config;
            }
            if (player.displayName == null) return null;
            if (player.userID < 70000000000) return null;
            Data.Profiles[userId] = config = new RPGInfo(player.displayName, DefaultHud, ShowProfile);
            config.SetUserId(userId);
            //SaveRPG();
            return config;
        }

        private RPGInfo FindRpgInfo(ulong userId)
        {
            RPGInfo config;
            Data.Profiles.TryGetValue(userId, out config);
            config?.SetUserId(userId);
            return config;
        }

        private bool IsBuildingAllowed(Vector3 position, BasePlayer player)
        {
            var hits = Physics.OverlapSphere(position, 2f, triggerMask);
            foreach (var collider in hits)
            {
                var buildingPrivlidge = collider.GetComponentInParent<BuildingPrivlidge>();
                if (buildingPrivlidge == null) continue;
                if (!buildingPrivlidge.IsAuthed(player)) return false;
            }
            return true;
        }

        private string XPProgression(BasePlayer player, RPGInfo rpgInfo)
        {
            var percent = CurrentPercent(rpgInfo);
            var nightBonus = string.Empty;
            if (IsNight())
                nightBonus = _(HMK.NightXp, player);
            return _(HMK.CurrentXp, player, percent, nightBonus);
        }

        private float CurrentPercent(RPGInfo rpgInfo)
        {
            var requiredXp = rpgInfo.RequiredExperience();
            return requiredXp <= 0 ? 1 : Mathf.Clamp01(rpgInfo.Experience / (float)requiredXp);
        }

        private bool IsNPCInRange(Vector3 pos)
        {
            return Physics.OverlapSphere(pos, 3, playersMask).Select(col => col.GetComponentInParent<BasePlayer>()).Any(player => player != null && Trainer.Contains(player.userID));
        }

        private static void TeleportPlayerTo(BasePlayer player, Vector3 position)
        {
            player.MovePosition(position);
            player.ClientRPCPlayer(null, player, "ForcePositionTo", position);
            //TODO replace later
            //ForcePlayerPosition(player, position);
        }

        private static Vector3 GetGround(Vector3 position)
        {
            var height = TerrainMeta.HeightMap.GetHeight(position);
            position.y = Math.Max(position.y, height);
            return position;
            /*var raycastHits = Physics.RaycastAll(position, Vector3.forward, 25f).GetEnumerator();
            var nearestDistance = 9999f;
            var nearestPoint = Vector3.zero;
            while (raycastHits.MoveNext())
            {
                if (raycastHits.Current == null) continue;
                var raycastHit = (RaycastHit)raycastHits.Current;
                if (raycastHit.distance < nearestDistance)
                {
                    nearestDistance = raycastHit.distance;
                    nearestPoint = raycastHit.point;
                }
            }
            return nearestPoint;*/
        }

        private static bool IsNight()
        {
            var dateTime = TOD_Sky.Instance.Cycle.DateTime;
            return dateTime.Hour >= 19 || dateTime.Hour <= 5;
        }

        private static bool IsSkillReady(Dictionary<HRK, float> playerCooldowns, ref float availableAt, float time, HRK skillKey)
        {
            bool isReady;
            if (playerCooldowns.TryGetValue(skillKey, out availableAt))
            {
                isReady = time >= availableAt;
            }
            else
            {
                isReady = true;
                playerCooldowns.Add(skillKey, availableAt);
            }
            return isReady;
        }

        private static BasePlayer FindPlayer(string nameOrIdOrIp)
        {
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.UserIDString == nameOrIdOrIp)
                    return activePlayer;
                if (activePlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.OrdinalIgnoreCase))
                    return activePlayer;
                if (activePlayer.net?.connection != null && activePlayer.net.connection.ipaddress == nameOrIdOrIp)
                    return activePlayer;
            }
            foreach (var sleepingPlayer in BasePlayer.sleepingPlayerList)
            {
                if (sleepingPlayer.UserIDString == nameOrIdOrIp)
                    return sleepingPlayer;
                if (sleepingPlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.OrdinalIgnoreCase))
                    return sleepingPlayer;
            }
            return null;
        }

        private static BasePlayer FindPlayer(ulong userId)
        {
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.userID == userId)
                    return activePlayer;
            }
            foreach (var sleepingPlayer in BasePlayer.sleepingPlayerList)
            {
                if (sleepingPlayer.userID == userId)
                    return sleepingPlayer;
            }
            return null;
        }

        private static string TimeLeft(float availableAt, float time)
        {
            var timeLeft = availableAt - time;
            var formatableTime = new DateTime(TimeSpan.FromSeconds(timeLeft).Ticks);
            return $"{formatableTime:mm\\:ss}";
        }

        private static string EntityId(BaseEntity entity)
        {
            if (entity == null) return "XYZ";
            var position = entity.transform.position;
            return $"X{position.x}Y{position.y}Z{position.z}";
        }

        private static string EntityName(BaseEntity entity)
        {
            var name = entity.ShortPrefabName;
            var pos = name.LastIndexOf(".", StringComparison.Ordinal);
            if (pos >= 0) name = name.Substring(0, pos);
            return name;
        }

        private void DestroyUi(BasePlayer player, string name)
        {
            if (!string.IsNullOrEmpty(name)) CuiHelper.DestroyUi(player, name);
        }
        #endregion

        public class IgnoreJsonPropertyResolver : DefaultContractResolver
        {
            private Dictionary<string, string> PropertyMappings { get; set; }

            public IgnoreJsonPropertyResolver()
            {
                PropertyMappings = new Dictionary<string, string>();
                var types = new[] { typeof(RPGInfo), typeof(ProfilePreferences) };
                foreach (var type in types)
                {
                    var fields = type.GetFields();
                    foreach (var fieldInfo in fields)
                    {
                        var jsonProperty = fieldInfo.GetCustomAttributes(typeof(JsonPropertyAttribute), false);
                        if (jsonProperty.Length > 0)
                        {
                            PropertyMappings.Add(((JsonPropertyAttribute)jsonProperty[0]).PropertyName, fieldInfo.Name);
                        }
                    }
                    var properties = type.GetProperties();
                    foreach (var propertyInfo in properties)
                    {
                        var jsonProperty = propertyInfo.GetCustomAttributes(typeof(JsonPropertyAttribute), false);
                        if (jsonProperty.Length > 0)
                        {
                            PropertyMappings.Add(((JsonPropertyAttribute)jsonProperty[0]).PropertyName, propertyInfo.Name);
                        }
                    }
                }
            }

            protected string ResolvePropertyName(string propertyName)
            {
                string resolvedName;
                return PropertyMappings.TryGetValue(propertyName, out resolvedName) ? resolvedName : base.ResolvePropertyName(propertyName);
            }
        }
    }
}

namespace Oxide.Plugins.HuntRPGExt
{
    public static class HuntTablesGenerator
    {
        public static Dictionary<int, long> GenerateXPTable(int maxLevel, int baseExp, float levelMultiplier, int levelModule, float moduleReducer)
        {
            var xpTable = new Dictionary<int, long>();
            long currentLevel = baseExp;
            xpTable.Add(0, baseExp);
            for (var i = 1; i < maxLevel; i++)
            {
                if (i % levelModule == 0)
                    levelMultiplier -= moduleReducer;
                if (levelMultiplier < 1.01f) levelMultiplier = 1.01f;
                currentLevel = (long)(currentLevel * levelMultiplier);
                xpTable.Add(i, currentLevel);
            }
            return xpTable;
        }

        public static Dictionary<HRK, Skill> GenerateSkillTable()
        {
            var skillTable = new Dictionary<HRK, Skill>();
            var lumberJack = new Skill(HRK.Lumberjack, HMK.LumberjackDesc, 0, 20);
            var woodAndFleshModifier = new Modifier( /*HRK.Gather, */new[] { 1.035265f });
            lumberJack.AddModifier(HRK.Gather, woodAndFleshModifier);
            skillTable.Add(HRK.Lumberjack, lumberJack);
            var miner = new Skill(HRK.Miner, HMK.MinerDesc, 0, 20);
            miner.AddModifier(HRK.Gather, new Modifier( /*HRK.Gather, */new[] { 1.02048f }));
            skillTable.Add(HRK.Miner, miner);
            var hunter = new Skill(HRK.Hunter, HMK.HunterDesc, 0, 20);
            hunter.AddModifier(HRK.Gather, woodAndFleshModifier);
            skillTable.Add(HRK.Hunter, hunter);
            var gatherer = new Skill(HRK.Gatherer, HMK.GathererDesc, 0, 20);
            gatherer.AddModifier(HRK.Gather, woodAndFleshModifier);
            skillTable.Add(HRK.Gatherer, gatherer);
            var researcher = new Skill(HRK.Researcher, HMK.ResearcherDesc, 30, 5)
            {
                SkillPointsPerLevel = 7,
                Usage = HMK.ResearcherUsage,
                Enabled = false
            };
            researcher.AddRequiredStat("int", researcher.RequiredLevel * 3);
            researcher.AddModifier(HRK.Cooldown, new Modifier( /*HRK.Cooldown, */new[] { 10f, 2f }));
            researcher.AddModifier(HRK.Chance, new Modifier( /*HRK.Chance, */new[] { .6f }));
            skillTable.Add(HRK.Researcher, researcher);
            var blacksmith = new Skill(HRK.Blacksmith, HMK.BlacksmithDesc, 30, 5)
            {
                SkillPointsPerLevel = 7
            };
            blacksmith.AddRequiredStat("str", (int)Math.Floor(blacksmith.RequiredLevel * 2.5f));
            blacksmith.AddModifier(HRK.Chance, new Modifier( /*HRK.Chance, */new[] { .15f }));
            blacksmith.AddModifier(HRK.RessRate, new Modifier( /*HRK.RessRate, */new[] { .5f }));
            skillTable.Add(HRK.Blacksmith, blacksmith);
            var blinkarrow = new Skill(HRK.Blinkarrow, HMK.BlinkarrowDesc, 150, 5)
            {
                Usage = HMK.BlinkarrowUsage,
                SkillPointsPerLevel = 10,
                Enabled = false
            };
            blinkarrow.AddModifier(HRK.Cooldown, new Modifier( /*HRK.Cooldown, */new[] { 9f, 2f }));
            blinkarrow.AddRequiredStat("agi", blinkarrow.RequiredLevel * 2);
            skillTable.Add(HRK.Blinkarrow, blinkarrow);
            var tamer = new Skill(HRK.Tamer, HMK.TamerDesc, 50, 6)
            {
                SkillPointsPerLevel = 5,
                Usage = HMK.TamerUsage
            };
            skillTable.Add(HRK.Tamer, tamer);
            return skillTable;
        }

        public static Dictionary<string, ItemInfo> GenerateItemTable(Dictionary<string, ItemInfo> itemDict = null)
        {
            if (itemDict == null) itemDict = new Dictionary<string, ItemInfo>();
            var definitions = ItemManager.itemList;
            foreach (var definition in definitions)
            {
                var key = definition.shortname;
                itemDict.Add(key, new ItemInfo
                {
                    DisplayName = definition.displayName.translated,
                    CanResearch = true,
                    ItemCategory = definition.category.ToString()
                });
            }
            return itemDict;
        }

        public static Dictionary<string, int> GenerateResearchTable()
        {
            return new Dictionary<string, int>
            {
                {"Tool", 1},
                {"Attire", 2},
                {"Construction", 3},
                {"Resources", 3},
                {"Medical", 4},
                {"Ammunition", 4},
                {"Weapon", 5}
            };
        }

        public static Dictionary<int, string> GenerateTameTable()
        {
            return new Dictionary<int, string>
            {
                {1, HPK.CanTameChicken},
                {2, HPK.CanTameBoar},
                {3, HPK.CanTameStag},
                {4, HPK.CanTameWolf},
                {5, HPK.CanTameBear},
                {6, HPK.CanTameHorse}
            };
        }

        public static Dictionary<BuildingGrade.Enum, float> GenerateUpgradeBuildingTable()
        {
            return new Dictionary<BuildingGrade.Enum, float>
            {
                {BuildingGrade.Enum.Twigs, 1f},
                {BuildingGrade.Enum.Wood, 1f},
                {BuildingGrade.Enum.Stone, 1f},
                {BuildingGrade.Enum.Metal, 1f},
                {BuildingGrade.Enum.TopTier, 1f}
            };
        }

        public static Dictionary<string, object> GenerateDefaults()
        {
            return new Dictionary<string, object>
            {
                {HK.SkillPointsGain, HKD.SkillPointsGain},
                {HK.SkillPointsPerLevel, HKD.SkillPointsPerLevel},
                {HK.StatPointsGain, HKD.StatPointsGain},
                {HK.StatPointsPerLevel, HKD.StatPointsPerLevel},
                {HK.MaximumLevel, HKD.MaximumLevel}
            };
        }

        public static Dictionary<HRK, Modifier> GenerateMaxStatsTable()
        {
            return new Dictionary<HRK, Modifier>
            {
                {HRK.str_block_percent_gain, new Modifier(new[] {1.00095f, .5f})},
                {HRK.agi_evasion_percent_gain, new Modifier(new[] {1.000625f, .5f})},
                {HRK.int_crafting_reducer_percent, new Modifier(new[] {1.001f, .5f})}
            };
        }

        public static Dictionary<ResourceDispenser.GatherType, float> GenerateExpRateTable()
        {
            return new Dictionary<ResourceDispenser.GatherType, float>
            {
                {ResourceDispenser.GatherType.Tree, .5f},
                {ResourceDispenser.GatherType.Ore, .5f},
                {ResourceDispenser.GatherType.Flesh, 5f}
            };
        }

        public static List<string> GenerateAllowedEntites()
        {
            return new List<string>
            {
                "furnace",
                "furnace.large",
                "refinery_small_deployed",
                "campfire",
                "bbq"
            };
        }
    }


    public struct ItemInfo
    {
        public string DisplayName;
        public bool CanResearch;
        public string ItemCategory;
    }

    public class ProfilePreferences
    {
        [JsonProperty("sxpmp")]
        public float ShowXPMessagePercent;
        [JsonProperty("sp")]
        public bool ShowProfile;
        [JsonProperty("scm")]
        public bool ShowCraftMessage;
        [JsonProperty("sh")]
        public uint ShowHud;
        [JsonProperty("uba")]
        public bool UseBlinkArrow;
        [JsonProperty("atba")]
        public bool AutoToggleBlinkArrow;

        public ProfilePreferences(uint defaultHud, bool showProfile)
        {
            ShowXPMessagePercent = .25f;
            ShowProfile = showProfile;
            ShowCraftMessage = false;
            ShowHud = defaultHud;
            UseBlinkArrow = true;
            AutoToggleBlinkArrow = true;
        }
    }

    public class GUIInfo
    {
        public string LastMain;
        public string LastContent;
        public string LastInfo;
        public string LastStats;
        public string LastSkills;
        public string LastHud;
        public string LastHudFirst;
        public string LastHudSecond;
        public float LastHudTime;
        public Timer LastHudTimer;
    }

    public class RPGInfo
    {
        private float evasionCache;
        private int agility;
        [JsonProperty("agi")]
        public int Agility
        {
            get { return agility; }
            set
            {
                agility = value;
                evasionCache = -1f;
            }
        }

        private float blockCache;
        private int strength;
        [JsonProperty("str")]
        public int Strength
        {
            get { return strength; }
            set
            {
                strength = value;
                blockCache = -1f;
            }
        }

        private float craftCache;
        private int intelligence;
        [JsonProperty("int")]
        public int Intelligence
        {
            get { return intelligence; }
            set
            {
                intelligence = value;
                craftCache = -1f;
            }
        }


        [JsonProperty("sn")]
        public string SteamName;
        [JsonProperty("l")]
        public int Level;
        [JsonProperty("xp")]
        public long Experience;
        [JsonProperty("statp")]
        public int StatsPoints;
        [JsonProperty("skillp")]
        public int SkillPoints;
        [JsonProperty("s")]
        public Dictionary<HRK, int> Skills;
        [JsonProperty("p")]
        public ProfilePreferences Preferences;
        [JsonProperty("ls")]
        public long LastSeen;
        private ulong userId;
        public static long[] XPTable = new long[0];
        public static Dictionary<HRK, Modifier> MaxStatsTable = new Dictionary<HRK, Modifier>();
        public static Dictionary<int, string> TameTable = new Dictionary<int, string>();
        public static float SkillPointsGain = HKD.SkillPointsGain;
        public static float StatPointsGain = HKD.StatPointsGain;
        public static int SkillPointsPerLevel = HKD.SkillPointsPerLevel;
        public static int StatPointsPerLevel = HKD.StatPointsPerLevel;
        public static int MaxLevel = HKD.MaximumLevel;
        public static Permission Perm;
        private static int[] skillCostCache;
        private static int[] statCostCache;

        public RPGInfo(string steamName, uint defaultHud, bool showProfile)
        {
            SteamName = steamName;
            Level = 0;
            Skills = new Dictionary<HRK, int>();
            Preferences = new ProfilePreferences(defaultHud, showProfile);
        }

        public void SetUserId(ulong userId)
        {
            this.userId = userId;
        }

        public bool AddExperience(long xp)
        {
            if (Level >= XPTable.Length) return false;
            Experience += xp;
            var requiredXp = XPTable[Level];
            if (Experience < requiredXp) return false;
            Experience -= requiredXp;
            LevelUp();
            return true;
        }

        public void LevelUp(int desiredLevel)
        {
            var levelsToUp = desiredLevel - Level;
            for (var i = 0; i < levelsToUp; i++)
                AddExperience(RequiredExperience());
        }

        public long RequiredExperience()
        {
            return Level >= XPTable.Length ? 0 : XPTable[Level];
        }

        public void Died(float percent)
        {
            Experience -= (long)(Experience * percent);
            if (Experience < 0)
                Experience = 0;
        }

        private void LevelUp()
        {
            Level++;
            Agility++;
            Strength++;
            Intelligence++;
            StatsPoints += StatPointsPerLevel;
            SkillPoints += SkillPointsPerLevel;
            if (Level >= XPTable.Length) Experience = 0;
        }

        public bool AddStat(HRK stat, int points)
        {
            if (stat != HRK.Agi && stat != HRK.Int && stat != HRK.Str) return false;
            points = Math.Abs(points);
            if (StatsPoints < points) return false;
            var pointsCost = GetStatPointsCost(stat, points);
            if (StatsPoints < pointsCost) return false;
            switch (stat)
            {
                case HRK.Agi:
                    Agility += points;
                    break;
                case HRK.Int:
                    Intelligence += points;
                    break;
                case HRK.Str:
                    Strength += points;
                    break;
                default:
                    return false;
            }
            StatsPoints -= pointsCost;
            return true;
        }

        public void Reset()
        {
            Level = 0;
            ResetStats();
        }

        public void ResetStats()
        {
            ResetSkills();
            StatsPoints = Level * StatPointsPerLevel;
            Agility = Intelligence = Strength = Level;
        }

        public void ResetSkills()
        {
            int skillLevel;
            if (Skills.TryGetValue(HRK.Tamer, out skillLevel))
            {
                Perm.RevokeUserPermission(userId.ToString(), HPK.CanTame);
                for (var j = 1; j <= skillLevel; j++)
                    Perm.RevokeUserPermission(userId.ToString(), TameTable[j]);
            }
            Skills.Clear();
            SkillPoints = Level * SkillPointsPerLevel;
        }

        public int AddSkill(Skill skill, int level, out HMK reason, Plugin pets = null)
        {
            int existingLevel;
            Skills.TryGetValue(skill.Type, out existingLevel);
            if (existingLevel >= skill.MaxLevel)
            {
                reason = HMK.AlreadyAtMaxLevel;
                return 0;
            }
            var levelsToAdd = Math.Abs(level);
            if (levelsToAdd + existingLevel > skill.MaxLevel) levelsToAdd = skill.MaxLevel - existingLevel;
            if (levelsToAdd <= 0)
            {
                reason = HMK.Empty;
                return 0;
            }
            var requiredPoints = GetSkillPointsCost(skill, existingLevel, levelsToAdd);
            if (SkillPoints < requiredPoints)
            {
                reason = HMK.NotEnoughPoints;
                return 0;
            }
            if (Level < skill.RequiredLevel)
            {
                reason = HMK.NotEnoughLevels;
                return 0;
            }
            if (skill.RequiredSkills.Count > existingLevel)
                foreach (var requiredSkill in skill.RequiredSkills[existingLevel])
                {
                    int tempLevel;
                    if (!Skills.TryGetValue(requiredSkill.Key, out tempLevel) || tempLevel < requiredSkill.Value)
                    {
                        reason = HMK.NotEnoughSkill;
                        return 0;
                    }
                }
            if (skill.RequiredStats.Count > existingLevel)
                foreach (var requiredStat in skill.RequiredStats[existingLevel])
                {
                    switch (requiredStat.Key.ToLower())
                    {
                        case "str":
                            if (Strength < requiredStat.Value)
                            {
                                reason = HMK.NotEnoughStrength;
                                return 0;
                            }
                            break;
                        case "agi":
                            if (Agility < requiredStat.Value)
                            {
                                reason = HMK.NotEnoughAgility;
                                return 0;
                            }
                            break;
                        case "int":
                            if (Intelligence < requiredStat.Value)
                            {
                                reason = HMK.NotEnoughIntelligence;
                                return 0;
                            }
                            break;
                        default:
                            reason = HMK.InvalidCommand;
                            return 0;
                    }
                }
            if (existingLevel > 0)
            {
                if (levelsToAdd > 0)
                    Skills[skill.Type] += levelsToAdd;
            }
            else
            {
                Skills.Add(skill.Type, levelsToAdd);
            }
            if (skill.Type == HRK.Tamer && pets != null)
            {
                var skillLevel = Skills[HRK.Tamer];
                Perm.GrantUserPermission(userId.ToString(), HPK.CanTame, pets);
                for (var j = 1; j <= skillLevel; j++)
                    Perm.GrantUserPermission(userId.ToString(), TameTable[j], pets);
            }
            reason = HMK.Empty;
            SkillPoints -= requiredPoints;
            return levelsToAdd;
        }

        public float GetEvasion()
        {
            if (evasionCache >= 0) return evasionCache;
            var args = MaxStatsTable[HRK.agi_evasion_percent_gain].Args;
            evasionCache = Mathf.Clamp((float)(Math.Pow(args[0], Agility) - 1), 0, args[1]);
            return evasionCache;
        }

        public float GetBlock()
        {
            if (blockCache >= 0) return blockCache;
            var args = MaxStatsTable[HRK.str_block_percent_gain].Args;
            blockCache = Mathf.Clamp((float)(Math.Pow(args[0], Strength) - 1), 0, args[1]);
            return blockCache;
        }

        public float GetCraftingReducer()
        {
            if (craftCache >= 0) return craftCache;
            var args = MaxStatsTable[HRK.int_crafting_reducer_percent].Args;
            craftCache = Mathf.Clamp((float)(Math.Pow(args[0], Intelligence) - 1), 0, args[1]);
            return craftCache;
        }

        public int GetSkillPointsCostNext(Skill skill, int levelsToAdd = 1)
        {
            int existingLevel;
            Skills.TryGetValue(skill.Type, out existingLevel);
            levelsToAdd = Math.Abs(levelsToAdd);
            if (levelsToAdd + existingLevel > skill.MaxLevel) levelsToAdd = skill.MaxLevel - existingLevel;
            if (levelsToAdd < 0) levelsToAdd = 1;
            return GetSkillPointsCost(skill, existingLevel, levelsToAdd);
        }

        private static int GetSkillPointsCost(Skill skill, int level, int add = 1)
        {
            if (SkillPointsGain <= 1) return skill.SkillPointsPerLevel * add;
            if (skillCostCache == null || skillCostCache.Length < XPTable.Length)
            {
                skillCostCache = new int[XPTable.Length];
                for (var i = 0; i < XPTable.Length; i++)
                    skillCostCache[i] = Math.Max((int)Math.Ceiling(Math.Pow(SkillPointsGain, i) - 1), 1);
            }
            var target = level + add;
            if (target > skillCostCache.Length)
            {
                var size = skillCostCache.Length - 1;
                Array.Resize(ref skillCostCache, target);
                for (var i = size; i < target; i++)
                    skillCostCache[i] = Math.Max((int)Math.Ceiling(Math.Pow(SkillPointsGain, i) - 1), 1);
            }
            var points = 0;
            for (var i = level; i < target; i++)
                points += skill.SkillPointsPerLevel + skillCostCache[i];
            return points;
        }

        public int GetStatPointsCost(HRK stat, int add = 1)
        {
            if (StatPointsGain <= 1) return add;
            var level = 0;
            switch (stat)
            {
                case HRK.Agi:
                    level = Agility;
                    break;
                case HRK.Int:
                    level = Intelligence;
                    break;
                case HRK.Str:
                    level = Strength;
                    break;
            }
            level -= Level;
            if (level < 0) return 1;
            if (statCostCache == null || statCostCache.Length < XPTable.Length)
            {
                statCostCache = new int[XPTable.Length];
                for (var i = 0; i < XPTable.Length; i++)
                    statCostCache[i] = Math.Max((int)Math.Ceiling(Math.Pow(StatPointsGain, i) - 1), 1);
            }
            var target = level + add;
            if (target > statCostCache.Length)
            {
                var size = statCostCache.Length - 1;
                Array.Resize(ref statCostCache, target);
                for (var i = size; i < target; i++)
                    statCostCache[i] = Math.Max((int)Math.Ceiling(Math.Pow(StatPointsGain, i) - 1), 1);
            }
            var points = 0;
            for (var i = level; i < target; i++)
                points += statCostCache[i];
            return points;
        }

        public static void OnUnload()
        {
            MaxStatsTable = null;
            TameTable = null;
            XPTable = null;
            skillCostCache = null;
            statCostCache = null;
            Perm = null;
        }
    }

    public class Skill
    {
        public string Name;
        public HRK Type;
        public bool Enabled;
        public HMK Description;
        public HMK Usage;
        public int RequiredLevel;
        public int MaxLevel;
        public List<Dictionary<HRK, int>> RequiredSkills;
        public Dictionary<HRK, Modifier> Modifiers;
        public List<Dictionary<string, int>> RequiredStats;
        public int SkillPointsPerLevel;

        public Skill(HRK type, HMK description, int requiredLevel, int maxLevel)
        {
            Name = type.ToString();
            Type = type;
            Enabled = true;
            Description = description;
            RequiredLevel = requiredLevel;
            MaxLevel = maxLevel;
            RequiredSkills = new List<Dictionary<HRK, int>>();
            Modifiers = new Dictionary<HRK, Modifier>();
            RequiredStats = new List<Dictionary<string, int>>();
            SkillPointsPerLevel = 1;
        }

        public void AddRequiredStat(string stat, int points, int level = 1)
        {
            while (RequiredStats.Count < level)
                RequiredStats.Add(new Dictionary<string, int>());
            if (!RequiredStats[level - 1].ContainsKey(stat))
                RequiredStats[level - 1].Add(stat, points);
        }

        public void AddRequiredSkill(HRK skillName, int pointsNeeded, int level = 1)
        {
            while (RequiredSkills.Count < level)
                RequiredSkills.Add(new Dictionary<HRK, int>());
            if (!RequiredSkills[level - 1].ContainsKey(skillName))
                RequiredSkills[level - 1].Add(skillName, pointsNeeded);
        }

        public void AddModifier(HRK modifier, Modifier handler)
        {
            if (!Modifiers.ContainsKey(modifier))
                Modifiers.Add(modifier, handler);
        }
    }

    public struct Modifier
    {
        public Modifier( /*HRK identifier, */ float[] args)
        {
            //Identifier = identifier;
            Args = args;
        }

        //public HRK Identifier;

        public float[] Args;
    }

    public class HuntData
    {
        [JsonProperty(HK.Furnaces)]
        public Dictionary<string, ulong> Furnaces { get; } = new Dictionary<string, ulong>();

        [JsonProperty(HK.Quarries)]
        public Dictionary<string, ulong> Quarries { get; } = new Dictionary<string, ulong>();

        [JsonProperty(HK.Profile)]
        public Dictionary<ulong, RPGInfo> Profiles { get; } = new Dictionary<ulong, RPGInfo>();
    }

    public class HuntDefaults
    {
        public float SkillPointsGain;
        public float StatPointsGain;
        public int SkillPointsPerLevel;
        public int StatPointsPerLevel;
        public int MaximumLevel;
        public HuntDefaults()
        {
            SkillPointsGain = HKD.SkillPointsGain;
            StatPointsGain = HKD.StatPointsGain;
            SkillPointsPerLevel = HKD.SkillPointsPerLevel;
            StatPointsPerLevel = HKD.StatPointsPerLevel;
            MaximumLevel = HKD.MaximumLevel;
        }

    }
}

namespace Oxide.Plugins.HuntRPGExt.Keys
{
    //config keys
    static class HK
    {
        public const string Defaults = "Defaults";
        public const string SkillPointsGain = "SkillPointsGain";
        public const string StatPointsGain = "StatPointsGain";
        public const string DeleteProfileAfterOfflineDays = "DeleteProfileAfterOfflineDays";
        public const string ShowHud = "SHOWHUD";
        public const string ShowProfile = "SHOWPROFILE";
        public const string DefaultHud = "DEFAULTHUD";
        public const string ConfigVersion = "VERSION";
        public const string DataVersion = "DATA_VERSION";
        public const string DataFileName = "RPGData";
        public const string Profile = "PROFILE";
        public const string Furnaces = "FURNACES";
        public const string Quarries = "QUARRIES";
        public const string ChatPrefix = "CHATPREFIX";
        public const string XPTable = "XPTABLE";
        public const string ExpRateTable = "EXPRATETABLE";
        public const string MaxStatsTable = "MAXSTATSTABLE";
        public const string SkillTable = "SKILLTABLE";
        public const string ItemTable = "ITEMTABLE";
        public const string ResearchSkillTable = "RESEARCHSKILLTABLE";
        public const string TameTable = "TAMETABLE";
        public const string UpgradeBuildTable = "UPGRADEBUILDTABLE";
        public const string AllowedEntities = "ALLOWEDENTITIES";
        public const string AdminReset = "ADMINRESET";
        public const string NightXP = "NIGHTXP";
        public const string EcoBoost = "ECOBOOST";
        public const string Trainer = "TRAINER";
        public const string DeathReducerK = "DEATHREDUCER";
        public const string SkillPointsPerLevel = "SkillPointsPerLevel";
        public const string StatPointsPerLevel = "StatPointsPerLevel";
        public const string MaximumLevel = "MaxLevel";
    }

    //defaults
    static class HKD
    {
        public const int MaximumLevel = 2002;
        public const float SkillPointsGain = 1.0975f;
        public const float StatPointsGain = 1.015f;
        public const int SkillPointsPerLevel = 2;
        public const int StatPointsPerLevel = 3;
        public const int BaseXp = 383;
        public const float LevelMultiplier = 1.088f;
        public const int LevelModule = 10;
        public const float ModuleReducer = .0055f;
        public const float DeathReducer = .05f;
    }

    [JsonConverter(typeof(StringEnumConverter))]
    public enum HMK
    {
        None,
        About,
        Agi,
        AgiColor,
        AlreadyAtMaxLevel,
        AvailableSkills,
        BlinkStatus,
        BlinkToggle,
        BlinkedRecently,
        BuildingOwnersPlugin,
        ButtonClose,
        ButtonResetSkills,
        ButtonResetStats,
        CantBlink,
        CantBlinkOther,
        CraftMessage,
        CraftingEnd,
        CraftingReducer,
        CurrentXp,
        DamageBlock,
        DataUpdated,
        Died,
        Dodged,
        TargetDodged,
        Empty,
        EvasionChance,
        GenerateXp,
        Help,
        IdAlreadyExists,
        Int,
        IntColor,
        InvalidCommand,
        InvalidSkillName,
        NotFoundItem,
        Level,
        LevelUp,
        NeedNpc,
        NightXp,
        NotAnAdmin,
        NotEnoughAgility,
        NotEnoughIntelligence,
        NotEnoughLevels,
        NotEnoughPoints,
        NotEnoughStrength,
        Off,
        On,
        PetsPlugin,
        PlayerLevelUp,
        NotFoundPlayer,
        ProfilePreferences,
        ProfileMessage,
        ResearchBlocked,
        ResearchFail,
        ResearchItem,
        ResearchReuse,
        ResearchSkill,
        ResearchSuccess,
        ResearchType,
        Shortcuts,
        SkillDisabled,
        SkillInfo,
        NotLearnedSkill,
        SkillPoints,
        SkillReset,
        SkillResetPlayer,
        StatPoints,
        StatReset,
        StatResetPlayer,
        Str,
        StrColor,
        XpMessage,
        NotEnoughSkill,
        SkillsHeader,
        Loaded,
        StatusLoad,
        StatusSave,
        TopPlayer,
        ProfileHeader,
        SkillUp,
        SkillInfoHeader,
        Usage,
        LevelShort,
        SkillCost,
        LumberjackDesc,
        MinerDesc,
        HunterDesc,
        GathererDesc,
        BlacksmithDesc,
        ResearcherDesc,
        TamerDesc,
        BlinkarrowDesc,
        ResearcherUsage,
        TamerUsage,
        BlinkarrowUsage,
        AgiDesc,
        StrDesc,
        IntDesc
    }

    //permission keys
    public static class HPK
    {
        public const string CanTame = "cannpc";
        public const string CanTameChicken = "pets.chicken";
        public const string CanTameBoar = "pets.boar";
        public const string CanTameStag = "pets.stag";
        public const string CanTameWolf = "pets.wolf";
        public const string CanTameBear = "pets.bear";
        public const string CanTameHorse = "pets.horse";
    }

    [JsonConverter(typeof(StringEnumConverter))]
    public enum HRK
    {
        Tamer,
        Blinkarrow,
        Blacksmith,
        Researcher,
        Lumberjack,
        Miner,
        Hunter,
        Gatherer,
        Gather,
        Cooldown,
        int_crafting_reducer_percent,
        agi_evasion_percent_gain,
        str_block_percent_gain,
        Agi,
        Int,
        Str,
        Chance,
        RessRate
    }
}


// --- End of file: HuntRPG.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/horse-settings ---
// --- Original File Path: H/HorseSettings/HorseSettings.cs ---

﻿using Newtonsoft.Json;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Horse Settings", "hoppel", "1.0.0")]
    [Description("Allows you to adjust ridable horses for players with certain permissions")]
    public class HorseSettings : RustPlugin
    {
        #region Declaration

        private Configuration _config;
        private HorseConfiguration _default = new HorseConfiguration();

        #endregion

        #region Hooks

        private void Init()
        {
            foreach (var setting in _config.HorseSettingsList)
            {
                permission.RegisterPermission(setting.Key, this);
            }
        }

        private void OnEntityMounted(BaseMountable entity, BasePlayer player)
        {
            if (!(player?.GetMountedVehicle() is RidableHorse))
            {
                return;
            }

            var horse = player.GetMountedVehicle() as RidableHorse;
            if (horse == null)
            {
                return;
            }

            foreach (var setting in _config.HorseSettingsList)
            {
                if (permission.UserHasPermission(player.UserIDString, setting.Key))
                {
                    ApplyHorseSettings(horse, setting.Value);
                    return;
                }
            }

            ApplyHorseSettings(horse, _default);
        }

        #endregion

        #region Functions

        private void ApplyHorseSettings(RidableHorse horse, HorseConfiguration config)
        {
            horse.walkSpeed = config.SpeedSetting.WalkSpeed;
            horse.trotSpeed = config.SpeedSetting.TrotSpeed;
            horse.runSpeed = config.SpeedSetting.RunSpeed;
            horse.roadSpeedBonus = config.SpeedSetting.RoadBonusSpeed;
            horse.turnSpeed = config.SpeedSetting.TurnSpeed;

            horse.maxWaterDepth = config.MiscSetting.MaxWaterDepth;
            horse.maxStaminaSeconds = config.MiscSetting.MaxStaminaSeconds;

            horse.staminaCoreLossRatio = config.MetabolismSetting.StaminaCoreLossRatio;
            horse.staminaCoreSpeedBonus = config.MetabolismSetting.StaminaCoreSpeedBonus;
            horse.staminaReplenishRatioMoving = config.MetabolismSetting.StaminaRecoveryRatioMoving;
            horse.staminaReplenishRatioStanding = config.MetabolismSetting.StaminaRecoveryRatioStanding;
            horse.calorieToStaminaRatio = config.MetabolismSetting.CaloriesToStaminaRatio;
            horse.maxStaminaCoreFromWater = config.MetabolismSetting.WaterToStaminaRatio;
        }

        #endregion

        #region HorseSettingClass

        public class HorseConfiguration
        {
            public SpeedSettings SpeedSetting = new SpeedSettings
            {
                WalkSpeed = 2f,
                RoadBonusSpeed = 2f,
                RunSpeed = 14f,
                TrotSpeed = 7f,
                TurnSpeed = 30f
            };

            public MiscSetttings MiscSetting = new MiscSetttings
            {
                MaxWaterDepth = 1.5f,
                MaxStaminaSeconds = 20f
            };

            public MetabolismSettings MetabolismSetting = new MetabolismSettings
            {
                StaminaCoreLossRatio = 0.1f,
                StaminaCoreSpeedBonus = 3f,
                StaminaRecoveryRatioMoving = 0.5f,
                StaminaRecoveryRatioStanding = 1f,
                CaloriesToStaminaRatio = 0.1f,
                WaterToStaminaRatio = 0.5f
            };


            public class SpeedSettings
            {
                public float WalkSpeed;
                public float TrotSpeed;
                public float RunSpeed;
                public float RoadBonusSpeed;
                public float TurnSpeed;
            }

            public class MiscSetttings
            {
                [JsonProperty("How deep can the horse go into water")]
                public float MaxWaterDepth;

                [JsonProperty("Max Stamina (seconds)")]
                public float MaxStaminaSeconds;
            }

            public class MetabolismSettings
            {
                [JsonProperty("How much Stamina the horse is using")]
                public float StaminaCoreLossRatio;

                [JsonProperty("Stamina core speed bonus")]
                public float StaminaCoreSpeedBonus;

                [JsonProperty("Stamina recovery ratio while moving")]
                public float StaminaRecoveryRatioMoving;

                [JsonProperty("Stamina recovery ratio while standing")]
                public float StaminaRecoveryRatioStanding;

                [JsonProperty("Calories used to recover stamina")]
                public float CaloriesToStaminaRatio;

                [JsonProperty("Water used to recover stamina")]
                public float WaterToStaminaRatio;
            }
        }

        #endregion

        #region Config

        public class Configuration
        {
            [JsonProperty(PropertyName = "Settings list")]
            public Dictionary<string, HorseConfiguration> HorseSettingsList;

            public static Configuration DefaultConfig()
            {
                return new Configuration
                {
                    HorseSettingsList = new Dictionary<string, HorseConfiguration>
                    {
                        ["horsesettings.admin"] = new HorseConfiguration
                        {
                            MetabolismSetting = new HorseConfiguration.MetabolismSettings
                            {
                                StaminaCoreLossRatio = 0f,
                                StaminaCoreSpeedBonus = 30f,
                                StaminaRecoveryRatioMoving = 200f,
                                StaminaRecoveryRatioStanding = 100f,
                                CaloriesToStaminaRatio = 0f,
                                WaterToStaminaRatio = 0f
                            },
                            MiscSetting = new HorseConfiguration.MiscSetttings
                            {
                                MaxWaterDepth = 100f,
                                MaxStaminaSeconds = 1000f
                            },
                            SpeedSetting = new HorseConfiguration.SpeedSettings
                            {
                                WalkSpeed = 100f,
                                RoadBonusSpeed = 20f,
                                RunSpeed = 140f,
                                TrotSpeed = 70f,
                                TurnSpeed = 90f
                            }
                        },
                        ["horsesettings.vip"] = new HorseConfiguration
                        {
                            MetabolismSetting = new HorseConfiguration.MetabolismSettings
                            {
                                StaminaCoreLossRatio = 0.05f,
                                StaminaCoreSpeedBonus = 5f,
                                StaminaRecoveryRatioMoving = 0.8f,
                                StaminaRecoveryRatioStanding = 3f,
                                CaloriesToStaminaRatio = 0.05f,
                                WaterToStaminaRatio = 0.3f
                            },
                            MiscSetting = new HorseConfiguration.MiscSetttings
                            {
                                MaxWaterDepth = 5f,
                                MaxStaminaSeconds = 40f
                            },
                            SpeedSetting = new HorseConfiguration.SpeedSettings
                            {
                                WalkSpeed = 4f,
                                RoadBonusSpeed = 3f,
                                RunSpeed = 17f,
                                TrotSpeed = 10f,
                                TurnSpeed = 34f
                            }
                        }
                    }
                };
            }
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    LoadDefaultConfig();
                    SaveConfig();
                }
            }
            catch
            {
                PrintWarning("Creating new config file.");
                LoadDefaultConfig();
            }
        }
        protected override void LoadDefaultConfig() => _config = Configuration.DefaultConfig();
        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion
    }
}


// --- End of file: HorseSettings.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/headquarters ---
// --- Original File Path: H/Headquarters/Headquarters.cs ---

using System;
using System.Linq;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("Headquarters", "digital0iced0", "1.2.0")]
    [Description("Allows players to have one protected headquarter base.")]
    public class Headquarters : RustPlugin
    {
        #region Declaration

        private static PluginData _data;

        protected static ConfigFile _config;

        private bool _freeForAllActive = false;

        private bool _hooksSubscribed = false;

        private Timer _utilityTimer;

        private CuiElementContainer _cachedUI;

        // Permissions
        private const string AdminPermissionName = "headquarters.admin";

        private static readonly string[] StorageTypesPenalizeModules = {
            "2module_camper",
            "1module_storage",
        };

        private static readonly string[] StorageTypes = {
            "skull_fire_pit",
            "bbq.deployed",
            "dropbox.deployed",
            "stocking_small_deployed",
            "campfire",
            "furnace.large",
            "furnace",
            "coffinstorage",
            "box.wooden.large",
            "small_stash_deployed",
            "refinery_small_deployed",
            "cupboard.tool.deployed",
            "vendingmachine.deployed",
            "woodbox_deployed",
            "locker.deployed",
        };

        #endregion

        #region Config

        protected class ConfigFile
        {
            public HeadquartersConfig HeadquartersConfig;

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    HeadquartersConfig = new HeadquartersConfig(),
                };
            }
        }

        protected class HeadquartersConfig
        {
            public float Radius { get; set; } = 27.5f;

            public bool MapMarkersEnabled { get; set; } = true;

            public bool TeleportEnabled { get; set; } = false;

            public float QuitPenaltyHours { get; set; } = 3f;

            public float DistanceToTC { get; set; } = 2f;

            public bool InvulnerableTC { get; set; } = true;

            public bool ConquerModeEnabled { get; set; } = false;

            public bool FreeForAllEnabled { get; set; } = true;

            public float FreeForAllHoursAfterWipe { get; set; } = 144f;

            public string MarkerPrefab { get; set; } = "assets/prefabs/tools/map/genericradiusmarker.prefab";

            public float ProtectionPercent { get; set; } = 100f;

            public float ProtectionPercentMinimum { get; set; } = 10f;

            public float ProtectionSlotsWithoutPenalty { get; set; } = 30f;

            public float ProtectionPenaltyPercentPerSlot { get; set; } = 1.5f;

            public int ProtectionConstantSecondsAfterDamage { get; set; } = 300;

            public bool MessagePlayersHeadquarterAttacked { get; set; } = true;

            public bool MessagePlayersHeadquarterDestroyed { get; set; } = true;

            public bool UIEnabled { get; set; } = true;

            public int UIRefreshRateSeconds { get; set; } = 0;

            public Anchor UIAnchorMin { get; set; } = new Anchor(0.75f, 0.92f);

            public Anchor UIAnchorMax { get; set; } = new Anchor(0.98f, 0.98f);

            public string[] AdditionalProtectedEntities { get; set; } = new string[] {
              "window",
              "barricade",
              "turret",
              "cctvcamera",
              "dropbox",
              "mailbox",
              "lantern",
              "sign",
            };
        }

        protected class Anchor
        {
            public float X { get; set; }
            public float Y { get; set; }

            public Anchor()
            {
            }

            public Anchor(float x, float y)
            {
                X = x;
                Y = y;
            }
        }

        protected static HeadquartersConfig getConfig()
        {
            return _config.HeadquartersConfig;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating default configuration file...");
            _config = ConfigFile.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion

        #region Helper Classes
        private class PluginData
        {
            [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, Headquarter> AvailableHeadquarters = new Dictionary<string, Headquarter>() { };

            [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, HeadquarterMember> MemberPlayers = new Dictionary<string, HeadquarterMember>() { };

            [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, HeadquarterQuitter> QuitterPlayers = new Dictionary<string, HeadquarterQuitter>() { };
        }

        private class HeadquarterQuitter
        {
            public string UserId { get; }

            public DateTime QuitStartedAt { get; set; }

            public HeadquarterQuitter(string user)
            {
                this.UserId = user;
                this.QuitStartedAt = DateTime.Now;
            }
        }

        private class HeadquarterMember
        {
            public string UserId { get; }

            // This is the id of the leader of the headquarter this player belongs to
            public string LeaderId { get; set; }

            public HeadquarterMember(string user, string leader)
            {
                this.UserId = user;
                this.LeaderId = leader;
            }
        }

        private class Headquarter
        {
            public string LeaderId { get; set; }
            public string Name { get; set; }
            public int StorageSlots { get; set; }
            public float PositionX { get; }
            public float PositionY { get; }
            public float PositionZ { get; }
            public bool IsActive { get; set; }
            public List<string> MemberIds { get; set; } = new List<string>();
            [JsonIgnore]
            public MapMarkerGenericRadius marker;
            public DateTime DismantleStartedAt { get; set; }
            public float LastKnownProtectionPercent { get; set; } = 1;
            public bool MapMarkerEnabled { get; set; }
            public DateTime LastMarkerRefresh { get; set; }
            public DateTime LastDamaged { get; set; }
            public DateTime LastUIUpdate { get; set; }
            [JsonIgnore]
            private Headquarters Instance;

            public Headquarter(string user, string name, float positionX, float positionY, float positionZ, int storageSlots = 0, bool mapMarkerEnabled = true)
            {
                this.LeaderId = user;
                this.Name = name;
                this.PositionX = positionX;
                this.PositionY = positionY;
                this.PositionZ = positionZ;
                this.IsActive = true;
                this.StorageSlots = storageSlots;
                this.MapMarkerEnabled = mapMarkerEnabled;
                this.LastDamaged = DateTime.Now.AddDays(-1);
                this.LastMarkerRefresh = DateTime.Now.AddDays(-1);
                this.LastUIUpdate = DateTime.Now.AddDays(-1);
                this.CreateMapMarker();
            }

            public void SetInstance(Headquarters instance)
            {
                this.Instance = instance;
            }

            public bool HasMember(string user)
            {
                return user == this.LeaderId || this.MemberIds.Contains(user);
            }

            public Vector3 getPosition()
            {
                return new Vector3(this.PositionX, this.PositionY, this.PositionZ);
            }

            public void MarkDamaged()
            {

                bool forceRefreshUI = false;

                if (!IsBeingRaided())
                {
                    forceRefreshUI = true;
                }

                this.LastDamaged = DateTime.Now;

                if (forceRefreshUI)
                {
                    RefreshUI(true);
                }
            }

            public void MarkUIUpdated()
            {
                this.LastUIUpdate = DateTime.Now;
            }

            public bool ShouldUpdateUI()
            {
                return DateTime.Now.Subtract(LastUIUpdate).TotalSeconds >= Headquarters.getConfig().UIRefreshRateSeconds;
            }

            public void CreateMapMarker(bool freeForAllActive = false)
            {
                if (marker != null || !MapMarkerEnabled)
                {
                    return;
                }

                marker = GameManager.server.CreateEntity(_config.HeadquartersConfig.MarkerPrefab, getPosition()) as MapMarkerGenericRadius;

                if (marker != null)
                {
                    marker.alpha = 0.6f;
                    marker.name = this.Name;

                    if (IsActive)
                    {
                        marker.color1 = (freeForAllActive) ? Color.red : Color.yellow;
                        marker.color2 = (freeForAllActive) ? Color.red : getProtectionColor();
                    }
                    else
                    {
                        marker.color1 = Color.black;
                        marker.color2 = Color.black;
                    }

                    marker.radius = 0.2f;
                    marker.Spawn();
                    marker.SendUpdate();
                }
            }

            public void RemoveMapMarker()
            {
                if (!MapMarkerEnabled)
                {
                    return;
                }

                if (marker != null)
                {
                    marker.Kill();
                    marker.SendUpdate();
                    marker.SendNetworkUpdate();
                    UnityEngine.Object.Destroy(marker);
                    marker = null;
                }
            }

            public void UpdateMapMarker()
            {
                if (!MapMarkerEnabled)
                {
                    return;
                }

                if (marker != null)
                {
                    marker.SendNetworkUpdate();
                    marker.SendUpdate();
                }
            }

            public void RefreshMapMarker(bool freeForAllActive = false, bool forceUpdate = false)
            {
                if (!MapMarkerEnabled)
                {
                    return;
                }

                if (forceUpdate || DateTime.Now.Subtract(LastMarkerRefresh).TotalSeconds > 10)
                {
                    RemoveMapMarker();
                    CreateMapMarker(freeForAllActive);
                    this.LastMarkerRefresh = DateTime.Now;
                }
            }

            private Color getProtectionColor()
            {
                if (!IsActive)
                {
                    return Color.red;
                }

                if (LastKnownProtectionPercent > .8)
                {
                    return Color.green;
                }
                else if (LastKnownProtectionPercent > .55)
                {
                    return Color.yellow;
                }
                else if (LastKnownProtectionPercent > .3)
                {
                    return new Color(1f, .65f, 0f, 1f); // Orange
                }
                else
                {
                    return Color.red;
                }
            }

            public void RecalculateProtectionScale()
            {
                if (IsBeingRaided())
                {
                    RefreshUI();
                    return;
                }

                this.LastKnownProtectionPercent = GetCurrentProtectionPercent();

                RefreshUI();
            }

            public void RefreshUI(bool forceRefresh = false)
            {
                HeadquartersConfig c = Headquarters.getConfig();

                if (Instance != null && (forceRefresh || (c.UIEnabled && ShouldUpdateUI())))
                {
                    List<string> playerIds = new List<string>();

                    playerIds.Add(LeaderId);
                    playerIds.AddRange(MemberIds);

                    playerIds.ForEach(delegate (string playerId)
                    {
                        ulong check;

                        if (ulong.TryParse(playerId, out check))
                        {
                            BasePlayer p = BasePlayer.FindByID(check);
                            if (p != null)
                            {
                                Instance.RefreshUIForPlayer(p, this);
                            }
                        }
                    });
                }
            }

            public void RemoveUI()
            {
                if (Instance == null)
                {
                    return;
                }

                List<string> playerIds = new List<string>();

                playerIds.Add(LeaderId);
                playerIds.AddRange(MemberIds);

                playerIds.ForEach(delegate (string playerId)
                {
                    ulong check;

                    if (ulong.TryParse(playerId, out check))
                    {
                        BasePlayer p = BasePlayer.FindByID(check);
                        if (p != null)
                        {
                            Instance.RemoveUIForPlayer(p);
                        }
                    }
                });
            }

            public bool IsBeingRaided()
            {
                return DateTime.Now.Subtract(LastDamaged).TotalSeconds < Headquarters.getConfig().ProtectionConstantSecondsAfterDamage;
            }

            public bool IsDismantling()
            {
                return DateTime.Now.Subtract(DismantleStartedAt).Hours < Headquarters.getConfig().QuitPenaltyHours;
            }

            public float GetCurrentProtectionPercent()
            {
                if (!IsActive)
                {
                    return 0;
                }

                HeadquartersConfig c = Headquarters.getConfig();

                return Mathf.Min(c.ProtectionPercent, Mathf.Max((c.ProtectionPercent - ((this.StorageSlots - c.ProtectionSlotsWithoutPenalty) * c.ProtectionPenaltyPercentPerSlot)), c.ProtectionPercentMinimum)) / 100;
            }
        }

        private class Rgba
        {
            public float R { get; set; }
            public float G { get; set; }
            public float B { get; set; }
            public float A { get; set; }

            public Rgba()
            {
            }

            public Rgba(float r, float g, float b, float a)
            {
                R = r;
                G = g;
                B = b;
                A = a;
            }

            public static string Format(Rgba rgba)
            {
                return $"{rgba.R / 255} {rgba.G / 255} {rgba.B / 255} {rgba.A}";
            }
        }

        private class UI
        {
            public const string MainContainer = "main_container";
            public const string ProtectionContainer = "protection_container";

            public static Rgba PrimaryColor = new Rgba(109, 141, 187, .4f);
            public static Rgba LightColor = new Rgba(255, 255, 255, .6f);
            public static Rgba TextColor = new Rgba(255, 255, 255, .5f);

            public static CuiElementContainer Container(string name, string bgColor, Anchor Min, Anchor Max,
                string parent = "Hud", float fadeOut = 0f, float fadeIn = 0f)
            {
                var newElement = new CuiElementContainer()
                {
                    new CuiElement()
                    {
                        Name = name,
                        Parent = parent,
                        FadeOut = fadeOut,
                        Components =
                        {
                            new CuiImageComponent()
                            {
                                Color = bgColor,
                                FadeIn = fadeIn
                            },
                            new CuiRectTransformComponent()
                            {
                                AnchorMin = $"{Min.X} {Min.Y}",
                                AnchorMax = $"{Max.X} {Max.Y}"
                            }
                        }
                    },
                };
                return newElement;
            }

            public static void Text(string name, string parent, ref CuiElementContainer container, TextAnchor anchor,
                string color, int fontSize, string text,
                Anchor Min, Anchor Max, string font = "robotocondensed-regular.ttf", float fadeOut = 0f,
                float fadeIn = 0f)
            {
                container.Add(new CuiElement()
                {
                    Name = name,
                    Parent = parent,
                    FadeOut = fadeOut,
                    Components =
                    {
                        new CuiTextComponent()
                        {
                            Text = text,
                            Align = anchor,
                            FontSize = fontSize,
                            Font = font,
                            FadeIn = fadeIn,
                            Color = color
                        },
                        new CuiRectTransformComponent()
                        {
                            AnchorMin = $"{Min.X} {Min.Y}",
                            AnchorMax = $"{Max.X} {Max.Y}"
                        }
                    }
                });
            }

            public static void Element(string name, string parent, ref CuiElementContainer container, Anchor Min, Anchor Max,
                string bgColor, float fadeOut = 0f, float fadeIn = 0f)
            {
                container.Add(new CuiElement()
                {
                    Name = name,
                    Parent = parent,
                    FadeOut = fadeOut,
                    Components =
                    {
                        new CuiImageComponent()
                        {
                            Color = bgColor,
                            Material = "",
                            FadeIn = fadeIn
                        },
                        new CuiRectTransformComponent()
                        {
                            AnchorMin = $"{Min.X} {Min.Y}",
                            AnchorMax = $"{Max.X} {Max.Y}"
                        }
                    }
                });
            }

            public static void Image(string name, string parent, ref CuiElementContainer container, Anchor Min, Anchor Max, string img, string color)
            {
                container.Add(new CuiElement
                {
                    Name = name,
                    Parent = parent,
                    Components =
                    {
                        new CuiRawImageComponent()
                        {
                            Url = img,
                            Sprite = "assets/content/textures/generic/fulltransparent.tga",
                            Color = color,
                            Material = "Assets/Icons/IconMaterial.mat"
                        },
                        new CuiRectTransformComponent()
                        {
                            AnchorMin = $"{Min.X} {Min.Y}",
                            AnchorMax = $"{Max.X} {Max.Y}"
                        }
                    }
                });
            }

            public static CuiElementContainer GetCachedUI(HeadquartersConfig c)
            {
                CuiElementContainer cached = Container(MainContainer, "0 0 0 0.1", c.UIAnchorMin, c.UIAnchorMax);

                Element("Icon_Element", MainContainer, ref cached, new Anchor(0f, 0f), new Anchor(0.2f, 1f), Rgba.Format(PrimaryColor));

                Element("Icon_Padded", "Icon_Element", ref cached, new Anchor(0.25f, 0.2f), new Anchor(0.9f, 0.8f), "0 0 0 0");

                Image("Icon_Image", "Icon_Padded", ref cached, new Anchor(0f, 0f), new Anchor(1f, 1f), "https://assets.umod.org/images/icons/plugin/62503f99a1307.png", Rgba.Format(LightColor));

                return cached;
            }

            public static CuiElementContainer GetProtectionUI(HeadquartersConfig c, Headquarter hq, BasePlayer player, Headquarters instance)
            {
                string titleText;
                string titleAmount;

                if (instance._freeForAllActive)
                {
                    titleText = instance.Lang("Headquarter_UI_Free_For_All", player.UserIDString);
                    titleAmount = "";
                }
                else if (!hq.IsActive)
                {
                    titleText = instance.Lang("Headquarter_UI_Dismantling", player.UserIDString);
                    titleAmount = "";
                }
                else
                {
                    float lastKnownPercent = hq.LastKnownProtectionPercent;

                    bool isBeingRaided = hq.IsBeingRaided();

                    titleText = isBeingRaided ? instance.Lang("Headquarter_UI_Raid_Locked", player.UserIDString) : instance.Lang("Headquarter_UI_Protection", player.UserIDString);
                    titleAmount = lastKnownPercent.ToString("p0");
                }

                CuiElementContainer protection = Container(ProtectionContainer, "0 0 0 0.1", new Anchor(c.UIAnchorMin.X + .001f, c.UIAnchorMin.Y), c.UIAnchorMax);

                Element("Title_Element", ProtectionContainer, ref protection, new Anchor(.2f, 0f), new Anchor(1f, 1f), Rgba.Format(PrimaryColor));
                Element("Title_Padded", "Title_Element", ref protection, new Anchor(0.05f, 0.05f), new Anchor(0.95f, 0.95f), "0 0 0 0");

                Text("Title_Protection", "Title_Padded", ref protection, TextAnchor.MiddleLeft, Rgba.Format(TextColor), 10, titleText, new Anchor(0f, .2f),
new Anchor(1f, .5f), "robotocondensed-bold.ttf");
                Text("Amount_Protection", "Title_Padded", ref protection, TextAnchor.MiddleLeft, Rgba.Format(TextColor), 10, titleAmount, new Anchor(.80f, .2f),
                    new Anchor(1f, .5f), "robotocondensed-bold.ttf");

                Text("Title_Slots", "Title_Padded", ref protection, TextAnchor.MiddleLeft, Rgba.Format(TextColor), 10, instance.Lang("Headquarter_UI_Storage_Slots", player.UserIDString), new Anchor(0f, .5f),
                    new Anchor(1f, .8f), "robotocondensed-bold.ttf");
                Text("Amount_Slots", "Title_Padded", ref protection, TextAnchor.MiddleLeft, Rgba.Format(TextColor), 10, hq.StorageSlots.ToString(), new Anchor(.80f, .5f),
                    new Anchor(1f, .8f), "robotocondensed-bold.ttf");

                return protection;
            }
        }
        #endregion


        #region Lang

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Headquarter_Init"] = "This server is running Headquarters mod.  It allows you to provide added defense to one of your bases.  For more details type /hq.help in chat",
                ["Headquarter_Protected_NoDamage"] = "This base is under the protection of a HQ.  It can't be damaged at this time.",
                ["Headquarter_Exists_Cant_Clear_List"] = "A HQ exists at this location.  You can't clear its privilege list.",
                ["Headquarter_Exists_Cant_Deauth"] = "A HQ exists at this location.  You can't deauthorize from it's Tool Cupboard.",
                ["Headquarter_Inside_Headquarter"] = "You can't create a HQ inside another HQ.",
                ["Headquarter_Not_Inside"] = "You're not inside a HQ.",
                ["Headquarter_Start_Near_TC"] = "You must stand next to your base's Tool Cupboard to start a HQ.",
                ["Headquarter_Successful_Start"] = "You have started a HQ at this base! You can invite others to join your HQ by having them authenticate at the Tool Cupboard.  To keep your HQ base secure, put a lock on your Tool Cupboard.",
                ["Headquarter_Already_Started"] = "You have already started or joined a HQ.  This disqualifies you from creating a new HQ. However, you can quit it, and after the penalty period you will be able to start another HQ.",
                ["Headquarter_Leader_Quit_Promoted"] = "Your HQ will not be dismantled.  Instead, one of its members will become its new leader.  As for your fate, you have been removed from the headquarter and deauthed from its Tool Cupboard.  You now have the mark of a quitter.  You will not be able to join or start a HQ for some time.  You can learn more by typing /hq.status.",
                ["Headquarter_Leader_Quit_Empty"] = "Your HQ is being dismantled.  Since you were its only member you will keep access to the base.  However, you will not be able to join or start a HQ for some time.  You can learn more by typing /hq.status.",
                ["Headquarter_Only_Leader"] = "Only the leader of a HQ can perform this action.",
                ["Headquarter_Found_Count"] = "Found {0} HQs.",
                ["Headquarter_Near_Found"] = "Headquarter {0} near {1}.",
                ["Headquarter_Name_Exists"] = "This name is already taken.  Please try another.",
                ["Headquarter_Already_Member"] = "You're already a member of this HQ.",
                ["Headquarter_Cleared"] = "All HQs have been removed.  Protections are disabled.",
                ["Headquarter_Here_Protection_Rating"] = "You're in {0}'s HQ! ({1}%).",
                ["Headquarter_Protection_Max_Min"] = "Maximum protection offered: {0} - Minimum: {1}",
                ["Headquarter_Protection_Slots"] = "Storage slots allowed without penalty: {0} - Penalty per additional slot utilized: {1}%",
                ["Headquarter_Protection_Raid_Lock_Seconds"] = "Protection is locked at the start of an attack.  It will remain locked for {0} seconds after the last attack.",
                ["Headquarter_Cant_Auth"] = "A HQ exists at this location and conqueror mode is disabled, therefore you can't authorize here.  If you wish to join this HQ, you must first quit your current HQ and suffer through the penalty period before you may do so.",
                ["Headquarter_Quitter"] = "You have quit your HQ and are now a deserter.  You will not be able to join or start a new HQ for some time.   You can learn more by typing /hq.status.",
                ["Headquarter_Quit_In_Progress"] = "Your reputation is still tarnished from quitting your previous headquarter.  Wait a while longer and try again.  You can learn more by typing /hq.status.",
                ["Headquarter_Conquered"] = "{0} has fallen!  It has been conquered by {1}!",
                ["Headquarter_Not_Member"] = "You are not in a headquarter.",

                ["Headquarter_Empty_Here"] = "There isn't a HQ at this position.",
                ["Headquarter_Require_Name"] = "You must provide a name for your HQ.",
                ["Headquarter_Deployable_Blocked"] = "You can't deploy this item inside someone else's HQ.",
                ["Headquarter_Dismantle_In_Progress"] = "The leader of your headquarter has previously initiated the dismantle process by performing a /hq.quit.  This process takes some time.  While its ongoing you can't start or join another HQ.",
                ["Headquarter_Being_Attacked"] = "Allies of {0}, the time to honor your alliance has come!  We're being attacked by {1}!",

                ["Headquarter_UI_Storage_Slots"] = "STORAGE SLOTS",
                ["Headquarter_UI_Protection"] = "PROTECTION",
                ["Headquarter_UI_Raid_Locked"] = "RAID LOCKED",
                ["Headquarter_UI_Free_For_All"] = "FREE FOR ALL",
                ["Headquarter_UI_Dismantling"] = "DISMANTLING",

                ["Free_For_All_Active"] = "<color=green>HQ free for all is active! HQ protections are disabled!</color>",
                ["Free_For_All_Stopped"] = "<color=red>HQ free for all is deactivated!</color>",
                ["Free_For_All_Status"] = "HQ free for all is expected {0}",
                ["Free_For_All_Only_Admin"] = "HQ free for all is deactivated.  Only an admin can enable it.",

                ["Cmd_Permission"] = "You don't have permission to use that command",
                ["Cmd_Remove_Heaquarter_Leader_Missing"] = "Please provide the user ID (numeric) of the player whose HQ you wish to remove.",
                ["Cmd_Headquarter_Removed"] = "The leader's HQ has been removed.",
                ["Cmd_Headquarter_Remove_Fail"] = "Could not find a HQ belonging to this player ID (numeric).",
                ["Cmd_Remove_Quitter_Player_Missing"] = "Remove quitter requires the player's ID (numeric).",
                ["Cmd_Remove_Quitter_Removed"] = "Quitter was removed successfully.",
                ["Cmd_Remove_Quitter_Fail"] = "Could not find a quitter with the given player ID (numeric).",
                ["Cmd_Cleared_Quitters"] = "Cleared all quitters.",

                ["Help_Welcome"] = "Welcome to Headquarters! This mod allows you to provide protection for one of your bases by designating it your headquarter (HQ).",
                ["Help_Details"] = "A few simple things to keep in mind: You can only belong to one HQ at any given time. You can switch HQ by authenticating at someone else's TC but you will lose your previous HQ.  If you place too many items inside your HQ it will reduce its protection level.  Removing items from the HQ will increase its protection again.",
                ["Help_Raid"] = "You can raid headquarters and regular bases.  However, it may not be worth it to raid a headquarter with a high protection level.  Conquer mode is {0}.",
                ["Help_Start"] = "Starts a named HQ at one of your bases' Tool Cupboard.",
                ["Help_Start_Name"] = "(name)",
                ["Help_Quit"] = "Quits your current HQ.  You will not be able to join or start a new HQ for {0} hours.",
                ["Help_FFA"] = "Provides details on how long until free for all is activated.",
                ["Help_Status"] = "Tells you your personal status.  Lets you know if there is a HQ nearby (and its protection level).  It also lets you know relevant Headquarters settings on this server.",

                ["Status_Dismantling"] = "Your previous headquarter is being dismantled.  This may have happened if it was conquered or the leader dismantled it. You will be able to start or join another HQ {0}",
                ["Status_Leader_Of_Headquarter"] = "You are the leader of {0}.",
                ["Status_Member_Of_Headquarter"] = "You are a member of {0}.",
                ["Status_Quitter"] = "Word still spreads of your dishonor in quitting a headquarter.  You will be able to start or join another HQ {0}",
                ["Status_Not_In_Headquarter"] = "You are not in a HQ!",

                ["Disband_Quit"] = "The /hq.disband command has been removed.  Please utilize /hq.quit instead for both members and leaders.",

                ["Time_In_Hours"] = "in approximately {0} hours.",
                ["Time_In_Minutes"] = "in approximately {0} minutes.",
                ["Time_Soon"] = "any moment now!",
                ["Protected"] = "protected",
                ["Unprotected"] = "unprotected",
                ["Enabled"] = "enabled",
                ["Disabled"] = "disabled",
            }, this);
        }

        #endregion

        #region Helper Methods

        string GetGrid(Vector3 pos)
        {
            char letter = 'A';
            var x = Mathf.Floor((pos.x + (ConVar.Server.worldsize / 2)) / 146.3f) % 26;
            var z = (Mathf.Floor(ConVar.Server.worldsize / 146.3f)) - Mathf.Floor((pos.z + (ConVar.Server.worldsize / 2)) / 146.3f);
            letter = (char)(((int)letter) + x);
            return $"{letter}{z}";
        }

        private Headquarter GetPlayerHeadquarter(BasePlayer player)
        {
            if (IsLeader(player))
            {
                return _data.AvailableHeadquarters[player.UserIDString];
            }
            else if (IsMember(player))
            {
                var leaderId = _data.MemberPlayers[player.UserIDString].LeaderId;

                if (_data.AvailableHeadquarters.ContainsKey(leaderId))
                {
                    return (_data.AvailableHeadquarters[leaderId]);
                }
            }

            return null;
        }

        private BuildingPrivlidge GetHeadquarterTC(Headquarter hq)
        {
            List<BaseCombatEntity> cblist = new List<BaseCombatEntity>();
            Vis.Entities<BaseCombatEntity>(hq.getPosition(), _config.HeadquartersConfig.DistanceToTC, cblist);

            foreach (BaseCombatEntity bp in cblist.Distinct().ToList())
            {
                if (bp is BuildingPrivlidge)
                {
                    return (BuildingPrivlidge)bp;
                }
            }

            return null;
        }

        private void DismantleLeaderHQ(BasePlayer player)
        {
            var hq = _data.AvailableHeadquarters[player.UserIDString];

            DismantleHQ(hq);
        }

        private void ConqueredHQ(Headquarter hq)
        {
            DismantleHQ(hq);
        }

        private void DismantleHQ(Headquarter hq)
        {
            hq.IsActive = false;
            hq.LastKnownProtectionPercent = 0f;
            hq.DismantleStartedAt = DateTime.Now;
            hq.RefreshMapMarker(_freeForAllActive, true);
            hq.RefreshUI(true);
            RefreshMapMarkers();
        }

        private void AddQuitter(BasePlayer player)
        {
            if (!_data.QuitterPlayers.ContainsKey(player.UserIDString))
            {
                _data.QuitterPlayers.Add(player.UserIDString, new HeadquarterQuitter(player.UserIDString));
            }

            SendReply(player, Lang("Headquarter_Quitter", player.UserIDString));
        }

        private void AnnounceConquered(Headquarter conqueringHQ, Headquarter fallenHQ)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                PrintToChat(player, Lang("Headquarter_Conquered", player.UserIDString, fallenHQ.Name, conqueringHQ.Name));
            }
        }

        private bool IsLeader(BasePlayer player)
        {
            return _data.AvailableHeadquarters.ContainsKey(player.UserIDString);
        }

        private bool IsMember(BasePlayer player)
        {
            return _data.MemberPlayers.ContainsKey(player.UserIDString);
        }

        private bool IsQuitter(BasePlayer player)
        {
            return _data.QuitterPlayers.ContainsKey(player.UserIDString);
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _data);

        private void LoadData()
        {
            try
            {
                _data = Interface.Oxide.DataFileSystem.ReadObject<PluginData>(Name);
                _data.AvailableHeadquarters.Values.ToList().ForEach(hq => hq.SetInstance(this));
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            if (_data == null) _data = new PluginData();
        }
        #endregion

        #region Hooks
        private void Init()
        {
            Unsubscribe(nameof(OnItemAddedToContainer));
            Unsubscribe(nameof(OnItemRemovedFromContainer));

            permission.RegisterPermission(AdminPermissionName, this);
            SaveConfig();
        }

        private void OnServerInitialized(bool initial)
        {
            LoadData();


            _utilityTimer = timer.Every(30f, () =>
            {
                // Delay the OnItemAddedToContainer and OnItemRemovedFromContainer because they throw error if active during init
                if (!_hooksSubscribed)
                {
                    Subscribe(nameof(OnItemAddedToContainer));
                    Subscribe(nameof(OnItemRemovedFromContainer));
                    _hooksSubscribed = true;
                }

                CheckFreeForAll();
                RefreshUIForAllPlayers();
                RefreshMapMarkers();
                RemoveDismantled();
                RemoveQuitters();
            });

            RefreshStorageCounts();

            LoadMapMarkers();

            _cachedUI = UI.GetCachedUI(_config.HeadquartersConfig);

            RefreshUIForAllPlayers();
        }

        private void OnServerSave()
        {
            SaveData();
            RefreshMapMarkers();
        }

        private void Unload()
        {
            RemoveMapMarkers();
            RemoveUIForAllPlayers();
            SaveData();
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                timer.Once(1f, () => OnPlayerConnected(player));
                return;
            }

            RefreshMapMarkers();

            if (_config.HeadquartersConfig.FreeForAllEnabled)
            {
                OutputFFAStatus(player);
            }

            AttemptRefreshUIForPlayer(player);
        }

        void OnEntityBuilt(Planner plan, GameObject go)
        {
            if (plan == null || go == null)
            {
                return;
            }

            var entity = go.ToBaseEntity();
            var player = plan.GetOwnerPlayer();

            string prefabName = entity?.ShortPrefabName ?? "unknown";

            if (entity == null || player == null || (!StorageTypes.Contains(prefabName) && !(entity is BuildingPrivlidge)))
            {
                return;
            }

            var headquarter = GetHeadquarterAtPosition(entity.transform.position);

            if (headquarter == null)
            {
                if (entity is BuildingPrivlidge)
                {
                    SendReply(player, Lang("Headquarter_Init", player.UserIDString));
                }

                return;
            }

            if (!headquarter.HasMember(player.UserIDString))
            {
                NextTick(() =>
                {
                    SendReply(player, Lang("Headquarter_Deployable_Blocked", player.UserIDString));
                    entity.Kill();
                });
            }
        }

        object CanMoveItem(Item item, PlayerInventory playerLoot, ItemContainerId targetContainerID, int targetSlot, int amount)
        {
            if (item == null || playerLoot == null || _freeForAllActive)
            {
                return null;
            }

            var player = item.GetOwnerPlayer();

            if (player == null)
            {
                return null;
            }

            var headquarter = GetHeadquarterAtPosition(player.transform.position);

            if (headquarter == null || !headquarter.IsActive)
            {
                return null;
            }

            var actualContainer = playerLoot.FindContainer(targetContainerID);

            if (actualContainer != null)
            {
                string prefabName = actualContainer?.entityOwner?.ShortPrefabName ?? "unknown";

                if (StorageTypes.Contains(prefabName) && !headquarter.HasMember(player.UserIDString))
                {
                    SendReply(player, Lang("Headquarter_Cant_Move_Storage", player.UserIDString));
                    return false;
                }
            }

            return null;
        }

        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (container == null || item == null || container.entityOwner == null || container.entityOwner.transform == null || container.entityOwner.ShortPrefabName == null || container.entityOwner.transform.position == null)
            {
                return;
            }

            string prefabName = container.entityOwner.ShortPrefabName ?? "unknown";

            if (!StorageTypes.Contains(prefabName))
            {
                return;
            }

            var hq = GetHeadquarterAtPosition(container.entityOwner.transform.position);

            if (hq != null)
            {
                hq.StorageSlots++;
                hq.RecalculateProtectionScale();
                hq.RefreshMapMarker(_freeForAllActive);
            }
        }

        void OnItemRemovedFromContainer(ItemContainer container, Item item)
        {
            if (container == null || item == null)
            {
                return;
            }

            string prefabName = container?.entityOwner?.ShortPrefabName ?? "unknown";

            if (container == null || !StorageTypes.Contains(prefabName))
            {
                return;
            }

            var hq = GetHeadquarterAtPosition(container.entityOwner.transform.position);

            if (hq != null)
            {
                hq.StorageSlots--;
                hq.RecalculateProtectionScale();
                hq.RefreshMapMarker(_freeForAllActive);
            }
        }

        private object OnEntityTakeDamage(BaseVehicleModule entity, HitInfo info)
        {
            if (_freeForAllActive || entity == null || info == null)
            {
                return null;
            }

            string prefabName = entity?.ShortPrefabName ?? "unknown";

            if (StorageTypesPenalizeModules.Contains(prefabName) && info.damageTypes.Has(Rust.DamageType.Decay))
            {
                var headquarter = GetHeadquarterAtPosition(entity.transform.position);
                var vehicleModule = entity as BaseVehicleModule;

                if (headquarter != null && vehicleModule != null && entity.healthFraction < .25)
                {
                    var foundSCs = vehicleModule.children.FindAll((BaseEntity x) => x is StorageContainer && !x.ShortPrefabName.Contains("fuel"));

                    var random = new System.Random();

                    foreach (var scEntity in foundSCs)
                    {
                        var storageContainer = scEntity as StorageContainer;

                        if (storageContainer != null && !storageContainer.inventory.IsEmpty())
                        {
                            storageContainer.inventory.itemList.RemoveAt(random.Next(storageContainer.inventory.itemList.Count));
                        }
                    }

                }

                return null;
            }

            return null;
        }

        private void OnEntityDeath(BuildingPrivlidge entity, HitInfo info)
        {
            if (entity == null)
            {
                return;
            }

            var headquarter = GetHeadquarterAtPosition(entity.transform.position, _config.HeadquartersConfig.DistanceToTC);

            if (headquarter != null && headquarter.IsActive)
            {
                headquarter.IsActive = false;
                headquarter.DismantleStartedAt = DateTime.Now;
                headquarter.RefreshMapMarker(_freeForAllActive, true);

                if (info.InitiatorPlayer != null)
                {
                    var attackerHQ = GetPlayerHeadquarter(info.InitiatorPlayer);

                    if (attackerHQ != null)
                    {
                        AnnounceConquered(attackerHQ, headquarter);
                    }

                }
            }
        }

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (_freeForAllActive || entity == null || info == null || !info.damageTypes.IsConsideredAnAttack())
            {
                return null;
            }

            if (entity is BuildingPrivlidge)
            {
                return HandleToolCupboardDamage((BuildingPrivlidge)entity, info);
            }

            return HandleBuildingDamage(entity, info);
        }

        private object HandleToolCupboardDamage(BuildingPrivlidge entity, HitInfo info)
        {
            if (!_config.HeadquartersConfig.InvulnerableTC)
            {
                return HandleBuildingDamage(entity, info);
            }

            var headquarter = GetHeadquarterAtPosition(entity.transform.position);

            if (headquarter != null && headquarter.IsActive)
            {
                var attacker = info?.Initiator?.ToPlayer();

                if (attacker != null)
                {
                    SendReply(attacker, Lang("Headquarter_Protected_NoDamage", attacker.UserIDString));
                }

                return true;
            }

            return null;
        }

        private bool shouldHandleBuildingDamage(BaseCombatEntity entity)
        {
            if (entity is BuildingBlock || entity is Door)
            {
                return true;
            }

            foreach (var check in _config.HeadquartersConfig.AdditionalProtectedEntities)
            {
                if (entity.name.Contains(check))
                {
                    return true;
                }
            }

            return false;
        }

        private object HandleBuildingDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (!shouldHandleBuildingDamage(entity))
            {
                return null;
            }

            var attacker = info.Initiator?.ToPlayer();

            if (attacker != null)
            {
                bool isAttackerAuthed = attacker.IsBuildingAuthed(entity.transform.position, entity.transform.rotation, entity.bounds);

                if (isAttackerAuthed)
                {
                    return null;
                }
            }

            var headquarter = GetHeadquarterAtPosition(entity.transform.position);

            if (headquarter != null && headquarter.IsActive)
            {
                headquarter.RecalculateProtectionScale();
                float headquarterScale = headquarter.LastKnownProtectionPercent;
                float damageScale = Mathf.Max((1f - headquarterScale), 0f);
                info.damageTypes.ScaleAll(damageScale);
                headquarter.RefreshMapMarker(_freeForAllActive);

                if (damageScale < .01f && attacker != null)
                {
                    SendReply(info.InitiatorPlayer, Lang("Headquarter_Protected_NoDamage", attacker.UserIDString));
                }
                else if (damageScale > .01)
                {
                    MessageAllPlayersHeadquarterBeingAttacked(headquarter, attacker);
                }

                headquarter.MarkDamaged();

                return null;
            }

            return null;
        }

        private Headquarter GetHeadquarterAtPosition(Vector3 position, float radius = 0)
        {
            radius = (radius == 0) ? _config.HeadquartersConfig.Radius : radius;

            foreach (KeyValuePair<string, Headquarter> currentHeadquarter in _data.AvailableHeadquarters)
            {
                if (Vector3.Distance(position, currentHeadquarter.Value.getPosition()) <= radius)
                {
                    return currentHeadquarter.Value;
                }
            }

            return null;
        }

        object OnCupboardClearList(BuildingPrivlidge privilege, BasePlayer player)
        {
            var headquarter = GetHeadquarterAtPosition(player.transform.position);

            if (headquarter != null && headquarter.IsActive)
            {
                SendReply(player, Lang("Headquarter_Exists_Cant_Clear_List", player.UserIDString));
                return true;
            }

            return null;
        }

        object OnCupboardDeauthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
            var headquarter = GetHeadquarterAtPosition(player.transform.position);

            if (headquarter != null && headquarter.IsActive)
            {
                SendReply(player, Lang("Headquarter_Exists_Cant_Deauth", player.UserIDString));
                return true;
            }

            return null;
        }

        object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
            var potentialHeadquarter = GetHeadquarterAtPosition(player.transform.position, _config.HeadquartersConfig.DistanceToTC);

            if (potentialHeadquarter != null)
            {
                if (IsQuitter(player))
                {
                    SendReply(player, Lang("Headquarter_Quit_In_Progress", player.UserIDString));
                    return true;
                }

                if (!IsLeader(player) && !IsMember(player))
                {
                    potentialHeadquarter.MemberIds.Add(player.UserIDString);
                    _data.MemberPlayers.Add(player.UserIDString, new HeadquarterMember(player.UserIDString, potentialHeadquarter.LeaderId));
                }
                else
                {
                    Headquarter nearestHeadquarter = (Headquarter)potentialHeadquarter;

                    Headquarter playerHeadquarter = GetPlayerHeadquarter(player);

                    if (nearestHeadquarter.LeaderId != playerHeadquarter.LeaderId)
                    {
                        if (!_config.HeadquartersConfig.ConquerModeEnabled)
                        {
                            SendReply(player, Lang("Headquarter_Cant_Auth", player.UserIDString));
                            return true;
                        }
                        else
                        {
                            ConqueredHQ(nearestHeadquarter);
                            AnnounceConquered(playerHeadquarter, nearestHeadquarter);
                        }
                    }
                }
            }

            return null;
        }
        #endregion

        #region Actions

        private void OutputFFAStatus(BasePlayer player)
        {
            if (_freeForAllActive)
            {
                SendReply(player, Lang("Free_For_All_Active", player.UserIDString));
            }
            else if (_config.HeadquartersConfig.FreeForAllEnabled)
            {
                var timeLeft = _config.HeadquartersConfig.FreeForAllHoursAfterWipe - DateTime.Now.Subtract(SaveRestore.SaveCreatedTime).TotalHours;
                string outLeft;

                if (timeLeft > 2)
                {
                    outLeft = Lang("Time_In_Hours", player.UserIDString, ((int)timeLeft).ToString());
                }
                else if (timeLeft < .2)
                {
                    outLeft = Lang("Time_Soon", player.UserIDString);
                }
                else
                {
                    outLeft = Lang("Time_In_Minutes", player.UserIDString, ((int)(timeLeft * 60)).ToString());
                }


                SendReply(player, Lang("Free_For_All_Status", player.UserIDString, outLeft));
            }
            else
            {
                SendReply(player, Lang("Free_For_All_Only_Admin", player.UserIDString));
            }
        }

        private void LoadMapMarkers()
        {
            if (!_config.HeadquartersConfig.MapMarkersEnabled)
            {
                return;
            }

            foreach (KeyValuePair<string, Headquarter> currentHeadquarter in _data.AvailableHeadquarters)
            {
                currentHeadquarter.Value.CreateMapMarker();
            }
        }

        private void RefreshMapMarkers()
        {
            if (!_config.HeadquartersConfig.MapMarkersEnabled)
            {
                return;
            }

            foreach (KeyValuePair<string, Headquarter> currentHeadquarter in _data.AvailableHeadquarters)
            {
                currentHeadquarter.Value.RefreshMapMarker(_freeForAllActive);
            }
        }

        private void RemoveMapMarkers()
        {
            if (!_config.HeadquartersConfig.MapMarkersEnabled)
            {
                return;
            }

            foreach (KeyValuePair<string, Headquarter> currentHeadquarter in _data.AvailableHeadquarters)
            {
                currentHeadquarter.Value.RemoveMapMarker();
            }
        }

        private void RefreshStorageCounts()
        {
            foreach (KeyValuePair<string, Headquarter> currentHeadquarter in _data.AvailableHeadquarters)
            {
                RefreshHeadquarterStorageCount(currentHeadquarter.Value);
            }
        }

        private void RefreshHeadquarterStorageCount(Headquarter headquarter)
        {
            if (headquarter == null || !headquarter.IsActive)
            {
                return;
            }

            headquarter.StorageSlots = 0;

            List<StorageContainer> containers = new List<StorageContainer>();
            Vis.Entities<StorageContainer>(headquarter.getPosition(), _config.HeadquartersConfig.Radius, containers);

            foreach (StorageContainer sc in containers.Distinct().ToList())
            {
                string prefabName = sc?.ShortPrefabName ?? "unknown";

                if (sc != null && StorageTypes.Contains(prefabName))
                {
                    headquarter.StorageSlots += sc.inventory.itemList.Count;
                }
            }

            headquarter.RecalculateProtectionScale();
        }

        private void RefreshUIForAllPlayers()
        {
            if (_config.HeadquartersConfig.UIEnabled)
            {
                _data.AvailableHeadquarters.Values.ToList().ForEach(hq => hq.RefreshUI());
            }
        }

        private void AttemptRefreshUIForPlayer(BasePlayer p)
        {
            if (_config.HeadquartersConfig.UIEnabled)
            {
                var hq = GetPlayerHeadquarter(p);

                if (hq != null)
                {
                    RefreshUIForPlayer(p, hq);
                }
            }
        }

        private void RefreshUIForPlayer(BasePlayer p, Headquarter hq)
        {
            CuiHelper.DestroyUi(p, UI.MainContainer);
            CuiHelper.DestroyUi(p, UI.ProtectionContainer);

            if (hq != null)
            {
                CuiHelper.AddUi(p, _cachedUI);
                CuiHelper.AddUi(p, UI.GetProtectionUI(_config.HeadquartersConfig, hq, p, this));
            }
        }

        private void RemoveUIForAllPlayers()
        {
            if (_config.HeadquartersConfig.UIEnabled)
            {
                foreach (var p in BasePlayer.activePlayerList)
                {
                    RemoveUIForPlayer(p);
                }
            }
        }

        private void RemoveUIForPlayer(BasePlayer p)
        {
            CuiHelper.DestroyUi(p, UI.MainContainer);
            CuiHelper.DestroyUi(p, UI.ProtectionContainer);
        }

        private void CheckFreeForAll()
        {
            if (!_freeForAllActive && _config.HeadquartersConfig.FreeForAllEnabled && DateTime.Now.Subtract(SaveRestore.SaveCreatedTime).TotalHours >= _config.HeadquartersConfig.FreeForAllHoursAfterWipe)
            {
                _freeForAllActive = true;
                RefreshMapMarkers();
                foreach (var player in BasePlayer.activePlayerList)
                {
                    PrintToChat(player, Lang("Free_For_All_Active", player.UserIDString));
                }
            }
        }


        private void RemoveDismantled()
        {
            foreach (var currentHQ in _data.AvailableHeadquarters.Values.ToList())
            {
                if (!currentHQ.IsActive)
                {
                    var isDismantleComplete = DateTime.Now.Subtract(currentHQ.DismantleStartedAt).TotalMinutes >= (_config.HeadquartersConfig.QuitPenaltyHours * 60);

                    if (isDismantleComplete)
                    {
                        currentHQ.RemoveMapMarker();
                        currentHQ.RemoveUI();
                        currentHQ.MemberIds.ForEach(memberId => _data.MemberPlayers.Remove(memberId));
                        _data.AvailableHeadquarters.Remove(currentHQ.LeaderId);
                    }
                }
            }
        }

        private void RemoveQuitters()
        {
            foreach (var quitter in _data.QuitterPlayers.Values.ToList())
            {
                var isQuitComplete = DateTime.Now.Subtract(quitter.QuitStartedAt).TotalMinutes >= (_config.HeadquartersConfig.QuitPenaltyHours * 60);

                if (isQuitComplete)
                {
                    _data.QuitterPlayers.Remove(quitter.UserId);
                }
            }
        }


        private void DeauthPlayerFromTC(BasePlayer player, BuildingPrivlidge privilege)
        {
            var found = privilege.authorizedPlayers.Find(e => e.userid == player.userID);

            if (found != null)
            {
                privilege.authorizedPlayers.Remove(found);
            }
        }

        private void MessageAllPlayersHeadquarterBeingAttacked(Headquarter hq, BasePlayer attacker)
        {
            if (attacker != null && _config.HeadquartersConfig.MessagePlayersHeadquarterAttacked && DateTime.Now.Subtract(hq.LastDamaged).TotalSeconds > _config.HeadquartersConfig.ProtectionConstantSecondsAfterDamage)
            {
                Headquarter attackerHQ = GetPlayerHeadquarter(attacker);
                String attackerString = attackerHQ == null ? attacker.displayName : attackerHQ.Name;

                foreach (var player in BasePlayer.activePlayerList)
                {
                    PrintToChat(player, Lang("Headquarter_Being_Attacked", player.UserIDString, hq.Name, attackerString));
                }
            }
        }

        private void OutputPlayerStatus(BasePlayer player)
        {
            var playerHQ = GetPlayerHeadquarter(player);

            if (playerHQ != null)
            {
                if (playerHQ.IsDismantling())
                {
                    var timeSinceDismantleStarted = DateTime.Now.Subtract(playerHQ.DismantleStartedAt).TotalMinutes;
                    var remaining = (Headquarters.getConfig().QuitPenaltyHours * 60) - timeSinceDismantleStarted;

                    SendReply(player, Lang("Status_Dismantling", player.UserIDString, Lang("Time_In_Minutes", player.UserIDString, Math.Round(Math.Max(remaining, 1)).ToString())));
                    return;
                }
                else if (IsLeader(player))
                {
                    SendReply(player, Lang("Status_Leader_Of_Headquarter", player.UserIDString, playerHQ.Name));
                }
                else
                {
                    SendReply(player, Lang("Status_Member_Of_Headquarter", player.UserIDString, playerHQ.Name));
                }
            }
            else
            {
                SendReply(player, Lang("Status_Not_In_Headquarter", player.UserIDString));
            }

            if (IsQuitter(player))
            {
                var timeSinceQuit = DateTime.Now.Subtract(_data.QuitterPlayers[player.UserIDString].QuitStartedAt).TotalMinutes;
                var remaining = (Headquarters.getConfig().QuitPenaltyHours * 60) - timeSinceQuit;

                SendReply(player, Lang("Status_Quitter", player.UserIDString, Lang("Time_In_Minutes", player.UserIDString, Math.Round(Math.Max(remaining, 1)).ToString())));
                return;
            }
        }
        #endregion

        #region Commands

        [ChatCommand("hq.help")]
        private void cmdChatHeadquarterListAll(BasePlayer player, string command)
        {
            SendReply(player, Lang("Help_Welcome", player.UserIDString));
            SendReply(player, Lang("Help_Details", player.UserIDString));
            SendReply(player, Lang("Help_Raid", player.UserIDString, _config.HeadquartersConfig.ConquerModeEnabled ? Lang("Enabled", player.UserIDString) : Lang("Disabled", player.UserIDString)));
            SendReply(player, "/hq.start " + Lang("Help_Start_Name", player.UserIDString) + " --- " + Lang("Help_Start", player.UserIDString));
            SendReply(player, "/hq.quit --- " + Lang("Help_Quit", player.UserIDString, _config.HeadquartersConfig.QuitPenaltyHours.ToString()));
            SendReply(player, "/hq.ffa --- " + Lang("Help_FFA", player.UserIDString));
            SendReply(player, "/hq.status --- " + Lang("Help_Status", player.UserIDString));
        }

        [ChatCommand("hq.start")]
        private void cmdChatHeadquarterStart(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 0 || args[0].Length == 0)
            {
                SendReply(player, Lang("Headquarter_Require_Name", player.UserIDString));
                return;
            }

            var hqName = args[0];

            foreach (KeyValuePair<string, Headquarter> currentHeadquarter in _data.AvailableHeadquarters)
            {
                if (currentHeadquarter.Value.Name.ToLower() == hqName.ToLower())
                {
                    SendReply(player, Lang("Headquarter_Name_Exists", player.UserIDString));
                    return;
                }
            }

            if (IsQuitter(player))
            {
                SendReply(player, Lang("Headquarter_Quit_In_Progress", player.UserIDString));
                return;
            }

            var isNotAssociatedWithHeadquarter = (!IsLeader(player) && !IsMember(player));

            if (!isNotAssociatedWithHeadquarter && !(GetPlayerHeadquarter(player).IsActive))
            {
                SendReply(player, Lang("Headquarter_Dismantle_In_Progress", player.UserIDString));
                return;
            }

            var existingHeadquarterHere = GetHeadquarterAtPosition(player.transform.position);

            if (existingHeadquarterHere != null)
            {
                SendReply(player, Lang("Headquarter_Inside_Headquarter", player.UserIDString));
                return;
            }

            // ensure next to TC
            List<BaseCombatEntity> cblist = new List<BaseCombatEntity>();
            Vis.Entities<BaseCombatEntity>(player.transform.position, _config.HeadquartersConfig.DistanceToTC, cblist);

            bool nextToCupboard = false;
            BuildingPrivlidge tc = null;

            foreach (BaseCombatEntity bp in cblist.Distinct().ToList())
            {
                if (bp is BuildingPrivlidge)
                {
                    tc = (BuildingPrivlidge)bp;
                    nextToCupboard = true;
                }
            }

            if (!nextToCupboard)
            {
                SendReply(player, Lang("Headquarter_Start_Near_TC", player.UserIDString));
                return;
            }


            // If this user is not associated with a headquarter
            if (isNotAssociatedWithHeadquarter)
            {
                if (tc != null)
                {
                    ((BuildingPrivlidge)tc).authorizedPlayers.Clear();
                    ((BuildingPrivlidge)tc).authorizedPlayers.Add(new ProtoBuf.PlayerNameID { username = player.name, userid = player.userID });

                    var mapMarkersEnabled = _config.HeadquartersConfig.MapMarkersEnabled;
                    var hq = new Headquarter(player.UserIDString, hqName, player.transform.position.x, player.transform.position.y, player.transform.position.z, 0, mapMarkersEnabled);
                    hq.SetInstance(this);
                    _data.AvailableHeadquarters[player.UserIDString] = hq;

                    RefreshHeadquarterStorageCount(hq);
                    hq.RefreshMapMarker(_freeForAllActive);


                    SendReply(player, Lang("Headquarter_Successful_Start", player.UserIDString));
                }


                return;
            }
            else
            {

                SendReply(player, Lang("Headquarter_Already_Started", player.UserIDString));
            }
        }

        [ChatCommand("hq.disband")]
        private void cmdChatHeadquarterDisband(BasePlayer player, string command)
        {
            SendReply(player, Lang("Disband_Quit", player.UserIDString));
        }

        [ChatCommand("hq.quit")]
        private void cmdChatHeadquarterQuit(BasePlayer player, string command)
        {
            if (IsLeader(player))
            {
                Headquarter leaderPreviousHQ = _data.AvailableHeadquarters[player.UserIDString] as Headquarter;

                if (leaderPreviousHQ != null)
                {
                    if (leaderPreviousHQ.IsDismantling())
                    {
                        SendReply(player, Lang("Headquarter_Dismantle_In_Progress", player.UserIDString));
                        return;
                    }

                    // If there are any members left, promote one to new leader and build a replacement HQ
                    if (leaderPreviousHQ.MemberIds.Any())
                    {
                        string newLeader = (string)(leaderPreviousHQ.MemberIds.First());

                        _data.MemberPlayers.Remove(newLeader);

                        var newHQ = new Headquarter(newLeader, leaderPreviousHQ.Name, leaderPreviousHQ.PositionX, leaderPreviousHQ.PositionY, leaderPreviousHQ.PositionZ, leaderPreviousHQ.StorageSlots, leaderPreviousHQ.MapMarkerEnabled);

                        newHQ.SetInstance(this);

                        leaderPreviousHQ.MemberIds.ForEach(memberId => _data.MemberPlayers[memberId].LeaderId = newLeader);

                        _data.AvailableHeadquarters.Add(newLeader, newHQ);

                        var tc = GetHeadquarterTC(leaderPreviousHQ);

                        if (tc != null)
                        {
                            DeauthPlayerFromTC(player, tc);
                        }

                        leaderPreviousHQ.RemoveMapMarker();

                        _data.AvailableHeadquarters.Remove(player.UserIDString);

                        RefreshMapMarkers();

                        AddQuitter(player);

                        RemoveUIForPlayer(player);

                        SendReply(player, Lang("Headquarter_Leader_Quit_Promoted", player.UserIDString));
                    }
                    else
                    {
                        DismantleLeaderHQ(player);

                        AddQuitter(player);

                        SendReply(player, Lang("Headquarter_Leader_Quit_Empty", player.UserIDString));
                    }
                }

                return;
            }
            else if (IsMember(player))
            {
                if (_data.AvailableHeadquarters.ContainsKey(_data.MemberPlayers[player.UserIDString].LeaderId))
                {
                    Headquarter memberPreviousHQ = _data.AvailableHeadquarters[_data.MemberPlayers[player.UserIDString].LeaderId] as Headquarter;

                    if (memberPreviousHQ.IsDismantling())
                    {
                        SendReply(player, Lang("Headquarter_Dismantle_In_Progress", player.UserIDString));
                        return;
                    }

                    if (memberPreviousHQ != null)
                    {

                        var tc = GetHeadquarterTC(memberPreviousHQ);

                        if (tc != null)
                        {
                            DeauthPlayerFromTC(player, tc);
                        }

                        //remove membership there
                        memberPreviousHQ.MemberIds.Remove(player.UserIDString);


                    }
                }

                _data.MemberPlayers.Remove(player.UserIDString);

                AddQuitter(player);

                RemoveUIForPlayer(player);

                return;
            }
            else
            {
                SendReply(player, Lang("Headquarter_Not_Member", player.UserIDString));
            }
        }

        [ChatCommand("hq.list")]
        private void cmdChatHeadquarterList(BasePlayer player, string command)
        {
            SendReply(player, Lang("Headquarter_Found_Count", player.UserIDString, _data.AvailableHeadquarters.Count.ToString()));
            foreach (KeyValuePair<string, Headquarter> currentHeadquarter in _data.AvailableHeadquarters)
            {
                SendReply(player, Lang("Headquarter_Near_Found", player.UserIDString, currentHeadquarter.Value.Name + " " + ((currentHeadquarter.Value.IsActive && !_freeForAllActive) ? "(" + Lang("Protected", player.UserIDString) + ")" : "(" + Lang("Unprotected", player.UserIDString) + ")"), GetGrid(currentHeadquarter.Value.getPosition())));
            }
        }

        [ChatCommand("hq.teleport")]
        private void cmdChatHeadquarterTeleport(BasePlayer player, string command)
        {

            if (_config.HeadquartersConfig.TeleportEnabled)
            {
                var playerHQ = GetPlayerHeadquarter(player);

                if (playerHQ != null)
                {
                    Vector3 hqPosition = playerHQ.getPosition();
                    player.transform.position = new Vector3(hqPosition.x, hqPosition.y + 1, hqPosition.z);
                }
            }
        }

        [ChatCommand("hq.ffa")]
        private void cmdChatHeadquarterFFA(BasePlayer player, string command)
        {
            OutputFFAStatus(player);
        }

        [ChatCommand("hq.status")]
        private void cmdChatHeadquarterCheck(BasePlayer player, string command)
        {
            OutputPlayerStatus(player);

            var existingHeadquarterHere = GetHeadquarterAtPosition(player.transform.position);

            if (existingHeadquarterHere != null)
            {
                existingHeadquarterHere.RecalculateProtectionScale();
                float headquarterScale = existingHeadquarterHere.LastKnownProtectionPercent;

                SendReply(player, Lang("Headquarter_Here_Protection_Rating", player.UserIDString, existingHeadquarterHere.Name, (headquarterScale * 100).ToString()));


                existingHeadquarterHere.RefreshMapMarker(_freeForAllActive);
            }
            else
            {
                SendReply(player, Lang("Headquarter_Empty_Here", player.UserIDString));
            }

            SendReply(player, Lang("Headquarter_Protection_Max_Min", player.UserIDString, _config.HeadquartersConfig.ProtectionPercent, _config.HeadquartersConfig.ProtectionPercentMinimum));
            SendReply(player, Lang("Headquarter_Protection_Slots", player.UserIDString, _config.HeadquartersConfig.ProtectionSlotsWithoutPenalty, _config.HeadquartersConfig.ProtectionPenaltyPercentPerSlot));
            SendReply(player, Lang("Headquarter_Protection_Raid_Lock_Seconds", player.UserIDString, _config.HeadquartersConfig.ProtectionConstantSecondsAfterDamage));
        }

        [ChatCommand("grid")]
        private void cmdChatHeadquarterGrid(BasePlayer player, string command)
        {
            SendReply(player, GetGrid(player.transform.position));
        }

        [ConsoleCommand("hq.hide-markers")]
        private void cmdConsoleHideMarkers(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null)
            {
                return;
            }

            if (!permission.UserHasPermission(arg.Connection.userid.ToString(), AdminPermissionName))
            {
                arg.ReplyWith(Lang("Cmd_Permission", arg.Connection.userid.ToString()));
                return;
            }

            foreach (KeyValuePair<string, Headquarter> currentHeadquarter in _data.AvailableHeadquarters)
            {
                currentHeadquarter.Value.RemoveMapMarker();
                currentHeadquarter.Value.MapMarkerEnabled = false;
            }
        }

        [ConsoleCommand("hq.show-markers")]
        private void cmdConsoleShowMarkers(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null)
            {
                return;
            }

            if (!permission.UserHasPermission(arg.Connection.userid.ToString(), AdminPermissionName))
            {
                arg.ReplyWith(Lang("Cmd_Permission", arg.Connection.userid.ToString()));
                return;
            }

            foreach (KeyValuePair<string, Headquarter> currentHeadquarter in _data.AvailableHeadquarters)
            {
                currentHeadquarter.Value.MapMarkerEnabled = true;
                currentHeadquarter.Value.RecalculateProtectionScale();
                currentHeadquarter.Value.RefreshMapMarker(_freeForAllActive);
            }
        }

        [ConsoleCommand("hq.clear-all")]
        private void cmdConsoleHeadquarterClearAll(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null)
            {
                return;
            }

            if (!permission.UserHasPermission(arg.Connection.userid.ToString(), AdminPermissionName))
            {
                arg.ReplyWith(Lang("Cmd_Permission", arg.Connection.userid.ToString()));
                return;
            }

            RemoveMapMarkers();
            RemoveUIForAllPlayers();
            _data.AvailableHeadquarters.Clear();
            _data.MemberPlayers.Clear();
            _data.QuitterPlayers.Clear();
            SaveData();
            PrintToChat(Lang("Headquarter_Cleared", arg.Player().UserIDString));
        }

        [ConsoleCommand("hq.start-ffa")]
        private void cmdConsoleStartFFA(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null)
            {
                return;
            }

            if (!permission.UserHasPermission(arg.Connection.userid.ToString(), AdminPermissionName))
            {
                arg.ReplyWith(Lang("Cmd_Permission", arg.Connection.userid.ToString()));
                return;
            }

            _freeForAllActive = true;

            RefreshMapMarkers();
            RefreshUIForAllPlayers();

            foreach (var player in BasePlayer.activePlayerList)
            {
                PrintToChat(player, Lang("Free_For_All_Active", player.UserIDString));
            }
        }

        [ConsoleCommand("hq.stop-ffa")]
        private void cmdConsoleStopFFA(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null)
            {
                return;
            }

            if (!permission.UserHasPermission(arg.Connection.userid.ToString(), AdminPermissionName))
            {
                arg.ReplyWith(Lang("Cmd_Permission", arg.Connection.userid.ToString()));
                return;
            }

            _freeForAllActive = false;

            RefreshMapMarkers();
            RefreshUIForAllPlayers();

            foreach (var player in BasePlayer.activePlayerList)
            {
                PrintToChat(player, Lang("Free_For_All_Stopped", player.UserIDString));
            }
        }

        [ConsoleCommand("hq.remove")]
        private void cmdConsoleRemoveHeadquarter(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null)
            {
                return;
            }

            if (!permission.UserHasPermission(arg.Connection.userid.ToString(), AdminPermissionName))
            {
                arg.ReplyWith(Lang("Cmd_Permission", arg.Connection.userid.ToString()));
                return;
            }

            if (!arg.HasArgs())
            {
                arg.ReplyWith(Lang("Cmd_Remove_Heaquarter_Leader_Missing", arg.Connection.userid.ToString()));
            }

            var leaderId = arg.Args[0];

            if (_data.AvailableHeadquarters.ContainsKey(leaderId))
            {
                var headquarterToRemove = _data.AvailableHeadquarters[leaderId];
                headquarterToRemove.RemoveMapMarker();
                headquarterToRemove.RemoveUI();
                headquarterToRemove.MemberIds.ForEach(memberId => _data.MemberPlayers.Remove(memberId));
                headquarterToRemove.RemoveMapMarker();
                _data.AvailableHeadquarters.Remove(leaderId);
                _data.QuitterPlayers.Remove(leaderId);
                RefreshMapMarkers();
                arg.ReplyWith(Lang("Cmd_Headquarter_Removed", arg.Connection.userid.ToString()));
            }
            else
            {
                arg.ReplyWith(Lang("Cmd_Headquarter_Remove_Fail", arg.Connection.userid.ToString()));
            }
        }

        [ConsoleCommand("hq.remove-quitter")]
        private void cmdConsoleRemoveQuitter(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null)
            {
                return;
            }

            if (!permission.UserHasPermission(arg.Connection.userid.ToString(), AdminPermissionName))
            {
                arg.ReplyWith(Lang("Cmd_Permission", arg.Connection.userid.ToString()));
                return;
            }

            if (!arg.HasArgs())
            {
                arg.ReplyWith(Lang("Cmd_Remove_Quitter_Player_Missing", arg.Connection.userid.ToString()));
            }

            var playerId = arg.Args[0];

            if (_data.QuitterPlayers.ContainsKey(playerId))
            {
                _data.QuitterPlayers.Remove(playerId);
                arg.ReplyWith(Lang("Cmd_Remove_Quitter_Removed", arg.Connection.userid.ToString()));
            }
            else
            {
                arg.ReplyWith(Lang("Cmd_Remove_Quitter_Fail", arg.Connection.userid.ToString()));
            }
        }

        [ConsoleCommand("hq.clear-quitters")]
        private void cmdConsoleClearQuitters(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null)
            {
                return;
            }

            if (!permission.UserHasPermission(arg.Connection.userid.ToString(), AdminPermissionName))
            {
                arg.ReplyWith(Lang("Cmd_Permission", arg.Connection.userid.ToString()));
                return;
            }

            _data.QuitterPlayers.Clear();

            arg.ReplyWith(Lang("Cmd_Cleared_Quitters", arg.Connection.userid.ToString()));
        }
        #endregion
    }
}

// --- End of file: Headquarters.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/hide-and-seek ---
// --- Original File Path: H/HideAndSeek/HideAndSeek.cs ---

﻿/*
TODO:
- Add configuration and localization support
- Add cooldown option for taunting
- Add option for picking which taunts are allowed?
- Add option to only taunt prop's effect(s)
- Add option to show gibs for props or not
- Figure out why Hurt() isn't working for damage passing
- Fix player kick with error on Unload()
- Fix OnPlayerInput checks not allowing players to be props sometimes (dictionary issue)
- Move taunt GUI button to better position
- Unselect active item if selected (make sure to restore fully)
- Update configuration to have usable defaults
- Update configuration automatically
- Whitelist objects to block bad prefabs
*/

using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Hide and Seek", "Wulf/lukespragg", "0.1.3", ResourceId = 1421)]
    [Description("The classic game(mode) of hide and seek, as props")]
    public class HideAndSeek : CovalencePlugin
    {
        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["AlreadyHidden"] = "You are already hidden",
                ["Hiding"] = "You are hiding... shhh!",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["NotHiding"] = "You are no longer hiding, run!"
            }, this);
        }

        #endregion
 
        #region Initialization

        private static System.Random random = new System.Random();
        private static readonly string[] animalTaunts = new[]
        {
            "animals/bear/attack1",
            "animals/bear/attack2",
            "animals/bear/bite",
            "animals/bear/breathe-1",
            "animals/bear/breathing",
            "animals/bear/death",
            "animals/bear/roar1",
            "animals/bear/roar2",
            "animals/bear/roar3",
            "animals/boar/attack1",
            "animals/boar/attack2",
            "animals/boar/flinch1",
            "animals/boar/flinch2",
            "animals/boar/scream",
            "animals/chicken/attack1",
            "animals/chicken/attack2",
            "animals/chicken/attack3",
            "animals/chicken/cluck1",
            "animals/chicken/cluck2",
            "animals/chicken/cluck3",
            "animals/horse/attack",
            "animals/horse/flinch1",
            "animals/horse/flinch2",
            "animals/horse/heavy_breath",
            "animals/horse/snort",
            "animals/horse/whinny",
            "animals/horse/whinny_large",
            "animals/rabbit/attack1",
            "animals/rabbit/attack2",
            "animals/rabbit/run",
            "animals/rabbit/walk",
            "animals/stag/attack1",
            "animals/stag/attack2",
            "animals/stag/death1",
            "animals/stag/death2",
            "animals/stag/flinch1",
            "animals/stag/scream",
            "animals/wolf/attack1",
            "animals/wolf/attack2",
            "animals/wolf/bark",
            "animals/wolf/breathe",
            "animals/wolf/howl1",
            "animals/wolf/howl2",
            "animals/wolf/run_attack",
        };
        private static readonly string[] buildingTaunts = new[]
        {
            "barricades/damage",
            "beartrap/arm",
            "beartrap/fire",
            //"bucket_drop_debris",
            "build/frame_place",
            //"build/promote_metal",
            //"build/promote_stone",
            //"build/promote_toptier",
            //"build/promote_wood",
            "build/repair",
            "build/repair_failed",
            "build/repair_full",
            "building/fort_metal_gib",
            "building/metal_sheet_gib",
            "building/stone_gib",
            "building/thatch_gib",
            "building/wood_gib",
            "door/door-metal-impact",
            "door/door-metal-knock",
            "door/door-wood-impact",
            "door/door-wood-knock",
            "door/lock.code.denied",
            "door/lock.code.lock",
            "door/lock.code.unlock",
            "door/lock.code.updated",
        };
        private static readonly string[] otherTaunts = new[]
        {
            //"entities/helicopter/heli_explosion",
            //"entities/helicopter/rocket_airburst_explosion",
            //"entities/helicopter/rocket_explosion",
            //"entities/helicopter/rocket_fire",
            "entities/loot_barrel/gib",
            "entities/loot_barrel/impact",
            "entities/tree/tree-impact",
            //"fire/fire_v2",
            //"fire/fire_v3",
            //"fire_explosion",
            //"gas_explosion_small",
            "gestures/cameratakescreenshot",
            "headshot",
            "headshot_2d",
            "hit_notify",
            /*"impacts/additive/explosion",
            "impacts/blunt/clothflesh/clothflesh1",
            "impacts/blunt/concrete/concrete1",
            "impacts/blunt/metal/metal1",
            "impacts/blunt/wood/wood1",
            "impacts/bullet/clothflesh/clothflesh1",
            "impacts/bullet/concrete/concrete1",
            "impacts/bullet/dirt/dirt1",
            "impacts/bullet/forest/forest1",
            "impacts/bullet/metal/metal1",
            "impacts/bullet/metalore/bullet_impact_metalore",
            "impacts/bullet/path/path1",
            "impacts/bullet/rock/bullet_impact_rock",
            "impacts/bullet/sand/sand1",
            "impacts/bullet/snow/snow1",
            "impacts/bullet/tundra/bullet_impact_tundra",
            "impacts/bullet/wood/wood1",
            "impacts/slash/concrete/slash_concrete_01",
            "impacts/slash/metal/metal1",
            "impacts/slash/metal/metal2",
            "impacts/slash/metalore/slash_metalore_01",
            "impacts/slash/rock/slash_rock_01",
            "impacts/slash/wood/wood1",*/
            "item_break",
            "player/beartrap_clothing_rustle",
            "player/beartrap_scream",
            "player/groundfall",
            "player/howl",
            //"player/onfire",
            "repairbench/itemrepair",
        };
        private static readonly string[] weaponTaunts = new[]
        {
            "ricochet/ricochet1",
            "ricochet/ricochet2",
            "ricochet/ricochet3",
            "ricochet/ricochet4",
            //"survey_explosion",
            //"weapons/c4/c4_explosion",
            "weapons/rifle_jingle1",
            "weapons/survey_charge/survey_charge_stick",
            "weapons/vm_machete/attack-1",
            "weapons/vm_machete/attack-2",
            "weapons/vm_machete/attack-3",
            "weapons/vm_machete/deploy",
            "weapons/vm_machete/hit"
        };

        private Dictionary<IPlayer, BaseEntity> props = new Dictionary<IPlayer, BaseEntity>();

        private const string permAllow = "hideandseek.allow";

        private void Init()
        {
            permission.RegisterPermission(permAllow, this);

            //foreach (var player in props.Values) TauntButton(player, null);
        }

        #endregion

        #region Player Restoring

        private void OnUserConnected(IPlayer player)
        {
            if (!props.ContainsKey(player)) return;

            var basePlayer = player.Object as BasePlayer;
            if (basePlayer.IsSleeping()) basePlayer.EndSleeping();
            SetPropFlags(basePlayer);
        }

        #endregion

        #region Prop Flags

        private void SetPropFlags(BasePlayer player)
        {
            // Remove admin/developer flags
            if (player.IsAdmin) player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
            if (player.IsDeveloper) player.SetPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper, false);

            // Change to third-person view
            player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, true);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.EyesViewmode, false);
        }

        private void UnsetPropFlags(BasePlayer player)
        {
            // Change to normal view
            player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, false);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.EyesViewmode, false);

            // Restore admin/developer flags
            if (player.net.connection.authLevel > 0) player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
            if (DeveloperList.IsDeveloper(player)) player.SetPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper, true);
        }

        #endregion

        #region Player Hiding

        private void HidePlayer(IPlayer player)
        {
            if (props.ContainsKey(player)) props.Remove(player);

            var basePlayer = player.Object as BasePlayer;
            var ray = new Ray(basePlayer.eyes.position, basePlayer.eyes.HeadForward());
            var entity = FindObject(ray, 3); // TODO: Make distance configurable
            if (entity == null || props.ContainsKey(player)) return;

            // Hide active item
            if (basePlayer.GetActiveItem() != null)
            {
                var heldEntity = basePlayer.GetActiveItem().GetHeldEntity() as HeldEntity;
                heldEntity?.SetHeld(false);
            }

            // Create the prop entity
            var prop = GameManager.server.CreateEntity(entity.name, basePlayer.transform.position, basePlayer.transform.rotation);
            prop.SendMessage("SetDeployedBy", basePlayer, SendMessageOptions.DontRequireReceiver);
            prop.SendMessage("InitializeItem", entity, SendMessageOptions.DontRequireReceiver);
            prop.Spawn();
            props.Add(player, prop);

            // Make the player invisible
            basePlayer.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, true);
            basePlayer.gameObject.SetLayerRecursive(10);
            basePlayer.CancelInvoke("MetabolismUpdate");
            basePlayer.CancelInvoke("InventoryUpdate");
            SetPropFlags(basePlayer);

            //TauntButton(basePlayer, null);
            player.Reply(Lang("Hiding", player.Id));
        }

        private void UnhidePlayer(IPlayer player)
        {
            if (!props.ContainsKey(player)) return;

            // Remove the prop entity
            var prop = props[player];
            if (!prop.IsDestroyed) prop.Kill(BaseNetworkable.DestroyMode.Gib);
            props.Remove(player);

            // Make the player visible
            var basePlayer = player.Object as BasePlayer;
            basePlayer.metabolism.Reset();
            basePlayer.InvokeRepeating("InventoryUpdate", 1f, 0.1f * Random.Range(0.99f, 1.01f));
            basePlayer.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, false);
            basePlayer.gameObject.SetLayerRecursive(17);
            UnsetPropFlags(basePlayer);

            //CuiHelper.DestroyUi(basePlayer, tauntPanel); // TODO
            player.Reply(Lang("NotHiding", player.Id));
        }

        #endregion

        #region Chat Commands

        [Command("hide")]
        private void HideCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAllow))
            {
                player.Reply(Lang("NotAllowed", player.Id, command));
                return;
            }

            var basePlayer = player.Object as BasePlayer;
            if (props.ContainsKey(player) && basePlayer.HasPlayerFlag(BasePlayer.PlayerFlags.Spectating))
            {
                player.Reply(Lang("AlreadyHidden", player.Id));
                return;
            }

            HidePlayer(player);
        }

        [Command("unhide")]
        private void UnhideCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAllow))
            {
                player.Reply(Lang("NotAllowed", player.Id, command));
                return;
            }

            var basePlayer = player.Object as BasePlayer;
            if (!props.ContainsKey(player) && !basePlayer.HasPlayerFlag(BasePlayer.PlayerFlags.Spectating))
            {
                player.Reply(Lang("AlreadyUnhidden", player.Id));
                return;
            }

            UnhidePlayer(player);
        }

        #endregion

        #region Prop Taunting

        [Command("taunt")]
        private void TauntCommand(IPlayer player, string command, string[] args)
        {
            var basePlayer = player.Object as BasePlayer;
            if (!props.ContainsKey(player) && !basePlayer.HasPlayerFlag(BasePlayer.PlayerFlags.Spectating))
            {
                player.Reply("You're not a prop!");
                return;
            }

            var taunt = otherTaunts[random.Next(otherTaunts.Length)];
            Effect.server.Run($"assets/bundled/prefabs/fx/{taunt}.prefab", basePlayer.transform.position, Vector3.zero);
        }

        #endregion

        #region Damage Passing

        private object OnEntityTakeDamage(BaseEntity entity, HitInfo info)
        {
            if (entity is BasePlayer) return null;

            if (!props.ContainsValue(entity))
            {
                var attacker = info.Initiator as BasePlayer;
                attacker?.Hurt(info.damageTypes.Total());
                return true;
            };

            /*var propPlayer = props[entity].Object as BasePlayer;
            if (propPlayer.health <= 1)
            {
                propPlayer.Die();
                return null;
            }

            propPlayer.InitializeHealth(propPlayer.health - info.damageTypes.Total(), 100f);*/
            return true;
        }

        #endregion

        #region Death Handling

        private void OnEntityDeath(BaseEntity entity)
        {
            // Check for prop entity/player
            var basePlayer = entity.ToPlayer();
            if (basePlayer == null) return;

            var player = players.FindPlayerById(basePlayer.UserIDString);
            if (!props.ContainsKey(player)) return;

            // Get the prop entity
            UnhidePlayer(player);
            props.Remove(player);
            basePlayer.RespawnAt(basePlayer.transform.position, basePlayer.transform.rotation);

            // Remove the prop entity
            var prop = props[player];
            if (!prop.IsDestroyed) prop.Kill(BaseNetworkable.DestroyMode.Gib);
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            // Remove all corpses
            if (entity.ShortPrefabName.Equals("player_corpse")) entity.KillMessage();
        }

        #endregion

        #region Spectate Blocking

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (arg?.Connection != null && arg.cmd.Name == "spectate") return true;
            return null;
        }

        private object OnPlayerInput(BasePlayer player, InputState input)
        {
            var iplayer = players.FindPlayerById(player.UserIDString);
            if (iplayer == null) return null;

            if (!props.ContainsKey(iplayer) && !player.IsSpectating() && input.WasJustPressed(BUTTON.FIRE_PRIMARY))
                HidePlayer(iplayer);
            else if (props.ContainsKey(iplayer) && player.IsSpectating() && input.WasJustPressed(BUTTON.FIRE_SECONDARY))
                UnhidePlayer(iplayer);
            else if (props.ContainsKey(iplayer) && player.IsSpectating() && input.WasJustPressed(BUTTON.JUMP) || input.WasJustPressed(BUTTON.DUCK))
                return true;

            return null;
        }

        #endregion

        #region GUI Button

        string tauntPanel;

        private void TauntButton(BasePlayer player, string text)
        {
            var elements = new CuiElementContainer();
            tauntPanel = elements.Add(new CuiPanel
            {
                Image = { Color = "0.0 0.0 0.0 0.0" },
                RectTransform = { AnchorMin = "0.026 0.037", AnchorMax = "0.075 0.10" }
            }, "Hud", "taunt");
            elements.Add(new CuiElement
            {
                Parent = tauntPanel,
                Components =
                {
                    new CuiRawImageComponent { Url = "http://i.imgur.com/28fdPww.png" },
                    new CuiRectTransformComponent { AnchorMin = "0.0 0.0", AnchorMax = "1.0 1.0" }
                }
            });
            elements.Add(new CuiButton
            {
                Button = { Command = $"taunt", Color = "0.0 0.0 0.0 0.0" },
                RectTransform = { AnchorMin = "0.026 0.037", AnchorMax = "0.075 0.10" },
                Text = { Text = "" }
            });
            CuiHelper.DestroyUi(player, tauntPanel);
            CuiHelper.AddUi(player, elements);
        }

        #endregion

        #region Cleanup Props

        private void Unload()
        {
            var propList = props.Keys.ToList();
            foreach (var prop in propList) UnhidePlayer(prop);
            //foreach (var player in BasePlayer.activePlayerList) CuiHelper.DestroyUi(player, tauntPanel);
        }

        #endregion

        #region Helper Methods

        private static BaseEntity FindObject(Ray ray, float distance)
        {
            RaycastHit hit;
            return !Physics.Raycast(ray, out hit, distance) ? null : hit.GetEntity();
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion
    }
}

// --- End of file: HideAndSeek.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/human-npc ---
// --- Original File Path: H/HumanNPC/HumanNPC.cs ---

//#define DEBUG
// Requires: PathFinding
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Rust;
using Network;
using Facepunch;
using Facepunch.Utility;
using System;
using System.Collections.Generic;
using System.Collections;
using System.Globalization;
using System.Linq;
using UnityEngine;
using Convert = System.Convert;

namespace Oxide.Plugins
{
    [Info("Human NPC", "Razor", "0.5.4")]
    [Description("Adds interactive human NPCs which can be modded by other plugins")]
    public class HumanNPC : RustPlugin
    {
        //////////////////////////////////////////////////////
        ///  Fields
        //////////////////////////////////////////////////////
        private static Collider[] colBuffer;
        private int playerLayer;
        private static int targetLayer;
        private static Vector3 Vector3Down;
        private static int groundLayer;
		private static HumanNPC ins;
        private Coroutine QueuedSpawn { get; set; }

        private bool NewTeam;
		private int TeamCount = 0;
		private BasePlayer TeamPlayer;
		private Hash<ulong, RelationshipManager.PlayerTeam> PlayersTeams = new Hash<ulong, RelationshipManager.PlayerTeam>();
 
        private Hash<ulong, HumanNPCInfo> humannpcs = new Hash<ulong, HumanNPCInfo>();

        static int playerMask = LayerMask.GetMask("Player (Server)");
        static int obstructionMask = LayerMask.GetMask(new[] { "Player (Server)", "Construction", "Deployed", "Clutter" });
        static int constructionMask = LayerMask.GetMask(new[] { "Construction", "Deployed", "Clutter" });
        static int terrainMask = LayerMask.GetMask(new[] { "Terrain", "Tree" });

        private readonly Hash<ulong, RecordingData> Recording = new Hash<ulong, RecordingData>();
        private readonly Hash<string, NpcSound> Sounds = new Hash<string, NpcSound>();
		private readonly Hash<string, NpcSound> cached = new Hash<string, NpcSound>();
		public List<ulong> NpcTalking = new List<ulong>();
		
        private bool save;
        private StoredData storedData;
        private DynamicConfigFile data;
        private Vector3 eyesPosition;
        private string chat = "<color=#FA58AC>{0}:</color> ";
		private bool TeamsNPC = true;
		private float RadiusNPC = 5.0f;
		
        [PluginReference]
        private Plugin Kits, Waypoints, Vanish;

        private static PathFinding PathFinding;

        private class StoredData
        {
            public HashSet<HumanNPCInfo> HumanNPCs = new HashSet<HumanNPCInfo>();
        }

        public class WaypointInfo
        {
            public float Speed;
            public Vector3 Position;

            public WaypointInfo(Vector3 position, float speed)
            {
                Speed = speed;
                Position = position;
            }
        }

        public static bool IsLayerBlocked(Vector3 position, float radius, int mask)
        {
            var colliders = Pool.GetList<Collider>();
            Vis.Colliders<Collider>(position, radius, colliders, mask, QueryTriggerInteraction.Collide);

            bool blocked = colliders.Count > 0;

            Pool.FreeList<Collider>(ref colliders);

            return blocked;
        }

        [ChatCommand("npc_sound")]
        private void ChatCommandNpctalk(BasePlayer player, string cmd, string[] args)
        {
			string colorCode = "#FFFF00";
			if (player.net.connection.authLevel < 1)
			{
				SendReply(player, "You do not have access to this command.");
				return;
			}
            if (args.Length == 0)
            {
				SendReply(player, "Record sound that can be played back with Npc\n\n" + $"<color={colorCode}>/npc_sound add soundname</color> - Start recording a new sound.\n" + $"<color={colorCode}>/npc_sound save</color> - Save your recorded sound.\n" + $"<color={colorCode}>/npc_sound cancel</color> - Cancel your recording and not save.\n" + $"<color={colorCode}>/npc_sound</color> - View help text.");
                return;
            }

            switch (args[0].ToLower())
            {
                case "add":
                    Add(player, args);
                    break;

                case "cancel":
                    Reset(player);
                    break;

                case "save":
                    Save(player);
                    break;

                default:
                 	SendReply(player, "Record sound that can be played back with Npc\n\n" + $"<color={colorCode}>/npc_sound add soundname</color> - Start recording a new sound.\n" + $"<color={colorCode}>/npc_sound save</color> - Save your recorded sound.\n" + $"<color={colorCode}>/npc_sound cancel</color> - Cancel your recording and not save.\n" + $"<color={colorCode}>/npc_sound</color> - View help text.");
                    break;
            }
        }

        private void Add(BasePlayer player, string[] args)
        {
            if (Recording.ContainsKey(player.userID))
            {
				SendReply(player, "You already started a recording.");
                return;
            }

            if (args.Length < 2)
            {
				SendReply(player, "Incorrect usage");
                return;
            }

            bool overwrite = args.Any(a => a.ToLower() == "overwrite");
            string name = string.Join(" ", args.Skip(1).Where(a => a.ToLower() != "overwrite").ToArray());
            if (!overwrite && FileExists(name))
            {
				SendReply(player, "There is a sound file with that name already");
                return;
            }

            Recording[player.userID] = new RecordingData
            {
                Name = name
            };

			SendReply(player, "Start talking ingame to record your voice and /npc_sound save when done.");
        }

        private void Save(BasePlayer player)
        {
            RecordingData recording = Recording[player.userID];
            if (recording == null)
            {
                SendReply(player, "You are not recording so nothing to save");
                return;
            }

            NpcSound data = new NpcSound
            {
                Data = recording.Data,
            };

            SaveSoundData(recording.Name, data);
            Recording.Remove(player.userID);
			
			SendReply(player, "Saved your recording as " + recording.Name);
        }

        private void Reset(BasePlayer player)
        {
            RecordingData recording = Recording[player.userID];
            if (recording == null)
            {
				SendReply(player, "You are not recording so nothing to cancel");
                return;
            }

            recording.Data.Clear();
			Recording.Remove(player.userID);

           SendReply(player, "Recording canceled!");
        }
		
        public class NpcSound
        {
            [JsonConverter(typeof(SoundFileConverter))]
            public List<byte[]> Data = new List<byte[]>();
        }

        private class SoundFileConverter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                List<byte[]> data = (List<byte[]>) value;

                writer.WriteValue(Convert.ToBase64String(Compression.Compress(ins.ToSaveData(data))));
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                JToken value = JToken.Load(reader);

                return ins.FromSaveData(Compression.Uncompress(Convert.FromBase64String(value.ToString())));
            }

            public override bool CanConvert(Type objectType)
            {
                return typeof(List<byte>) == objectType;
            }
        }

        private byte[] ToSaveData(List<byte[]> data)
        {
            return data.Select(cd => BitConverter.GetBytes(cd.Length))
                .SelectMany(cd => cd)
                .Concat(data.SelectMany(cd => cd))
                .ToArray();
        }

        private NpcSound LoadDataSound(string name)
        {
            NpcSound cache = cached[name];
            if (cache != null)
            {
                return cache;
            }

            NpcSound data = Interface.Oxide.DataFileSystem.ReadObject<NpcSound>(Name + "/Sounds/" + name);
			if (data == null) return null;
            cached[name] = data;
            return data;
        }
		
        private List<byte[]> FromSaveData(byte[] bytes)
        {
            List<int> dataSize = new List<int>();
            List<byte[]> dataBytes = new List<byte[]>();

            int offset = 0;
            while (true)
            {
                dataSize.Add(BitConverter.ToInt32(bytes, offset));
                offset += 4;

                int sum = dataSize.Sum();
                if (sum == bytes.Length - offset)
                {
                    break;
                }

                if (sum > bytes.Length - offset)
                {
                    throw new ArgumentOutOfRangeException(nameof(dataSize),
                        $"Voice Data is outside the saved range {dataSize.Sum()} > {bytes.Length - offset}");
                }
            }

            foreach (int size in dataSize)
            {
                dataBytes.Add(bytes.Skip(offset).Take(size).ToArray());
                offset += size;
            }

            return dataBytes;
        }
		
        private NpcSound LoadData(string name)
        {
            NpcSound cache = Sounds[name];
            if (cache != null)
            {
                return cache;
            }

            if (!FileExists(name))
            {
                return null;
            }

            NpcSound data = Interface.Oxide.DataFileSystem.ReadObject<NpcSound>($"{Name}/Sounds/{name}");
            Sounds[name] = data;
            return data;
        }   
        private class RecordingData : NpcSound
        {
            public string Name { get; set; }
        }
		
		private bool FileExists(string name)
        {
            return Interface.Oxide.DataFileSystem.ExistsDatafile($"{Name}/Sounds/{name}");
        }
		
		private void SaveSoundData(string name, NpcSound data)
        {
            Interface.Oxide.DataFileSystem.WriteObject($"{Name}/Sounds/{name}", data);
            Sounds[name] = data;
        }

        private void OnPlayerVoice(BasePlayer player, byte[] data)
        {
            RecordingData recording = Recording[player.userID];
            recording?.Data.Add(data);
        }
	
        //////////////////////////////////////////////////////
        ///  class SpawnInfo
        ///  Spawn information, position & rotation
        ///  public => will be saved in the data file
        ///  non public => won't be saved in the data file
        //////////////////////////////////////////////////////
        public class SpawnInfo
        {
            public Vector3 position;
            public Quaternion rotation;

            public SpawnInfo(Vector3 position, Quaternion rotation)
            {
                this.position = position;
                this.rotation = rotation;
            }

            public string String()
            {
                return $"Pos{position} - Rot{rotation}";
            }
            public string ShortString()
            {
                return $"Pos({Math.Ceiling(position.x)},{Math.Ceiling(position.y)},{Math.Ceiling(position.z)})";
            }
        }

        //////////////////////////////////////////////////////
        ///  class HumanTrigger
        /// MonoBehaviour: managed by UnityEngine
        ///  This takes care of all collisions and area management of humanNPCs
        //////////////////////////////////////////////////////
        public class HumanTrigger : MonoBehaviour
        {
            private HumanPlayer npc;

            private readonly HashSet<BasePlayer> triggerPlayers = new HashSet<BasePlayer>();

            public float collisionRadius;

            private void Awake()
            {
                npc = GetComponent<HumanPlayer>();
                collisionRadius = npc.info.collisionRadius;
                InvokeRepeating("UpdateTriggerArea", 2f, 1.5f);
            }

            private void OnDestroy()
            {
#if DEBUG
                //Interface.Oxide.LogInfo("Destroy child: {0}", child?.name);
#endif
                CancelInvoke("UpdateTriggerArea");
            }

            private void UpdateTriggerArea()
            {
                var count = Physics.OverlapSphereNonAlloc(npc.player.transform.position, collisionRadius, colBuffer, targetLayer);
                var collidePlayers = new HashSet<BasePlayer>();
                for (int i = 0; i < count; i++)
                {
                    var collider = colBuffer[i];
                    colBuffer[i] = null;
                    var player = collider.GetComponentInParent<BasePlayer>();
                    if (player != null)
                    {
                        if (player == npc.player) continue;
                        collidePlayers.Add(player);
                        if (triggerPlayers.Add(player)) OnEnterCollision(player);
                        continue;
                    }
                    //temp fix
                    /*var ai = collider.GetComponentInParent<NPCAI>();
                    if (ai != null && ai.decider.hatesHumans)
                        npc.StartAttackingEntity(collider.GetComponentInParent<BaseNpc>());*/
                }

                var removePlayers = new HashSet<BasePlayer>();
                foreach (BasePlayer player in triggerPlayers)
                    if (!collidePlayers.Contains(player)) removePlayers.Add(player);
                foreach (BasePlayer player in removePlayers)
                {
                    triggerPlayers.Remove(player);
                    OnLeaveCollision(player);
                }
            }

            private void OnEnterCollision(BasePlayer player)
            {
                Interface.Oxide.CallHook("OnEnterNPC", npc.player, player);
            }

            private void OnLeaveCollision(BasePlayer player)
            {
                Interface.Oxide.CallHook("OnLeaveNPC", npc.player, player);
            }
        }


        //assets/bundled/prefabs/static/chair_c.static.prefab
        //////////////////////////////////////////////////////
        ///  class HumanLocomotion
        /// MonoBehaviour: managed by UnityEngine
        ///  This takes care of all movements and attacks of HumanNPCs
        //////////////////////////////////////////////////////
        public class HumanLocomotion : MonoBehaviour
        {
            private HumanPlayer npc;
            public Vector3 StartPos = new Vector3(0f, 0f, 0f);
            public Vector3 EndPos = new Vector3(0f, 0f, 0f);
            public Vector3 LastPos = new Vector3(0f, 0f, 0f);
			public Dictionary<Vector3, float> NoMoveInfo = new Dictionary<Vector3, float>();
            private Vector3 nextPos = new Vector3(0f, 0f, 0f);
            private float waypointDone = 0f;
            public float secondsTaken = 0f;
            private float secondsToTake = 0f;

            public List<WaypointInfo> cachedWaypoints;
            private int currentWaypoint = -1;

            public float followDistance = 3.5f;
            private float lastHit = 0f;

            public int noPath = 0;
            public bool shouldMove = true;

            private float startedReload = 0f;
            private bool reloading = false;
            public bool returning = false;
            public bool sitting = false;
            public static List<BaseEntity> allChairs = new List<BaseEntity>();
            public static List<Vector3> chairPosition = new List<Vector3>();

            public BaseCombatEntity attackEntity = null;
            public BaseEntity followEntity = null;
            public Vector3 targetPosition = Vector3.zero;

            public List<Vector3> pathFinding;

            private HeldEntity firstWeapon = null;

            public void Awake()
            {
                npc = GetComponent<HumanPlayer>();
                UpdateWaypoints();

                npc.player.modelState.onground = true;
            }

            public void UpdateWaypoints()
            {
                if (string.IsNullOrEmpty(npc.info.waypoint)) return;
                var cwaypoints = Interface.Oxide.CallHook("GetWaypointsList", npc.info.waypoint);
                if (cwaypoints == null)
                    cachedWaypoints = null;
                else
                {
                    cachedWaypoints = new List<WaypointInfo>();
                    var lastPos = npc.info.spawnInfo.position;
                    var speed = GetSpeed();
					NoMoveInfo.Clear();
                    foreach (var cwaypoint in (List<object>)cwaypoints)
                    {
                        foreach (var pair in (Dictionary<Vector3, float>)cwaypoint)
                        {
							foreach (var find in cachedWaypoints)
							{
								if (find.Position == pair.Key)
								{
									if (!NoMoveInfo.ContainsKey(pair.Key))
									NoMoveInfo.Add(pair.Key, pair.Value);
								}
							}
                            if (HumanNPC.PathFinding == null)
                            {
                                cachedWaypoints.Add(new WaypointInfo(pair.Key, pair.Value));								
                                continue;
                            }
                            var temppathFinding = HumanNPC.PathFinding.Go(lastPos, pair.Key);
                            speed = pair.Value;
                            if (temppathFinding != null)
                            {
                                lastPos = pair.Key;
                                foreach (var vector3 in temppathFinding)
								{
                                    cachedWaypoints.Add(new WaypointInfo(vector3, speed));
								}
                            }
                            else
                            {
#if DEBUG
                                Interface.Oxide.LogInfo("Blocked waypoint? {0} for {1}", pair.Key, npc.player.displayName);
#endif
                                //cachedWaypoints.Add(new WaypointInfo(pair.Key, speed));
                            }
                        }
                    }
                    if (HumanNPC.PathFinding != null && lastPos != npc.info.spawnInfo.position)
                    {
                        var temppathFinding = HumanNPC.PathFinding.Go(lastPos, npc.info.spawnInfo.position);
                        if (temppathFinding != null)
                        {
                            foreach (var vector3 in temppathFinding)
                                cachedWaypoints.Add(new WaypointInfo(vector3, speed));
                        }
                        else
                        {
#if DEBUG
                            Interface.Oxide.LogInfo("Blocked waypoint to spawn? {0} for {1}", lastPos, npc.player.displayName);
#endif
                        }
                    }
                    if (cachedWaypoints.Count <= 0) cachedWaypoints = null;
#if DEBUG
                    Interface.Oxide.LogInfo("Waypoints: {0} for {1}", cachedWaypoints.Count, npc.player.displayName);
#endif
                }
            }
            private void FixedUpdate()
            {
                TryToMove();
            }
            public void TryToMove()
            {
                if (npc.player.IsDead() || npc.player.IsWounded()) return;

                if (targetPosition != Vector3.zero)
                {
#if DEBUG
                    Interface.Oxide.LogInfo("TryToMove: ProcessFollow(target)");
#endif
                    ProcessFollow(targetPosition);
                }
                if (attackEntity is BaseCombatEntity)
                {
#if DEBUG
                    Interface.Oxide.LogInfo("TryToMove: ProcessAttack(attackEntity)");
#endif
                    ProcessAttack(attackEntity);
                }
                else if (followEntity is BaseEntity)
                {
#if DEBUG
                    Interface.Oxide.LogInfo("TryToMove: ProcessFollow(followEntity)");
#endif
                    ProcessFollow(followEntity.transform.position);
                }
                else if (secondsTaken == 0f) GetNextPath();

                if (StartPos != EndPos) Execute_Move();
                if (waypointDone >= 1f) secondsTaken = 0f;
            }
            private void Execute_Move()
            {
                if (!shouldMove) return;
                secondsTaken += Time.deltaTime;
                waypointDone = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);
                nextPos = Vector3.Lerp(StartPos, EndPos, waypointDone);
                nextPos.y = GetMoveY(nextPos);
                npc.player.MovePosition(nextPos);
                //npc.player.eyes.position = nextPos + new Vector3(0, 1.6f, 0);
                var newEyesPos = nextPos + new Vector3(0, 1.6f, 0);
                npc.player.eyes.position.Set(newEyesPos.x, newEyesPos.y, newEyesPos.z);
                npc.player.EnablePlayerCollider();
				//npc.player.UpdatePlayerCollider(true);
                npc.player.modelState.onground = !IsSwimming();
            }

            public void Evade()
            {
                if(IsSwimming()) return;
                if(npc.info.evade == false) return;
#if DEBUG
                Interface.Oxide.LogInfo("Evading...");
#endif
//                var ra = UnityEngine.Random.Range(0f, 100f);
//                if(ra > 40f)
//                {
//                    npc.player.modelState.ducked = true;
//                }
//                else
//                {
//                    npc.player.modelState.ducked = false;
//                }
                   Vector3 ev = new Vector3(UnityEngine.Random.Range(-npc.info.evdist, npc.info.evdist), UnityEngine.Random.Range(-1.5f, 1.5f));
                Vector3 newpos = npc.player.transform.position + ev;
#if DEBUG
                Interface.Oxide.LogInfo($"  first trying new position {newpos.ToString()}");
#endif
                RaycastHit hitinfo;
                int i = 0;
                while(Physics.OverlapSphere(newpos, npc.info.evdist, constructionMask) != null)
                {
                    newpos.x = newpos.x + UnityEngine.Random.Range(-0.2f, 0.2f);
                    newpos.y = newpos.y + UnityEngine.Random.Range(-0.1f, 0.1f);
                    newpos.z = newpos.z + UnityEngine.Random.Range(-0.2f, 0.2f);
#if DEBUG
                    Interface.Oxide.LogInfo($"  trying new position {newpos.ToString()}");
#endif
                    if(Physics.Raycast(newpos, Vector3Down, out hitinfo, 0.1f, groundLayer))
                    {
#if DEBUG
                        Interface.Oxide.LogInfo($"  found ground or construction at {newpos.ToString()}");
#endif
                        break;
                    }
                    else
                    {
                        newpos.y = npc.locomotion.GetGroundY(newpos);
#if DEBUG
                        Interface.Oxide.LogInfo($"  fell through floor, relocating to {newpos.ToString()}");
#endif
                    }

                    i++;
                    if(i > 100) break;
                }
                npc.player.MovePosition(newpos);
            }

            public bool IsSwimming()
            {
                return WaterLevel.Test(npc.player.transform.position + new Vector3(0, 0.65f, 0), false, false);
            }

            public static bool checkChairPosition(Vector3 positionChair)
            {
                foreach (Vector3 newChairPosition in chairPosition)
                {
                    if (Vector3.Distance(positionChair, newChairPosition) <= 0.02f)
                        return false;
                }
                return true;
            }

            private bool CanSit()
            {
                if(sitting)
                {
                    return false;
                }
                return npc.info.allowsit;
            }

            public void Sit()
            {
                npc.Invoke("AllowMove",0);
                // Find a place to sit
                List<BaseMountable> chairs = new List<BaseMountable>();
                Vis.Entities<BaseMountable>(npc.player.transform.position, 15f, chairs);

                List<BaseEntity> chairs2 = new List<BaseEntity>();
                Vis.Entities<BaseEntity>(npc.player.transform.position, 15f, chairs2);

                foreach (var mountable in chairs.Distinct().ToList().Where(n => n.AnyMounted() == false))
                {
#if DEBUG             
                    Interface.Oxide.LogInfo($"HumanNPC {npc.player.displayName} trying to sit...");
#endif
                    if (mountable.AnyMounted() || mountable.mountAnchor == null || HumanLocomotion.allChairs.Contains(mountable) || !checkChairPosition(mountable.transform.position))
                    {
#if DEBUG
                        Interface.Oxide.LogInfo($"Someone is sitting here.");
#endif
                        continue;
                    }
#if DEBUG
                    Interface.Oxide.LogInfo($"Found an empty chair.");
#endif
                    if (mountable is BaseChair)
                    {
                        sitting = true;
                        mountable.MountPlayer(npc.player);
                        //npc.player.MovePosition(mountable.mountAnchor.transform.position);
                        //npc.player.transform.rotation = mountable.mountAnchor.transform.rotation;
                        //npc.player.ServerRotation = mountable.mountAnchor.transform.rotation;
                        npc.player.OverrideViewAngles(mountable.mountAnchor.transform.rotation.eulerAngles);
                        npc.player.eyes.NetworkUpdate(mountable.mountAnchor.transform.rotation);
                        npc.player.ClientRPCPlayer<Vector3>(null, npc.player, "ForcePositionTo", npc.player.transform.position);
                        if (!allChairs.Contains(mountable))
                            allChairs.Add(mountable);
                        if (!chairPosition.Contains(mountable.transform.position))
                            chairPosition.Add(mountable.transform.position);
                        //mountable.SetFlag(BaseEntity.Flags.Busy, true, true);
                        break;
                    }
                    else if (mountable is BaseVehicle && (mountable.name != null && mountable.name.Contains("sofa")))
                    {
                        sitting = true;
                        (mountable as BaseVehicle).WantsMount(npc.player);
                        npc.player.OverrideViewAngles(mountable.mountAnchor.transform.rotation.eulerAngles);
                        npc.player.eyes.NetworkUpdate(mountable.mountAnchor.transform.rotation);
                        npc.player.ClientRPCPlayer<Vector3>(null, npc.player, "ForcePositionTo", npc.player.transform.position);
                        if (!allChairs.Contains(mountable))
                            allChairs.Add(mountable);
                        if (!chairPosition.Contains(mountable.transform.position))
                            chairPosition.Add(mountable.transform.position);
                        break;
                    }
                }
            }

            public void Stand()
            {
                //if(CanSit() && sitting)
                if(sitting)
                {
#if DEBUG
                    Interface.Oxide.LogInfo($"HumanNPC {npc.player.displayName} trying to stand...");
#endif
//                    npc.Invoke("AllowMove",0);
                    var mounted = npc.player.GetMounted();
                    mounted.DismountPlayer(npc.player);
                    mounted.SetFlag(BaseEntity.Flags.Busy, false, false);
                    sitting = false;
                    if (allChairs.Contains(mounted))
                        allChairs.Remove(mounted);
                    if (chairPosition.Contains(mounted.transform.position))
                        chairPosition.Remove(mounted.transform.position);
                }
            }

            private float GetSpeed(float speed = -1)
            {
                if (sitting)
                    speed = 0;
                if (returning)
                    speed = 7;
                else if (speed == -1)
                    speed = npc.info.speed;

                if (IsSwimming())
                    speed = speed / 2f;

                return speed;
            }
            private void GetNextPath()
            {
                if (npc == null) npc = GetComponent<HumanPlayer>();

                if(CanSit() && sitting == false)
                {
                    Sit();
                }

                LastPos = Vector3.zero;
                if (cachedWaypoints == null)
                {
                    shouldMove = false;
                    return;
                }
                shouldMove = true;
                Interface.Oxide.CallHook("OnNPCPosition", npc.player, npc.player.transform.position);
                if (currentWaypoint + 1 >= cachedWaypoints.Count)
                {
                    UpdateWaypoints();
                    currentWaypoint = -1;
                }
                if (cachedWaypoints == null)
                {
                    shouldMove = false;
                    return;
                }
                
		
				currentWaypoint++;
                var wp = cachedWaypoints[currentWaypoint];

                SetMovementPoint(npc.player.transform.position, wp.Position, GetSpeed(wp.Speed));

                if (NoMoveInfo.ContainsKey(wp.Position))
                {
                    npc.DisableMove();
                    npc.Invoke("AllowMove", NoMoveInfo[wp.Position]);
                    return;
                }
			
		}

            public void SetMovementPoint(Vector3 startpos, Vector3 endpos, float s)
            {
                StartPos = startpos;

                if (endpos != Vector3.zero)
                {
                    EndPos = endpos;
                    EndPos.y = Math.Max(EndPos.y, TerrainMeta.HeightMap.GetHeight(EndPos));
                    if (StartPos != EndPos)
                        secondsToTake = Vector3.Distance(EndPos, StartPos) / s;
                    npc.LookTowards(EndPos);
                }
                else
                {
                    if (IsInvoking("PathFinding")) { CancelInvoke("PathFinding"); }
                }

                secondsTaken = 0f;
                waypointDone = 0f;
            }

            private bool HitChance(float chance = -1f)
            {
                if (chance < 0)
                    chance = npc.info.hitchance;
                return UnityEngine.Random.Range(1, 100) < (int)(chance * 100);
            }

            private void Move(Vector3 position, float speed = -1)
            {
                if (speed == -1)
                {
                    speed = npc.info.speed;
                }

                if (waypointDone >= 1f)
                {
                    if (pathFinding != null && pathFinding.Count > 0) pathFinding.RemoveAt(pathFinding.Count - 1);
                    waypointDone = 0f;
                }
                if (pathFinding == null || pathFinding.Count < 1) return;
                shouldMove = true;

                if (waypointDone == 0f) SetMovementPoint(position, pathFinding[pathFinding.Count - 1], GetSpeed(speed));
            }

            private void ProcessAttack(BaseCombatEntity entity)
            {
#if DEBUG
                Interface.Oxide.LogInfo("ProcessAttack: {0} -> {1}", npc.player.displayName, entity.name);
#endif
                if (entity != null && entity.IsAlive())
                {
                    //var c_attackDistance = Vector3.Distance(entity.transform.position, npc.player.transform.position);
                    var c_attackDistance = Vector3.Distance(entity.transform.position + new Vector3(0, 1.6f, 0), npc.player.transform.position + new Vector3(0, 1.6f, 0));
                    shouldMove = false;

                    bool validAttack = Vector3.Distance(LastPos, npc.player.transform.position) < npc.info.maxDistance && noPath < 5;

#if DEBUG
                    Interface.Oxide.LogInfo("  Entity: Type {0}, alive {1}, valid {2}", entity.GetType().FullName, entity.IsAlive(), validAttack);
#endif
                    if (validAttack)
                    {
                        bool range = false;
                        if(npc.info.follow)
                        {
                            range = c_attackDistance < npc.info.damageDistance;
                        }
                        else
                        {
                            range = c_attackDistance < npc.info.maxDistance;
                        }
                        var see = CanSee(npc, entity);
#if DEBUG
                        Interface.Oxide.LogInfo("  validAttack Entity: Type {0}, ranged {1}, cansee {2}", entity.GetType().FullName, range, see);
#endif
                        if (range && see)
                        {
                            AttemptAttack(entity);
                            return;
                        }
                        if (GetSpeed() <= 0)
                        {
                            npc.EndAttackingEntity();
                        }
                        else if(!npc.info.follow)
                        {
                        }
                        else
                        {
                            Move(npc.player.transform.position);
                        }
                    }
                    else
                    {
                        npc.EndAttackingEntity();
                    }
                }
                else
                {
                    npc.EndAttackingEntity();
                }
            }

            public void ProcessFollow(Vector3 target)
            {
#if DEBUG
                Interface.Oxide.LogInfo($"ProcessFollow() called for {target.ToString()}");
#endif
                var c_followDistance = Vector3.Distance(target, npc.player.transform.position);
                shouldMove = false;
#if DEBUG
                Interface.Oxide.LogInfo($"ProcessFollow() distance {c_followDistance.ToString()}");
#endif
                //if (c_followDistance > 0)// && Vector3.Distance(LastPos, npc.player.transform.position) < followDistance)// && noPath < 5)
				if (c_followDistance > followDistance && Vector3.Distance(LastPos, npc.player.transform.position) < npc.info.maxDistance && noPath < 5)
                {
                    Move(npc.player.transform.position, npc.info.speed);
                }
                else
                {
                    if (followEntity is BaseEntity)
                    {
#if DEBUG
                        Interface.Oxide.LogInfo($"ProcessFollow() bailing out - is BaseEntity");
#endif
                        npc.EndFollowingEntity(noPath < 5);
                    }
                    else if (targetPosition != Vector3.zero)
                    {
#if DEBUG
                        Interface.Oxide.LogInfo($"ProcessFollow() bailing out");
#endif
                        npc.EndGo(noPath < 5);
                    }
                }
            }

            public void PathFinding()
            {
                Vector3 target = Vector3.zero;

                if (attackEntity != null)
                {
                    //Vector3 diff = new Vector3(Core.Random.Range(-npc.info.attackDistance, npc.info.attackDistance), 0, Core.Random.Range(-npc.info.attackDistance, npc.info.attackDistance));
                    target = attackEntity.transform.position;// + diff;
                }
                else if (followEntity != null)
                {
                    target = followEntity.transform.position;
                }
                else if (targetPosition != Vector3.zero)
                {
                    target = targetPosition;
                }

                if (target != Vector3.zero)
                {
                    PathFinding(new Vector3(target.x, GetMoveY(target), target.z));
                }
            }

            public void PathFinding(Vector3 targetPos)
            {
                if (gameObject == null) return;
                if (IsInvoking("PathFinding")) { CancelInvoke("PathFinding"); }
                if (GetSpeed() <= 0) return;

                var temppathFinding = HumanNPC.PathFinding?.Go(npc.player.transform.position, targetPos);

                if (temppathFinding == null)
                {
                    if(pathFinding == null || pathFinding.Count == 0)
                    {
                        noPath++;
                    }
                    else
                    {
                        noPath = 0;
                    }
                    if(noPath < 5)
                    {
                        Invoke("PathFinding", 2);
                    }
                    else if (returning)
                    {
                        returning = false;
                        SetMovementPoint(npc.player.transform.position, LastPos, 7f);
                        secondsTaken = 0.01f;
                    }
                }
                else
                {
                    noPath = 0;

                    pathFinding = temppathFinding;
                    pathFinding.Reverse();
                    waypointDone = 0f;
                    Invoke("PathFinding", pathFinding.Count / GetSpeed(npc.info.speed));
                }
            }

            public void GetBackToLastPos()
            {
                if (npc.player.transform.position == LastPos) return;
                if (LastPos == Vector3.zero) LastPos = npc.info.spawnInfo.position;
                if (Vector3.Distance(npc.player.transform.position, LastPos) < 5)
                {
                    SetMovementPoint(npc.player.transform.position, LastPos, 7f);
                    secondsTaken = 0.01f;
                    return;
                }
                returning = true;
                npc.StartGo(LastPos);
            }

            public void Enable()
            {
                //if (GetSpeed() <= 0) return;
                enabled = true;
            }
            public void Disable()
            {
                enabled = false;
            }

            public float GetMoveY(Vector3 position)
            {
                if (IsSwimming())
                {
                    float point = TerrainMeta.WaterMap.GetHeight(position) - 0.65f;
                    float groundY = GetGroundY(position);
                    if (groundY > point)
                    {
                        return groundY;
                    }

                    return point - 0.65f;
                }

                return GetGroundY(position);
            }

            public float GetGroundY(Vector3 position)
            {
                position = position + Vector3.up;
                RaycastHit hitinfo;
                if (Physics.Raycast(position, Vector3Down, out hitinfo, 100f, groundLayer))
                {
                    return hitinfo.point.y;
                }
                return position.y - .5f;
            }

            public void CreateProjectileEffect(BaseCombatEntity target, BaseProjectile baseProjectile, float dmg, bool miss = false)
            {
                if (baseProjectile.primaryMagazine.contents <= 0)
                {
#if DEBUG
                    Interface.Oxide.LogInfo("Attack failed(empty): {0} - {1}", npc.player.displayName, attackEntity.name);
#endif
                    return;
                }
                var component = baseProjectile.primaryMagazine.ammoType.GetComponent<ItemModProjectile>();
                if (component == null)
                {
#if DEBUG
                    Interface.Oxide.LogInfo("Attack failed(Component): {0} - {1}", npc.player.displayName, attackEntity.name);
#endif
                    return;
                }
                npc.LookTowards(target.transform.position);

                var source = npc.player.transform.position + npc.player.GetOffset();
                if(baseProjectile.MuzzlePoint != null)
                {
                    source += Quaternion.LookRotation(target.transform.position - npc.player.transform.position) * baseProjectile.MuzzlePoint.position;
                }
                var dir = (target.transform.position + npc.player.GetOffset() - source).normalized;
                var vector32 = dir * (component.projectileVelocity * baseProjectile.projectileVelocityScale);

                Vector3 hit;
                RaycastHit raycastHit;
                if(Vector3.Distance(npc.player.transform.position, target.transform.position) < 0.5)
                {
                    hit = target.transform.position + npc.player.GetOffset(true);
                }
                else if(!Physics.SphereCast(source, .01f, vector32, out raycastHit, float.MaxValue, targetLayer))
                {
#if DEBUG
                    Interface.Oxide.LogInfo("Attack failed: {0} - {1}", npc.player.displayName, attackEntity.name);
#endif
                    return;
                }
                else
                {
                    hit = raycastHit.point;
                  //  target = raycastHit.GetCollider().GetComponent<BaseCombatEntity>();
#if DEBUG
                    Interface.Oxide.LogInfo("Attack failed: {0} - {1}", raycastHit.GetCollider().name, (Rust.Layer)raycastHit.GetCollider().gameObject.layer);
#endif
                    miss = miss || target == null;
                }
                baseProjectile.primaryMagazine.contents--;
                npc.ForceSignalAttack();
				
				if(baseProjectile.MuzzlePoint != null)
				{					
					npc.LookTowards(target.transform.position);
					Vector3 origin = baseProjectile.MuzzlePoint.transform.position - baseProjectile.MuzzlePoint.forward * 0.25f;
					Vector3 vector3 = baseProjectile.MuzzlePoint.transform.forward;
					vector32 = AimConeUtil.GetModifiedAimConeDirection(0.5f, vector3, true);
					
					Vector3 targetPos = origin + vector32 * 300f;
					baseProjectile.MuzzlePoint.transform.position = baseProjectile.MuzzlePoint.forward * 0.25f;

					if (!miss) ApplyDamage(target, target.transform.position, vector32, npc.player);
 
					baseProjectile.ServerUse(1f, 1f, baseProjectile.MuzzlePoint);
				
				}

                Vector3 dest;
                if (miss)
                {
                    dmg = 0;
                    dest = hit;
                }
                else
                {
                    dest = target.transform.position;
                }
					   
            }

		  private void ApplyDamage(BaseCombatEntity entity, Vector3 point, Vector3 normal, BaseCombatEntity target)
		  {
			float damageAmount = 15f * UnityEngine.Random.Range(0.9f, 1.1f);
			if (entity is BasePlayer && (UnityEngine.Object) entity != (UnityEngine.Object) target)
			  damageAmount *= 0.5f;

			HitInfo info = new HitInfo((BaseEntity) target, (BaseEntity) entity, DamageType.Bullet, damageAmount, point);
			entity.OnAttacked(info);
			if (!(entity is BasePlayer) && !(entity is BaseNpc))
			  return;
			Effect.server.ImpactEffect(new HitInfo()
			{
			  HitPositionWorld = point,
			  HitNormalWorld = -normal,
			  HitMaterial = StringPool.Get("Flesh")
			});
		  }

            public void AttemptAttack(BaseCombatEntity entity)
            {
                var weapon = firstWeapon as BaseProjectile;
                if (weapon != null)
                {
                    if (!reloading && weapon.primaryMagazine.contents <= 0)
                    {
                        reloading = true;
                        npc.player.SignalBroadcast(BaseEntity.Signal.Reload, string.Empty);
                        startedReload = Time.realtimeSinceStartup;
                        return;
                    }
                    if (reloading && Time.realtimeSinceStartup > startedReload + (npc.info.reloadDuration > 0 ? npc.info.reloadDuration : weapon.reloadTime))
                    {
                        reloading = false;
                        if (npc.info.needsAmmo)
                        {
                            weapon.TryReloadMagazine((IAmmoContainer)npc.player.inventory);
                            npc.player.inventory.ServerUpdate(0f);
                        }
                        else
                        {
                            weapon.primaryMagazine.contents = weapon.primaryMagazine.capacity;
                        }
                    }
                    if (reloading) return;
                }
                if (!(Time.realtimeSinceStartup > lastHit + npc.info.damageInterval)) return;
                lastHit = Time.realtimeSinceStartup;
                DoAttack(entity, !HitChance());
            }

            public void DoAttack(BaseCombatEntity target, bool miss = false)
            {
                if (npc == null) return;
                var weapon = firstWeapon as BaseProjectile;
                if (firstWeapon == null || (firstWeapon != null && (firstWeapon.IsDestroyed || weapon != null && weapon.primaryMagazine.contents == 0)))
                {
                    firstWeapon = npc.EquipFirstWeapon();
                    weapon = firstWeapon as BaseProjectile;
                    npc.SetActive(new ItemId());
                }

                var attackitem = firstWeapon?.GetItem();
                if (attackitem == null)
                {
                    npc.EndAttackingEntity();
                    return;
                }
                if (attackitem.uid != npc.player.svActiveItemID)
                    npc.SetActive(attackitem.uid);

                float dmg = npc.info.damageAmount * UnityEngine.Random.Range(0.8f, 1.2f);
                if (target is BaseNpc)
                    dmg *= 1.5f;
                else if (target is AutoTurret)
                    dmg *= 3f;

                if (weapon != null)
                {
                    //npc.ForceSignalGesture();
                    CreateProjectileEffect(target, weapon, dmg, miss);
                }
                else
                {
                    var hitInfo = new HitInfo(npc.player, target, DamageType.Stab, dmg, target.transform.position)
                    {
                        PointStart = npc.player.transform.position,
                        PointEnd = target.transform.position
                    };
                    target.SendMessage("OnAttacked", hitInfo, SendMessageOptions.DontRequireReceiver);
                    npc.ForceSignalAttack();
                }
            }
        }

        //////////////////////////////////////////////////////
        ///  class HumanPlayer : MonoBehaviour
        ///  MonoBehaviour: managed by UnityEngine
        /// Takes care of all the sub categories of the HumanNPCs
        //////////////////////////////////////////////////////
        public class HumanPlayer : MonoBehaviour
        {
            public HumanNPCInfo info;
            public HumanLocomotion locomotion;
            public HumanTrigger trigger;
            public ProtectionProperties protection;
			private HeldEntity heldEntity;
			private readonly List<NpcSound> _queuedSounds = new List<NpcSound>();
			private Coroutine QueuedRoutine { get; set; }
            //public InstrumentKeyController instrument;

            public BasePlayer player;

            public float lastMessage;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                protection = ScriptableObject.CreateInstance<ProtectionProperties>();
            }

            public void SetInfo(HumanNPCInfo info, bool update = false)
            {
                this.info = info;
                if (info == null) return;
                player.displayName = info.displayName;
                SetViewAngle(info.spawnInfo.rotation);
                player.syncPosition = true;
				if (info.permission != null)
				{
					if (info.permission != "" && info.permission.Contains("humannpc"))
					ins.permission.RegisterPermission(info.permission, ins);
				}
                if (!update)
                {
                    //player.xp = ServerMgr.Xp.GetAgent(info.userid);
                    player.stats = new PlayerStatistics(player);
                    player.userID = info.userid;
                    player.UserIDString = player.userID.ToString();
                    player.MovePosition(info.spawnInfo.position);
                    player.eyes = player.eyes ?? player.GetComponent<PlayerEyes>();
                    //player.eyes.position = info.spawnInfo.position + new Vector3(0, 1.6f, 0);
                    var newEyes = info.spawnInfo.position + new Vector3(0, 1.6f, 0);
                    player.eyes.position.Set(newEyes.x, newEyes.y, newEyes.z);
                    player.EndSleeping();
					if (info.playTune) PlayTune();
                    protection.Clear();
                    foreach (var pro in info.protections)
                        protection.Add(pro.Key, pro.Value);
                }
                if (locomotion != null) Destroy(locomotion);
                locomotion = player.gameObject.AddComponent<HumanLocomotion>();
                if (trigger != null) Destroy(trigger);
                trigger = player.gameObject.AddComponent<HumanTrigger>();
                lastMessage = Time.realtimeSinceStartup;
                DisableMove();
                AllowMove();
            }

            public void QueueSound(NpcSound data)
            {
                _queuedSounds.Add(data);
                if (QueuedRoutine == null)
                {
                    QueuedRoutine = InvokeHandler.Instance.StartCoroutine(RunTalker());
                }
            }
			
            private IEnumerator RunTalker()
            {
                while (_queuedSounds.Count != 0)
                {
                    NpcSound soundData = _queuedSounds[0];
                    _queuedSounds.RemoveAt(0);

                    foreach (byte[] data in soundData.Data)
                    {
						if (player == null) break;
                        SendSound(player.net.ID, data);
                        yield return new WaitForSeconds(0.07f);
                    }

                    yield return new WaitForSeconds(2f);
                }
				QueuedRoutine = null;
				ins.NpcTalking.Remove(player.userID);
            }
		
            private void SendSound(NetworkableId netId, byte[] data)
            {

                foreach (BasePlayer current in BasePlayer.activePlayerList)
                {
                    if (player == null) return;
                    if (current == null) continue;
                    float distance = Vector3.Distance(player.transform.position, current.transform.position);
                    if (distance > 100) continue;
                    if (current.IsConnected && Network.Net.sv.IsConnected())
                    {
                        NetWrite netWrite = Network.Net.sv.StartWrite();
                        netWrite.PacketID(Network.Message.Type.VoiceData);
                        netWrite.EntityID(netId);
                        netWrite.BytesWithSize(data);
                        netWrite.Send(new SendInfo(current.Connection)
                        {
                            priority = Network.Priority.Immediate
                        });
                    }
                }
            }

            public void PlayTune()
            {
				ins.NextTick(() =>
                {
					heldEntity = GetCurrentWeapon();
					if (heldEntity != null && heldEntity is InstrumentTool)
					{
						heldEntity.SetLightsOn(true);
						InvokeRepeating("PlayNote", 0.01f, 0.01f);
						heldEntity.SendNetworkUpdateImmediate(true);
						player.SendNetworkUpdateImmediate(true);
					}
				});
            }
            public void PlayNote()
            {
				if (heldEntity != null && player != null && heldEntity is InstrumentTool)
				{
					heldEntity.ServerUse();
				}
            }
			
            public void UpdateHealth(HumanNPCInfo info)
            {
                player.InitializeHealth(info.health, info.health);
                player.health = info.health;
            }

            public void Evade()
            {
                this.locomotion.Evade();
            }

            public void AllowMove()
            {
                locomotion?.Enable();
            }
            public void DisableMove()
            {
                locomotion?.Disable();
            }
            public void TemporaryDisableMove(float thetime = -1f)
            {
                if (thetime == -1f) thetime = info.stopandtalkSeconds;
                DisableMove();
                if (gameObject == null) return;
                if (IsInvoking("AllowMove")) CancelInvoke("AllowMove");
                Invoke("AllowMove", thetime);
            }
            public void EndAttackingEntity(bool trigger = true)
            {
                if (locomotion.gameObject != null && locomotion.IsInvoking("PathFinding")) locomotion.CancelInvoke("PathFinding");
                locomotion.noPath = 0;
                locomotion.shouldMove = true;
                if (trigger)
                {
                    Interface.Oxide.CallHook("OnNPCStopTarget", player, locomotion.attackEntity);
                }
                locomotion.attackEntity = null;
                player.health = info.health;
                locomotion.GetBackToLastPos();
                SetActive(new ItemId());
            }
            public void EndFollowingEntity(bool trigger = true)
            {
                if (locomotion.IsInvoking("PathFinding")) locomotion.CancelInvoke("PathFinding");

                locomotion.noPath = 0;
                locomotion.shouldMove = true;
                if (trigger)
                {
                    Interface.Oxide.CallHook("OnNPCStopTarget", player, locomotion.followEntity);
                }
                locomotion.followEntity = null;
            }

            public void EndGo(bool trigger = true)
            {
                if (locomotion.IsInvoking("PathFinding")) locomotion.CancelInvoke("PathFinding");

                locomotion.noPath = 0;
                locomotion.shouldMove = true;

                if (trigger)
                {
                    Interface.Oxide.CallHook("OnNPCStopGo", player, locomotion.targetPosition);
                }
                if (locomotion.returning)
                {
                    locomotion.returning = false;
                    locomotion.SetMovementPoint(player.transform.position, locomotion.LastPos, 7f);
                    locomotion.secondsTaken = 0.01f;
                }
                locomotion.targetPosition = Vector3.zero;
            }

            public void StartAttackingEntity(BaseCombatEntity entity)
            {
                if (locomotion.attackEntity != null && UnityEngine.Random.Range(0f, 1f) < 0.75f) return;
                if (Interface.Oxide.CallHook("OnNPCStartTarget", player, entity) == null)
                {
                    var item = GetFirstWeaponItem();
                    if (item != null)
                        SetActive(item.uid);
                    locomotion.attackEntity = entity;
                    locomotion.pathFinding = null;

                    if (locomotion.LastPos == Vector3.zero) locomotion.LastPos = player.transform.position;
                    if (gameObject != null && IsInvoking("AllowMove"))
                    {
                        CancelInvoke("AllowMove");
                        AllowMove();
                    }
                    locomotion.Invoke("PathFinding", 0);
                }
            }

            public void StartFollowingEntity(BaseEntity entity, string pname = "player")
            {
#if DEBUG
                Interface.Oxide.LogInfo($"StartFollowingEntity() called for {pname}");
#endif
                if (locomotion.targetPosition != Vector3.zero)
                {
                    EndGo(false);
                }
                player.SendNetworkUpdate();
                locomotion.followEntity = entity;
                locomotion.pathFinding = null;

                if (locomotion.LastPos == Vector3.zero) locomotion.LastPos = player.transform.position;
//                if (IsInvoking("AllowMove")) { CancelInvoke("AllowMove"); AllowMove(); }
                locomotion.Invoke("PathFinding", 0);
            }

            public void StartGo(Vector3 position)
            {
                if (locomotion.followEntity != null)
                {
                    EndFollowingEntity(false);
                }
                player.SendNetworkUpdate();
                locomotion.targetPosition = position;
                locomotion.pathFinding = null;

                if (locomotion.LastPos == Vector3.zero) locomotion.LastPos = player.transform.position;
                if (IsInvoking("AllowMove")) { CancelInvoke("AllowMove"); AllowMove(); }
                locomotion.Invoke("PathFinding", 0);
            }

            public HeldEntity GetCurrentWeapon()
            {
                foreach (Item item in player.inventory.containerBelt.itemList)
                {
                    BaseEntity heldEntity = item.GetHeldEntity();
                    if (heldEntity is HeldEntity && !heldEntity.HasFlag(BaseEntity.Flags.Disabled))
                        return (HeldEntity)heldEntity;
                }
                return null;
            }

            public Item GetFirstWeaponItem()
            {
                return GetFirstWeapon()?.GetItem();
            }

            public HeldEntity GetFirstWeapon()
            {
                foreach (Item item in player.inventory.containerBelt.itemList)
                {
                    if(item.CanBeHeld() && HasAmmo(item) && (item.info.category == ItemCategory.Weapon))
                    {
                        return item.GetHeldEntity() as HeldEntity;
                    }
                }
                return null;
            }

            public HeldEntity GetFirstTool()
            {
                foreach (Item item in player.inventory.containerBelt.itemList)
                {
                    if(item.CanBeHeld() && item.info.category == ItemCategory.Tool)
                    {
                        return item.GetHeldEntity() as HeldEntity;
                    }
                }
                return null;
            }

            public HeldEntity GetFirstMisc()
            {
                foreach (Item item in player.inventory.containerBelt.itemList)
                {
                    if(item.CanBeHeld() && item.info.category != ItemCategory.Tool && item.info.category != ItemCategory.Weapon)
                    {
                        return item.GetHeldEntity() as HeldEntity;
                    }
                }
                return null;
            }

            public HeldEntity GetFirstInstrument()
            {
                foreach (Item item in player.inventory.containerBelt.itemList)
                {
                    if(item.CanBeHeld() && item.info.category == ItemCategory.Fun)
                    {
                        return item.GetHeldEntity() as HeldEntity;
                    }
                }
                return null;
            }

            public List<Item> GetAmmo(Item item)
            {
                var ammos = new List<Item>();
                AmmoTypes ammoType;
                if (!ammoTypes.TryGetValue(item.info.shortname, out ammoType))
                    return ammos;
                player.inventory.FindAmmo(ammos, ammoType);
                return ammos;
            }

            public bool HasAmmo(Item item)
            {
                if (!info.needsAmmo) return true;
                var weapon = item.GetHeldEntity() as BaseProjectile;
                if (weapon == null) return true;
                return weapon.primaryMagazine.contents > 0 || weapon.primaryMagazine.CanReload((IAmmoContainer) player.inventory);
            }

            public void UnequipAll()
            {
                if (player.inventory?.containerBelt == null) return;
                foreach (Item item in player.inventory.containerBelt.itemList)
                {
                    if (item.CanBeHeld())
                        (item.GetHeldEntity() as HeldEntity)?.SetHeld(false);
                }
            }

            public HeldEntity EquipFirstWeapon()
            {
                HeldEntity weapon = GetFirstWeapon();
                if (weapon != null)
                {
                    UnequipAll();
                    weapon.SetHeld(true);
                }
                return weapon;
            }

            public HeldEntity EquipFirstTool()
            {
                HeldEntity tool = GetFirstTool();
                if (tool != null)
                {
                    UnequipAll();
                    tool.SetHeld(true);
                }
                return tool;
            }

            public HeldEntity EquipFirstMisc()
            {
                HeldEntity misc = GetFirstMisc();
                if (misc != null)
                {
                    UnequipAll();
                    misc.SetHeld(true);
                }
                return misc;
            }

            public HeldEntity EquipFirstInstrument()
            {
                HeldEntity misc = GetFirstInstrument();
                if (misc != null)
                {
                    UnequipAll();
                    misc.SetHeld(true);
                }
                return misc;
            }

            public void SetActive(ItemId id)
            {
                player.svActiveItemID = id;
                player.SendNetworkUpdate();
                player.SignalBroadcast(BaseEntity.Signal.Reload, string.Empty);
            }

            private void OnDestroy()
            {
                locomotion.Stand();
                Destroy(locomotion);
                Destroy(trigger);
                Destroy(protection);
            }

            public void LookTowards(Vector3 pos)
            {
                if (pos != player.transform.position)
                    SetViewAngle(Quaternion.LookRotation(pos - player.transform.position));
					//player.transform.LookAt(pos - player.transform.position);
					player.eyes.position.Set(pos.x, pos.y, pos.z);
			}

            public void ForceSignalGesture()
            {
                player.SignalBroadcast(BaseEntity.Signal.Gesture, "pickup_item");
            }

            public void ForceSignalAttack()
            {
                player.SignalBroadcast(BaseEntity.Signal.Attack, string.Empty);
            }

            public void SetViewAngle(Quaternion viewAngles)
            {
                if (viewAngles.eulerAngles == default(Vector3)) return;
                player.viewAngles = viewAngles.eulerAngles;
                player.SendNetworkUpdate();
            }
        }

        //////////////////////////////////////////////////////
        ///  class HumanNPCInfo
        ///  NPC information that will be saved inside the datafile
        ///  public => will be saved in the data file
        ///  non public => won't be saved in the data file
        //////////////////////////////////////////////////////
        public class HumanNPCInfo
        {
            public ulong userid;
            public string displayName;
            public bool invulnerability;
            public float health;
            public bool respawn;
            public float respawnSeconds;
            public SpawnInfo spawnInfo;
            public string waypoint;
            public float collisionRadius;
            public string spawnkit;
            public float damageAmount;
            public float damageDistance;
            public float damageInterval;
            public float attackDistance;
            public float maxDistance;
            public bool hostile;
            public float speed;
            public bool stopandtalk;
            public float stopandtalkSeconds;
            public bool enable;
            public bool lootable;
            public float hitchance;
            public float reloadDuration;
            public bool needsAmmo;
            public bool defend;
            public bool evade;
            public bool follow;
            public float evdist;
            public bool allowsit;
            public string musician;
			public bool playTune;
			public bool SoundOnEnter;
			public bool SoundOnUse;
            public float band = 0f;
			public string permission = "";
			public string Sound = "";
            public List<string> message_hello;
            public List<string> message_bye;
            public List<string> message_use;
            public List<string> message_hurt;
            public List<string> message_kill;
            public Dictionary<DamageType, float> protections = new Dictionary<DamageType, float>();

            public HumanNPCInfo(ulong userid, Vector3 position, Quaternion rotation)
            {
                this.userid = userid;
                displayName = "NPC";
                invulnerability = true;
                health = 50;
                hostile = false;
                needsAmmo = true;
                respawn = true;
                respawnSeconds = 60;
                spawnInfo = new SpawnInfo(position, rotation);
                collisionRadius = 10;
                damageDistance = 3;
                damageAmount = 10;
                attackDistance = 100;
                maxDistance = 200;
                hitchance = 0.75f;
                speed = 3;
                stopandtalk = true;
                stopandtalkSeconds = 3;
                enable = true;
                lootable = true;
                defend = false;
                evade = false;
                evdist = 0f;
                follow = true;
                allowsit = false;
                damageInterval = 2;
				playTune = false;

                for(var i = 0; i < (int)DamageType.LAST; i++)
                {
                    protections[(DamageType)i] = 0f;
                }
            }

            public HumanNPCInfo Clone(ulong userid)
            {
                return new HumanNPCInfo(userid, spawnInfo.position, spawnInfo.rotation)
                {
                    displayName = displayName,
                    invulnerability = invulnerability,
                    health = health,
                    respawn = respawn,
                    respawnSeconds = respawnSeconds,
                    waypoint = waypoint,
                    collisionRadius = collisionRadius,
                    spawnkit = spawnkit,
                    damageAmount = damageAmount,
                    damageDistance = damageDistance,
                    attackDistance = attackDistance,
                    maxDistance = maxDistance,
                    hostile = hostile,
                    speed = speed,
                    stopandtalk = stopandtalk,
                    stopandtalkSeconds = stopandtalkSeconds,
                    lootable = lootable,
                    defend = defend,
                    evade = evade,
                    follow = follow,
                    evdist = evdist,
                    allowsit = allowsit,
                    damageInterval = damageInterval,
					permission = permission,
					Sound = Sound,
                    message_hello = message_hello?.ToList(),
                    message_bye = message_bye?.ToList(),
                    message_use = message_use?.ToList(),
                    message_hurt = message_hurt?.ToList(),
                    message_kill = message_kill?.ToList(),
                    needsAmmo = needsAmmo,
                    hitchance = hitchance,
                    reloadDuration = reloadDuration,
					playTune = playTune,
					SoundOnEnter = SoundOnEnter,
					SoundOnUse = SoundOnUse,
                    protections = protections?.ToDictionary(p => p.Key, p => p.Value)
                };
            }
        }

        private class NPCEditor : MonoBehaviour
        {
            public BasePlayer player;
            public HumanPlayer targetNPC;
            private void Awake()
            {
                player = GetComponent<BasePlayer>();
            }
        }

        public static Dictionary<string, AmmoTypes> ammoTypes = new Dictionary<string, AmmoTypes>();
        //{
        //    {"bow.hunting", AmmoTypes.BOW_ARROW},
        //    {"crossbow", AmmoTypes.BOW_ARROW},
        //    {"pistol.eoka", AmmoTypes.HANDMADE_SHELL},
        //    {"pistol.semiauto", AmmoTypes.PISTOL_9MM},
        //    {"pistol.revolver", AmmoTypes.PISTOL_9MM},
        //    {"rifle.ak", AmmoTypes.RIFLE_556MM},
        //    {"rifle.bolt", AmmoTypes.RIFLE_556MM},
        //    {"shotgun.pump", AmmoTypes.SHOTGUN_12GUAGE},
        //    {"shotgun.waterpipe", AmmoTypes.HANDMADE_SHELL},
        //    {"smg.2", AmmoTypes.PISTOL_9MM},
        //    {"smg.thompson", AmmoTypes.PISTOL_9MM}
        //};

        private static Dictionary<string, BaseProjectile> weaponProjectile = new Dictionary<string, BaseProjectile>();

        private void Init()
        {
            ammoTypes = new Dictionary<string, AmmoTypes>();
            weaponProjectile = new Dictionary<string, BaseProjectile>();
			chat = configData.settings.Chat;
			TeamsNPC = configData.settings.NpcInTeams;
			RadiusNPC = configData.settings.NpcUseRadius;
			if (configData.settings.NpcUseRadius <= 0) { configData.settings.NpcUseRadius = 5.0f; SaveConfig(); }
            LoadData();
        }

        #region Config 	
        private ConfigData configData;
        class ConfigData
        {

            [JsonProperty(PropertyName = "Settings")]
            public Settings settings { get; set; }
			
            public class Settings
            {
				public string Chat{ get; set; }
				public bool NpcInTeams { get; set; }
				public float NpcUseRadius { get; set; }
			}					
           
            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                settings = new ConfigData.Settings
                {
					Chat = "<color=#FA58AC>{0}:</color> ",
					NpcInTeams = false,
					NpcUseRadius = 5.0f
				},	 			 
							
					Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(1, 0, 4))
                configData = baseConfig;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion
		
        private static bool GetBoolValue(string value)
        {
            if (value == null) return false;
            value = value.Trim().ToLower();
            switch (value)
            {
                case "t":
                case "true":
                case "1":
                case "yes":
                case "y":
                case "on":
                    return true;
                default:
                    return false;
            }
        }

        private void Unload()
        {
            if (QueuedSpawn != null)
                InvokeHandler.Instance.StopCoroutine(QueuedSpawn);

            var HumanNPCMono = UnityEngine.Object.FindObjectsOfType<HumanPlayer>();
            foreach (var mono in HumanNPCMono)
            {
                mono.locomotion.Stand();
                PrintWarning($"Deleting {mono.info.displayName} ({mono.info.userid})");
                mono.GetComponent<BasePlayer>().Kill();
            }

            var npcEditors = UnityEngine.Object.FindObjectsOfType<NPCEditor>();
            foreach (var gameObj in npcEditors)
            {
                UnityEngine.Object.Destroy(gameObj);
            }
            SaveData();
			
			foreach (var team in PlayersTeams)
			{
				RelationshipManager.ServerInstance.DisbandTeam(team.Value);
			}
        }

        private void SaveData()
        {
            if (storedData == null || !save) return;
            data.WriteObject(storedData);
            save = false;
        }

        private void LoadData()
        {
            data = Interface.Oxide.DataFileSystem.GetFile(Name + "/NpcData");
            data.Settings.ReferenceLoopHandling = ReferenceLoopHandling.Ignore;
            data.Settings.Converters = new JsonConverter[] { new SpawnInfoConverter(), new UnityQuaternionConverter(), new UnityVector3Converter() };

            try
            {
                storedData = data.ReadObject<StoredData>();
            }
            catch
            {
                storedData = new StoredData();
            }
            data.Clear();
            foreach (var thenpc in storedData.HumanNPCs)
                humannpcs[thenpc.userid] = thenpc;
        }

        //////////////////////////////////////////////////////
        ///  Oxide Hooks
        //////////////////////////////////////////////////////

        //////////////////////////////////////////////////////
        ///  OnServerInitialized()
        ///  called when the server is done being initialized
        //////////////////////////////////////////////////////
        private void OnServerInitialized()
        {
            if (QueuedSpawn != null)
                InvokeHandler.Instance.StopCoroutine(QueuedSpawn);

            ins = this;
            colBuffer = Vis.colBuffer;
            eyesPosition = new Vector3(0f, 0.5f, 0f);
            Vector3Down = new Vector3(0f, -1f, 0f);
            PathFinding = (PathFinding)plugins.Find(nameof(PathFinding));
            playerLayer = LayerMask.GetMask("Player (Server)");
            targetLayer = LayerMask.GetMask("Player (Server)", "AI", "Deployed", "Construction");
            groundLayer = LayerMask.GetMask("Construction", "Terrain", "World");

            foreach (var info in ItemManager.itemList)
            {
                var baseProjectile = info.GetComponent<ItemModEntity>()?.entityPrefab.Get().GetComponent<BaseProjectile>();
                if (baseProjectile == null) continue;
                weaponProjectile.Add(info.shortname, baseProjectile);

                var projectile = baseProjectile.primaryMagazine.ammoType.GetComponent<ItemModProjectile>();
                if (projectile != null && !ammoTypes.ContainsKey(info.shortname))
                {
                    ammoTypes.Add(info.shortname, projectile.ammoType);
                }
            }

            //RefreshAllNPC();
            RespawnAllNpc();
        }

        private void RespawnAllNpc() => QueuedSpawn = InvokeHandler.Instance.StartCoroutine(respawnAllNPC());

        private IEnumerator respawnAllNPC()
        {
            foreach (KeyValuePair<ulong, HumanNPCInfo> pair in humannpcs)
            {
                if (!pair.Value.enable) continue;
                SpawnOrRefresh(pair.Key);
                yield return new WaitForSeconds(0.2f);
            }
        }

        //////////////////////////////////////////////////////
        ///  OnServerSave()
        ///  called when a server performs a save
        //////////////////////////////////////////////////////
        private void OnServerSave() => SaveData();

        private void OnServerShutdown() => SaveData();

        //////////////////////////////////////////////////////
        /// OnPlayerInput(BasePlayer player, InputState input)
        /// Called when a plugin presses a button
        //////////////////////////////////////////////////////


        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (!input.WasJustPressed(BUTTON.USE)) return;
#if DEBUG
            Interface.Oxide.LogInfo("Use pressed: {0}", player.displayName);
#endif
            Quaternion currentRot;
            TryGetPlayerView(player, out currentRot);
            var hitpoints = Physics.RaycastAll(new Ray(player.transform.position + eyesPosition, currentRot * Vector3.forward), RadiusNPC, playerLayer);
            Array.Sort(hitpoints, (a, b) => a.distance == b.distance ? 0 : a.distance > b.distance ? 1 : -1);
            for (var i = 0; i < hitpoints.Length; i++)
            {
#if DEBUG
                Interface.Oxide.LogInfo("Raycast: {0} ({1})", player.displayName, hitpoints[i].collider.name);
#endif
                var humanPlayer = hitpoints[i].collider.GetComponentInParent<HumanPlayer>();
                if (humanPlayer != null)
                {
					if (humanPlayer.info.permission != null && humanPlayer.info.permission != "")
					{
						if (permission.UserHasPermission(player.UserIDString, humanPlayer.info.permission))
						{					
							if(humanPlayer.locomotion.sitting)
							{
								humanPlayer.locomotion.Stand();
							}
							if (humanPlayer.info.stopandtalk && humanPlayer.locomotion.attackEntity == null)
							{
								humanPlayer.LookTowards(player.transform.position);
								humanPlayer.TemporaryDisableMove();
							}
							if (humanPlayer.info.message_use != null && humanPlayer.info.message_use.Count != 0)
							{
								SendMessage(humanPlayer, player, GetRandomMessage(humanPlayer.info.message_use));
							}
							Interface.Oxide.CallHook("OnUseNPC", humanPlayer.player, player);
							if (!string.IsNullOrEmpty(humanPlayer.info.Sound))
							{
								if (humanPlayer.info.SoundOnUse)
								{
									if (NpcTalking.Contains(humanPlayer.player.userID)) return;
									if (FileExists(humanPlayer.info.Sound))
									{
										NpcTalking.Add(humanPlayer.player.userID);											
										humanPlayer.QueueSound(LoadDataSound(humanPlayer.info.Sound));
									}
								}
							}
							break;
						}
						else break;
					}
					else
					{
						if(humanPlayer.locomotion.sitting)
						{
							humanPlayer.locomotion.Stand();
						}
						if (humanPlayer.info.stopandtalk && humanPlayer.locomotion.attackEntity == null)
						{
							humanPlayer.LookTowards(player.transform.position);
							humanPlayer.TemporaryDisableMove();
						}
						if (humanPlayer.info.message_use != null && humanPlayer.info.message_use.Count != 0)
						{
							SendMessage(humanPlayer, player, GetRandomMessage(humanPlayer.info.message_use));
						}
						Interface.Oxide.CallHook("OnUseNPC", humanPlayer.player, player);
							if (!string.IsNullOrEmpty(humanPlayer.info.Sound))
							{
								if (humanPlayer.info.SoundOnUse)
								{
									if (NpcTalking.Contains(humanPlayer.player.userID)) return;
									if (FileExists(humanPlayer.info.Sound))
									{
										NpcTalking.Add(humanPlayer.player.userID);	
										humanPlayer.QueueSound(LoadDataSound(humanPlayer.info.Sound));
									}
								}
							}						
						break;					
					}
                }
            }
        }

        //////////////////////////////////////////////////////
        /// OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitinfo)
        /// Called when an entity gets attacked (can be anything, building, animal, player ..)
        //////////////////////////////////////////////////////
        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitinfo)
        {
            if (entity == null || hitinfo == null || entity.IsNpc) return;
            var humanPlayer = entity.GetComponent<HumanPlayer>();
            if(humanPlayer != null)
            {

				if (hitinfo?.Initiator != null && hitinfo.Initiator.ToString().Contains("fireball") && humanPlayer.info.invulnerability)
				{
                    hitinfo.DoHitEffects = false; 
					hitinfo.damageTypes?.ScaleAll(0);
					return;
				}

				if (hitinfo?.Initiator != null && (BaseCombatEntity)hitinfo?.Initiator == entity)
				{
                    hitinfo.damageTypes = new DamageTypeList();
                    hitinfo.DoHitEffects = false;
                    hitinfo.HitMaterial = 0;
					hitinfo.damageTypes?.ScaleAll(0);				
					return;
				}
#if DEBUG
                Interface.Oxide.LogInfo($"OnEntityTakeDamage(by {entity.name})");
#endif
				
                if(hitinfo?.Initiator != null && hitinfo.Initiator is BaseCombatEntity && !(hitinfo.Initiator is Barricade) && humanPlayer.info.defend)
                {	
						humanPlayer.StartAttackingEntity((BaseCombatEntity)hitinfo.Initiator);
				}

                if(humanPlayer.info.message_hurt != null && humanPlayer.info.message_hurt.Count != 0)
                {
                    if(hitinfo.InitiatorPlayer != null)
                    {
                        SendMessage(humanPlayer, hitinfo.InitiatorPlayer, GetRandomMessage(humanPlayer.info.message_hurt));
                    }
                }

				Interface.Oxide.CallHook("OnHitNPC", entity.GetComponent<BaseCombatEntity>(), hitinfo);
                if(humanPlayer.info.invulnerability)
                {
                    hitinfo.damageTypes = new DamageTypeList();
                    hitinfo.DoHitEffects = false;
                    hitinfo.HitMaterial = 0;
					hitinfo.damageTypes.ScaleAll(0);
                }
                else
                {
                    humanPlayer.protection.Scale(hitinfo?.damageTypes);
                }

                if(humanPlayer.locomotion.sitting)
                {
                    humanPlayer.locomotion.Stand();
                    humanPlayer.locomotion.Evade();
                }
                humanPlayer.locomotion.Evade();
            }
        }

        //////////////////////////////////////////////////////
        /// OnEntityDeath(BaseEntity entity, HitInfo hitinfo)
        /// Called when an entity gets killed (can be anything, building, animal, player ..)
        //////////////////////////////////////////////////////
		object CanDropActiveItem(BasePlayer player)
		{
			var humanPlayer = player.GetComponent<HumanPlayer>();
            if (humanPlayer?.info == null) return null;
			{
				if (!humanPlayer.info.lootable)
				return false;
			}
			return null;
		}

        private void OnEntityDeath(BaseEntity entity, HitInfo hitinfo)
        {
            var humanPlayer = entity.GetComponent<HumanPlayer>();
            if (humanPlayer?.info == null) return;
            if (!humanPlayer.info.lootable)
            {
				if (humanPlayer.player.inventory != null)
				foreach(var item in humanPlayer.player.inventory.containerBelt.itemList)
                {
                    item?.Remove();
                }
                humanPlayer.player.inventory?.Strip();
            }
            var player = hitinfo?.InitiatorPlayer;
            if (player != null)
            {
                if(humanPlayer.info.message_kill != null && humanPlayer.info.message_kill.Count > 0)
                {
                    SendMessage(humanPlayer, player, GetRandomMessage(humanPlayer.info.message_kill));
                }
                //if (humanPlayer.info.xp > 0)
                //    player.xp.Add(Definitions.Cheat, humanPlayer.info.xp);
            }
            Interface.Oxide.CallHook("OnKillNPC", entity.GetComponent<BasePlayer>(), hitinfo);
            if(humanPlayer.info.respawn)
            {
                timer.Once(humanPlayer.info.respawnSeconds, () => SpawnOrRefresh(humanPlayer.info.userid));
            }
        }

		private void CreatNpcTeam(BasePlayer player)
		{	
					RelationshipManager.ServerInstance.playerToTeam.Remove(player.userID);
					player.ClearTeam();		
					RelationshipManager.PlayerTeam team = RelationshipManager.ServerInstance.CreateTeam();
					RelationshipManager.PlayerTeam playerTeam = team;
					playerTeam.teamLeader = player.userID;

					if (!playerTeam.AddPlayer(player))
					{
						player.currentTeam = playerTeam.teamID;
						playerTeam.members.Add(player.userID);
						PlayersTeams.Add(player.currentTeam, team);
						player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
					}

		}

		private void AddNpcTeam(BasePlayer player, BasePlayer teamPlayer)
		{
			if (teamPlayer.currentTeam != null && teamPlayer.currentTeam != 0UL)
			{
				RelationshipManager.ServerInstance.playerToTeam.Remove(player.userID);
				player.ClearTeam();
				player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
				
				RelationshipManager.PlayerTeam team = RelationshipManager.ServerInstance.teams[teamPlayer.currentTeam];
				RelationshipManager.PlayerTeam playerTeam = team;
					if (!playerTeam.AddPlayer(player))
					{
						player.currentTeam = playerTeam.teamID;
						playerTeam.members.Add(player.userID);
						player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
					}
			}
		}
		
        private object CanLootPlayer(BasePlayer target, BasePlayer looter)
        {
            try
            {
                var humanPlayer = target.GetComponent<HumanPlayer>();
                if (humanPlayer != null && !humanPlayer.info.lootable)
                {
					
                    NextTick(looter.EndLooting);
                    return false;
                }
            }
            catch {}
            return null;
        }

        private void OnLootPlayer(BasePlayer looter, BasePlayer target)
        {
            if (humannpcs[target.userID] != null)
                Interface.Oxide.CallHook("OnLootNPC", looter.inventory.loot, target, target.userID);
        }

        private void OnLootEntity(BasePlayer looter, BaseEntity entity)
        {
            if (looter == null || !(entity is PlayerCorpse)) return;
            var userId = ((PlayerCorpse)entity).playerSteamID;
            if (humannpcs[userId] != null)
                Interface.Oxide.CallHook("OnLootNPC", looter.inventory.loot, entity, userId);
        }

        //////////////////////////////////////////////////////
        /// End of Oxide Hooks
        //////////////////////////////////////////////////////

        private Dictionary<ulong, HumanPlayer> cache = new Dictionary<ulong, HumanPlayer>();

        public HumanPlayer FindHumanPlayerByID(ulong userid)
        {
            HumanPlayer humanPlayer;
            if (cache.TryGetValue(userid, out humanPlayer))
                return humanPlayer;
            var allBasePlayer = Resources.FindObjectsOfTypeAll<HumanPlayer>();
            foreach (var humanplayer in allBasePlayer)
            {
                if (humanplayer.player.userID != userid) continue;
                cache[userid] = humanplayer;
                return humanplayer;
            }
            return null;
        }

        public HumanPlayer FindHumanPlayer(string nameOrId)
        {
            if (string.IsNullOrEmpty(nameOrId)) return null;
            var allBasePlayer = Resources.FindObjectsOfTypeAll<HumanPlayer>();
            foreach (var humanplayer in allBasePlayer)
            {
                if (!nameOrId.Equals(humanplayer.player.UserIDString) && !humanplayer.player.displayName.Contains(nameOrId, CompareOptions.OrdinalIgnoreCase)) continue;
                return humanplayer;
            }
            return null;
        }

        private BasePlayer FindPlayerByID(ulong userid)
        {
            var allBasePlayer = Resources.FindObjectsOfTypeAll<BasePlayer>();
            foreach (BasePlayer player in allBasePlayer)
            {
                if (player.userID == userid) return player;
            }
            return null;
        }

        private void RefreshAllNPC()
        {
            List<ulong> npcspawned = new List<ulong>();
            foreach (KeyValuePair<ulong, HumanNPCInfo> pair in humannpcs)
            {
                if (!pair.Value.enable) continue;
                npcspawned.Add(pair.Key);
                SpawnOrRefresh(pair.Key);
            }
        }

        private void SpawnOrRefresh(ulong userid)
        {
            BasePlayer findplayer = FindPlayerByID(userid);

            if (findplayer == null || findplayer.IsDestroyed)
            {
                cache.Remove(userid);
                SpawnNPC(userid, false);
            }
            else RefreshNPC(findplayer, false);
        }
		
        private void SpawnNPC(ulong userid, bool isediting)
        {
            HumanNPCInfo info;
            if (!humannpcs.TryGetValue(userid, out info)) return;
            if (!isediting && !info.enable) return;
            var newPlayer = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", info.spawnInfo.position, info.spawnInfo.rotation).ToPlayer();
            var humanPlayer = newPlayer.gameObject.AddComponent<HumanPlayer>();
            humanPlayer.SetInfo(info);
            newPlayer.Spawn();

            humanPlayer.UpdateHealth(info);
            cache[userid] = humanPlayer;
            UpdateInventory(humanPlayer);
            Interface.Oxide.CallHook("OnNPCRespawn", newPlayer);
			if (!TeamsNPC) PrintWarning($"Spawned NPC: {userid}");
			
			if (TeamsNPC)
			{
				if (!NewTeam)
				{
					NewTeam = true;
					TeamPlayer = newPlayer;
					TeamCount++;
					CreatNpcTeam(newPlayer);
					PrintWarning($"Spawned NPC: {userid} and made team leader");				
				}
				else if (TeamCount <= 7 && TeamPlayer != null)
				{
					TeamCount++;
					AddNpcTeam(newPlayer, TeamPlayer);
					PrintWarning($"Spawned NPC: {userid} and added to team");				
				}
				else
				{
					TeamCount = 1;
					TeamPlayer = newPlayer;
					CreatNpcTeam(newPlayer);
					PrintWarning($"Spawned NPC: {userid} team full creating another team");							
				}
			}
        }

        private void UpdateInventory(HumanPlayer humanPlayer)
        {
            humanPlayer.player.inventory.DoDestroy();
            humanPlayer.player.inventory.ServerInit(humanPlayer.player);
            if (!string.IsNullOrEmpty(humanPlayer.info.spawnkit))
            {
                //player.inventory.Strip();
                Kits?.Call("GiveKit", humanPlayer.player, humanPlayer.info.spawnkit);
                if (humanPlayer.EquipFirstWeapon() == null && humanPlayer.EquipFirstTool() == null)// && humanPlayer.EquipFirstInstrument() == null)
                {
                    humanPlayer.EquipFirstMisc();
                }
            }
            /*player.SV_ClothingChanged();
            if (humanPlayer.info.protections != null)
            {
                player.baseProtection.Clear();
                foreach (var protection in info.protections)
                    player.baseProtection.Add(protection.Key, protection.Value);
            }*/
            humanPlayer.player.inventory.ServerUpdate(0f);
        }

        private void KillNpc(BasePlayer player)
        {
            if (player.userID >= 76560000000000000L || player.userID <= 0L || player.IsDestroyed) return;
            cache.Remove(player.userID);
            player.KillMessage();
        }

        public void RefreshNPC(BasePlayer player, bool isediting)
        {
            HumanNPCInfo info;
            if (!humannpcs.TryGetValue(player.userID, out info)) return;
            KillNpc(player);
            if (!info.enable && !isediting)
            {
               // Puts($"NPC was killed because he is disabled: {player.userID}");
                return;
            }
            SpawnOrRefresh(player.userID);
        }

        public void UpdateNPC(BasePlayer player, bool isediting)
        {
            HumanNPCInfo info;
            if (!humannpcs.TryGetValue(player.userID, out info)) return;
            if (!info.enable && !isediting)
            {
                KillNpc(player);
               // Puts($"NPC was killed because he is disabled: {player.userID}");
                return;
            }
            if (player.GetComponent<HumanPlayer>() != null)
                UnityEngine.Object.Destroy(player.GetComponent<HumanPlayer>());
            var humanplayer = player.gameObject.AddComponent<HumanPlayer>();
            humanplayer.SetInfo(info, true);
            cache[player.userID] = humanplayer;
           // Puts("Refreshed NPC: " + player.userID);
        }

		private object CreateNPCHook(Vector3 position, Quaternion currentRot, string name = "NPC", ulong clone = 0, bool saved = true)
        {
            HumanPlayer humanPlayer = CreateNPC(position, currentRot, name, clone, saved);
			if (humanPlayer == null) return null;
			return humanPlayer.player;
        }
		
        public HumanPlayer CreateNPC(Vector3 position, Quaternion currentRot, string name = "NPC", ulong clone = 0, bool saved = true)
        {
            HumanNPCInfo npcInfo = null;
            var userId = (EncryptedValue<ulong>) (ulong)UnityEngine.Random.Range(41234564, 11474836478);
            if (clone != 0)
            {
                HumanNPCInfo tempInfo;
                if (humannpcs.TryGetValue(clone, out tempInfo))
                {
                    npcInfo = tempInfo.Clone(userId);
                    npcInfo.spawnInfo = new SpawnInfo(position, currentRot);
                }
            }
            if (npcInfo == null) npcInfo = new HumanNPCInfo(userId, position, currentRot);
            npcInfo.displayName = name;
            RemoveNPC(userId);

            humannpcs[userId] = npcInfo;
            storedData.HumanNPCs.Add(npcInfo);
            save = saved;

            SpawnNPC(userId, true);

            return FindHumanPlayerByID(userId);
        }

        public void RemoveNPC(ulong npcid)
        {
            if (humannpcs.ContainsKey(npcid))
            {
                storedData.HumanNPCs.Remove(humannpcs[npcid]);
                humannpcs[npcid] = null;
            }
            cache.Remove(npcid);
            var npc = FindHumanPlayerByID(npcid);
            if (npc?.player != null && !npc.player.IsDestroyed)
                npc.player.KillMessage();
        }

        private bool hasAccess(BasePlayer player)
        {
            if (player.net.connection.authLevel < 1)
            {
                SendReply(player, "You don't have access to this command");
                return false;
            }
            return true;
        }

        private bool TryGetPlayerView(BasePlayer player, out Quaternion viewAngle)
        {
            viewAngle = new Quaternion(0f, 0f, 0f, 0f);
            if (player.serverInput?.current == null) return false;
            viewAngle = Quaternion.Euler(player.serverInput.current.aimAngles);
            return true;
        }

        private bool TryGetClosestRayPoint(Vector3 sourcePos, Quaternion sourceDir, out object closestEnt, out Vector3 closestHitpoint)
        {
            Vector3 sourceEye = sourcePos + new Vector3(0f, 1.5f, 0f);
            Ray ray = new Ray(sourceEye, sourceDir * Vector3.forward);

            var hits = Physics.RaycastAll(ray);
            float closestdist = 999999f;
            closestHitpoint = sourcePos;
            closestEnt = false;
            for (var i = 0; i < hits.Length; i++)
            {
                var hit = hits[i];
                if (hit.collider.GetComponentInParent<TriggerBase>() == null && hit.distance < closestdist)
                {
                    closestdist = hit.distance;
                    closestEnt = hit.collider;
                    closestHitpoint = hit.point;
                }
            }

            if (closestEnt is bool) return false;
            return true;
        }

/*        private static bool CanSee(HumanPlayer npc, BaseEntity target)
        {
#if DEBUG
            Interface.Oxide.LogInfo($"CanSee(): {npc.transform.position} looking at {target.transform.position}");
#endif
            var source = npc.player;
			if (source == target) return false;
			var weapon = source.GetActiveItem()?.GetHeldEntity() as BaseProjectile;
            var pos = source.transform.position + source.GetOffset();
            if(weapon?.MuzzlePoint != null)
            {
                pos += Quaternion.LookRotation(target.transform.position - source.transform.position) * weapon.MuzzlePoint.position;
#if DEBUG
                Interface.Oxide.LogInfo($"CanSee(): MuzzlePoint NULL");
#endif
            }
            else
            {
#if DEBUG
                Interface.Oxide.LogInfo($"CanSee(): MuzzlePoint NOT null");
#endif
            }

			//if(Physics.Linecast(source.transform.position + new Vector3(0, 1.6f, 0), target.transform.position + new Vector3(0, 1.6f, 0), obstructionMask))
			if(Physics.Linecast(source.transform.position, target.transform.position, obstructionMask))
            {
#if DEBUG
                Interface.Oxide.LogInfo($"CanSee(): Blocked by some obstruction.");
#endif
                return false;
            }
            if(Vector3.Distance(source.transform.position, target.transform.position) <  npc.info.damageDistance)
            {
#if DEBUG
                Interface.Oxide.LogInfo($"CanSee(): In range!");
#endif
                //if(!IsLayerBlocked(target.transform.position, npc.info.attackDistance, obstructionMask))
                if(!IsLayerBlocked(target.transform.position, 10f, obstructionMask))
                {
                    npc.Evade();
                }

                npc.LookTowards(target.transform.position);
                return true;
            }
            List<BasePlayer> nearPlayers = new List<BasePlayer>();
            Vis.Entities<BasePlayer>(pos, npc.info.maxDistance, nearPlayers, playerMask);
            foreach (var player in nearPlayers)
            {
                if (player == target)
                {
#if DEBUG
                    Interface.Oxide.LogInfo($"CanSee(): I can see them!");
#endif
                    //if(!IsLayerBlocked(target.transform.position, npc.info.attackDistance, obstructionMask))
                    if(!IsLayerBlocked(target.transform.position, 10f, obstructionMask))
                    {
                        npc.Evade();
                    }

                    npc.LookTowards(target.transform.position);
                    return true;
                }
            }
#if DEBUG
            Interface.Oxide.LogInfo($"CanSee(): NOPE");
#endif
            return false;
        }
*/

		private static bool CanSee(HumanPlayer npc, BaseEntity target1)
        {
            var source = npc.player;
             RaycastHit raycastHit;
			 var target = target1 as BasePlayer;
			 var weapon = source.GetActiveItem()?.GetHeldEntity() as BaseProjectile;
			 if (weapon?.MuzzlePoint == null) return Vector3.Distance(source.transform.position, target1.transform.position) < 0.75;
			 if (target == null) return Vector3.Distance(source.transform.position, target1.transform.position) < 90f;
             var pos = source.eyes.position + source.GetOffset();
             var rayDirection = (target.transform.position + target.GetOffset() - new Vector3(0, 0.7f, 0)) - source.eyes.position;
			 if(!IsLayerBlocked(target.transform.position, 10f, obstructionMask))
             {
                npc.Evade();
             }
             if (Vector3.Distance(source.transform.position, target.transform.position) < 1f) // really close (front or behind), CanSee = true. If you want npc to hate being approached from too close
                 return true;
             if (Vector3.Angle(rayDirection, source.eyes.HeadForward()) < npc.info.attackDistance) // in the 180 front cone, CanSee = true
             { // Detect if player is within the field of view
                 if (Physics.Raycast(pos, rayDirection, out raycastHit))
                 {
                     if (raycastHit.GetCollider().GetComponent<BasePlayer>() == target)
                         return true;
                 }
             }
             return false;
        }
		
        private static string GetRandomMessage(List<string> messagelist) => messagelist[GetRandom(0, messagelist.Count)];
        private static int GetRandom(int min, int max) => UnityEngine.Random.Range(min, max);

        private List<string> ListFromArgs(string[] args, int from)
        {
            var newlist = new List<string>();
            for (var i = from; i < args.Length; i++)
                newlist.Add(args[i]);
            return newlist;
        }

        //////////////////////////////////////////////////////////////////////////////
        /// Chat Commands
        //////////////////////////////////////////////////////////////////////////////
        [ChatCommand("npc_add")]
        private void cmdChatNPCAdd(BasePlayer player, string command, string[] args)
        {
            if(!hasAccess(player)) return;
            if(player.GetComponent<NPCEditor>() != null)
            {
                SendReply(player, "NPC Editor: Already editing an NPC, say /npc_end first");
                return;
            }
            Quaternion currentRot;
            if(!TryGetPlayerView(player, out currentRot))
            {
                SendReply(player, "Couldn't get player rotation");
                return;
            }

            HumanPlayer humanPlayer;
            if(args.Length > 0)
            {
                ulong targetId;
                if (!ulong.TryParse(args[0], out targetId))
                {
                    SendReply(player, "/npc_add [TARGETID]");
                    return;
                }
                HumanNPCInfo tempInfo;
                if (!humannpcs.TryGetValue(targetId, out tempInfo))
                {
                    SendReply(player, "Couldn't find the NPC");
                    return;
                }
                humanPlayer = CreateNPC(player.transform.position, currentRot, "NPC", targetId);
            }
            else
            {
                humanPlayer = CreateNPC(player.transform.position, currentRot);
            }
            if(humanPlayer == null)
            {
                SendReply(player, "Couldn't spawn the NPC");
                return;
            }
            var npcEditor = player.gameObject.AddComponent<NPCEditor>();
            npcEditor.targetNPC = humanPlayer;
        }

        [ChatCommand("npc_way")]
        private void cmdChatNPCWay(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;

            HumanPlayer humanPlayer;
            if (args.Length == 0)
            {
                Quaternion currentRot;
                if (!TryGetPlayerView(player, out currentRot)) return;
                object closestEnt;
                Vector3 closestHitpoint;
                if (!TryGetClosestRayPoint(player.transform.position, currentRot, out closestEnt, out closestHitpoint)) return;
                humanPlayer = ((Collider)closestEnt).GetComponentInParent<HumanPlayer>();
                if (humanPlayer == null)
                {
                    SendReply(player, "This is not an NPC");
                    return;
                }
            }
            else if (args.Length > 0)
            {
                humanPlayer = FindHumanPlayer(args[0]);
                if (humanPlayer == null)
                {
                    ulong userid;
                    if (!ulong.TryParse(args[0], out userid))
                    {
                        SendReply(player, "/npc_way TargetId/Name");
                        return;
                    }
                    SpawnNPC(userid, true);
                    humanPlayer = FindHumanPlayerByID(userid);
                }
                if (humanPlayer == null)
                {
                    SendReply(player, "Couldn't Spawn the NPC");
                    return;
                }
            }
            else
            {
                SendReply(player, "You are not looking at an NPC or this userid doesn't exist");
                return;
            }
            if (humanPlayer.locomotion.cachedWaypoints == null)
            {
                SendReply(player, "The NPC has no waypoints");
                return;
            }
            var eyes = new Vector3(0, 1.6f, 0);
            var lastPos = humanPlayer.info.spawnInfo.position + eyes;
            for (var i = 0; i < humanPlayer.locomotion.cachedWaypoints.Count; i++)
            {
                var pos = humanPlayer.locomotion.cachedWaypoints[i].Position + eyes;
                //player.SendConsoleCommand("ddraw.sphere", 30f, Color.black, lastPos, .5f);
                player.SendConsoleCommand("ddraw.line", 30f, i % 2 == 0 ? Color.blue : Color.red, lastPos, pos);
                lastPos = pos;
            }
        }

        [ChatCommand("npc_edit")]
        private void cmdChatNPCEdit(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (player.GetComponent<NPCEditor>() != null)
            {
                SendReply(player, "NPC Editor: Already editing an NPC, say /npc_end first");
                return;
            }

            HumanPlayer humanPlayer;
            if (args.Length == 0)
            {
                Quaternion currentRot;
                if (!TryGetPlayerView(player, out currentRot)) return;
                object closestEnt;
                Vector3 closestHitpoint;
                if (!TryGetClosestRayPoint(player.transform.position, currentRot, out closestEnt, out closestHitpoint)) return;
                humanPlayer = ((Collider)closestEnt).GetComponentInParent<HumanPlayer>();
                if (humanPlayer == null)
                {
                    SendReply(player, "This is not an NPC");
                    return;
                }
            }
            else if (args.Length > 0)
            {
                humanPlayer = FindHumanPlayer(args[0]);
                if (humanPlayer == null)
                {
                    ulong userid;
                    if (!ulong.TryParse(args[0], out userid))
                    {
                        SendReply(player, "/npc_edit TargetId/Name");
                        return;
                    }
                    SpawnNPC(userid, true);
                    humanPlayer = FindHumanPlayerByID(userid);
                }
                if (humanPlayer == null)
                {
                    SendReply(player, "Couldn't Spawn the NPC");
                    return;
                }
            }
            else
            {
                SendReply(player, "You are not looking at an NPC or this userid doesn't exist");
                return;
            }

            var npceditor = player.gameObject.AddComponent<NPCEditor>();
            npceditor.targetNPC = humanPlayer;
            SendReply(player, $"NPC Editor: Start Editing {npceditor.targetNPC.player.displayName} - {npceditor.targetNPC.player.userID}");
        }

        [ChatCommand("npc_list")]
        private void cmdChatNPCList(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (humannpcs.Count == 0)
            {
                SendReply(player, "No NPC created yet");
                return;
            }

            SendReply(player, "==== NPCs ====");
            foreach (var pair in humannpcs) SendReply(player, $"{pair.Key} - {pair.Value.displayName} - {pair.Value.spawnInfo.ShortString()} {(pair.Value.enable ? "" : "- Disabled")}");
        }

        [ChatCommand("npc")]
        private void cmdChatNPC(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            var npcEditor = player.GetComponent<NPCEditor>();
            if (npcEditor == null)
            {
                SendReply(player, "NPC Editor: You need to be editing an NPC, say /npc_add or /npc_edit");
                return;
            }
            if (args.Length == 0)
            {
                SendReply(player, "<color=#81F781>/npc attackdistance</color><color=#F2F5A9> XXX </color>=> <color=#D8D8D8>Distance between him and the target needed for the NPC to ignore the target and go back to spawn</color>");
                SendReply(player, "<color=#81F781>/npc bye</color> reset/<color=#F2F5A9>\"TEXT\" \"TEXT2\" \"TEXT3\" </color>=><color=#D8D8D8> Dont forgot the \", this is what NPC with say when a player gets away, multiple texts are possible</color>");
                SendReply(player, "<color=#81F781>/npc damageamount</color> <color=#F2F5A9>XXX </color>=> <color=#D8D8D8>Damage done by that NPC when he hits a player</color>");
                SendReply(player, "<color=#81F781>/npc damagedistance</color> <color=#F2F5A9>XXX </color>=> <color=#D8D8D8>Min distance for the NPC to hit a player (3 is default, maybe 20-30 needed for snipers?)</color>");
                SendReply(player, "<color=#81F781>/npc damageinterval</color> <color=#F2F5A9>XXX </color>=> <color=#D8D8D8>Time to wait before attacking again (2 seconds is default)</color>");
                SendReply(player, "<color=#81F781>/npc enable</color> <color=#F2F5A9>true</color>/<color=#F6CECE>false</color><color=#D8D8D8>Enable/Disable the NPC, maybe save it for later?</color>");
                SendReply(player, "<color=#81F781>/npc health</color> <color=#F2F5A9>XXX </color>=> <color=#D8D8D8>To set the Health of the NPC</color>");
                SendReply(player, "<color=#81F781>/npc hello</color> <color=#F6CECE>reset</color>/<color=#F2F5A9>\"TEXT\" \"TEXT2\" \"TEXT3\" </color>=> <color=#D8D8D8>Dont forgot the \", this what will be said when the player gets close to the NPC</color>");
                SendReply(player, "<color=#81F781>/npc hostile</color> <color=#F2F5A9>true</color>/<color=#F6CECE>false</color> <color=#F2F5A9>XX </color>=> <color=#D8D8D8>To set it if the NPC is Hostile</color>");
                SendReply(player, "<color=#81F781>/npc hurt</color> <color=#F6CECE>reset</color>/<color=#F2F5A9>\"TEXT\" \"TEXT2\" \"TEXT3\"</color> => <color=#D8D8D8>Dont forgot the \", set a message to tell the player when he hurts the NPC</color>");
                SendReply(player, "<color=#81F781>/npc invulnerable</color> <color=#F2F5A9>true</color>/<color=#F6CECE>false </color>=> <color=#D8D8D8>To set the NPC invulnerable or not</color>");
                SendReply(player, "<color=#81F781>/npc kill</color> <color=#F6CECE>reset</color>/<color=#F2F5A9>\"TEXT\" \"TEXT2\" \"TEXT3\" </color>=> <color=#D8D8D8>Dont forgot the \", set a message to tell the player when he kills the NPC</color>");
                SendReply(player, "<color=#81F781>/npc kit</color> <color=#F6CECE>reset</color>/<color=#F2F5A9>\"KitName\" </color>=> <color=#D8D8D8>To set the kit of this NPC, requires the Kit plugin</color>");
                SendReply(player, "<color=#81F781>/npc lootable</color> <color=#F2F5A9>true</color>/<color=#F6CECE>false</color> <color=#F2F5A9>XX </color>=> <color=#D8D8D8>To set it if the NPC corpse is lootable or not</color>");
                SendReply(player, "<color=#81F781>/npc maxdistance</color> <color=#F2F5A9>XXX </color>=><color=#D8D8D8> Max distance from the spawn point that the NPC can run from (while attacking a player)</color>");
                SendReply(player, "<color=#81F781>/npc name</color> <color=#F2F5A9>\"THE NAME\"</color> =><color=#D8D8D8> To set a name to the NPC</color>");
                SendReply(player, "<color=#81F781>/npc radius</color> <color=#F2F5A9>XXX</color> =><color=#D8D8D8> Radius of which the NPC will detect the player</color>");
                SendReply(player, "<color=#81F781>/npc respawn</color> <color=#F2F5A9>true</color>/<color=#F6CECE>false</color> <color=#F2F5A9>XX </color>=> <color=#D8D8D8>To set it to respawn on death after XX seconds, default is instant respawn</color>");
                SendReply(player, "<color=#81F781>/npc spawn</color> <color=#F2F5A9>\"new\" </color>=> <color=#D8D8D8>To set the new spawn location</color>");
                SendReply(player, "<color=#81F781>/npc speed</color><color=#F2F5A9> XXX </color>=> <color=#D8D8D8>To set the NPC running speed (while chasing a player)</color>");
                SendReply(player, "<color=#81F781>/npc stopandtalk</color> <color=#F2F5A9>true</color>/<color=#F6CECE>false</color> XX <color=#F2F5A9>XX </color>=> <color=#D8D8D8>To choose if the NPC should stop & look at the player that is talking to him</color>");
                SendReply(player, "<color=#81F781>/npc use</color> <color=#F6CECE>reset</color>/<color=#F2F5A9>\"TEXT\" \"TEXT2\" \"TEXT3\"</color> => <color=#D8D8D8>Dont forgot the \", this what will be said when the player presses USE on the NPC</color>");
                SendReply(player, "<color=#81F781>/npc waypoints</color> <color=#F6CECE>reset</color>/<color=#F2F5A9>\"Waypoint list Name\" </color>=> <color=#D8D8D8>To set waypoints of an NPC, /npc_help for more information</color>");
				SendReply(player, "<color=#81F781>/npc sound</color> <color=#F2F5A9>\" Sound file name\" </color>=> <color=#D8D8D8>To set sound file created with /npc_sound</color>");
				return;
            }
            var param = args[0].ToLower();
            if (args.Length == 1)
            {
                string message;
                switch (param)
                {
                    case "name":
                        message = $"This NPC name is: {npcEditor.targetNPC.info.displayName}";
                        break;
                    case "enable":
                    case "enabled":
                        message = $"This NPC enabled: {npcEditor.targetNPC.info.enable}";
                        break;
                    case "invulnerable":
                    case "invulnerability":
                        message = $"This NPC invulnerability is set to: {npcEditor.targetNPC.info.invulnerability}";
                        break;
                    case "lootable":
                        message = $"This NPC lootable is set to: {npcEditor.targetNPC.info.lootable}";
                        break;
                    case "hostile":
                        message = $"This NPC hostility is set to: {npcEditor.targetNPC.info.hostile}";
                        break;
                    case "defend":
                        message = $"This NPC defend is set to: {npcEditor.targetNPC.info.defend}";
                        break;
                    case "evade":
                        message = $"This NPC evade is set to: {npcEditor.targetNPC.info.evade}";
                        break;
                    case "evdist":
                        message = $"This NPC evade distance is set to: {npcEditor.targetNPC.info.evade}";
                        break;
                    case "follow":
                        message = $"This NPC follow is set to: {npcEditor.targetNPC.info.follow}";
                        break;
                    case "allowsit":
                        message = $"This NPC allowsit is set to: {npcEditor.targetNPC.info.allowsit}";
                        break;
                    case "needsammo":
                        message = $"This NPC needsAmmo is set to: {npcEditor.targetNPC.info.needsAmmo}";
                        break;
                    case "health":
                        message = $"This NPC Initial health is set to: {npcEditor.targetNPC.info.health}";
                        break;
                    case "attackdistance":
                        message = $"This Max Attack Distance is: {npcEditor.targetNPC.info.attackDistance}";
                        break;
                    case "damageamount":
                        message = $"This Damage amount is: {npcEditor.targetNPC.info.damageAmount}";
                        break;
                    case "damageinterval":
                        message = $"This Damage interval is: {npcEditor.targetNPC.info.damageInterval} seconds";
                        break;
                    case "maxdistance":
                        message = $"The Max Distance from spawn is: {npcEditor.targetNPC.info.maxDistance}";
                        break;
                    case "damagedistance":
                        message = $"This Damage distance is: {npcEditor.targetNPC.info.damageDistance}";
                        break;
                    case "radius":
                        message = $"This NPC Collision radius is set to: {npcEditor.targetNPC.info.collisionRadius}";
                        break;
                    case "respawn":
                        message = $"This NPC Respawn is set to: {npcEditor.targetNPC.info.respawn} after {npcEditor.targetNPC.info.respawnSeconds} seconds";
                        break;
                    case "spawn":
                        message = $"This NPC Spawn is set to: {npcEditor.targetNPC.info.spawnInfo.String()}";
                        break;
                    case "speed":
                        message = $"This NPC Chasing speed is: {npcEditor.targetNPC.info.speed}";
                        break;
                    case "playtune":
                        message = $"This NPC will play tune: {npcEditor.targetNPC.info.playTune}";
                        break;
                    case "sound":
                        if (string.IsNullOrEmpty(npcEditor.targetNPC.info.Sound))
                            message = "No sound file set";
                        else
                            message = $"This NPC will play sound file: {npcEditor.targetNPC.info.Sound}";
                        break;						
                    case "stopandtalk":
                        message = $"This NPC stop to talk is set to: {npcEditor.targetNPC.info.stopandtalk} for {npcEditor.targetNPC.info.stopandtalkSeconds} seconds";
                        break;
                    case "waypoints":
                    case "waypoint":
                        message = string.IsNullOrEmpty(npcEditor.targetNPC.info.waypoint) ? "No waypoints set for this NPC yet" : $"This NPC waypoints are: {npcEditor.targetNPC.info.waypoint}";
                        break;
                    case "kit":
                    case "kits":
                        message = string.IsNullOrEmpty(npcEditor.targetNPC.info.spawnkit) ? "No spawn kits set for this NPC yet" : $"This NPC spawn kit is: {npcEditor.targetNPC.info.spawnkit}";
                        break;
                    case "hello":
                        if (npcEditor.targetNPC.info.message_hello == null || (npcEditor.targetNPC.info.message_hello.Count == 0))
                            message = "No hello message set yet";
                        else
                            message = $"This NPC will say hi: {npcEditor.targetNPC.info.message_hello.Count} different messages";
                        break;
                    case "bye":
                        if (npcEditor.targetNPC.info.message_bye == null || npcEditor.targetNPC.info.message_bye.Count == 0)
                            message = "No bye message set yet";
                        else
                            message = $"This NPC will say bye: {npcEditor.targetNPC.info.message_bye.Count} difference messages ";
                        break;
                    case "use":
                        if (npcEditor.targetNPC.info.message_use == null || npcEditor.targetNPC.info.message_use.Count == 0)
                            message = "No bye message set yet";
                        else
                            message = $"This NPC will say bye: {npcEditor.targetNPC.info.message_use.Count} different messages";
                        break;
                    case "hurt":
                        if (npcEditor.targetNPC.info.message_hurt == null || npcEditor.targetNPC.info.message_hurt.Count == 0)
                            message = "No hurt message set yet";
                        else
                            message = $"This NPC will say ouch: {npcEditor.targetNPC.info.message_hurt.Count} different messages";
                        break;
                    case "kill":
                        if (npcEditor.targetNPC.info.message_kill == null || npcEditor.targetNPC.info.message_kill.Count == 0)
                            message = "No kill message set yet";
                        else
                            message = $"This NPC will say a death message: {npcEditor.targetNPC.info.message_kill.Count} different messages";
                        break;
                    case "hitchance":
                        message = $"This NPC hit chance is: {npcEditor.targetNPC.info.hitchance}";
                        break;
                    case "reloadduration":
                        message = $"This NPC reload duration is: {npcEditor.targetNPC.info.reloadDuration}";
                        break;
                    case "stand":
                        message = $"Standing!";
                        npcEditor.targetNPC.info.allowsit = false;
                        npcEditor.targetNPC.locomotion.Stand();
                        break;
                    case "sit":
                        message = $"Sitting!";
                        npcEditor.targetNPC.info.allowsit = true;
                        npcEditor.targetNPC.locomotion.Sit();
                        break;
                    case "info":
                        message = $" {npcEditor.targetNPC.info.displayName}\n"
                            + $"\tenabled: {npcEditor.targetNPC.info.enable}\n"
                            + $"\tinvulnerability: {npcEditor.targetNPC.info.invulnerability}\n"
                            + $"\tlootable: {npcEditor.targetNPC.info.lootable}\n"
                            + $"\thostility: {npcEditor.targetNPC.info.hostile}\n"
                            + $"\tdefend: {npcEditor.targetNPC.info.defend}\n"
                            + $"\tevade: {npcEditor.targetNPC.info.evade}\n"
                            + $"\tevdist: {npcEditor.targetNPC.info.evdist}\n"
                            + $"\tfollow: {npcEditor.targetNPC.info.follow}\n"
                            + $"\tallowsit: {npcEditor.targetNPC.info.allowsit}\n"
                            + $"\tsitting: {npcEditor.targetNPC.locomotion.sitting}\n"
                            + $"\tneedsAmmo: {npcEditor.targetNPC.info.needsAmmo}\n"
                            + $"\tinitial health: {npcEditor.targetNPC.info.health}\n"
                            + $"\tmax attack distance: {npcEditor.targetNPC.info.attackDistance}\n"
                            + $"\tdamage amount: {npcEditor.targetNPC.info.damageAmount}\n"
                            + $"\tdamage interval: {npcEditor.targetNPC.info.damageInterval} seconds\n"
                            + $"\tmax Distance from spawn: {npcEditor.targetNPC.info.maxDistance}\n"
                            + $"\tdamage distance: {npcEditor.targetNPC.info.damageDistance}\n"
                            + $"\tcollision radius: {npcEditor.targetNPC.info.collisionRadius}\n"
                            + $"\trespawn: {npcEditor.targetNPC.info.respawn} after {npcEditor.targetNPC.info.respawnSeconds} seconds\n"
                            + $"\tspawn:\n\t\t{npcEditor.targetNPC.info.spawnInfo.String()}\n"
                            + $"\tposition:\n\t\t{npcEditor.targetNPC.player.transform.position.ToString()}\n"
                            + $"\tchasing speed: {npcEditor.targetNPC.info.speed}\n"
							+ $"\tplaytune: {npcEditor.targetNPC.info.playTune}\n"
							+ $"\tstop to talk: {npcEditor.targetNPC.info.stopandtalk} for {npcEditor.targetNPC.info.stopandtalkSeconds} seconds\n";
                        if(npcEditor.targetNPC.info.waypoint == null)
                        {
                            message += "\tNo waypoints";
                        }
                        else
                        {
                            message += $"\twaypoints: {npcEditor.targetNPC.info.waypoint}\n";
                        }
                        if(npcEditor.targetNPC.info.spawnkit == null)
                        {
                            message += "\tNo kits\n";
                        }
                        else
                        {
                            message += $"\tspawn kit: {npcEditor.targetNPC.info.spawnkit}\n";
                        }
                        if (npcEditor.targetNPC.info.message_hello == null || (npcEditor.targetNPC.info.message_hello.Count == 0))
                        {
                            message += "\tNo hello message set yet\n";
                        }
                        else
                        {
                            message += $"\twill say hi: {npcEditor.targetNPC.info.message_hello.Count} different messages\n";
                        }
                        if (npcEditor.targetNPC.info.message_bye == null || npcEditor.targetNPC.info.message_bye.Count == 0)
                        {
                            message += "\tNo bye message set yet\n";
                        }
                        else
                        {
                            message += $"\twill say bye: {npcEditor.targetNPC.info.message_bye.Count} difference messages\n";
                        }
                        if (npcEditor.targetNPC.info.message_use == null || npcEditor.targetNPC.info.message_use.Count == 0)
                        {
                            message += "\tNo bye message set yet\n";
                        }
                        else
                        {
                            message += $"\twill say bye: {npcEditor.targetNPC.info.message_use.Count} different messages\n";
                        }
                        if (npcEditor.targetNPC.info.message_hurt == null || npcEditor.targetNPC.info.message_hurt.Count == 0)
                        {
                            message += "\tNo hurt message set yet\n";
                        }
                        else
                        {
                            message += $"\twill say ouch: {npcEditor.targetNPC.info.message_hurt.Count} different messages\n";
                        }
                        if (npcEditor.targetNPC.info.message_kill == null || npcEditor.targetNPC.info.message_kill.Count == 0)
                        {
                            message += "\tNo kill message set yet\n";
                        }
                        else
                        {
                            message += $"\twill say a death message: {npcEditor.targetNPC.info.message_kill.Count} different messages\n";
                        }
                        message += $"\thit chance: {npcEditor.targetNPC.info.hitchance}\n";
                        message += $"\treload duration: {npcEditor.targetNPC.info.reloadDuration}\n";

                        SendReply(player, $"NPC Info: {message}\n\n");
                        return;
                    default:
                        message = "Wrong Argument.  /npc for more information.";
                        break;
                }
                SendReply(player, message);
                return;
            }
            switch (param)
            {
                case "name":
                    npcEditor.targetNPC.info.displayName = args[1];
                    break;
                case "enable":
                case "enabled":
                    npcEditor.targetNPC.info.enable = GetBoolValue(args[1]);
                    break;
                case "invulnerable":
                case "invulnerability":
                    npcEditor.targetNPC.info.invulnerability = GetBoolValue(args[1]);
                    break;
                case "lootable":
                    npcEditor.targetNPC.info.lootable = GetBoolValue(args[1]);
                    break;
                case "hostile":
                    npcEditor.targetNPC.info.hostile = GetBoolValue(args[1]);
                    break;
				case "playtune":
                    npcEditor.targetNPC.info.playTune = GetBoolValue(args[1]);
                    break;	
                case "defend":
                    npcEditor.targetNPC.info.defend = GetBoolValue(args[1]);
                    break;
                case "evade":
                    npcEditor.targetNPC.info.evade = GetBoolValue(args[1]);
                    break;
                case "evdist":
                    npcEditor.targetNPC.info.evdist = Convert.ToSingle(args[1]);
                    break;
                case "follow":
                    npcEditor.targetNPC.info.follow = GetBoolValue(args[1]);
                    break;
                case "allowsit":
                    npcEditor.targetNPC.info.allowsit = GetBoolValue(args[1]);
                    break;
                case "needsammo":
                    npcEditor.targetNPC.info.needsAmmo = GetBoolValue(args[1]);
                    break;
                case "health":
                    npcEditor.targetNPC.info.health = Convert.ToSingle(args[1]);
                    break;
                case "attackdistance":
                    npcEditor.targetNPC.info.attackDistance = Convert.ToSingle(args[1]);
                    break;
                case "damageamount":
                    npcEditor.targetNPC.info.damageAmount = Convert.ToSingle(args[1]);
                    break;
                case "damageinterval":
                    npcEditor.targetNPC.info.damageInterval = Convert.ToSingle(args[1]);
                    break;
                case "maxdistance":
                    npcEditor.targetNPC.info.maxDistance = Convert.ToSingle(args[1]);
                    break;
                case "damagedistance":
                    npcEditor.targetNPC.info.damageDistance = Convert.ToSingle(args[1]);
                    break;
                case "radius":
                    npcEditor.targetNPC.info.collisionRadius = Convert.ToSingle(args[1]);
                    break;
                case "respawn":
                    npcEditor.targetNPC.info.respawn = GetBoolValue(args[1]);
                    npcEditor.targetNPC.info.respawnSeconds = 60;
                    if (args.Length > 2)
                        npcEditor.targetNPC.info.respawnSeconds = Convert.ToSingle(args[2]);
                    break;
                case "spawn":
                    Quaternion currentRot;
                    TryGetPlayerView(player, out currentRot);
                    var newSpawn = new SpawnInfo(player.transform.position, currentRot);
                    npcEditor.targetNPC.info.spawnInfo = newSpawn;
                    SendReply(player, $"This NPC Spawn now is set to: {newSpawn.String()}");
                    break;
                case "speed":
                    npcEditor.targetNPC.info.speed = Convert.ToSingle(args[1]);
                    break;
                case "stopandtalk":
                    npcEditor.targetNPC.info.stopandtalk = GetBoolValue(args[1]);
                    npcEditor.targetNPC.info.stopandtalkSeconds = 3;
                    if (args.Length > 2)
                        npcEditor.targetNPC.info.stopandtalkSeconds = Convert.ToSingle(args[2]);
                    break;
                case "waypoints":
                case "waypoint":
                    var name = args[1].ToLower();
                    if (name == "reset")
                        npcEditor.targetNPC.info.waypoint = null;
                    else if (Interface.Oxide.CallHook("GetWaypointsList", name) == null)
                    {
                        SendReply(player, "This waypoint doesn't exist");
                        return;
                    }
                    else npcEditor.targetNPC.info.waypoint = name;
                    break;
                case "kit":
                case "kits":
                    npcEditor.targetNPC.info.spawnkit = args[1].ToLower();
                    break;
                case "hello":
                    npcEditor.targetNPC.info.message_hello = args[1] == "reset" ? new List<string>() : ListFromArgs(args, 1);
                    break;
                case "bye":
                    npcEditor.targetNPC.info.message_bye = args[1] == "reset" ? new List<string>() : ListFromArgs(args, 1);
                    break;
                case "use":
                    npcEditor.targetNPC.info.message_use = args[1] == "reset" ? new List<string>() : ListFromArgs(args, 1);
                    break;
                case "hurt":
                    npcEditor.targetNPC.info.message_hurt = args[1] == "reset" ? new List<string>() : ListFromArgs(args, 1);
                    break;
                case "kill":
                    npcEditor.targetNPC.info.message_kill = args[1] == "reset" ? new List<string>() : ListFromArgs(args, 1);
                    break;
                case "hitchance":
                    npcEditor.targetNPC.info.hitchance = Convert.ToSingle(args[1]);
                    break;
                case "sound":
                    npcEditor.targetNPC.info.Sound = args[1];
                    break;
				case "soundonuse":
                    npcEditor.targetNPC.info.SoundOnUse = GetBoolValue(args[1]);
                    break;
				case "soundonenter":
                    npcEditor.targetNPC.info.SoundOnEnter = GetBoolValue(args[1]);
                    break;						
                case "reloadduration":
                    npcEditor.targetNPC.info.reloadDuration = Convert.ToSingle(args[1]);
                    break;
                default:
                    SendReply(player, "Wrong Argument, /npc for more information");
                    return;
            }
            SendReply(player, $"NPC Editor: Set {args[0]} to {args[1]}");
            save = true;
            RefreshNPC(npcEditor.targetNPC.player, true);
        }

        [ChatCommand("npc_end")]
        private void cmdChatNPCEnd(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            var npcEditor = player.GetComponent<NPCEditor>();
            if (npcEditor == null)
            {
                SendReply(player, "NPC Editor: You are not editing any NPC");
                return;
            }
            if (!npcEditor.targetNPC.info.enable)
            {
                npcEditor.targetNPC.player.KillMessage();
                SendReply(player, "NPC Editor: The NPC you edited is disabled, killing him");
            }
            UnityEngine.Object.Destroy(npcEditor);
            SendReply(player, "NPC Editor: Ended");
            SaveData();
        }

        [ChatCommand("npc_pathtest")]
        private void cmdChatNPCPathTest(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            var npcEditor = player.GetComponent<NPCEditor>();
            if (npcEditor == null)
            {
                SendReply(player, "NPC Editor: You are not editing any NPC");
                return;
            }
            Quaternion currentRot;
            if (!TryGetPlayerView(player, out currentRot)) return;
            object closestEnt;
            Vector3 closestHitpoint;
            if (!TryGetClosestRayPoint(player.transform.position, currentRot, out closestEnt, out closestHitpoint)) return;
            Interface.Oxide.CallHook("FindAndFollowPath", npcEditor.targetNPC.player, npcEditor.targetNPC.player.transform.position, closestHitpoint);
        }

//        [ChatCommand("npc_follow")]
//        private void cmdChatNPCFollow(BasePlayer player, string command, string[] args)
//        {
//            if (!hasAccess(player)) return;
//
//            HumanPlayer humanPlayer;
//            BaseEntity pe = player as BaseEntity;
//            if (args.Length == 0)
//            {
//                Quaternion currentRot;
//                if (!TryGetPlayerView(player, out currentRot)) return;
//                object closestEnt;
//                Vector3 closestHitpoint;
//                if (!TryGetClosestRayPoint(player.transform.position, currentRot, out closestEnt, out closestHitpoint)) return;
//                humanPlayer = ((Collider)closestEnt).GetComponentInParent<HumanPlayer>();
//                if (humanPlayer == null)
//                {
//                    SendReply(player, "This is not an NPC");
//                    return;
//                }
//            }
//            else
//            {
//                SendReply(player, "You are not looking at an NPC or this userid doesn't exist");
//                return;
//            }
//
//            var targetid = humanPlayer.player.userID;
//            humanPlayer.AllowMove();
//            //humanPlayer.StartFollowingEntity(pe, player.displayName);
//            humanPlayer.locomotion.targetPosition = player.transform.position;
//            humanPlayer.locomotion.followEntity = player;
//            humanPlayer.locomotion.TryToMove();
//            SendReply(player, $"NPC {targetid} following");
//        }

        [ChatCommand("npc_remove")]
        private void cmdChatNPCRemove(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;

            HumanPlayer humanPlayer;
            if (args.Length == 0)
            {
                Quaternion currentRot;
                if (!TryGetPlayerView(player, out currentRot)) return;
                object closestEnt;
                Vector3 closestHitpoint;
                if (!TryGetClosestRayPoint(player.transform.position, currentRot, out closestEnt, out closestHitpoint)) return;
                humanPlayer = ((Collider)closestEnt).GetComponentInParent<HumanPlayer>();
                if (humanPlayer == null)
                {
                    SendReply(player, "This is not an NPC");
                    return;
                }
            }
            else if (args.Length > 0)
            {
                ulong userid;
                if (!ulong.TryParse(args[0], out userid))
                {
                    SendReply(player, "/npc_remove TARGETID");
                    return;
                }
                humanPlayer = FindHumanPlayerByID(userid);
                if (humanPlayer == null)
                {
                    SendReply(player, "This NPC doesn't exist");
                    return;
                }
            }
            else
            {
                SendReply(player, "You are not looking at an NPC or this userid doesn't exist");
                return;
            }

            var targetid = humanPlayer.player.userID;
            RemoveNPC(targetid);
            SendReply(player, $"NPC {targetid} Removed");
        }

        [ChatCommand("npc_reset")]
        private void cmdChatNPCReset(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (player.GetComponent<NPCEditor>() != null) UnityEngine.Object.Destroy(player.GetComponent<NPCEditor>());
            cache.Clear();
            humannpcs.Clear();
            storedData.HumanNPCs.Clear();
            save = true;
            SendReply(player, "All NPCs were removed");
            OnServerInitialized();
        }

        private void SendMessage(HumanPlayer npc, BasePlayer target, string message)
        {
            if (Time.realtimeSinceStartup > npc.lastMessage + 0.1f)
            {
                SendReply(target, $"{chat}{message}", npc.player.displayName);
                npc.lastMessage = Time.realtimeSinceStartup;
            }
        }

        //////////////////////////////////////////////////////
        // NPC HOOKS:
        // will call ALL plugins
        //////////////////////////////////////////////////////

        //////////////////////////////////////////////////////
        /// OnHitNPC(BasePlayer npc, HitInfo hinfo)
        /// called when an NPC gets hit
        //////////////////////////////////////////////////////
        /*void OnHitNPC(BasePlayer npc, HitInfo hinfo)
        {
        }*/

        //////////////////////////////////////////////////////
        ///  OnUseNPC(BasePlayer npc, BasePlayer player)
        ///  called when a player press USE while looking at the NPC (5m max)
        //////////////////////////////////////////////////////
        /*void OnUseNPC(BasePlayer npc, BasePlayer player)
        {
        }*/

        //////////////////////////////////////////////////////
        ///  OnEnterNPC(BasePlayer npc, BasePlayer player)
        ///  called when a player gets close to an NPC (default is in 10m radius)
        //////////////////////////////////////////////////////
        private void OnEnterNPC(BasePlayer npc, BasePlayer player)
        {
            if (player.userID < 76560000000000000L) return;
            var humanPlayer = npc.GetComponent<HumanPlayer>();
            if (humanPlayer.info.message_hello != null && humanPlayer.info.message_hello.Count > 0)
            {
                SendMessage(humanPlayer, player, GetRandomMessage(humanPlayer.info.message_hello));
            }
            if(humanPlayer.info.hostile && player.GetComponent<NPCEditor>() == null && !(bool)(Vanish?.CallHook("IsInvisible", player) ?? false))
            {
                if(humanPlayer.locomotion.sitting)
                {
                    humanPlayer.locomotion.Stand();
                    humanPlayer.locomotion.Evade();
                }
                humanPlayer.StartAttackingEntity(player);
            }
			
			if (!string.IsNullOrEmpty(humanPlayer.info.Sound))
			{
				if (humanPlayer.info.SoundOnEnter)
				{
					if (NpcTalking.Contains(humanPlayer.player.userID)) return;
					if (FileExists(humanPlayer.info.Sound))
					{
						NpcTalking.Add(humanPlayer.player.userID);
						humanPlayer.QueueSound(LoadDataSound(humanPlayer.info.Sound));
					}
				}
			}
        }

        //////////////////////////////////////////////////////
        ///  OnLeaveNPC(BasePlayer npc, BasePlayer player)
        ///  called when a player gets away from an NPC
        //////////////////////////////////////////////////////
        private void OnLeaveNPC(BasePlayer npc, BasePlayer player)
        {
            if (player.userID < 76560000000000000L) return;
            var humanPlayer = npc.GetComponent<HumanPlayer>();
            if (humanPlayer.info.message_bye != null && humanPlayer.info.message_bye.Count > 0)
            {
                SendMessage(humanPlayer, player, GetRandomMessage(humanPlayer.info.message_bye));
            }
        }

        //////////////////////////////////////////////////////
        ///  OnKillNPC(BasePlayer npc, HitInfo hinfo)
        ///  called when an NPC gets killed
        //////////////////////////////////////////////////////
        /*void OnKillNPC(BasePlayer npc, HitInfo hinfo)
        {
        }*/

        //////////////////////////////////////////////////////
        ///  OnNPCPosition(BasePlayer npc, Vector3 pos)
        ///  Called when an npc reachs a position
        //////////////////////////////////////////////////////
        /*void OnNPCPosition(BasePlayer npc, Vector3 pos)
        {
        }*/

        //////////////////////////////////////////////////////
        ///  OnNPCRespawn(BasePlayer npc)
        ///  Called when an NPC respawns
        ///  here it will give an NPC a kit and set the first tool in the belt as the active weapon
        //////////////////////////////////////////////////////
        /*void OnNPCRespawn(BasePlayer npc)
        {
        }*/

        //////////////////////////////////////////////////////
        ///  OnNPCStartAttacking(BasePlayer npc, BaseEntity target)
        ///  Called when an NPC start to target someone to attack
        ///  return anything will block the attack
        //////////////////////////////////////////////////////
        /*object OnNPCStartTarget(BasePlayer npc, BaseEntity target)
        {
            return null;
        }*/
        //////////////////////////////////////////////////////
        ///  OnNPCStopTarget(BasePlayer npc, BaseEntity target)
        ///  Called when an NPC stops targetting
        ///  no return;
        //////////////////////////////////////////////////////
        /*void OnNPCStopTarget(BasePlayer npc, BaseEntity target)
        {
        }*/

        //////////////////////////////////////////////////////
        ///  OnLootNPC(PlayerLoot loot, BaseEntity target, string npcuserID)
        ///  Called when an NPC gets looted
        ///  no return;
        //////////////////////////////////////////////////////
        /*void OnLootNPC(PlayerLoot loot, BaseEntity target, ulong npcuserID)
        {
        }*/

        private class UnityQuaternionConverter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                var quaternion = (Quaternion)value;
                writer.WriteValue($"{quaternion.x} {quaternion.y} {quaternion.z} {quaternion.w}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    var values = reader.Value.ToString().Trim().Split(' ');
                    return new Quaternion(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]), Convert.ToSingle(values[3]));
                }
                var o = JObject.Load(reader);
                return new Quaternion(Convert.ToSingle(o["rx"]), Convert.ToSingle(o["ry"]), Convert.ToSingle(o["rz"]), Convert.ToSingle(o["rw"]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Quaternion);
            }
        }

        private class UnityVector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                var vector = (Vector3)value;
                writer.WriteValue($"{vector.x} {vector.y} {vector.z}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    var values = reader.Value.ToString().Trim().Split(' ');
                    return new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]));
                }
                var o = JObject.Load(reader);
                return new Vector3(Convert.ToSingle(o["x"]), Convert.ToSingle(o["y"]), Convert.ToSingle(o["z"]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        }

        private class SpawnInfoConverter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                var o = JObject.Load(reader);
                Vector3 position;
                Quaternion rotation;
                if (o["position"] != null)
                {
                    var values = Convert.ToString(o["position"]).Trim().Split(' ');
                    position = new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]));
                    values = Convert.ToString(o["rotation"]).Trim().Split(' ');
                    rotation = new Quaternion(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]), Convert.ToSingle(values[3]));
                }
                else
                {
                    position = new Vector3(Convert.ToSingle(o["x"]), Convert.ToSingle(o["y"]), Convert.ToSingle(o["z"]));
                    rotation = new Quaternion(Convert.ToSingle(o["rx"]), Convert.ToSingle(o["ry"]), Convert.ToSingle(o["rz"]), Convert.ToSingle(o["rw"]));
                }
                return new SpawnInfo(position, rotation);
            }

            public override bool CanWrite => false;

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(SpawnInfo);
            }
        }
    }
}


// --- End of file: HumanNPC.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/hazmat-diving ---
// --- Original File Path: H/HazmatDiving/HazmatDiving.cs ---

﻿using Oxide.Core;
using System.Collections.Generic;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using System;

namespace Oxide.Plugins
{
    [Info("Hazmat Diving", "Krungh Crow", "2.0.2")]
    [Description("This will protect you from drowning and cold damage while swimming.")]

/*======================================================================================================================= 
*
*   
*   16th november 2018
*
*	THANKS TO THE OXIDE/UMOD TEAM for coding quality, ideas, and time spent for the community
*
*   2.0.0   20181116    Rewrite of plugin by new maintainer _ hazmat clothes parts no more existing. Switched to Suit. added messages on wear
*   2.0.1   20190123    permission hazmatdiving.use
*
*   add scientist suit ?
*
*
*********************************************
*   Original author :   DaBludger on versions <2.0.0
*   Maintainer(s)   :   BuzZ since 20181116 from v2.0.0
*   Maintainer(s)   :   Krungh Crow since 20201009 from v2.0.2
*********************************************   
*
*=======================================================================================================================*/

    public class HazmatDiving : RustPlugin
    {
        private bool Changed;
        bool debug = false;
        bool loaded;

        private bool applydamageArmour = false;
        //private bool configloaded = false;
        private float armourDamageAmount = 0f;
        private float dmgdrowning1 = 30f;
        private float dmgcold1 = 30f;
        private float dmgdrowning2 = 50f;
        private float dmgcold2 = 50f;
        private float dmgdrowning3 = 40f;
        private float dmgcold3 = 40f;
        private float dmgdrowning4 = 35f;
        private float dmgcold4 = 35f;
        private float dmgdrowning5 = 60f;
        private float dmgcold5 = 60f;

        string Prefix = "[HazmatDiving] ";                  // CHAT PLUGIN PREFIX
        string PrefixColor = "#ebdf42";                 // CHAT PLUGIN PREFIX COLOR
        string ChatColor = "#8bd9ff";                   // CHAT MESSAGE COLOR
        ulong SteamIDIcon = 76561199090290915;  

        const string HazmatUse = "hazmatdiving.use"; 

        void Init()
        {
            LoadVariables();
            permission.RegisterPermission(HazmatUse, this);
        }

        protected override void LoadDefaultConfig()
        {
            LoadVariables();
        }

        void Loaded()
        {
            loaded = true;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        private void LoadVariables()
        {
            if (debug){Puts("Loading Config File:");}

            dmgcold1 = Convert.ToSingle(GetConfig("Hazmat Suit Variables", "Cold reduction in %", "30"));
            if (debug){Puts($"Cold damage = X - {dmgcold1}%");}
            dmgdrowning1 = Convert.ToSingle(GetConfig("Hazmat Suit Variables", "Drowning reduction in %", "30"));
            if (debug){Puts($"Drown damage = X - {dmgdrowning1}%");}

            dmgcold2 = Convert.ToSingle(GetConfig("Heavy Scientist Suit Variables", "Cold reduction in %", "50"));
            if (debug){Puts($"Cold damage = X - {dmgcold2}%");}
            dmgdrowning2 = Convert.ToSingle(GetConfig("Heavy Scientist Suit Variables", "Drowning reduction in %", "50"));
            if (debug){Puts($"Drown damage = X - {dmgdrowning2}%");}

            dmgcold3 = Convert.ToSingle(GetConfig("Scientist Suit (Green) Variables", "Cold reduction in %", "40"));
            if (debug){Puts($"Cold damage = X - {dmgcold3}%");}
            dmgdrowning3 = Convert.ToSingle(GetConfig("Scientist Suit (Green) Variables", "Drowning reduction in %", "40"));
            if (debug){Puts($"Drown damage = X - {dmgdrowning3}%");}

            dmgcold4 = Convert.ToSingle(GetConfig("Scientist Suit (Blue) Variables", "Cold reduction in %", "35"));
            if (debug){Puts($"Cold damage = X - {dmgcold4}%");}
            dmgdrowning4 = Convert.ToSingle(GetConfig("Scientist Suit (Blue) Variables", "Drowning reduction in %", "35"));
            if (debug){Puts($"Drown damage = X - {dmgdrowning4}%");}

            dmgcold5 = Convert.ToSingle(GetConfig("Space Suit Variables", "Cold reduction in %", "60"));
            if (debug){Puts($"Cold damage = X - {dmgcold5}%");}
            dmgdrowning5 = Convert.ToSingle(GetConfig("Space Suit Variables", "Drowning reduction in %", "60"));
            if (debug){Puts($"Drown damage = X - {dmgdrowning5}%");}

            Prefix = Convert.ToString(GetConfig("Chat Settings", "Prefix", "[HazmatDiving] "));                       // CHAT PLUGIN PREFIX
            PrefixColor = Convert.ToString(GetConfig("Chat Settings", "PrefixColor", "#ebdf42"));                // CHAT PLUGIN PREFIX COLOR
            ChatColor = Convert.ToString(GetConfig("Chat Settings", "ChatColor", "#8bd9ff"));                    // CHAT MESSAGE COLOR
            SteamIDIcon = Convert.ToUInt64(GetConfig("Chat Settings", "SteamIDIcon", "76561199090290915"));        // SteamID FOR PLUGIN ICON - STEAM PROFILE CREATED FOR THIS PLUGIN / NONE YET /

            ////////////////// FROM AUTHOR
            //applydamageArmour = Convert.ToBoolean(GetConfig("Attire", "TakesDamage", "false"));
            //Puts("Amour takes damage: "+ applydamageArmour);
            //armourDamageAmount = Convert.ToSingle(GetConfig("Attire", "DamageAmount", "0.0"));
            //Puts("How much damage does the armour take: "+ armourDamageAmount);

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }


#region MESSAGES

        protected override void LoadDefaultMessages()
        {

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"coldMsg", "Cold damages will be reduce by"},
                {"drowningMsg", "Drowning damages will be reduce by"},

            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"coldMsg", "Les dommages de froid seront réduits de"},
                {"drowningMsg", "Les dommages de noyade seront réduits de"},

            }, this, "fr");
        }

#endregion

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitinfo)
        {
            if (hitinfo == null) return;
            BasePlayer onlinecheck = entity.ToPlayer();
            if (onlinecheck == null) return;
            if (onlinecheck.IsConnected == false)
            {
                if (debug){Puts($"-> IGNORED DAMAGE. From not steam online player.");}
                return;
            }
            bool diver = permission.UserHasPermission(onlinecheck.UserIDString, HazmatUse);
            if (!diver) return;
            if (hitinfo.hasDamage)
            {
                float damagedone;
                bool armourDamaged = false;
                if (hitinfo.damageTypes?.Get(Rust.DamageType.Drowned) > 0)
                {
                    damagedone = getDamageDeduction(onlinecheck, Rust.DamageType.Drowned);
                    float newdamage = getScaledDamage(hitinfo.damageTypes.Get(Rust.DamageType.Drowned), damagedone);
                    hitinfo.damageTypes.Set(Rust.DamageType.Drowned, newdamage);
                    armourDamaged = true;
                    if (debug){Puts($"-> DROWNED damage");}
                }
                if (hitinfo.damageTypes?.Get(Rust.DamageType.Cold) > 0 && onlinecheck.IsSwimming())
                {
                    damagedone = getDamageDeduction(onlinecheck, Rust.DamageType.Cold);
                    float newdamage = getScaledDamage(hitinfo.damageTypes.Get(Rust.DamageType.Cold), damagedone);
                    hitinfo.damageTypes.Set(Rust.DamageType.Cold, newdamage);
                    armourDamaged = true;
                    if (debug){Puts($"-> COLD damage on SWIMMING");}
                }
                //////////////////////////////
                // IF CONFIG damageArmour is true ... damage the armour !
                /////////////////////////////
                /////// FROM ORIGINAL AUTHOR

                /*if (armourDamaged && applydamageArmour)
                {
                    foreach (Item item in onlinecheck.inventory.containerWear.itemList) // foreach is not a good point
                    {
                        if (item.info.name.ToLower().Contains("hazmat"))
                        {
                            item.condition = item.condition - armourDamageAmount;
                        }
                    }
                }*/
            }
        }

        private float getScaledDamage(float current, float deduction)
        {
            float newdamage = current - (current * deduction);
            if (newdamage < 0)
            {
                newdamage = 0;
            }
            return newdamage;
        }

        private float getDamageDeduction(BasePlayer player, Rust.DamageType damageType)
        {
            float dd = 0.0f;
            foreach (Item item in player.inventory.containerWear.itemList)
            {
                if (!item.isBroken)
                {
                    if (item.info.shortname == "hazmatsuit")
                    {
                        if (damageType == Rust.DamageType.Drowned)
                        {
                            dd += (dmgdrowning1/100);
                        }
                        if (damageType == Rust.DamageType.Cold)
                        {
                            dd += (dmgcold1/100);
                        }
                    }

                    else if (item.info.shortname == "scientistsuit_heavy")
                    {
                        if (damageType == Rust.DamageType.Drowned)
                        {
                            dd += (dmgdrowning2/100);
                        }
                        if (damageType == Rust.DamageType.Cold)
                        {
                            dd += (dmgcold2/100);
                        }
                    }

                    else if (item.info.shortname == "hazmatsuit_scientist_peacekeeper")
                    {
                        if (damageType == Rust.DamageType.Drowned)
                        {
                            dd += (dmgdrowning3/100);
                        }
                        if (damageType == Rust.DamageType.Cold)
                        {
                            dd += (dmgcold3/100);
                        }
                    }

                    else if (item.info.shortname == "hazmatsuit_scientist")
                    {
                        if (damageType == Rust.DamageType.Drowned)
                        {
                            dd += (dmgdrowning4/100);
                        }
                        if (damageType == Rust.DamageType.Cold)
                        {
                            dd += (dmgcold4/100);
                        }
                    }

                    else if (item.info.shortname == "hazmatsuit.spacesuit")
                    {
                        if (damageType == Rust.DamageType.Drowned)
                        {
                            dd += (dmgdrowning5/100);
                        }
                        if (damageType == Rust.DamageType.Cold)
                        {
                            dd += (dmgcold5/100);
                        }
                    }
                }
            }
            return dd;
        }

        void CanWearItem(PlayerInventory inventory, Item item, int targetPos)
        {
            if (loaded == false) return;
            if (item == null) return;
            if (inventory == null) return;
            BasePlayer HDUser = inventory.GetComponent<BasePlayer>();
            if (HDUser == null) return;
            if (HDUser.IsConnected == false) return;
            bool diver = permission.UserHasPermission(HDUser.UserIDString, HazmatUse);
            if (!diver) return;

            if (item.info.shortname == "hazmatsuit")
            {
                Player.Message(HDUser, $"Hazmat Suit :\n<color={ChatColor}>{lang.GetMessage("coldMsg", this, HDUser.UserIDString)} {dmgcold1}%\n"
                + $"{lang.GetMessage("drowningMsg", this, HDUser.UserIDString)} {dmgdrowning1}%</color>",$"<color={PrefixColor}> {Prefix} </color>"
                , SteamIDIcon); 
            }   

            if (item.info.shortname == "scientistsuit_heavy")
            {
                Player.Message(HDUser, $"Heavy Scientist Suit :\n<color={ChatColor}>{lang.GetMessage("coldMsg", this, HDUser.UserIDString)} {dmgcold2}%\n"
                + $"{lang.GetMessage("drowningMsg", this, HDUser.UserIDString)} {dmgdrowning2}%</color>",$"<color={PrefixColor}> {Prefix} </color>"
                , SteamIDIcon); 
            }

            if (item.info.shortname == "hazmatsuit_scientist_peacekeeper")
            {
                Player.Message(HDUser, $"Green Scientist Suit :\n<color={ChatColor}>{lang.GetMessage("coldMsg", this, HDUser.UserIDString)} {dmgcold3}%\n"
                + $"{lang.GetMessage("drowningMsg", this, HDUser.UserIDString)} {dmgdrowning3}%</color>",$"<color={PrefixColor}> {Prefix} </color>"
                , SteamIDIcon); 
            }

            if (item.info.shortname == "hazmatsuit_scientist")
            {
                Player.Message(HDUser, $"Blue Scientist Suit :\n<color={ChatColor}>{lang.GetMessage("coldMsg", this, HDUser.UserIDString)} {dmgcold4}%\n"
                + $"{lang.GetMessage("drowningMsg", this, HDUser.UserIDString)} {dmgdrowning4}%</color>",$"<color={PrefixColor}> {Prefix} </color>"
                , SteamIDIcon); 
            }   

            if (item.info.shortname == "hazmatsuit.spacesuit")
            {
                Player.Message(HDUser, $"Space Suit :\n<color={ChatColor}>{lang.GetMessage("coldMsg", this, HDUser.UserIDString)} {dmgcold5}%\n"
                + $"{lang.GetMessage("drowningMsg", this, HDUser.UserIDString)} {dmgdrowning5}%</color>",$"<color={PrefixColor}> {Prefix} </color>"
                , SteamIDIcon); 
            }  
        }
    }
}

// --- End of file: HazmatDiving.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/holograms ---
// --- Original File Path: H/Holograms/Holograms.cs ---

﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text.RegularExpressions;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Holograms", "birthdates", "1.4.3")]
    [Description("Provide floating text with information to players")]
    public class Holograms : RustPlugin
    {
        #region Variables

        /// <summary>
        ///     Layer mask with players (saves performances)
        /// </summary>
        private int PlayerMask { get; } = LayerMask.GetMask("Player (Server)");

        /// <summary>
        ///     The obstruction layer mask from <see cref="ConfigFile.ObstructionMask" />
        /// </summary>
        private LayerMask ObstructionMask { get; set; }

        /// <summary>
        ///     Our instance
        /// </summary>
        private static Holograms Instance { get; set; }

        /// <summary>
        ///     A map of placeholders: id -> instance
        /// </summary>
        private readonly IDictionary<string, Placeholder> _placeholders = new Dictionary<string, Placeholder>();

        /// <summary>
        ///     A global stopwatch
        /// </summary>
        private readonly Stopwatch _stopwatch = new Stopwatch();

        /// <summary>
        ///     Placeholder regex (%id%)
        /// </summary>
        private readonly Regex _placeholderRegex = new Regex("%.+?%");

        /// <summary>
        ///     Main permission
        /// </summary>
        private const string UsePermission = "holograms.use";

        #endregion

        #region Hooks

        private void Init()
        {
            Instance = this;
            permission.RegisterPermission(UsePermission, this);
            _data = Interface.Oxide.DataFileSystem.ReadObject<Data>(Name);
            timer.Every(_config.PlaceholderInterval, UpdatePlaceholders);
            cmd.AddChatCommand("h", this, nameof(HologramPlayerCommand));
            cmd.AddConsoleCommand("h", this, nameof(HologramConsoleCommand));
            if (_config.ObstructionMask != null) ObstructionMask = LayerMask.GetMask(_config.ObstructionMask);
        }

        private void Unload()
        {
            SaveData();
            Instance = null;
        }

        private void OnServerInitialized()
        {
            timer.Every(_config.TickInterval, TickHolograms);
            RegisterPlaceholder("players", () => $"{BasePlayer.activePlayerList.Count:n0}");
            RegisterPlaceholder("sleepers", () => $"{BasePlayer.sleepingPlayerList.Count:n0}");
            RegisterPlaceholder("queued", () => $"{ServerMgr.Instance.connectionQueue.Queued:n0}");
            RegisterPlaceholder("joining", () => $"{ServerMgr.Instance.connectionQueue.Joining:n0}");
            RegisterPlaceholder("entities", () => $"{BaseNetworkable.serverEntities.Count:n0}");
            RegisterPlaceholder("fps", 1f, () => $"{Performance.report.frameRate:n0}");
        }

        #endregion

        #region Core Logic

        /// <summary>
        ///     Update all our placeholders
        /// </summary>
        private void UpdatePlaceholders()
        {
            foreach (var placeholder in _placeholders.Values) placeholder.TryUpdate();
        }

        /// <summary>
        ///     Get a placeholder's value/data
        /// </summary>
        /// <param name="id">Placeholder's ID</param>
        /// <returns>A <see cref="string" /> if a value/data was found. <see langword="null" /> otherwise.</returns>
        private string GetPlaceholderValue(string id)
        {
            Placeholder placeholder;
            return !_placeholders.TryGetValue(id, out placeholder) ? null : placeholder.Value;
        }

        /// <summary>
        ///     Register a new placeholder
        /// </summary>
        /// <param name="id">Placeholder's ID</param>
        /// <param name="updateTime">Placeholder's update interval in seconds</param>
        /// <param name="callback">Placeholder's callback with data</param>
        [HookMethod("RegisterPlaceholder")]
        private void RegisterPlaceholder(string id, float updateTime, Func<string> callback)
        {
            _placeholders[id] = new Placeholder(id, updateTime, callback);
        }

        /// <summary>
        ///     Register a new placeholder at a 10 second update interval
        /// </summary>
        /// <param name="id">Placeholder's ID</param>
        /// <param name="callback">Placeholder's callback with data</param>
        private void RegisterPlaceholder(string id, Func<string> callback)
        {
            RegisterPlaceholder(id, 10f, callback);
        }

        /// <summary>
        ///     Tick all holograms
        /// </summary>
        private void TickHolograms()
        {
            foreach (var hologram in _data.Holograms.Values) hologram.Tick();
        }

        /// <summary>
        ///     Try to create a hologram
        /// </summary>
        /// <param name="id">Hologram's ID</param>
        /// <param name="spawnPos">Hologram's position</param>
        /// <returns>
        ///     <see langword="true" />, if the hologram was created. <see langword="false" /> if there is currently a
        ///     hologram with that name.
        /// </returns>
        [HookMethod("CreateHologram")]
        private Hologram CreateHologram(string id, Vector3 spawnPos = default(Vector3))
        {
            if (_data.Holograms.ContainsKey(id)) return null;
            return _data.Holograms[id] = new Hologram
            {
                Id = id, Position = spawnPos,
                Lines = new List<Line>
                    {new Line {Text = $"<size=25>Hologram with id <color=green>\"{id}\"</color></size>"}}
            };
        }

        /// <summary>
        ///     Try to find a hologram by it's ID
        /// </summary>
        /// <param name="id">Target ID</param>
        /// <returns>A <see cref="Hologram" /> if found. <see langword="null" /> otherwise.</returns>
        [HookMethod("FindHologram")]
        private Hologram FindHologram(string id)
        {
            Hologram hologram;
            return !_data.Holograms.TryGetValue(id, out hologram) ? null : hologram;
        }

        /// <summary>
        ///     Try to delete a hologram by ID
        /// </summary>
        /// <param name="id">Hologram's ID</param>
        /// <returns><see langword="true" />, if the hologram was removed. <see langword="false" /> otherwise.</returns>
        [HookMethod("DeleteHologram")]
        private bool DeleteHologram(string id)
        {
            return _data.Holograms.Remove(id);
        }

        #endregion

        #region Commands

        [ChatCommand("hologram")]
        private void HologramPlayerCommand(BasePlayer player, string label, string[] args)
        {
            HologramCommand(new PlayerExecutor(player), label, args);
        }

        [ConsoleCommand("hologram")]
        private void HologramConsoleCommand(ConsoleSystem.Arg arg)
        {
            HologramCommand(new ConsoleExecutor(arg), arg.cmd.Name, arg.Args);
        }

        private void HologramCommand(IExecutor executor, string label, string[] args)
        {
            if (!executor.HasPermission(UsePermission))
            {
                executor.Reply(lang.GetMessage("NoPermission", this, executor.GetId()));
                return;
            }

            if (args.Length < 1)
            {
                SendHelp(executor, label);
                return;
            }

            var arg = args[0].ToLowerInvariant();
            if (arg.Equals("list"))
            {
                var str = _data.Holograms.Count > 0
                    ? string.Join(", ", _data.Holograms.Select(hologram => hologram.Value.Id).ToArray())
                    : "N/A";
                executor.Reply(string.Format(lang.GetMessage("List", this, executor.GetId()), str));
                return;
            }

            // Hologram Commands
            if (args.Length > 1)
            {
                var name = args[1].ToLowerInvariant().EscapeRichText();
                switch (arg)
                {
                    case "create":
                        var created = CreateHologram(name, executor.GetPosition()) != null;
                        if (created) SaveData();
                        executor.Reply(lang.GetMessage(
                            !created ? "HologramExists" : "HologramCreated", this,
                            executor.GetId()));
                        return;
                    case "delete":
                        var removed = DeleteHologram(name);
                        if (removed) SaveData();
                        executor.Reply(lang.GetMessage(removed ? "HologramDeleted" : "InvalidHologram",
                            this, executor.GetId()));
                        return;
                }

                var hologram = FindHologram(name);
                if (hologram == null)
                {
                    executor.Reply(lang.GetMessage("InvalidHologram", this, executor.GetId()));
                    return;
                }

                if (arg.Equals("teleport"))
                {
                    if (!executor.Teleport(hologram.Position)) return;
                    executor.Reply(string.Format(lang.GetMessage("Teleported", this, executor.GetId()), hologram.Id));
                    return;
                }
                if (arg.Equals("tphere"))
                {
                    hologram.Position = executor.GetPosition();
                    executor.Reply(string.Format(lang.GetMessage("TeleportedHere", this, executor.GetId()), hologram.Id));
                    return;
                }

                if (args.Length > 2)
                {
                    var thirdArg = args[2].ToLowerInvariant();
                    switch (arg)
                    {
                        case "spacing":
                            float spacing;
                            if (!float.TryParse(thirdArg, out spacing))
                            {
                                executor.Reply(lang.GetMessage("InvalidNumber", this, executor.GetId()));
                                return;
                            }

                            hologram.LineSpacing = spacing;
                            executor.Reply(string.Format(lang.GetMessage("LineSpacing", this, executor.GetId()),
                                hologram.Id, spacing));
                            return;
                        case "radius":
                            float radius;
                            if (!float.TryParse(thirdArg, out radius))
                            {
                                executor.Reply(lang.GetMessage("InvalidNumber", this, executor.GetId()));
                                return;
                            }

                            hologram.ViewRadius = radius;
                            executor.Reply(string.Format(lang.GetMessage("ViewRadius", this, executor.GetId()), radius,
                                hologram.Id));
                            return;
                        case "update":
                            float update;
                            if (!float.TryParse(thirdArg, out update))
                            {
                                executor.Reply(lang.GetMessage("InvalidNumber", this, executor.GetId()));
                                return;
                            }

                            hologram.UpdateInterval = update;
                            executor.Reply(string.Format(lang.GetMessage("UpdateInterval", this, executor.GetId()),
                                update, hologram.Id));
                            return;
                        case "permission":
                            hologram.Permission = thirdArg.Equals("null") ? null : thirdArg;
                            executor.Reply(string.Format(lang.GetMessage("Permission", this, executor.GetId()),
                                $"holograms.{thirdArg}", hologram.Id));
                            return;
                        case "rename":
                            if (FindHologram(thirdArg) != null)
                            {
                                executor.Reply(lang.GetMessage("HologramExists", this, executor.GetId()));
                                return;
                            }

                            var oldName = hologram.Id;
                            _data.Holograms.Remove(hologram.Id);
                            hologram.Id = thirdArg;
                            _data.Holograms[hologram.Id] = hologram;
                            executor.Reply(string.Format(lang.GetMessage("Renamed", this, executor.GetId()), oldName,
                                hologram.Id));
                            SaveData();
                            return;
                        case "addline":
                            var lines = string.Join(" ", args, 2, args.Length - 2);
                            hologram.AddLine(lines);
                            executor.Reply(string.Format(lang.GetMessage("AddLine", this, executor.GetId()),
                                hologram.Id));
                            return;
                        case "setline":
                            int line;
                            if (!int.TryParse(thirdArg, out line))
                            {
                                executor.Reply(lang.GetMessage("InvalidNumber", this, executor.GetId()));
                                return;
                            }

                            if (line > hologram.Lines.Count || line < 1)
                            {
                                executor.Reply(lang.GetMessage("InvalidIndex", this, executor.GetId()));
                                return;
                            }

                            var text = string.Join(" ", args, 3, args.Length - 3);
                            hologram.SetLine(line - 1, text);
                            executor.Reply(string.Format(lang.GetMessage("SetLine", this, executor.GetId()), line,
                                hologram.Id));
                            return;
                        case "remline":
                            int remLine;
                            if (!int.TryParse(thirdArg, out remLine))
                            {
                                executor.Reply(lang.GetMessage("InvalidNumber", this, executor.GetId()));
                                return;
                            }

                            if (remLine > hologram.Lines.Count || remLine < 1)
                            {
                                executor.Reply(lang.GetMessage("InvalidIndex", this, executor.GetId()));
                                return;
                            }

                            hologram.RemoveLine(remLine - 1);
                            executor.Reply(string.Format(lang.GetMessage("RemovedLine", this, executor.GetId()),
                                remLine, hologram.Id));
                            return;
                    }
                }
            }

            SendHelp(executor, label);
        }

        /// <summary>
        ///     Send the help locale message to an executor
        /// </summary>
        /// <param name="executor">Target executor</param>
        /// <param name="label">Command label</param>
        private void SendHelp(IExecutor executor, string label)
        {
            executor.Reply(string.Format(lang.GetMessage("Help", this, executor.GetId()), label));
        }

        #endregion

        #region Classes

        /// <summary>
        ///     Base placeholder implementation
        /// </summary>
        private class Placeholder
        {
            /// <summary>
            ///     This placeholder's ID
            /// </summary>
            private string Id { get; }

            /// <summary>
            ///     The next update
            /// </summary>
            private DateTime _nextUpdate;

            /// <summary>
            ///     Update interval in seconds
            /// </summary>
            private float UpdateTime { get; }

            /// <summary>
            ///     Placeholder value callback
            /// </summary>
            private Func<string> Callback { get; }

            /// <summary>
            ///     Current placeholder value
            /// </summary>
            public string Value { get; private set; }

            public Placeholder(string id, float updateTime, Func<string> callback)
            {
                Id = id;
                UpdateTime = updateTime;
                Callback = callback;
                _nextUpdate = DateTime.UtcNow;
                Value = null;
            }

            /// <summary>
            ///     Try to update <see cref="Value" />
            /// </summary>
            public void TryUpdate()
            {
                if (_nextUpdate > DateTime.UtcNow) return;
                _nextUpdate = DateTime.UtcNow.AddSeconds(UpdateTime);
                Instance._stopwatch.Start();
                Value = Callback.Invoke();
                Instance._stopwatch.Stop();
                Instance._stopwatch.Reset();
                if (Instance._stopwatch.ElapsedMilliseconds >= 100)
                    Instance.PrintWarning(
                        $"The placeholder with id \"{Id}\" took {Instance._stopwatch.ElapsedMilliseconds}ms to execute!");
            }
        }

        /// <summary>
        ///     Simple line class for placeholders
        /// </summary>
        private class Line
        {
            /// <summary>
            ///     Stored text
            /// </summary>
            public string Text { get; set; }

            /// <summary>
            ///     Placeholder mapped text
            /// </summary>
            [JsonIgnore]
            public string PlaceholderText { get; set; }
        }

        /// <summary>
        ///     Base hologram implementation
        /// </summary>
        private class Hologram
        {
            /// <summary>
            ///     Do we have placeholders?
            /// </summary>
            private bool _hasPlaceholders;

            /// <summary>
            ///     Have we checked?
            /// </summary>
            private bool _hasChecked;

            /// <summary>
            ///     Our next update time
            /// </summary>
            private DateTime _nextUpdate = DateTime.UtcNow;

            /// <summary>
            ///     This hologram's ID
            /// </summary>
            public string Id { get; set; }

            /// <summary>
            ///     A list of lines this hologram holds
            /// </summary>
            public IList<Line> Lines { get; set; }

            /// <summary>
            ///     The position of this hologram
            /// </summary>
            public Vector3 Position { get; set; }

            /// <summary>
            ///     The spacing between lines in metres
            /// </summary>
            public float LineSpacing { get; set; } = Instance._config.DefaultLineSpacing;

            /// <summary>
            ///     The time between updates in seconds
            /// </summary>
            public float UpdateInterval { get; set; } = -1f;

            /// <summary>
            ///     The view radius in metres
            /// </summary>
            public float ViewRadius { get; set; } = 15f;

            /// <summary>
            ///     The permission to view this hologram
            /// </summary>
            public string Permission { get; set; }

            /// <summary>
            ///     Add a new line
            /// </summary>
            /// <param name="text">Line text</param>
            public void AddLine(string text)
            {
                DoesHavePlaceholders(text);
                Lines.Add(new Line {Text = text});
                UpdateForNearby();
            }

            /// <summary>
            ///     Set a line at a certain index
            /// </summary>
            /// <param name="index">Target index</param>
            /// <param name="text">New line</param>
            public void SetLine(int index, string text)
            {
                DoesHavePlaceholders(text);
                Lines[index] = new Line {Text = text};
                UpdateForNearby();
            }

            /// <summary>
            ///     Remove a line at a certain index
            /// </summary>
            /// <param name="index">Target index</param>
            public void RemoveLine(int index)
            {
                Lines.RemoveAt(index);
                UpdateForNearby();
                CheckForPlaceholders();
            }

            /// <summary>
            ///     Check for placeholders in all lines
            /// </summary>
            private void CheckForPlaceholders()
            {
                if (_hasPlaceholders) return;
                _hasChecked = true;
                foreach (var line in Lines)
                {
                    DoesHavePlaceholders(line.Text);
                    if (_hasPlaceholders) break;
                }
            }

            /// <summary>
            ///     Update if we have placeholders
            /// </summary>
            /// <param name="text">A line from <see cref="Lines" /></param>
            private void DoesHavePlaceholders(string text)
            {
                if (!_hasPlaceholders) _hasPlaceholders = Instance._placeholderRegex.IsMatch(text);
                _hasChecked = true;
            }

            /// <summary>
            ///     Tick this hologram
            /// </summary>
            public void Tick()
            {
                UpdateForNearby();
                if (_nextUpdate > DateTime.UtcNow) return;
                Update();
                _nextUpdate = DateTime.UtcNow.AddSeconds(UpdateInterval);
            }

            /// <summary>
            ///     Update our lines and replace placeholders
            /// </summary>
            private void Update()
            {
                if (!_hasChecked) CheckForPlaceholders();
                if (!_hasPlaceholders) return;
                foreach (var line in Lines)
                {
                    var text = line.Text;
                    var matches = Instance._placeholderRegex.Matches(text);
                    foreach (Match match in matches)
                    {
                        var id = match.Value.Substring(1, match.Value.Length - 2);
                        var value = Instance.GetPlaceholderValue(id);
                        if (string.IsNullOrEmpty(value)) continue;
                        text = Regex.Replace(text, match.Value, value);
                    }

                    line.PlaceholderText = text;
                }
            }

            /// <summary>
            ///     Send updates to nearby players
            /// </summary>
            private void UpdateForNearby()
            {
                var players = new List<BasePlayer>();
                Vis.Entities(Position, ViewRadius, players, Instance.PlayerMask, QueryTriggerInteraction.Ignore);
                var hasPermission = !string.IsNullOrEmpty(Permission);
                foreach (var player in players.Where(player =>
                    !player.IsNpc && player.IPlayer != null &&
                    (!hasPermission || player.IPlayer.HasPermission($"holograms.{Permission}"))))
                {
                    if (Instance._config.ObstructionMask != null && Instance._config.ObstructionMask.Length > 0 &&
                        Physics.Raycast(player.eyes.HeadRay(),
                            player.Distance(Position), Instance.ObstructionMask, QueryTriggerInteraction.Ignore))
                        continue;
                    var position = new Vector3(Position.x, Position.y, Position.z);
                    foreach (var line in Lines)
                    {
                        var wasAdmin = player.IsAdmin;
                        if (!wasAdmin)
                        {
                            player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                            player.SendNetworkUpdateImmediate();
                        }

                        player.SendConsoleCommand("ddraw.text", Instance._config.TickInterval, Color.white, position,
                            _hasPlaceholders ? line.PlaceholderText : line.Text);
                        if (!wasAdmin)
                        {
                            player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                            player.SendNetworkUpdateImmediate();
                        }

                        position -= new Vector3(0, LineSpacing, 0);
                    }
                }
            }
        }

        private struct ConsoleExecutor : IExecutor
        {
            /// <summary>
            ///     Our arg
            /// </summary>
            private readonly ConsoleSystem.Arg _arg;

            public ConsoleExecutor(ConsoleSystem.Arg arg)
            {
                _arg = arg;
            }

            /// <inheritdoc />
            public void Reply(string message)
            {
                _arg.ReplyWith(message);
            }

            /// <inheritdoc />
            public bool HasPermission(string permission)
            {
                return _arg.Player()?.IPlayer.HasPermission(permission) ?? true;
            }

            /// <inheritdoc />
            public string GetId()
            {
                return _arg.Player()?.UserIDString;
            }

            /// <inheritdoc />
            public Vector3 GetPosition()
            {
                return _arg.Player()?.transform.position ?? default(Vector3);
            }

            /// <inheritdoc />
            public bool Teleport(Vector3 position)
            {
                var player = _arg.Player();
                if (player == null)
                {
                    Reply("You must be a player to do this.");
                    return false;
                }

                player.Teleport(position);
                return true;
            }
        }

        /// <inheritdoc />
        private struct PlayerExecutor : IExecutor
        {
            /// <summary>
            ///     Our player
            /// </summary>
            private readonly BasePlayer _player;

            public PlayerExecutor(BasePlayer player)
            {
                _player = player;
            }

            /// <inheritdoc />
            public void Reply(string message)
            {
                _player.ChatMessage(message);
            }

            /// <inheritdoc />
            public bool HasPermission(string permission)
            {
                return _player.IPlayer.HasPermission(permission);
            }

            /// <inheritdoc />
            public string GetId()
            {
                return _player.UserIDString;
            }

            /// <inheritdoc />
            public Vector3 GetPosition()
            {
                return _player.transform.position;
            }

            /// <inheritdoc />
            public bool Teleport(Vector3 position)
            {
                _player.Teleport(position);
                return true;
            }
        }

        /// <summary>
        ///     Interface executor
        /// </summary>
        private interface IExecutor
        {
            /// <summary>
            ///     Reply to this executor
            /// </summary>
            /// <param name="message">Target message</param>
            void Reply(string message);

            /// <summary>
            ///     Does this executor have a permission?
            /// </summary>
            /// <param name="permission">Target permission</param>
            /// <returns><see langword="true" /> if this executor has the permission. <see langword="false" /> otherwise. </returns>
            bool HasPermission(string permission);

            /// <summary>
            ///     Get this executor's ID
            /// </summary>
            /// <returns>A <see cref="string" /> ID</returns>
            string GetId();

            /// <summary>
            ///     Get this executor's position
            /// </summary>
            /// <returns>A <see cref="Vector3" /></returns>
            Vector3 GetPosition();

            /// <summary>
            ///     Teleport this executor to a position
            /// </summary>
            /// <param name="position">Target position</param>
            /// <returns><see langword="true" /> if successful. <see langword="false" /> otherwise.</returns>
            bool Teleport(Vector3 position);
        }

        #endregion

        #region Configuration, Localization & Data

        private Data _data;
        private ConfigFile _config;

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"List", "Active Holograms:\n- {0}\nYou can teleport to them with /hologram teleport <hologram>"},
                {"Teleported", "You have teleported to the hologram \"{0}\"."},
                {"HologramCreated", "You have created a hologram with that name at your position."},
                {"InvalidHologram", "A hologram with that name couldn't be found."},
                {"HologramExists", "A hologram with that name already exists."},
                {"InvalidNumber", "That is not a number."},
                {"InvalidIndex", "This hologram does not have that many/little lines."},
                {"RemovedLine", "You have removed the line #{0} from the hologram \"{1}\""},
                {"AddLine", "You have added that line to the hologram \"{0}\""},
                {"SetLine", "You have re-set the line #{0} from the hologram \"{1}\""},
                {"Renamed", "You have renamed the hologram \"{0}\" to \"{1}\""},
                {"LineSpacing", "You have set the line spacing of the hologram \"{0}\" to {1}m"},
                {"HologramDeleted", "You have deleted that hologram."},
                {"ViewRadius", "You have set the view radius of the hologram \"{0}\" to {1}m"},
                {"NoPermission", "You do not have permission to execute this command."},
                {"Permission", "You have set the viewing permission of the hologram \"{0}\" to \"{1}\""},
                {"UpdateInterval", "You have set the update interval of the hologram \"{0}\" to {1}s"},
                {"TeleportedHere", "You have teleported the hologram \"{0}\" to your position."},
                {
                    "Help", "<color=#4287f5>Holograms Help</color>\n" +
                            "/{0} create <name> - Create a hologram with that name\n" +
                            "/{0} delete <name> - Delete a hologram with that name\n" +
                            "/{0} list - List all of the active holograms\n" +
                            "/{0} teleport <hologram> - Teleport to that hologram\n" +
                            "/{0} tphere <hologram> - Teleport to that hologram to your location\n" +
                            "/{0} rename <hologram> <new name> - Rename a hologram\n\n" +
                            "/{0} spacing <hologram> <spacing> - Change the spacing between lines (metres) of a hologram\n" +
                            "/{0} update <hologram> <interval> - Change the placeholder update delay (seconds) of a hologram\n" +
                            "/{0} radius <hologram> <radius> - Change the view radius (metres) of a hologram\n" +
                            "/{0} permission <hologram> <permission> - Change the viewing permission (null to disable)\n\n" +
                            "/{0} addline <hologram> <text> - Add a line to the hologram\n" +
                            "/{0} setline <hologram> <line> <text> - Set an existing line of a hologram\n" +
                            "/{0} remline <hologram> <line> - Remove a line from a hologram"
                }
            }, this);
        }

        public class ConfigFile
        {
            /// <summary>
            ///     The default line spacing when creating a hologram
            /// </summary>
            [JsonProperty("Default Line Spacing")]
            public float DefaultLineSpacing { get; set; }

            /// <summary>
            ///     The time between hologram ticks (seconds)
            /// </summary>
            [JsonProperty("Hologram Tick Interval (seconds)")]
            public float TickInterval { get; set; }

            /// <summary>
            ///     The time between placeholder ticks (seconds)
            /// </summary>
            [JsonProperty("Placeholder Tick Interval (seconds)")]
            public float PlaceholderInterval { get; set; }

            /// <summary>
            ///     The obstruction layer masks
            /// </summary>
            [JsonProperty("Obstruction Mask")]
            public string[] ObstructionMask { get; set; }

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    ObstructionMask = new[] {"Construction", "Deployed", "World", "Terrain"},
                    DefaultLineSpacing = 0.1f,
                    TickInterval = 1f,
                    PlaceholderInterval = 0.5f
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null) LoadDefaultConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        private class Data
        {
            public IDictionary<string, Hologram> Holograms { get; } = new Dictionary<string, Hologram>();
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, _data);
        }

        #endregion
    }
}

// --- End of file: Holograms.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/hackable-lock ---
// --- Original File Path: H/HackableLock/HackableLock.cs ---

using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Hackable Lock", "Ryz0r", "2.3.0")]
    [Description("Locks Hackable Crate to person who started hack process")]
    public class HackableLock : CovalencePlugin
    {
        #region Class Fields

        [PluginReference]
        private Plugin DiscordEvents, Clans, Friends;

        private const string PermissionUse = "hackablelock.use";

        #endregion Class Fields

        #region Initialization

        private void Init()
        {
            permission.RegisterPermission(PermissionUse, this);
            LoadData();

            if (!_configData.GlobalSettings.Enabled)
            {
                Unsubscribe(nameof(CanHackCrate));
                Unsubscribe(nameof(CanLootEntity));
                Unsubscribe(nameof(OnEntityKill));
            }
        }

        private void OnServerSave() => timer.Once(UnityEngine.Random.Range(0f, 60f), SaveData);

        private void Unload() => SaveData();

        #endregion Initialization

        #region Configuration

        private ConfigData _configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Global settings")]
            public GlobalConfiguration GlobalSettings = new GlobalConfiguration();

            [JsonProperty(PropertyName = "Chat settings")]
            public ChatConfiguration ChatSettings = new ChatConfiguration();

            [JsonProperty(PropertyName = "Discord settings")]
            public DiscordConfiguration DiscordSettings = new DiscordConfiguration();

            public class GlobalConfiguration
            {
                [JsonProperty(PropertyName = "Use permissions")]
                public bool UsePermission = true;

                [JsonProperty(PropertyName = "Allow admins to use without permission")]
                public bool AdminsAllowed = true;

                [JsonProperty(PropertyName = "Enabled?")]
                public bool Enabled = true;

                [JsonProperty(PropertyName = "Lock time (seconds)")]
                public float LockTime = 1200f;
                
                [JsonProperty(PropertyName = "Use Clans")]
                public bool EnableClans = false;
                
                [JsonProperty(PropertyName = "Use Teams")]
                public bool EnableTeams = false;
                
                [JsonProperty(PropertyName = "Use Friends")]
                public bool EnableFriends = false;
            }

            public class ChatConfiguration
            {
                [JsonProperty(PropertyName = "Chat steamID icon")]
                public ulong SteamIDIcon = 0;

                [JsonProperty(PropertyName = "Notifications Enabled?")]
                public bool Notifications = true;
                
                [JsonProperty(PropertyName = "Player Console Notifications only")]
                public bool SendConsoleOnly = true;
            }
            
            public class DiscordConfiguration
            {
                [JsonProperty(PropertyName = "WebhookURL")]
                public string WebhookURL = "";

                [JsonProperty(PropertyName = "Enabled?")]
                public bool Enabled = false;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _configData = Config.ReadObject<ConfigData>();
                if (_configData == null)
                {
                    LoadDefaultConfig();
                    SaveConfig();
                }
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
                SaveConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(_configData);

        #endregion Configuration

        #region DataFile

        private StoredData _storedData;

        private class StoredData
        {
            public Dictionary<ulong, LockInfo> _lockedCrates = new Dictionary<ulong, LockInfo>();
        }

        private class LockInfo
        {          
            public ulong PlayerID;
            public string PlayerName;
            public float UnlockTime;
        }

        private void LoadData()
        {
            try
            {
                _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                _storedData = null;
            }
            finally
            {
                if (_storedData == null)
                {
                    ClearData();
                }
            }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);

        private void ClearData()
        {
            _storedData = new StoredData();
            SaveData();
        }

        #endregion DataFile

        #region Localization

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Prefix"] = "<color=#00FFFF>[Hackable Crate Lock]</color>: ",
                ["Hacking"] = "<color=#FFA500>{0}</color> started locked crate hack at <color=#FFA500>{1}</color>. This crate will be locked for others for <color=#FFA500>{2}</color> more seconds",
                ["Locked"] = "This crate was hacked by <color=#FFA500>{0}</color> and protected for <color=#FFA500>{1}</color> more seconds",
                ["Discord"] = ":lock: `{0}` started locked crate hack at `{1}`. This crate will be locked for others for `{2}` more seconds",
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Prefix"] = "<color=#00FFFF>[Блокировка закрытого ящика]</color>: ",
                ["Hacking"] = "<color=#00FFFF>{0}</color> начал процесс взлома запертого ящика на <color=#FFA500>{1}</color>. Этот ящик будет защищён от других игроков ещё <color=#FFA500>{2}</color> секунд",
                ["Locked"] = "Этот ящик был взломан игроком <color=#FFA500>{0}</color> и защищён от других ещё <color=#FFA500>{1}</color> секунд",
                ["Discord"] = ":lock: `{0}` начал процесс взлома запертого ящика на `{1}`. Этот ящик будет защищён от других игроков ещё `{2}` секунд",
            }, this, "ru");
        }

        #endregion Localization

        #region Oxide Hooks

        private void CanHackCrate(BasePlayer player, HackableLockedCrate crate)
        {
            if (!_configData.GlobalSettings.Enabled || player == null || crate == null)
            {
                return;
            }

            if (_configData.GlobalSettings.UsePermission && !permission.UserHasPermission(player.UserIDString, PermissionUse))
            {
                if (!_configData.GlobalSettings.AdminsAllowed || !player.IsAdmin)
                {
                    return;
                }
            }

            LockInfo lockInfo = new LockInfo()
            {
                PlayerID = player.userID,
                PlayerName = player.displayName,
                UnlockTime = Time.realtimeSinceStartup + _configData.GlobalSettings.LockTime,
            };

            if (!_storedData._lockedCrates.ContainsKey(crate.net.ID.Value))
            {
                _storedData._lockedCrates.Add(crate.net.ID.Value, lockInfo);
                SaveData();

                if (_configData.ChatSettings.Notifications)
                {
                    foreach (BasePlayer basePlayer in BasePlayer.activePlayerList)
                    {
                        Print(basePlayer.IPlayer, Lang("Hacking", basePlayer.UserIDString, player.displayName, GetGridPosition(crate.transform.position), (lockInfo.UnlockTime - Time.realtimeSinceStartup).ToString("F0")));
                    }
                }

                if (_configData.DiscordSettings.Enabled)
                {
                    PrintDiscord(Lang("Discord", player.UserIDString, player.displayName, GetGridPosition(crate.transform.position), (lockInfo.UnlockTime - Time.realtimeSinceStartup).ToString("F0")));
                }
            }
        }
        
        private void OnEntityKill(HackableLockedCrate crate)
        {
            if (crate == null || !_storedData._lockedCrates.ContainsKey(crate.net.ID.Value))
            {
                return;
            }

            _storedData._lockedCrates.Remove(crate.net.ID.Value);
            SaveData();
        }

        private object CanLootEntity(BasePlayer player, HackableLockedCrate crate)
        {
            if (!_configData.GlobalSettings.Enabled)
            {
                return null;
            }

            float unlockTime = GetCrateLockTime(crate.net.ID.Value);

            if (unlockTime > 0 && !IsOwner(player.userID, _storedData._lockedCrates[crate.net.ID.Value].PlayerID))
            {
                Print (player.IPlayer, Lang("Locked", player.UserIDString, _storedData._lockedCrates[crate.net.ID.Value].PlayerName, unlockTime.ToString("F0")));
                return true;
            }

            return null;
        }

        #endregion Oxide Hooks

        #region API Methods

        private void LockCrateToPlayer(BasePlayer player, HackableLockedCrate crate)
        {
            if (player == null || crate == null || _storedData._lockedCrates.ContainsKey(crate.net.ID.Value))
            {
                return;
            }

            LockInfo lockInfo = new LockInfo()
            {
                PlayerID = player.userID,
                PlayerName = player.displayName,
                UnlockTime = Time.realtimeSinceStartup + _configData.GlobalSettings.LockTime,
            };

            if (!_storedData._lockedCrates.ContainsKey(crate.net.ID.Value))
            {
                _storedData._lockedCrates.Add(crate.net.ID.Value, lockInfo);
                SaveData();
            }
        }

        #endregion API Methods

        #region Helpers

        private float GetCrateLockTime(ulong crateID)
        {
            if (_configData.GlobalSettings.Enabled)
            {
                Dictionary<ulong, LockInfo> actualized = new Dictionary<ulong, LockInfo>();

                foreach (KeyValuePair<ulong,Oxide.Plugins.HackableLock.LockInfo> lockedCrate in _storedData._lockedCrates)
                {
                    if (lockedCrate.Value.UnlockTime > Time.realtimeSinceStartup)
                    {
                        actualized.Add(lockedCrate.Key, lockedCrate.Value);
                    }
                }

                _storedData._lockedCrates = actualized;

                if (_storedData._lockedCrates.ContainsKey(crateID))
                {
                    return _storedData._lockedCrates[crateID].UnlockTime - Time.realtimeSinceStartup;
                }
            }

            return 0;
        }

        private string GetGridPosition(Vector3 pos)
        {
            const float gridCellSize = 146.3f;

            int maxGridSize = Mathf.FloorToInt(World.Size / gridCellSize) - 1;
            float halfWorldSize = World.Size / 2f;
            int xGrid = Mathf.Clamp(Mathf.FloorToInt((pos.x + halfWorldSize) / gridCellSize),0, maxGridSize);
            int zGrid = Mathf.Clamp(maxGridSize - Mathf.FloorToInt((pos.z + halfWorldSize) / gridCellSize),0, maxGridSize);

            string extraA = string.Empty;
            if (xGrid > 26)
            {
                extraA = $"{(char) ('A' + (xGrid / 26 - 1))}";
            }

            return $"{extraA}{(char) ('A' + xGrid % 26)}{zGrid.ToString()}";
        }

        private void PrintDiscord(string message)
        {
            if (!_configData.DiscordSettings.Enabled)
            {
                return;
            }

            if (DiscordEvents == null || !DiscordEvents.IsLoaded)
            {
                PrintError("Prints to Discord enabled, but DiscordEvents is null or empty!");
                return;
            }

            if (string.IsNullOrEmpty(_configData.DiscordSettings.WebhookURL))
            {
                PrintError("Prints to Discord enabled, but WebhookURL is null or empty!");
                return;
            }

            DiscordEvents?.Call("SendMessage", message, _configData.DiscordSettings.WebhookURL);
        }

        private void Print(IPlayer player, string message)
        {
            string text;
            if (string.IsNullOrEmpty(Lang("Prefix", player.Id)))
            {
                text = message;
            }
            else
            {
                text = Lang("Prefix", player.Id) + message;
            }

            if (_configData.ChatSettings.SendConsoleOnly)
            {
                ((BasePlayer)player.Object).SendConsoleCommand ("chat.add", 2, _configData.ChatSettings.SteamIDIcon, text);
                return;
            }

            player.Message(text);
        }

        private bool IsOwner(ulong userID, ulong owner)
        {
            if (userID == owner)
            {
                return true;
            }
            
            if (_configData.GlobalSettings.EnableTeams && SameTeam(userID, owner))
            {
                return true;
            }

            if (_configData.GlobalSettings.EnableClans && SameClan(userID, owner))
            {
                return true;
            }

            if (_configData.GlobalSettings.EnableFriends && AreFriends(userID, owner))
            {
                return true;
            }

            return false;
        }
        
        private bool SameTeam(ulong playerID, ulong friendID)
        {
            if (!RelationshipManager.TeamsEnabled())
            {
                return false;
            }

            RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(playerID);
            if (playerTeam == null) 
            {
                return false;
            }

            RelationshipManager.PlayerTeam friendTeam = RelationshipManager.ServerInstance.FindPlayersTeam(friendID);
            if (friendTeam == null)
            {
                return false;
            }

            return playerTeam == friendTeam;
        }

        private bool AreFriends(ulong playerID, ulong friendID)
        {
            // Friends plugin
            return Friends != null && Friends.Call<bool>("AreFriends", playerID, friendID);
        }

        private bool SameClan(ulong playerID, ulong friendID)
        {
            // Clans plugin
            bool isMember = Clans != null && Clans.Call<bool>("IsClanMember", playerID.ToString(), friendID.ToString());
            if (isMember != null) return isMember;

            // Rust:IO Clans plugin
            string playerClan = Clans?.Call<string>("GetClanOf", playerID);
            if (playerClan == null) return false;
            
            string friendClan = Clans?.Call<string>("GetClanOf", friendID);
            if (friendClan == null) return false;

            return playerClan == friendClan;
        }

        #endregion Helpers
    }
}


// --- End of file: HackableLock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/hostile-time ---
// --- Original File Path: H/HostileTime/HostileTime.cs ---

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Hostile Time", "Orange", "1.0.2")]
    [Description("Changes value of hostile duration")]
    public class HostileTime : RustPlugin
    {
        #region Oxide Hooks

        private void OnEntityMarkHostile(BasePlayer player, float duration)
        {
            if (player.userID.IsSteamId() == false)
            {
                return;
            }
            
            NextTick(() =>
            {
                if (player.IsValid() == false || player.IsHostile() == false)
                {
                    return;
                }
                
                var diff = duration - config.newDuration;
                if (diff > 0)
                {
                    Unsubscribe(nameof(OnEntityMarkHostile));
                    player.State.unHostileTimestamp -= diff;
                    player.MarkHostileFor(0f);
                    Subscribe(nameof(OnEntityMarkHostile));
                }
            });
        }

        #endregion
        
        #region Configuration | 24.05.2020

        private static ConfigData config = new ConfigData();

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Hostile duration (seconds)")]
            public float newDuration = 300;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                for (var i = 0; i < 3; i++)
                {
                    PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                }
                
                LoadDefaultConfig();
                return;
            }

            ValidateConfig();
            SaveConfig();
        }

        private static void ValidateConfig()
        {
            if (ConVar.Server.hostname.Contains("[DEBUG]") == true)
            {
                config = new ConfigData();
            }
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: HostileTime.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/heli-sams ---
// --- Original File Path: H/HeliSams/HeliSams.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using VLB;
using static SamSite;
using static BaseVehicle;

namespace Oxide.Plugins
{
    [Info("Heli Sams", "WhiteThunder & Whispers88", "2.1.3")]
    [Description("Allows Sam Sites to target CH47 and Patrol Helicopters")]
    internal class HeliSams : CovalencePlugin
    {
        #region Fields

        private const float DebugDrawDistance = 500;

        private const string PermissionCh47Npc = "helisams.ch47.npc";
        private const string PermissionCh47Player = "helisams.ch47.player";
        private const string PermissionPatrolHeli = "helisams.patrolheli";
        private const string CH47NpcPrefab = "assets/prefabs/npc/ch47/ch47scientists.entity.prefab";

        private readonly object False = false;

        private static Configuration _config;
        private static uint _ch47NpcPrefabId;

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(PermissionCh47Npc, this);
            permission.RegisterPermission(PermissionCh47Player, this);
            permission.RegisterPermission(PermissionPatrolHeli, this);
        }

        private void OnServerInitialized()
        {
            _ch47NpcPrefabId = StringPool.Get(CH47NpcPrefab);

            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var ch47 = entity as CH47Helicopter;
                if (ch47 != null)
                {
                    OnEntitySpawned(ch47);
                    continue;
                }

                var patrolHeli = entity as PatrolHelicopter;
                if (patrolHeli != null)
                {
                    OnEntitySpawned(patrolHeli);
                    continue;
                }
            }
        }

        private void Unload()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var ch47 = entity as CH47Helicopter;
                if (ch47 != null)
                {
                    SAMTargetComponent.RemoveFromEntity(ch47);
                    continue;
                }

                var patrolHeli = entity as PatrolHelicopter;
                if (patrolHeli != null)
                {
                    SAMTargetComponent.RemoveFromEntity(patrolHeli);
                    continue;
                }
            }

            _config = null;
        }

        private void OnEntitySpawned(CH47Helicopter entity) => SAMTargetComponent.AddToEntity(entity);

        private void OnEntitySpawned(PatrolHelicopter entity) => SAMTargetComponent.AddToEntity(entity);

        private void OnEntityKill(CH47Helicopter entity) => SAMTargetComponent.RemoveFromEntity(entity);

        private void OnEntityKill(PatrolHelicopter entity) => SAMTargetComponent.RemoveFromEntity(entity);

        private object OnSamSiteTarget(SamSite samSite, SAMTargetComponent targetComponent)
        {
            var ch47 = targetComponent.Entity as CH47Helicopter;
            if ((object)ch47 != null)
            {
                if (IsNpcCH47(ch47))
                    return ShouldTargetNpcCH47(samSite, ch47) ? null : False;

                return ShouldTargetPlayerCH47(samSite, ch47) ? null : False;
            }

            var patrolHeli = targetComponent.Entity as PatrolHelicopter;
            if ((object)patrolHeli != null)
                return ShouldTargetPatrolHelicopter(samSite, patrolHeli) ? null : False;

            return null;
        }

        private void OnEntityTakeDamage(CH47Helicopter ch47, HitInfo info)
        {
            var samSite = info.Initiator as SamSite;
            if (samSite == null)
                return;

            var damageMultiplier = IsNpcCH47(ch47)
                ? _config.CH47Npc.RocketDamageMultiplier
                : _config.CH47Player.RocketDamageMultiplier;

            if (damageMultiplier > 1)
            {
                info.damageTypes.ScaleAll(damageMultiplier);
                if (_config.DebugRocketDamage)
                {
                    ShowRocketDamage(info.HitPositionWorld, info.damageTypes.Total());
                }
            }
        }

        private void OnEntityTakeDamage(PatrolHelicopter patrolHeli, HitInfo info)
        {
            var samSite = info.Initiator as SamSite;
            if (samSite == null)
                return;

            var damageMultiplier = _config.PatrolHeli.RocketDamageMultiplier;
            if (damageMultiplier > 1)
            {
                info.damageTypes.ScaleAll(damageMultiplier);
                if (_config.DebugRocketDamage)
                {
                    ShowRocketDamage(info.HitPositionWorld, info.damageTypes.Total());
                }
            }
        }

        #endregion

        #region Helper Methods

        private static bool IsNpcCH47(CH47Helicopter ch47)
        {
            return ch47.prefabID == _ch47NpcPrefabId;
        }

        private static bool IsOccupied(BaseCombatEntity entity, List<MountPointInfo> mountPoints)
        {
            if (mountPoints != null)
            {
                foreach (var mountPoint in mountPoints)
                {
                    var player = mountPoint.mountable.GetMounted();
                    if ((object)player != null)
                        return true;
                }
            }

            foreach (var child in entity.children)
            {
                if (child is BasePlayer)
                    return true;
            }

            return false;
        }

        private static bool IsAuthed(BuildingPrivlidge cupboard, ulong userId)
        {
            foreach (var entry in cupboard.authorizedPlayers)
            {
                if (entry.userid == userId)
                    return true;
            }

            return false;
        }

        private static BuildingPrivlidge GetSamSiteToolCupboard(SamSite samSite)
        {
            return samSite.GetBuildingPrivilege(samSite.WorldSpaceBounds());
        }

        private bool ShouldTargetNpcCH47(SamSite samSite, CH47Helicopter ch47)
        {
            // Always allow static sam sites since this will only be called if that is enabled in the config.
            if (samSite.staticRespawn)
                return true;

            if (!SamSiteHasPermission(samSite, PermissionCh47Npc))
                return false;

            return true;
        }

        private bool ShouldTargetPlayerCH47(SamSite samSite, CH47Helicopter ch47)
        {
            // Always allow static sam sites since this will only be called if that is enabled in the config.
            if (samSite.staticRespawn)
                return true;

            if (!SamSiteHasPermission(samSite, PermissionCh47Player))
                return false;

            var mountPoints = ch47.mountPoints;
            if (!IsOccupied(ch47, mountPoints))
                return false;

            if (!_config.CH47Player.CheckCupboardAuth)
                return true;

            var cupboard = GetSamSiteToolCupboard(samSite);
            if ((object)cupboard == null)
                return true;

            if (mountPoints != null)
            {
                foreach (var mountPoint in mountPoints)
                {
                    var player = mountPoint.mountable.GetMounted();
                    if ((object)player != null && IsAuthed(cupboard, player.userID))
                        return false;
                }
            }

            foreach (var child in ch47.children)
            {
                var player = child as BasePlayer;
                if ((object)player != null)
                {
                    if (IsAuthed(cupboard, player.userID))
                        return false;
                }
            }

            return true;
        }

        private bool ShouldTargetPatrolHelicopter(SamSite samSite, PatrolHelicopter patrolHeli)
        {
            // Don't allow static sam sites to target owned helicopters if cupboard auth is required.
            // Otherwise, allow static sam sites since this will only be called if that is enabled in the config.
            if (samSite.staticRespawn)
                return !_config.PatrolHeli.RequireCupboardAuth;

            if (!SamSiteHasPermission(samSite, PermissionPatrolHeli))
                return false;

            // Always allow unowned Patrol Helicopters to be targeted by Sam Sites that have permission.
            if (patrolHeli.OwnerID == 0)
                return true;

            if (_config.PatrolHeli.RequireCupboardAuth)
            {
                var cupboard = GetSamSiteToolCupboard(samSite);

                // Don't allow Sam Sites without a Tool Cupboard to target owned Patrol Helicopters.
                // This could possibly be changed in the future, to follow the Sam Site ownership,
                // if the config option is renamed for clarity.
                if ((object)cupboard == null)
                    return false;

                // Only target the Patrol Helicopter if owned by an authorized player.
                return IsAuthed(cupboard, patrolHeli.OwnerID);
            }

            return true;
        }

        private bool SamSiteHasPermission(SamSite samSite, string perm)
        {
            if (samSite.OwnerID == 0)
                return false;

            return permission.UserHasPermission(samSite.OwnerID.ToString(), perm);
        }

        private Vector3 PredictedPos(BaseEntity target, SamSite samSite, Vector3 targetVelocity, float projectileSpeedMultiplier)
        {
            Vector3 targetpos = target.transform.TransformPoint(target.transform.GetBounds().center);
            Vector3 displacement = targetpos - samSite.eyePoint.transform.position;
            float projectileSpeed = samSite.projectileTest.Get().GetComponent<ServerProjectile>().speed * projectileSpeedMultiplier;
            float targetMoveAngle = Vector3.Angle(-displacement, targetVelocity) * Mathf.Deg2Rad;
            if (targetVelocity.magnitude == 0 || targetVelocity.magnitude > projectileSpeed && Mathf.Sin(targetMoveAngle) / projectileSpeed > Mathf.Cos(targetMoveAngle) / targetVelocity.magnitude)
                return targetpos;

            float shootAngle = Mathf.Asin(Mathf.Sin(targetMoveAngle) * targetVelocity.magnitude / projectileSpeed);
            return targetpos + targetVelocity * displacement.magnitude / Mathf.Sin(Mathf.PI - targetMoveAngle - shootAngle) * Mathf.Sin(shootAngle) / targetVelocity.magnitude;
        }

        private void ShowRocketPath(Vector3 samSitePositon, Vector3 position)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player.IsAdmin && (position - player.transform.position).sqrMagnitude <= DebugDrawDistance*DebugDrawDistance)
                {
                    player.SendConsoleCommand("ddraw.sphere", 5, Color.red, position, 1);
                    player.SendConsoleCommand("ddraw.arrow", 5, Color.red, samSitePositon, position, 1);
                }
            }
        }

        private void ShowRocketDamage(Vector3 position, float amount)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player.IsAdmin && (position - player.transform.position).sqrMagnitude <= DebugDrawDistance*DebugDrawDistance)
                {
                    player.SendConsoleCommand("ddraw.text", 5, Color.red, position, amount.ToString());
                }
            }
        }

        #endregion

        #region Target Component

        private class SAMTargetComponent : FacepunchBehaviour, ISamSiteTarget
        {
            public static HashSet<SAMTargetComponent> SAMTargetComponents = new HashSet<SAMTargetComponent>();

            public static void AddToEntity(BaseCombatEntity entity) =>
                entity.GetOrAddComponent<SAMTargetComponent>();

            public static void RemoveFromEntity(BaseCombatEntity entity) =>
                DestroyImmediate(entity.GetComponent<SAMTargetComponent>());

            public BaseEntity Entity;
            public float TargetRangeSquared;
            private GameObject _child;
            private Transform _transform;
            private SamTargetType _targetType;

            private void Awake()
            {
                SAMTargetComponents.Add(this);

                Entity = GetComponent<BaseEntity>();
                _transform = Entity.transform;

                var ch47 = Entity as CH47Helicopter;
                if ((object)ch47 != null)
                {
                    if (IsNpcCH47(ch47))
                    {
                        TargetRangeSquared = Mathf.Pow(_config.CH47Npc.TargetRange, 2);
                        _targetType = _config.CH47Npc.TargetType;
                    }
                    else
                    {
                        TargetRangeSquared = Mathf.Pow(_config.CH47Player.TargetRange, 2);
                        _targetType = _config.CH47Player.TargetType;
                    }
                }

                if (Entity is PatrolHelicopter)
                {
                    TargetRangeSquared = Mathf.Pow(_config.PatrolHeli.TargetRange, 2);
                    _targetType = _config.PatrolHeli.TargetType;

                    _child = Entity.gameObject.CreateChild();
                    _child.gameObject.layer = (int)Rust.Layer.Vehicle_World;
                    _child.AddComponent<SphereCollider>();
                }
            }

            private void OnDestroy()
            {
                if (_child != null)
                {
                    DestroyImmediate(_child);
                }

                SAMTargetComponents.Remove(this);
            }

            public Vector3 Position => _transform.position;

            public SamTargetType SAMTargetType => _targetType;

            public bool isClient => false;

            public bool IsValidSAMTarget(bool isStaticSamSite)
            {
                if (!isStaticSamSite)
                {
                    // If not static, whether to target will be determined in OnSamSiteTarget,
                    // since that is when the sam site itself is available to check permissions.
                    return true;
                }

                var ch47 = Entity as CH47Helicopter;
                if ((object)ch47 != null)
                {
                    return IsNpcCH47(ch47)
                        ? _config.CH47Npc.CanBeTargetedByStaticSamSites
                        : _config.CH47Player.CanBeTargetedByStaticSamSites;
                }

                if (Entity is PatrolHelicopter)
                    return _config.PatrolHeli.CanBeTargetedByStaticSamSites;

                return false;
            }

            public Vector3 CenterPoint() => Entity.CenterPoint();

            public Vector3 GetWorldVelocity() => Entity.GetWorldVelocity();

            public bool IsVisible(Vector3 position, float distance) => Entity.IsVisible(position, distance);
        }

        private void OnSamSiteTargetScan(SamSite samSite, List<ISamSiteTarget> targetList)
        {
            if (samSite.IsInDefenderMode() || SAMTargetComponent.SAMTargetComponents.Count == 0)
                return;

            var samSitePosition = samSite.transform.position;

            foreach (var targetComponent in SAMTargetComponent.SAMTargetComponents)
            {
                if ((samSitePosition - targetComponent.Position).sqrMagnitude <= targetComponent.TargetRangeSquared)
                {
                    targetList.Add(targetComponent);
                }
            }
        }

        private void CanSamSiteShoot(SamSite samSite)
        {
            var targetComponent = samSite.currentTarget as SAMTargetComponent;
            if (targetComponent == null)
                return;

            var ch47 = targetComponent.Entity as CH47Helicopter;
            if (ch47 != null)
            {
                var targetVelocity = targetComponent.gameObject.GetComponent<Rigidbody>().velocity;
                var estimatedPoint = PredictedPos(ch47, samSite, targetVelocity, targetComponent.SAMTargetType.speedMultiplier);
                samSite.currentAimDir = (estimatedPoint - samSite.eyePoint.transform.position).normalized;
                if (_config.DebugRocketPrediction)
                {
                    ShowRocketPath(samSite.eyePoint.position, estimatedPoint);
                }

                return;
            }

            var patrolHeli = targetComponent.Entity as PatrolHelicopter;
            if (patrolHeli != null)
            {
                var patrolHeliAI = patrolHeli.myAI;
                var targetVelocity = patrolHeliAI.GetLastMoveDir() * patrolHeliAI.GetMoveSpeed() * 1.25f;
                var estimatedPoint = PredictedPos(patrolHeli, samSite, targetVelocity, targetComponent.SAMTargetType.speedMultiplier);
                samSite.currentAimDir = (estimatedPoint - samSite.eyePoint.transform.position).normalized;
                if (_config.DebugRocketPrediction)
                {
                    ShowRocketPath(samSite.transform.position, estimatedPoint);
                }

                return;
            }
        }

        #endregion

        #region Configuration

        [JsonObject(MemberSerialization.OptIn)]
        private class HeliSettings
        {
            [JsonProperty("Can be targeted by static SAM Sites")]
            public bool DeprecatedCanBeTargetedByStaticSamSites { set { CanBeTargetedByStaticSamSites = value; } }

            [JsonProperty("Can be targeted by static Sam Sites")]
            public bool CanBeTargetedByStaticSamSites = true;

            [JsonProperty("Targeting range")]
            public float TargetRange = 150;

            [JsonProperty("Rocket speed multiplier")]
            public float RocketSpeedMultiplier = 1;

            [JsonProperty("Rocket damage multiplier")]
            public float RocketDamageMultiplier = 1;

            [JsonProperty("Seconds between rocket bursts")]
            public float SecondsBetweenBursts = 5;

            private SamTargetType _targetType;
            public SamTargetType TargetType
            {
                get
                {
                    if (_targetType == null)
                    {
                        _targetType = new SamTargetType(TargetRange, RocketSpeedMultiplier, SecondsBetweenBursts);
                    }

                    return _targetType;
                }
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class PatrolHeliSettings : HeliSettings
        {
            [JsonProperty("Require cupboard auth for owned helicopters", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool RequireCupboardAuth = false;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class PlayerCH47Settings : HeliSettings
        {
            [JsonProperty("Check cupboard auth")]
            public bool CheckCupboardAuth = false;
        }

        private class Configuration : BaseConfiguration
        {
            [JsonProperty("NPC CH47 Helicopter")]
            public HeliSettings CH47Npc = new HeliSettings
            {
                RocketDamageMultiplier = 4,
            };

            [JsonProperty("Player CH47 Helicopter")]
            public PlayerCH47Settings CH47Player = new PlayerCH47Settings
            {
                RocketDamageMultiplier = 2,
            };

            [JsonProperty("Patrol Helicopter")]
            public PatrolHeliSettings PatrolHeli = new PatrolHeliSettings
            {
                RocketDamageMultiplier = 4,
                RocketSpeedMultiplier = 1.5f,
            };

            [JsonProperty("Debug rocket prediction")]
            public bool DebugRocketPrediction;

            [JsonProperty("Debug rocket damage")]
            public bool DebugRocketDamage;
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #region Configuration Helpers

        private class BaseConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion
    }
}


// --- End of file: HeliSams.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/helicopter-hover ---
// --- Original File Path: H/HelicopterHover/HelicopterHover.cs ---

using System;
using System.Collections;
using System.Collections.Generic;

using UnityEngine;

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Helicopter Hover", "0x89A", "2.0.8")]
    [Description("Allows minicopters to hover without driver on command")]
    class HelicopterHover : RustPlugin
    {
        #region -Fields-

        private static HelicopterHover _plugin;
        private static Configuration _config;

        private Dictionary<int, HoveringComponent> _helicopters = new Dictionary<int, HoveringComponent>();

        private const string CanHover = "helicopterhover.canhover";

        #endregion -Fields-

        #region -Init-

        void Init()
        {
            _plugin = this;

            if (!_config.EnterBroadcast) Unsubscribe(nameof(OnEntityMounted));
            if (!_config.Hovering.DisableHoverOnDismount) Unsubscribe(nameof(OnEntityDismounted));

            permission.RegisterPermission(CanHover, this);
        }

        void Unload()
        {
            _plugin = null;
            _config = null;

            foreach (KeyValuePair<int, HoveringComponent> pair in _helicopters) UnityEngine.Object.Destroy(pair.Value);
        }

        void OnServerInitialized()
        {
            foreach (BaseNetworkable networkable in BaseNetworkable.serverEntities)
            {
                if (networkable is PlayerHelicopter) OnEntitySpawned(networkable as BaseHelicopter);
            }
        }

        #endregion -Init-

        #region -Commands-

        [ConsoleCommand("helicopterhover.hover")]
        void ConsoleHover(ConsoleSystem.Arg args)
        {
            if (args.Player() != null) Hover(args.Player());
        }

        [ChatCommand("hover")]
        void Hover(BasePlayer player)
        {
            if (player == null) return;
            BaseHelicopter helicopter = player.GetMountedVehicle() as BaseHelicopter;

            if (permission.UserHasPermission(player.UserIDString, CanHover) && helicopter != null && _helicopters.ContainsKey(helicopter.GetInstanceID()) && (_config.Permission.PassengerToggle || helicopter.GetDriver() == player) && (_config.Permission.EnableHoverWithTwoOccupants || helicopter.NumMounted() <= 1))
            {
                if (helicopter.IsEngineOn() || helicopter.GetDriver() != player) _helicopters[helicopter.GetInstanceID()]?.ToggleHover();
                else PrintToChat(player, lang.GetMessage("NotFlying", this, player.UserIDString));
            }
            else if (!permission.UserHasPermission(player.UserIDString, CanHover)) 
                PrintToChat(player, lang.GetMessage("NoPermission", this, player.UserIDString));
            else if (helicopter == null) 
                PrintToChat(player, lang.GetMessage("NotInHelicopter", this, player.UserIDString));
            else if (!_config.Permission.PassengerToggle || helicopter.GetDriver() != player) 
                PrintToChat(player, lang.GetMessage("NoPassengerToggle", this, player.UserIDString));
            else if (!_config.Permission.EnableHoverWithTwoOccupants && helicopter.NumMounted() > 1) 
                PrintToChat(player, lang.GetMessage("CantHoverTwoOccupants", this, player.UserIDString));
        }
        
        #endregion -Commands-

        #region -Hooks-

        void OnEntitySpawned(BaseHelicopter helicopter) //Apply custom script when helicopters spawn
        {
            if (_helicopters.ContainsKey(helicopter.GetInstanceID()) || (helicopter is ScrapTransportHelicopter && !_config.Permission.ScrapheliCanHover) || (helicopter is Minicopter && !_config.Permission.MiniCanHover) || (helicopter is CH47Helicopter && !_config.Permission.ChinookCanHover)) return;

            _helicopters.Add(helicopter.GetInstanceID(), helicopter.gameObject.AddComponent<HoveringComponent>());
        }

        void OnEntityMounted(BaseMountable mount, BasePlayer player) //Broadcast message when mounting helicopter.
        {
            BaseEntity parentEntity = mount.GetParentEntity();

            //Make sure that chat message only sends if the vehicle is allowed to hover (set in config)
            if (parentEntity != null && permission.UserHasPermission(player.UserIDString, CanHover) && ((parentEntity is ScrapTransportHelicopter && _config.Permission.ScrapheliCanHover) || (parentEntity is Minicopter && _config.Permission.MiniCanHover) || (parentEntity is CH47Helicopter && _config.Permission.ChinookCanHover)))
                PrintToChat(player, lang.GetMessage("Mounted", this, player.UserIDString));
        }

        void OnEntityDismounted(BaseMountable mount, BasePlayer player) //Handle disabling hover on dismount
        {
            BaseHelicopter parent = mount?.GetParentEntity() as BaseHelicopter;

            //If is not helicopter or "helicopters" does not contain key, return
            if (parent == null || !_helicopters.ContainsKey(parent.GetInstanceID())) return;

            if (_config.Hovering.DisableHoverOnDismount) _helicopters[parent.GetInstanceID()]?.StopHover();
        }

        void OnServerCommand(ConsoleSystem.Arg args)
        {
            BaseHelicopter vehicle = args.Player()?.GetMountedVehicle() as BaseHelicopter;
            if (args.cmd.FullName != "vehicle.swapseats" || vehicle == null || vehicle.GetDriver() != args.Player() || !_helicopters.ContainsKey(vehicle.GetInstanceID())) return;

            HoveringComponent hover = _helicopters[vehicle.GetInstanceID()];

            if (_config.Hovering.DisableHoverOnSeat && hover.IsHovering) hover.StopHover();
            else if (_config.Hovering.HoverOnSeatSwitch && !hover.IsHovering) hover.StartHover();
        }

        #endregion -Hooks-

        private class HoveringComponent : MonoBehaviour
        {
            private BaseHelicopter _helicopter;
            private PlayerHelicopter _playerHelicopter;
            
            Rigidbody _rb;

            Timer _timedHoverTimer;
            Timer _fuelUseTimer;

            Coroutine _hoverCoroutine;

            VehicleEngineController<PlayerHelicopter> _engineController;

            public bool IsHovering => _rb.constraints == RigidbodyConstraints.FreezePositionY;

            void Awake()
            {
                if (!TryGetComponent(out _helicopter) || !TryGetComponent(out _rb))
                {
                    _plugin._helicopters.Remove(_helicopter?.GetInstanceID() ?? 0);
                    DestroyImmediate(this);
                    return;
                }
                
                _engineController = (_playerHelicopter = _helicopter as PlayerHelicopter)?.engineController;
            }

            public void ToggleHover()
            {
                if (IsHovering) StopHover();
                else StartHover();

                foreach (BaseVehicle.MountPointInfo info in _helicopter.mountPoints)
                {
                    BasePlayer player = info.mountable.GetMounted();
                    if (player != null) _plugin.PrintToChat(player, _plugin.lang.GetMessage(IsHovering ? "HelicopterEnabled" : "HelicopterDisabled", _plugin, player.UserIDString));
                }
            }

            public void StartHover()
            {
                _rb.constraints = RigidbodyConstraints.FreezePositionY;
                if (!_config.Hovering.EnableRotationOnHover) _rb.freezeRotation = true;

                _engineController?.FinishStartingEngine();

                if (_config.Hovering.KeepEngineOnHover && _helicopter != null) _hoverCoroutine = ServerMgr.Instance.StartCoroutine(HoveringCoroutine());
            }

            public void StopHover()
            {
                _rb.constraints = RigidbodyConstraints.None;
                _rb.freezeRotation = false;

                if (_hoverCoroutine != null) ServerMgr.Instance.StopCoroutine(_hoverCoroutine);
                if (_timedHoverTimer != null) _timedHoverTimer.Destroy();
                if (_fuelUseTimer != null) _fuelUseTimer.Destroy();
            }

            IEnumerator HoveringCoroutine() //Keep engine running and manage fuel
            {
                if (_config.Hovering.TimedHover) _timedHoverTimer = _plugin.timer.Once(_config.Hovering.HoverDuration, () => StopHover());

                IFuelSystem fuelSystem = _helicopter?.GetFuelSystem();
                
                if (fuelSystem != null)
                {
                    if (_config.Hovering.UseFuelOnHover) _fuelUseTimer = _plugin.timer.Every(1f, () =>
                    {
                        if (fuelSystem.HasFuel() && _helicopter.GetDriver() == null) fuelSystem.TryUseFuel(1f, _playerHelicopter.fuelPerSec);
                        else if (!fuelSystem.HasFuel()) _fuelUseTimer.Destroy();
                    });
                }

                //Keep engine on
                
                while (IsHovering)
                {
                    if (!(_engineController?.IsOn ?? false) && (_helicopter.AnyMounted() || !_config.Hovering.DisableHoverOnDismount)) _engineController?.FinishStartingEngine();

                    if (fuelSystem != null)
                    {
                        if (!fuelSystem.HasFuel()) //If no fuel, stop hovering
                        {
                            StopHover();
                            _engineController?.StopEngine();

                            yield break;
                        }
                    }

                    yield return null;
                }
            }

            void OnDestroy() //Stop any timers or coroutines persisting after destruction or plugin unload
            {
                if (_hoverCoroutine != null) ServerMgr.Instance.StopCoroutine(_hoverCoroutine);
                _timedHoverTimer?.Destroy();
                _fuelUseTimer?.Destroy();
            }
        }

        #region -Configuration-

        class Configuration
        {
            [JsonProperty(PropertyName = "Broadcast message on mounted")]
            public bool EnterBroadcast = true;

            [JsonProperty(PropertyName = "Permissions")]
            public PermissionClass Permission = new PermissionClass();

            [JsonProperty(PropertyName = "Hovering")]
            public HoveringClass Hovering = new HoveringClass();

            public class PermissionClass
            {
                [JsonProperty(PropertyName = "Minicopter can hover")]
                public bool MiniCanHover = true;
                
                [JsonProperty(PropertyName = "Scrap Transport Helicopter can hover")]
                public bool ScrapheliCanHover = true;

                [JsonProperty(PropertyName = "Chinook can hover")]
                public bool ChinookCanHover = true;

                [JsonProperty(PropertyName = "Enable hover with two occupants")]
                public bool EnableHoverWithTwoOccupants = true;

                [JsonProperty(PropertyName = "Passenger can toggle hover")]
                public bool PassengerToggle = true;
            }

            public class HoveringClass
            {
                [JsonProperty(PropertyName = "Disable hover on dismount")]
                public bool DisableHoverOnDismount = true;

                [JsonProperty(PropertyName = "Use fuel while hovering")]
                public bool UseFuelOnHover = true;

                [JsonProperty(PropertyName = "Keep engine on when hovering")]
                public bool KeepEngineOnHover = true;

                [JsonProperty(PropertyName = "Enable helicopter rotation on hover")]
                public bool EnableRotationOnHover = true;

                [JsonProperty(PropertyName = "Disable hover on change seats")]
                public bool DisableHoverOnSeat = false;

                [JsonProperty(PropertyName = "Hover on seat change")]
                public bool HoverOnSeatSwitch = true;

                [JsonProperty(PropertyName = "Timed hover")]
                public bool TimedHover = false;

                [JsonProperty(PropertyName = "Timed hover duration")]
                public float HoverDuration = 60;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Failed to load config, using default values");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion -Configuration-s

        #region -Localisation-

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["OnlyAdmins"] = "This command is exclusive to admins",
                ["NotFlying"] = "The helicopter is not flying",
                ["Mounted"] = "Use '/hover' to toggle hover",
                ["NoPermission"] = "You do not have permission to hover",
                ["CantHoverTwoOccupants"] = "Cannot hover with two occupants",
                ["HelicopterEnabled"] = "Helicopter hover: enabled",
                ["HelicopterDisabled"] = "Helicopter hover: disabled",
                ["NotInHelicopter"] = "You are not in a helicopter",
                ["NoPassengerToggle"] = "Passengers cannot toggle hover"
            }
            , this);
        }

        #endregion
    }
}


// --- End of file: HelicopterHover.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/handy-man ---
// --- Original File Path: H/HandyMan/HandyMan.cs ---

using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Facepunch;
using System;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Handy Man", "nivex", "1.3.4")]
    [Description("Provides AOE repair functionality to the player. Repair is only possible where you can build.")]
    public class HandyMan : RustPlugin
    {
        [PluginReference]
        Plugin NoEscape;

        readonly DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetFile(nameof(Name));
        Dictionary<ulong, bool> playerData = new Dictionary<ulong, bool>(); //player preference values
        Dictionary<BuildingPrivlidge, BaseCombatEntity> entities = new Dictionary<BuildingPrivlidge, BaseCombatEntity>();
        bool _allowHandyManFixMessage = true;
        bool _allowAOERepair = true;
        PluginTimers RepairMessageTimer; //Timer to control HandyMan chats
        static int constructionMask = LayerMask.GetMask("Construction");
        static int allMask = LayerMask.GetMask("Construction", "Deployed");
        static float lastAttackLimit = 30f;
        static float privDistance = 21f;

        bool IsRaidBlocked(string targetId) => UseRaidBlocker && (bool)(NoEscape?.Call("IsRaidBlocked", targetId) ?? false);
        bool HasPerm(BasePlayer player) => permission.UserHasPermission(player.UserIDString, "handyman.use") || player.IsAdmin || player.IsDeveloper || player.net.connection.authLevel > 0;
        bool HasResources(BasePlayer player)
        {
            bool found = false;
            var itemList = Pool.Get<List<Item>>();
            player.inventory.GetAllItems(itemList);
            foreach (var item in itemList)
            {
                if (item.info.shortname == "wood" || item.info.shortname == "metal.refined" || item.info.shortname == "stones" || item.info.shortname == "metal.fragments")
                { found = true; break; }
            }
            Pool.Free(ref itemList);
            return found;
        }

        private void Loaded()
        {
            permission.RegisterPermission("handyman.use", this);
            LoadVariables();

            try
            {
                playerData = dataFile.ReadObject<Dictionary<ulong, bool>>();
            }
            catch { }

            if (playerData == null)
                playerData = new Dictionary<ulong, bool>();

            //Set message timer to prevent user spam
            RepairMessageTimer = new PluginTimers(this);
            RepairMessageTimer.Every(HandyManChatInterval, () => _allowHandyManFixMessage = true);
        }

        void OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (!_allowAOERepair || !HasPerm(player) || IsRaidBlocked(player.UserIDString) || info.HitEntity == null || info.HitEntity.IsDestroyed)
            {
                return;
            }

            var entity = info.HitEntity as BaseCombatEntity;

            if (!entity)
            {
                return;
            }

            if (!playerData.ContainsKey(player.userID))
            {
                playerData[player.userID] = DefaultHandyManOn;
                dataFile.WriteObject(playerData);
            }

            if (playerData[player.userID])
            {
                if (!HasResources(player))
                {
                    SendChatMessage(player, msg("No Resources", player.UserIDString));
                    return;
                }

                Repair(entity, player);
            }
        }

        void Repair(BaseCombatEntity entity, BasePlayer player)
        {
            if (player.CanBuild())
            {
                if (_allowHandyManFixMessage)
                {
                    SendChatMessage(player, msg("Fix", player.UserIDString));
                    _allowHandyManFixMessage = false;
                }

                RepairAOE(entity, player);
            }
            else
                SendChatMessage(player, msg("NotAllowed", player.UserIDString));
        }

        private void RepairAOE(BaseCombatEntity entity, BasePlayer player)
        {
            //Prevent infinite loop
            _allowAOERepair = false;

            //gets the position of the block we just hit
            var position = new OBB(entity.transform, entity.bounds).ToBounds().center;
            //sets up the collection for the blocks that will be affected
            var entities = Pool.Get<List<BaseCombatEntity>>();

            //gets a list of entities within a specified range of the current target
            Vis.Entities(position, RepairRange, entities, repairDeployables ? allMask : constructionMask);
            int repaired = 0;

            if (entities.Count == 1)
            {
                _allowAOERepair = true;
                Pool.FreeUnmanaged(ref entities);
                return;
            }

            //check if we have blocks - we should always have at least 1
            if (entities.Count > 0)
            {
                var resources = new Dictionary<string, float>();
                int lastAttacked = 0;

                //cycle through our block list - figure out which ones need repairing
                foreach (var ent in entities)
                {
                    //check to see if the block has been damaged before repairing.
                    if (ent.health < ent.MaxHealth())
                    {
                        if (ent.SecondsSinceAttacked <= lastAttackLimit)
                        {
                            lastAttacked++;
                            continue;
                        }

                        var ret = CanRepair(ent, player, entities);

                        if (ret is KeyValuePair<string, float>)
                        {
                            var kvp = (KeyValuePair<string, float>)ret;

                            if (!resources.ContainsKey(kvp.Key))
                            {
                                resources.Add(kvp.Key, kvp.Value);
                            }
                            else
                            {
                                resources[kvp.Key] += kvp.Value;
                            }
                        }
                        else if (ret is bool && (bool)ret)
                        {
                            if (DoRepair(ent, player))
                            {
                                if (markRepairedTime > 0f && player.IsAdmin)
                                {
                                    player.SendConsoleCommand("ddraw.text", markRepairedTime, Color.green, ent.WorldSpaceBounds().ToBounds().center, "R");
                                }

                                if (++repaired > maxRepairEnts)
                                {
                                    break;
                                }
                            }
                        }
                    }
                }

                Pool.FreeUnmanaged(ref entities);

                if (resources.Count > 0)
                {
                    if (resources.Count > 1 || (resources.Count == 1 && resources.First().Key == "High Quality Metal" && resources.First().Value > 3))
                    {
                        foreach (var kvp in resources)
                        {
                            SendChatMessage(player, msg("Missing Resources Multiple", player.UserIDString, kvp.Key, kvp.Value));
                        }

                        SendChatMessage(player, msg("Missing Resources Partial", player.UserIDString));
                    }
                    else
                    {
                        SendChatMessage(player, msg("Missing Resources Single", player.UserIDString, resources.First().Key, resources.First().Value));
                    }

                    if (repaired == 0)
                    {
                        _allowAOERepair = true;
                    }
                }

                if (!_allowAOERepair)
                {
                    SendChatMessage(player, repaired > 0 ? msg("IFixedEx", player.UserIDString, repaired) : msg(lastAttacked > 0 && repaired == 0 ? "CannotFixYet" : "FixDone", player.UserIDString));
                }
            }
            else
            {
                SendChatMessage(player, msg("MissingFix", player.UserIDString));
            }

            _allowAOERepair = true;
        }

        object CanRepair(BaseCombatEntity entity, BasePlayer player, List<BaseCombatEntity> entities)
        {
            float num = entity.MaxHealth() - entity.health;
            float num2 = num / entity.MaxHealth();
            var list = entity.RepairCost(num2);

            if (list != null && list.Count > 0)
            {
                foreach (var ia in list)
                {
                    var items = player.inventory.FindItemsByItemID(ia.itemid);
                    int sum = items.Sum(item => item.amount);

                    if (sum * repairMulti < ia.amount * repairMulti)
                    {
                        return new KeyValuePair<string, float>(ia.itemDef.displayName.english, ia.amount);
                    }
                }
            }

            var privs = entities.Where(ent => ent != null && ent.net != null && !ent.IsDestroyed && ent is BuildingPrivlidge).Cast<BuildingPrivlidge>().ToList();

            if (privs.Count == 0)
            {
                return true;
            }

            foreach(var priv in privs)
            {
                if (priv.Distance(entity) <= privDistance)
                {
                    return !priv.AnyAuthed() || priv.IsAuthed(player);
                }
            }

            return false; // player.CanBuild(new OBB(entity.transform, entity.bounds));
        }

        // BaseCombatEntity
        public bool DoRepair(BaseCombatEntity entity, BasePlayer player)
        {
            if (!entity.repair.enabled)
            {
                return false;
            }
            if (Interface.CallHook("OnStructureRepair", new object[]
            {
                entity,
                player
            }) != null)
            {
                return false;
            }
            if (entity.SecondsSinceAttacked <= lastAttackLimit)
            {
                entity.OnRepairFailed(player, string.Format("Unable to repair: Recently damaged. Repairable in: {0:N0}s.", lastAttackLimit - entity.SecondsSinceAttacked));
                return false;
            }
            float num = entity.MaxHealth() - entity.Health();
            float num2 = num / entity.MaxHealth();
            if (num <= 0f || num2 <= 0f)
            {
                entity.OnRepairFailed(player, "Unable to repair: Not damaged.");
                return false;
            }
            var list = entity.RepairCost(num2);
            if (list == null || list.Count == 0)
            {
                return false;
            }
            foreach (var ia in list)
            {
                ia.amount *= repairMulti;
            }
            float num3 = list.Sum(x => x.amount);

            if (num3 > 0f)
            {
                float num4 = list.Min(x => Mathf.Clamp01((float)player.inventory.GetAmount(x.itemid) / x.amount));
                num4 = Mathf.Min(num4, 50f / num);
                if (num4 <= 0f)
                {
                    entity.OnRepairFailed(player, "Unable to repair: Insufficient resources.");
                    return false;
                }
                int num5 = 0;
                foreach (var current in list)
                {
                    int amount = Mathf.CeilToInt(num4 * current.amount);
                    num5 += player.inventory.Take(null, current.itemid, amount);
                }

                float num7 = (float)num5 / num3;
                entity.health += num * num7;
                entity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            }
            else
            {
                entity.health += num;
                entity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            }
            if (entity.health >= entity.MaxHealth())
            {
                entity.OnRepairFinished();
            }
            else
            {
                entity.OnRepair();
            }

            return true;
        }

        [ChatCommand("handyman")]
        private void ChatCommand_HandyMan(BasePlayer player, string command, string[] args)
        {
            if (!HasPerm(player))
            {
                SendChatMessage(player, msg("NoPermission", player.UserIDString));
                return;
            }

            if (!playerData.ContainsKey(player.userID))
            {
                playerData[player.userID] = DefaultHandyManOn;
                dataFile.WriteObject(playerData);
            }

            if (args.Length > 0)
            {
                playerData[player.userID] = args[0].ToLower() == "on";
                dataFile.WriteObject(playerData);
            }

            SendChatMessage(player, msg(playerData[player.userID] ? "Hired" : "Fired", player.UserIDString));
        }

        [ConsoleCommand("healthcheck")]
        private void ConsoleCommand_HealthCheck() => Puts("HandyMan is running.");

        #region Config
        private bool Changed;
        private bool UseRaidBlocker;
        private bool DefaultHandyManOn;
        private int RepairRange;
        private int HandyManChatInterval;
        private float repairMulti;
        private bool repairDeployables;
        private int maxRepairEnts;
        private float markRepairedTime;

        protected override void LoadDefaultMessages()
        {
            string helpText =
                  "HandyMan - Help - v {ver} \n"
                + "-----------------------------\n"
                + "/HandyMan - Shows your current preference for HandyMan.\n"
                + "/HandyMan on/off - Turns HandyMan on/off.";

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Hired", "HandyMan has been Hired."},
                {"Fired", "HandyMan has been Fired."},
                {"Fix", "You fix this one, I'll get the rest."},
                {"NotAllowed", "You are not allowed to build here - I can't repair for you."},
                {"IFixed", "I fixed some damage over here..."},
                {"IFixedEx", "I fixed {0} constructions over here..."},
                {"FixDone", "Guess I fixed them all..."},
                {"MissingFix", "I'm telling you... it disappeared... I can't find anything to fix."},
                {"NoPermission", "You don't have permission to use this command." },
                {"Help", helpText},
                {"Missing Resources Single", "Missing resources: {0} ({1}). I'll need the full amount to repair this." },
                {"Missing Resources Multiple", "Missing resources: {0} ({1})" },
                {"Missing Resources Partial", "I can do some repairs with a partial amount of these resources." },
                {"No Resources", "You must have some resources in order to repair!" },
                {"CannotFixYet", "Everything has been attacked recently and cannot be repaired yet." }
            }, this);
        }

        void LoadVariables() //Assigns configuration data once read
        {
            HandyManChatInterval = Convert.ToInt32(GetConfig("Settings", "Chat Interval", 30));
            DefaultHandyManOn = Convert.ToBoolean(GetConfig("Settings", "Default On", true));
            RepairRange = Convert.ToInt32(GetConfig("Settings", "Repair Range", 50));
            UseRaidBlocker = Convert.ToBoolean(GetConfig("Settings", "Use Raid Blocker", false));
            repairMulti = Convert.ToSingle(GetConfig("Settings", "Repair Cost Multiplier", 1.0f));
            repairDeployables = Convert.ToBoolean(GetConfig("Settings", "Repair Deployables", false));
            maxRepairEnts = Convert.ToInt32(GetConfig("Settings", "Maximum Entities To Repair", 50));
            markRepairedTime = Convert.ToSingle(GetConfig("Settings", "Mark Repaired Entities For X Seconds (Admins Only)", 0f));

            if (repairMulti < 1.0f)
                repairMulti = 1.0f;

            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }

        /// <summary>
        /// Responsible for loading default configuration.
        /// Also creates the initial configuration file
        /// </summary>
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            Config.Clear();
            LoadVariables();
        }

        object GetConfig(string menu, string dataValue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(dataValue, out value))
            {
                value = defaultValue;
                data[dataValue] = value;
                Changed = true;
            }
            return value;
        }

        public string msg(string key, string id = null, params object[] args)
        {
            string message = id == null ? RemoveFormatting(lang.GetMessage(key, this, id)) : lang.GetMessage(key, this, id);

            return args.Length > 0 ? string.Format(message, args) : message;
        }

        public string RemoveFormatting(string source)
        {
            return source.Contains(">") ? System.Text.RegularExpressions.Regex.Replace(source, "<.*?>", string.Empty) : source;
        }

        private void SendChatMessage(BasePlayer player, string msg) => player.ChatMessage($"<color=#00FF8D>{Title}</color>: {msg}");
        #endregion
    }
}

// --- End of file: HandyMan.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/home-protection ---
// --- Original File Path: H/HomeProtection/HomeProtection.cs ---

namespace Oxide.Plugins
{
    [Info("Home Protection", "Wulf/lukespragg", "1.0.0")]
    [Description("Protects you and your home from intruders.")]

    class HomeProtection : RustPlugin
    {
        private void OnEntityTakeDamage(BasePlayer victim, HitInfo hitInfo)
        {
            if (hitInfo == null || victim == null || victim.userID.IsSteamId() == false)
                return;

            BasePlayer attacker = hitInfo.InitiatorPlayer;
            if (attacker == null || attacker.userID.IsSteamId() == false)
                return;

            if (attacker == victim)
                return;

            if (victim.Team != null && victim.Team.members.Contains(attacker.userID))
                return;

            if (victim.IsBuildingAuthed() && !attacker.IsBuildingAuthed())
                hitInfo.damageTypes.Clear();
        }

        private void OnEntityTakeDamage(BuildingBlock buildingBlock, HitInfo hitInfo)
        {
            if (hitInfo == null)
                return;

            BasePlayer attacker = hitInfo.InitiatorPlayer;
            if (attacker == null || attacker.userID.IsSteamId() == false)
                return;

            if (buildingBlock.OwnerID == attacker.userID)
                return;

            if (buildingBlock.GetBuildingPrivilege() != null && !attacker.IsBuildingAuthed())
                hitInfo.damageTypes.Clear();
        }
    }
}

// --- End of file: HomeProtection.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/help-text ---
// --- Original File Path: H/HelpText/HelpText.cs ---

﻿using System;
using System.Collections.Generic;
using System.Text;

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("HelpText", "Calytic", "2.0.51")]
    class HelpText : CovalencePlugin
    {
        private bool UseCustomHelpText;
        private bool AllowHelpTextFromOtherPlugins;
        private int BreakAfter;
        private Dictionary<string, Dictionary<string, object>> Pages = new Dictionary<string,Dictionary<string,object>>();

        private void Loaded()
        {
            CheckConfig();
            UseCustomHelpText = GetConfig("Settings", "UseCustomHelpText", false);
            AllowHelpTextFromOtherPlugins = GetConfig("Settings", "AllowHelpTextFromOtherPlugins", true);
            Pages.Add("default", GetConfig("Pages", "default", GetDefaultPages()));
            foreach(var group in permission.GetGroups()) {
                if(group != "default" && Config["Pages", group] != null) {
                    Pages.Add(group, GetConfig("Pages", group, GetEmptyPages()));
                }
            }

            BreakAfter = GetConfig("Settings", "BreakAfter", 10);
        }

        protected override void LoadDefaultConfig()
        {
            Config["Settings", "UseCustomHelpText"] = false;
            Config["Settings", "AllowHelpTextFromOtherPlugins"] = true;
            Config["Pages", "default"] = GetDefaultPages();

            Config["Settings", "BreakAfter"] = BreakAfter = 10;

            Config["VERSION"] = Version.ToString();
            SaveConfig();
        }

        protected Dictionary<string, object> GetDefaultPages()
        {
            return new Dictionary<string, object>() {{
                    "*", new List<object>() {
                        "custom helptext",
                    }
                },{
                    "mypage", new List<object>() {
                        "custom page helptext",
                }}
            };
        }

        protected Dictionary<string, object> GetEmptyPages()
        {
            return new Dictionary<string, object>();
        }

        [Command("help")]
        void cmdHelp(IPlayer player, string command, string[] args)
        {
            if (player == null) return;

            if (UseCustomHelpText)
            {
                StringBuilder sb = new StringBuilder();
                int i = 0;
                var page = "*";
                if(args != null && args.Length == 1) {
                    page = args[0];
                }

                foreach(KeyValuePair<string, Dictionary<string, object>> kvp in Pages) {
                    var group = kvp.Key;
                    if (player.BelongsToGroup(group))
                    {
                        var pages = kvp.Value;
                        object currentPage;
                        if (pages.TryGetValue(page, out currentPage))
                        {
                            if (currentPage is List<object>)
                            {
                                foreach (var text in currentPage as List<object>)
                                {
                                    sb.AppendLine(text.ToString());
                                    i++;

                                    if (i % BreakAfter == 0)
                                    {
                                        player.Reply(sb.ToString());
                                        sb.Length = 0;
                                        i = 0;
                                    }
                                }
                            }
                            else if (currentPage is string)
                            {
                                sb.AppendLine(currentPage.ToString());
                                i++;

                                if (i % BreakAfter == 0)
                                {
                                    player.Reply(sb.ToString());
                                    sb.Length = 0;
                                    i = 0;
                                }
                            }
                        }
                        else if (page != "*")
                        {
                            player.Reply("No help page named '" + page + "' exists.");
                        }
                    }
                }

                if (i > 0)
                {
                    player.Reply(sb.ToString());
                }
            }

            if (AllowHelpTextFromOtherPlugins)
            {
                plugins.CallHook("SendHelpText", player.Object);
            }
        }

        void CheckConfig()
        {
            if (Config["VERSION"] == null)
            {
                // FOR COMPATIBILITY WITH INITIAL VERSIONS WITHOUT VERSIONED CONFIG
                ReloadConfig();
            }
            else if (GetConfig<string>("VERSION", "") != Version.ToString())
            {
                // ADDS NEW, IF ANY, CONFIGURATION OPTIONS
                ReloadConfig();
            }
        }

        protected void ReloadConfig()
        {
            Config["VERSION"] = Version.ToString();

            // NEW CONFIGURATION OPTIONS HERE
            Config["Settings","UseCustomHelpText"] = GetConfig("Settings", "UseCustomHelpText", false);
            Config["Settings", "AllowHelpTextFromOtherPlugins"] = GetConfig("Settings", "AllowHelpTextFromOtherPlugins", true);
            if (Config["Pages", "default", "*"] == null)
            {
                Config["Pages", "default", "*"] = GetConfig("Settings", "CustomHelpText", new List<object>() {
                    "custom helptext",
                    "custom helptext"
                });
            }
            Config["Settings", "BreakAfter"] = GetConfig("Settings", "BreakAfter", 10);
            // END NEW CONFIGURATION OPTIONS
            PrintWarning("Upgrading configuration file");
            SaveConfig();
        }

        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null)
            {
                return defaultValue;
            }

            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        private T GetConfig<T>(string name, string name2, T defaultValue)
        {
            if (Config[name, name2] == null)
            {
                return defaultValue;
            }

            return (T)Convert.ChangeType(Config[name, name2], typeof(T));
        }
    }
}

// --- End of file: HelpText.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/hazmat-skin-changer ---
// --- Original File Path: H/HazmatSkinChanger/HazmatSkinChanger.cs ---

using System;                   //config
using System.Collections.Generic;   //config

namespace Oxide.Plugins
{
	[Info("Hazmat Skin Changer", "MasterSplinter", "1.0.3")]
	[Description("Craft/Skin any Hazmat instead of the stock Hazmat for players with permission.")]

/*======================================================================================================================= 
*
*   Thx to BuzZ the original creator of this plugin
*
*=======================================================================================================================*/


	public class HazmatSkinChanger : RustPlugin
	{

        string Prefix = "Hazmat Skin Changer: ";       // CHAT PLUGIN PREFIX
        string PrefixHelp = "Hazmat Skin Changer";       // CHAT PLUGIN PREFIX HELP
        string PrefixColor = "#555555";                 // CHAT PLUGIN PREFIX COLOR
        ulong SteamIDIcon = 76561199133165664;          //  STEAMID created for this plugin 76561199133165664
        private bool ConfigChanged;
        string stocksuit = "Hazmat Suit";
        string suitblue = "Revised Blue Scientist Suit";
        string suitgreen = "Revised Green Peacekeeper Suit";
        string suitheavy = "Revised Heavy Scientist Suit";
        string suitarctic = "Revised Arctic Scientist Suit";
        string arcticsuit = "Revised Arctic Suit";
        string suitspace = "Revised Space Suit";
        string suitnomad = "Revised Nomad Suit";


        bool loaded = false;
        bool debug = true;

        const string HTSS_craftS = "hazmatskinchanger.craft_bluesuit";//to be able to craft blue scientistsuit
        const string HTSS_skinS = "hazmatskinchanger.skin_bluesuit";//to be able to skin blue scientistsuit
        const string HTSS_wearS = "hazmatskinchanger.wear_bluesuit";//to be able to use blue scientist suit

        const string HTSS_craftGS = "hazmatskinchanger.craft_greensuit";//to be able to craft green scientist suit      
        const string HTSS_skinGS = "hazmatskinchanger.skin_greensuit";//to be able to skin green scientist suit
        const string HTSS_wearGS = "hazmatskinchanger.wear_greensuit";//to be able to use green scientist suit

        const string HTSS_craftH = "hazmatskinchanger.craft_heavy";//to be able to craft heavy scientist suit
        const string HTSS_skinH = "hazmatskinchanger.skin_heavy";//to be able to skin heavy scientist suit
        const string HTSS_wearH = "hazmatskinchanger.wear_heavy";//to be able to use heavy scientist suit

        const string HTSS_craftASS = "hazmatskinchanger.craft_arctic_scientist";//to be able to craft arctic scientist suit
        const string HTSS_skinASS = "hazmatskinchanger.skin_arctic_scientist";//to be able to skin arctic scientist suit
        const string HTSS_wearASS = "hazmatskinchanger.wear_arctic_scientist";//to be able to use artic scientist suit

        const string HTSS_craftAS = "hazmatskinchanger.craft_arcticsuit";//to be able to craft arctic suit
        const string HTSS_skinAS = "hazmatskinchanger.skin_arcticsuit";//to be able to skin arctic suit
        const string HTSS_wearAS = "hazmatskinchanger.wear_arcticsuit";//to be able to use artic suit

        const string HTSS_craftSS = "hazmatskinchanger.craft_spacesuit";//to be able to craft the space suit (does not change players skinned hazmat suits)
        const string HTSS_skinSS = "hazmatskinchanger.skin_spacesuit";//to be able to skin the space suit (does not change players skinned hazmat suits)
        const string HTSS_wearSS = "hazmatskinchanger.wear_spacesuit";//to be able to use the space suit (does not change players skinned hazmat suits)

        const string HTSS_craftNS = "hazmatskinchanger.craft_nomadsuit";//to be able to craft the nomad suit (does not change players skinned hazmat suits)
        const string HTSS_skinNS = "hazmatskinchanger.skin_nomadsuit";//to be able to skin the nomad suit (does not change players skinned hazmat suits)                         
        const string HTSS_wearNS = "hazmatskinchanger.wear_nomadsuit";//to be able to use the nomad suit (does not change players skinned hazmat suits)                         


        protected override void LoadDefaultConfig()

        {
            Config.Clear();
            LoadVariables();
        }

        private void LoadVariables()
        {

            Prefix = Convert.ToString(GetConfig("Chat Settings", "Prefix", "Hazmat Skin Changer: "));                  // CHAT PLUGIN PREFIX
            PrefixHelp = Convert.ToString(GetConfig("Chat Settings", "PrefixHelp", "Hazmat Skin Changer"));                  // CHAT PLUGIN PREFIX
            PrefixColor = Convert.ToString(GetConfig("Chat Settings", "PrefixColor", "#47ff6f"));                       // CHAT PLUGIN PREFIX COLOR
            SteamIDIcon = Convert.ToUInt64(GetConfig("Chat Icon", "SteamIDIcon", 76561199133165664));                   // SteamID FOR PLUGIN ICON
            suitblue = Convert.ToString(GetConfig("Suit Name", "Blue scientist suit", "Revised Blue Scientist Suit"));
            suitgreen = Convert.ToString(GetConfig("Suit Name", "Green scientist suit", "Revised Green Peacekeeper Suit"));
            suitheavy = Convert.ToString(GetConfig("Suit Name", "Heavy scientist suit", "Revised Heavy Scientist Suit"));
            suitarctic = Convert.ToString(GetConfig("Suit Name", "Arctic scientist suit", "Revised Arctic Scientist Suit"));
            arcticsuit = Convert.ToString(GetConfig("Suit Name", "Arctic suit", "Revised Arctic Suit"));
            suitspace = Convert.ToString(GetConfig("Suit Name", "Space suit", "Revised Space Suit"));
            suitnomad = Convert.ToString(GetConfig("Suit Name", "Nomad suit", "Revised Nomad Suit"));

            if (!ConfigChanged) return;
            SaveConfig();
            ConfigChanged = false;
        }

        #region MESSAGES / LANG

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {

                {"TransMsg", "[#e0e0e0]Your crafted Hazmat Suit has transformed to a[/#]"},
                {"BackTransMsg", "[#e0e0e0]It has returned to a classic Hazmat Suit[/#]"},
                {"NoPermMsg", "[#e0e0e0]You are not allowed to wear a[/#]"},
                {"need_hold_hazmat", "[#e0e0e0]You are not holding a Hazmat![/#]"},
                {"hazmat_skinned", "[#e0e0e0]Your Hazmat has successfully skinned to a[/#]"},
                {"noperm_hazmat_skin", "[#e0e0e0]You are not allowed to skin your Hazmat to a[/#]"},
                {"skinitem_help", "\n[#eeeeee]<size=14>Available Commands:</size>[/#]\n[#ffe479]/skinhazmat[/#] [#e0e0e0]- Display Help[/#]\n[#ffe479]/skinhazmat <Available Suits>[/#] [#e0e0e0]- Skin Hazmat to selected suit[/#]\n \n[#ffd479]<size=14>Available Suits:</size>[/#]\n[#ffe479]\"blue\"[/#] [#e0e0e0]- Blue Scientist Suit[/#]\n[#ffe479]\"green\"[/#] [#e0e0e0]- Green Peacekeeper Suit[/#]\n[#ffe479]\"heavy\"[/#] [#e0e0e0]- Heavy Scientist Suit[/#]\n[#ffe479]\"arcticscientist\"[/#] [#e0e0e0]- Arctic Scientist Suit[/#]\n[#ffe479]\"arctic\"[/#] [#e0e0e0]- Arctic Suit[/#]\n[#ffe479]\"space\"[/#] [#e0e0e0]- Space Suit[/#]\n[#ffe479]\"nomad\"[/#] [#e0e0e0]- Nomad Suit[/#]\n \n[#73c2fa]<size=14>Example:</size>[/#]\n[#ffe479]/skinhazmat space[/#] [#e0e0e0]- This will skin to a Space Suit[/#]"},

                #region Templates/Color Codes

                //{"Template_help", "\n[#eeeeee]<size=14>Title of Section:</size>[/#]\n[#ffe479]/commandhere 1[/#] [#e0e0e0]- Description of chatcommand[/#]\n[#ffe479]/commandhere 2[/#] [#e0e0e0]- Description of chatcommand[/#]\n \n[#ffd479]<size=14>Title of Section 2:</size>[/#]\n[#ffe479]\"commandhere\"[/#] [#e0e0e0]- Description of command[/#]\n[#ffe479]\"commandhere\"[/#] [#e0e0e0]- Description of command[/#]\n \n[#73c2fa]<size=14>Title of Section 3:</size>[/#]\n[#ffe479]\"anything\" [/#] [#e0e0e0]- Description of anything[/#]\n"},
                //{"Template_info", "[#e0e0e0]What you like to say to the player[/#]"},

                //Player.Message(player, $"{lang.GetMessage("Template_help", this, player.UserIDString)}", $"<color={PrefixColor}>{PrefixHelp/Prefix}</color>", SteamIDIcon);
                //Player.Message(player, $"{lang.GetMessage("Template_info", this, player.UserIDString)} <color=#ffe479>{player.UserIDString}.</color> {lang.GetMessage("Template_info", this, wannawear.UserIDString)}", $"<color={PrefixColor}>{Prefix/PrefixHelp}</color>", SteamIDIcon);

                //#e0e0e0 Grey
                //#eeeeee Dark White 
                //#ffd479 Orange
                //#ffe479 Yellow
                //#73c2fa Blue
                //#f9f178 Red
                //#a0ffb5 Light Green                             

                #endregion

            }, this, "en");
        }

        #endregion

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                ConfigChanged = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                ConfigChanged = true;
            }
            return value;
        }

		private void Init()
        {
            LoadVariables();
            permission.RegisterPermission(HTSS_craftS, this);
            permission.RegisterPermission(HTSS_skinS, this);
            permission.RegisterPermission(HTSS_wearS, this);

            permission.RegisterPermission(HTSS_craftGS, this);
            permission.RegisterPermission(HTSS_skinGS, this);
            permission.RegisterPermission(HTSS_wearGS, this);

            permission.RegisterPermission(HTSS_craftH, this);
            permission.RegisterPermission(HTSS_skinH, this);
            permission.RegisterPermission(HTSS_wearH, this);

            permission.RegisterPermission(HTSS_craftASS, this);
            permission.RegisterPermission(HTSS_skinASS, this);
            permission.RegisterPermission(HTSS_wearASS, this);

            permission.RegisterPermission(HTSS_craftAS, this);
            permission.RegisterPermission(HTSS_skinAS, this);
            permission.RegisterPermission(HTSS_wearAS, this);

            permission.RegisterPermission(HTSS_craftSS, this);
            permission.RegisterPermission(HTSS_skinSS, this);
            permission.RegisterPermission(HTSS_wearSS, this);

            permission.RegisterPermission(HTSS_craftNS, this);
            permission.RegisterPermission(HTSS_skinNS, this);
            permission.RegisterPermission(HTSS_wearNS, this);

            loaded = true;
        }

        void OnItemCraftFinished(ItemCraftTask task, Item item)
        {
            if (loaded == false) return;
            if (item == null) return;
            BasePlayer owner = task.owner as BasePlayer;
            int color = 1266491000;//stock suit
            string suitName = stocksuit;

            if (item.info.shortname == "hazmatsuit")
            {
                ulong unull = 0;
                if (permission.UserHasPermission(owner.UserIDString, HTSS_craftS) == true)
                {
                    item.UseItem();
                    color = -253079493;//blue scientist suit
                    suitName = suitblue;
                }
                else if (permission.UserHasPermission(owner.UserIDString, HTSS_craftGS) == true)
                {
                    item.UseItem();
                    color = -1958316066;//green scientist suit
                    suitName = suitgreen;
                }
                else if (permission.UserHasPermission(owner.UserIDString, HTSS_craftH) == true)
                {
                    item.UseItem();
                    color = -1772746857;//heavy scientist suit
                    suitName = suitheavy;

                }
                else if (permission.UserHasPermission(owner.UserIDString, HTSS_craftASS) == true)
                {
                    item.UseItem();
                    color = 1107575710;//arctic scientist suit
                    suitName = suitarctic;

                }
                else if (permission.UserHasPermission(owner.UserIDString, HTSS_craftAS) == true)
                {
                    item.UseItem();
                    color = -470439097;//arctic suit
                    suitName = arcticsuit;

                }
                else if (permission.UserHasPermission(owner.UserIDString, HTSS_craftSS) == true)
                {
                    item.UseItem();
                    color = -560304835;//space suit
                    suitName = suitspace;
                }
                else if (permission.UserHasPermission(owner.UserIDString, HTSS_craftNS) == true)
                {
                    item.UseItem();
                    color = 491263800;//Nomad suit
                    suitName = suitnomad;
                }
                Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(color).itemid, 1, unull);
                itemtogive.name = suitName;
                if (itemtogive == null) return;
                if (owner == null) return;
                if (suitName == stocksuit) return;
                owner.GiveItem(itemtogive);
                Player.Message(owner, $"{lang.GetMessage("TransMsg", this, owner.UserIDString)} <color=#ffe479>{suitName}.</color>", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
            }

        }

        void CanWearItem(PlayerInventory inventory, Item item, int targetPos)
        {
            if (loaded == false) { return; }
            if (item == null) { return; }
            if (inventory == null) { return; }
            BasePlayer wannawear = inventory.GetComponent<BasePlayer>();

            if (wannawear.IsConnected)
            {
                if (debug) Puts($"item.name = {item.name} || item.info.shortname = {item.info.shortname} || itemID = {ItemManager.FindItemDefinition(item.info.shortname)?.itemid}");
                if (item.name == null) return;
                if (item.name.Contains($"{suitblue}") == true)
                {
                    if (permission.UserHasPermission(wannawear.UserIDString, HTSS_wearS) == false) //if permission to use/wear the crafted suits
                    {
                        string suitName = suitblue;

                        item.Remove();
                        ulong unull = 0;
                        Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(1266491000).itemid, 1, unull);//gives regular hazmat suit if wear permission is false on attempt to wear the Revised suit
                        if (itemtogive == null) { return; }
                        if (wannawear == null) { return; }
                        wannawear.GiveItem(itemtogive);
                        Player.Message(wannawear, $"{lang.GetMessage("NoPermMsg", this, wannawear.UserIDString)} <color=#ffe479>{suitName}.</color> {lang.GetMessage("BackTransMsg", this, wannawear.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                    }
                }
                if (item.name.Contains($"{suitgreen}") == true)
                {
                    if (permission.UserHasPermission(wannawear.UserIDString, HTSS_wearGS) == false) //if permission to use/wear the crafted suits
                    {
                        string suitName = suitgreen;

                        item.Remove();
                        ulong unull = 0;
                        Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(1266491000).itemid, 1, unull);//gives regular hazmat suit if wear permission is false on attempt to wear the Revised suit
                        if (itemtogive == null) { return; }
                        if (wannawear == null) { return; }
                        wannawear.GiveItem(itemtogive);
                        Player.Message(wannawear, $"{lang.GetMessage("NoPermMsg", this, wannawear.UserIDString)} <color=#ffe479>{suitName}.</color> {lang.GetMessage("BackTransMsg", this, wannawear.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);

                    }
                }
                if (item.name.Contains($"{suitheavy}") == true)
                {
                    if (permission.UserHasPermission(wannawear.UserIDString, HTSS_wearH) == false) //if permission to use/wear the crafted suits
                    {
                        string suitName = suitheavy;

                        item.Remove();
                        ulong unull = 0;
                        Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(1266491000).itemid, 1, unull);//gives regular hazmat suit if wear permission is false on attempt to wear the Revised suit
                        if (itemtogive == null) { return; }
                        if (wannawear == null) { return; }
                        wannawear.GiveItem(itemtogive);
                        Player.Message(wannawear, $"{lang.GetMessage("NoPermMsg", this, wannawear.UserIDString)} <color=#ffe479>{suitName}.</color> {lang.GetMessage("BackTransMsg", this, wannawear.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);

                    }
                }
                if (item.name.Contains($"{suitarctic}") == true)
                {
                    if (permission.UserHasPermission(wannawear.UserIDString, HTSS_wearASS) == false) //if permission to use/wear the crafted suits
                    {
                        string suitName = suitarctic;

                        item.Remove();
                        ulong unull = 0;
                        Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(1266491000).itemid, 1, unull);//gives regular hazmat suit if wear permission is false on attempt to wear the Revised suit
                        if (itemtogive == null) { return; }
                        if (wannawear == null) { return; }
                        wannawear.GiveItem(itemtogive);
                        Player.Message(wannawear, $"{lang.GetMessage("NoPermMsg", this, wannawear.UserIDString)} <color=#ffe479>{suitName}.</color> {lang.GetMessage("BackTransMsg", this, wannawear.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);

                    }
                }
                if (item.name.Contains($"{arcticsuit}") == true)
                {
                    if (permission.UserHasPermission(wannawear.UserIDString, HTSS_wearAS) == false) //if permission to use/wear the crafted suits
                    {
                        string suitName = arcticsuit;

                        item.Remove();
                        ulong unull = 0;
                        Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(1266491000).itemid, 1, unull);//gives regular hazmat suit if wear permission is false on attempt to wear the Revised suit
                        if (itemtogive == null) { return; }
                        if (wannawear == null) { return; }
                        wannawear.GiveItem(itemtogive);
                        Player.Message(wannawear, $"{lang.GetMessage("NoPermMsg", this, wannawear.UserIDString)} <color=#ffe479>{suitName}.</color> {lang.GetMessage("BackTransMsg", this, wannawear.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);

                    }
                }
                if (item.name.Contains($"{suitspace}") == true)
                {
                    if (permission.UserHasPermission(wannawear.UserIDString, HTSS_wearSS) == false) //if permission to use/wear the crafted suits
                    {
                        string suitName = suitspace;

                        item.Remove();
                        ulong unull = 0;
                        Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(1266491000).itemid, 1, unull);//gives regular hazmat suit if wear permission is false on attempt to wear the Revised suit
                        if (itemtogive == null) { return; }
                        if (wannawear == null) { return; }
                        wannawear.GiveItem(itemtogive);
                        Player.Message(wannawear, $"{lang.GetMessage("NoPermMsg", this, wannawear.UserIDString)} <color=#ffe479>{suitName}.</color> {lang.GetMessage("BackTransMsg", this, wannawear.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);

                    }
                }
                if (item.name.Contains($"{suitnomad}") == true)
                {
                    if (permission.UserHasPermission(wannawear.UserIDString, HTSS_wearNS) == false) //if permission to use/wear the crafted suits
                    {
                        string suitName = suitnomad;

                        item.Remove();
                        ulong unull = 0;
                        Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(1266491000).itemid, 1, unull);//gives regular hazmat suit if wear permission is false on attempt to wear the Revised suit
                        if (itemtogive == null) { return; }
                        if (wannawear == null) { return; }
                        wannawear.GiveItem(itemtogive);
                        Player.Message(wannawear, $"{lang.GetMessage("NoPermMsg", this, wannawear.UserIDString)} <color=#ffe479>{suitName}.</color> {lang.GetMessage("BackTransMsg", this, wannawear.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);

                    }
                }
            }
        }

        void OnItemPickup(Item item, BasePlayer player, int targetPos)
        {
            if (loaded == false) { return; }
            if (item == null) { return; }

            if (player.IsConnected)
            {
                if (debug) Puts($"item.name = {item.name} || item.info.shortname = {item.info.shortname} || itemID = {ItemManager.FindItemDefinition(item.info.shortname)?.itemid}");
                if (item.name == null) return;
                if (item.name.Contains($"{suitblue}") == true)
                {
                    if (permission.UserHasPermission(player.UserIDString, HTSS_wearS) == false) //if permission to use/wear the crafted suits
                    {
                        string suitName = suitblue;

                        item.Remove();
                        ulong unull = 0;
                        Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(1266491000).itemid, 1, unull);//gives regular hazmat suit if wear permission is false on attempt to wear the Revised suit
                        if (itemtogive == null) { return; }
                        if (player == null) { return; }
                        player.GiveItem(itemtogive);
                        Player.Message(player, $"{lang.GetMessage("NoPermMsg", this, player.UserIDString)} <color=#ffe479>{suitName}.</color> {lang.GetMessage("BackTransMsg", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);

                    }
                }
                if (item.name.Contains($"{suitgreen}") == true)
                {
                    if (permission.UserHasPermission(player.UserIDString, HTSS_wearGS) == false) //if permission to use/wear the crafted suits
                    {
                        string suitName = suitgreen;

                        item.Remove();
                        ulong unull = 0;
                        Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(1266491000).itemid, 1, unull);//gives regular hazmat suit if wear permission is false on attempt to wear the Revised suit
                        if (itemtogive == null) { return; }
                        if (player == null) { return; }
                        player.GiveItem(itemtogive);
                        Player.Message(player, $"{lang.GetMessage("NoPermMsg", this, player.UserIDString)} <color=#ffe479>{suitName}.</color> {lang.GetMessage("BackTransMsg", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);

                    }
                }
                if (item.name.Contains($"{suitheavy}") == true)
                {
                    if (permission.UserHasPermission(player.UserIDString, HTSS_wearH) == false) //if permission to use/wear the crafted suits
                    {
                        string suitName = suitheavy;

                        item.Remove();
                        ulong unull = 0;
                        Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(1266491000).itemid, 1, unull);//gives regular hazmat suit if wear permission is false on attempt to wear the Revised suit
                        if (itemtogive == null) { return; }
                        if (player == null) { return; }
                        player.GiveItem(itemtogive);
                        Player.Message(player, $"{lang.GetMessage("NoPermMsg", this, player.UserIDString)} <color=#ffe479>{suitName}.</color> {lang.GetMessage("BackTransMsg", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);

                    }
                }
                if (item.name.Contains($"{suitarctic}") == true)
                {
                    if (permission.UserHasPermission(player.UserIDString, HTSS_wearASS) == false) //if permission to use/wear the crafted suits
                    {
                        string suitName = suitarctic;

                        item.Remove();
                        ulong unull = 0;
                        Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(1266491000).itemid, 1, unull);//gives regular hazmat suit if wear permission is false on attempt to wear the Revised suit
                        if (itemtogive == null) { return; }
                        if (player == null) { return; }
                        player.GiveItem(itemtogive);
                        Player.Message(player, $"{lang.GetMessage("NoPermMsg", this, player.UserIDString)} <color=#ffe479>{suitName}.</color> {lang.GetMessage("BackTransMsg", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);

                    }
                }
                if (item.name.Contains($"{arcticsuit}") == true)
                {
                    if (permission.UserHasPermission(player.UserIDString, HTSS_wearAS) == false) //if permission to use/wear the crafted suits
                    {
                        string suitName = arcticsuit;

                        item.Remove();
                        ulong unull = 0;
                        Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(1266491000).itemid, 1, unull);//gives regular hazmat suit if wear permission is false on attempt to wear the Revised suit
                        if (itemtogive == null) { return; }
                        if (player == null) { return; }
                        player.GiveItem(itemtogive);
                        Player.Message(player, $"{lang.GetMessage("NoPermMsg", this, player.UserIDString)} <color=#ffe479>{suitName}.</color> {lang.GetMessage("BackTransMsg", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);

                    }
                }
                if (item.name.Contains($"{suitspace}") == true)
                {
                    if (permission.UserHasPermission(player.UserIDString, HTSS_wearSS) == false) //if permission to use/wear the crafted suits
                    {
                        string suitName = suitspace;

                        item.Remove();
                        ulong unull = 0;
                        Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(1266491000).itemid, 1, unull);//gives regular hazmat suit if wear permission is false on attempt to wear the Revised suit
                        if (itemtogive == null) { return; }
                        if (player == null) { return; }
                        player.GiveItem(itemtogive);
                        Player.Message(player, $"{lang.GetMessage("NoPermMsg", this, player.UserIDString)} <color=#ffe479>{suitName}.</color> {lang.GetMessage("BackTransMsg", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);

                    }
                }
                if (item.name.Contains($"{suitnomad}") == true)
                {
                    if (permission.UserHasPermission(player.UserIDString, HTSS_wearNS) == false) //if permission to use/wear the crafted suits
                    {
                        string suitName = suitnomad;

                        item.Remove();
                        ulong unull = 0;
                        Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(1266491000).itemid, 1, unull);//gives regular hazmat suit if wear permission is false on attempt to wear the Revised suit
                        if (itemtogive == null) { return; }
                        if (player == null) { return; }
                        player.GiveItem(itemtogive);
                        Player.Message(player, $"{lang.GetMessage("NoPermMsg", this, player.UserIDString)} <color=#ffe479>{suitName}.</color> {lang.GetMessage("BackTransMsg", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);

                    }
                }
            }
        }

        #region Commands

        [ChatCommand("skinhazmat")]
        private void skinhazmatCmd(BasePlayer player, string command, string[] args, Item item)
        {
            if (player == null) return;

            if (args.Length < 1)
            {
                Player.Message(player, $"{lang.GetMessage("skinitem_help", this, player.UserIDString)}", $"<color={PrefixColor}>{PrefixHelp}</color>", SteamIDIcon);

                return;
            }

            switch (args[0].ToLower())
            {
                case "blue":
                    {
                        if (permission.UserHasPermission(player.UserIDString, HTSS_skinS) == true) //if permision to skin
                        {
                            if (player.GetActiveItem() == null)
                            {
                                Player.Message(player, $"{lang.GetMessage("need_hold_hazmat", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                                return;
                            }

                            if (!player.GetActiveItem().info.shortname.Contains("hazmatsuit"))
                            {
                                Player.Message(player, $"{lang.GetMessage("need_hold_hazmat", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                                return;
                            }

                            if (player.GetActiveItem().info.shortname.Contains("hazmatsuit"))
                            {
                                if (loaded == false) return;

                                int color = -253079493;//blue scientist suit
                                string suitName = suitblue;

                                player.GetActiveItem().UseItem();
                                ulong unull = 0;

                                Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(color).itemid, 1, unull);
                                itemtogive.name = suitName;
                                if (itemtogive == null) { return; }
                                if (player == null) { return; }
                                player.GiveItem(itemtogive);
                                Player.Message(player, $"{lang.GetMessage("hazmat_skinned", this, player.UserIDString)} <color=#ffe479>{suitName}.</color>", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);

                            }
                        }

                        if (permission.UserHasPermission(player.UserIDString, HTSS_skinS) == false)
                        {
                            string suitName = suitblue;

                            Player.Message(player, $"{lang.GetMessage("noperm_hazmat_skin", this, player.UserIDString)} <color=#ffe479>{suitName}.</color>", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                        }

                        return;
                    }

                case "green":
                    {
                        if (permission.UserHasPermission(player.UserIDString, HTSS_skinGS) == true) //if permision to skin
                        {
                            if (player.GetActiveItem() == null)
                            {
                                Player.Message(player, $"{lang.GetMessage("need_hold_hazmat", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                            }

                            if (!player.GetActiveItem().info.shortname.Contains("hazmatsuit"))
                            {
                                Player.Message(player, $"{lang.GetMessage("need_hold_hazmat", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                                return;
                            }

                            if (player.GetActiveItem().info.shortname.Contains("hazmatsuit"))
                            {
                                if (loaded == false) return;

                                int color = -1958316066;//green scientist suit
                                string suitName = suitgreen;

                                player.GetActiveItem().UseItem();
                                ulong unull = 0;

                                Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(color).itemid, 1, unull);
                                itemtogive.name = suitName;
                                if (itemtogive == null) { return; }
                                if (player == null) { return; }
                                player.GiveItem(itemtogive);
                                Player.Message(player, $"{lang.GetMessage("hazmat_skinned", this, player.UserIDString)} <color=#ffe479>{suitName}.</color>", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                            }
                        }

                        if (permission.UserHasPermission(player.UserIDString, HTSS_skinGS) == false)
                        {
                            string suitName = suitgreen;

                            Player.Message(player, $"{lang.GetMessage("noperm_hazmat_skin", this, player.UserIDString)} <color=#ffe479>{suitName}.</color>", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                        }

                        return;
                    }

                case "heavy":
                    {
                        if (permission.UserHasPermission(player.UserIDString, HTSS_skinH) == true) //if permision to skin
                        {
                            if (player.GetActiveItem() == null)
                            {
                                Player.Message(player, $"{lang.GetMessage("need_hold_hazmat", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                            }

                            if (!player.GetActiveItem().info.shortname.Contains("hazmatsuit"))
                            {
                                Player.Message(player, $"{lang.GetMessage("need_hold_hazmat", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                                return;
                            }

                            if (player.GetActiveItem().info.shortname.Contains("hazmatsuit"))
                            {
                                if (loaded == false) return;

                                int color = -1772746857;//heavy scientist suit
                                string suitName = suitheavy;

                                player.GetActiveItem().UseItem();
                                ulong unull = 0;

                                Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(color).itemid, 1, unull);
                                itemtogive.name = suitName;
                                if (itemtogive == null) { return; }
                                if (player == null) { return; }
                                player.GiveItem(itemtogive);
                                Player.Message(player, $"{lang.GetMessage("hazmat_skinned", this, player.UserIDString)} <color=#ffe479>{suitName}.</color>", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                            }
                        }

                        if (permission.UserHasPermission(player.UserIDString, HTSS_skinH) == false)
                        {
                            string suitName = suitheavy;

                            Player.Message(player, $"{lang.GetMessage("noperm_hazmat_skin", this, player.UserIDString)} <color=#ffe479>{suitName}.</color>", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                        }

                        return;
                    }

                case "arcticscientist":
                    {
                        if (permission.UserHasPermission(player.UserIDString, HTSS_skinASS) == true) //if permision to skin
                        {
                            if (player.GetActiveItem() == null)
                            {
                                Player.Message(player, $"{lang.GetMessage("need_hold_hazmat", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                            }

                            if (!player.GetActiveItem().info.shortname.Contains("hazmatsuit"))
                            {
                                Player.Message(player, $"{lang.GetMessage("need_hold_hazmat", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                                return;
                            }

                            if (player.GetActiveItem().info.shortname.Contains("hazmatsuit"))
                            {
                                if (loaded == false) return;

                                int color = 1107575710;//arctic scientist suit
                                string suitName = suitarctic;

                                player.GetActiveItem().UseItem();
                                ulong unull = 0;

                                Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(color).itemid, 1, unull);
                                itemtogive.name = suitName;
                                if (itemtogive == null) { return; }
                                if (player == null) { return; }
                                player.GiveItem(itemtogive);
                                Player.Message(player, $"{lang.GetMessage("hazmat_skinned", this, player.UserIDString)} <color=#ffe479>{suitName}.</color>", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                            }
                        }

                        if (permission.UserHasPermission(player.UserIDString, HTSS_skinASS) == false)
                        {
                            string suitName = suitarctic;

                            Player.Message(player, $"{lang.GetMessage("noperm_hazmat_skin", this, player.UserIDString)} <color=#ffe479>{suitName}.</color>", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                        }

                        return;
                    }

                case "arctic":
                    {
                        if (permission.UserHasPermission(player.UserIDString, HTSS_skinAS) == true) //if permision to skin
                        {
                            if (player.GetActiveItem() == null)
                            {
                                Player.Message(player, $"{lang.GetMessage("need_hold_hazmat", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                            }

                            if (!player.GetActiveItem().info.shortname.Contains("hazmatsuit"))
                            {
                                Player.Message(player, $"{lang.GetMessage("need_hold_hazmat", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                                return;
                            }

                            if (player.GetActiveItem().info.shortname.Contains("hazmatsuit"))
                            {
                                if (loaded == false) return;

                                int color = -470439097;//arctic scientist suit
                                string suitName = arcticsuit;

                                player.GetActiveItem().UseItem();
                                ulong unull = 0;

                                Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(color).itemid, 1, unull);
                                itemtogive.name = suitName;
                                if (itemtogive == null) { return; }
                                if (player == null) { return; }
                                player.GiveItem(itemtogive);
                                Player.Message(player, $"{lang.GetMessage("hazmat_skinned", this, player.UserIDString)} <color=#ffe479>{suitName}.</color>", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                            }
                        }

                        if (permission.UserHasPermission(player.UserIDString, HTSS_skinAS) == false)
                        {
                            string suitName = arcticsuit;

                            Player.Message(player, $"{lang.GetMessage("noperm_hazmat_skin", this, player.UserIDString)} <color=#ffe479>{suitName}.</color>", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                        }

                        return;
                    }

                case "space":
                    {
                        if (permission.UserHasPermission(player.UserIDString, HTSS_skinSS) == true) //if permision to skin
                        {
                            if (player.GetActiveItem() == null)
                            {
                                Player.Message(player, $"{lang.GetMessage("need_hold_hazmat", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                            }

                            if (!player.GetActiveItem().info.shortname.Contains("hazmatsuit"))
                            {
                                Player.Message(player, $"{lang.GetMessage("need_hold_hazmat", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                                return;
                            }

                            if (player.GetActiveItem().info.shortname.Contains("hazmatsuit"))
                            {
                                if (loaded == false) return;

                                int color = -560304835;//space suit
                                string suitName = suitspace;

                                player.GetActiveItem().UseItem();
                                ulong unull = 0;

                                Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(color).itemid, 1, unull);
                                itemtogive.name = suitName;
                                if (itemtogive == null) { return; }
                                if (player == null) { return; }
                                player.GiveItem(itemtogive);
                                Player.Message(player, $"{lang.GetMessage("hazmat_skinned", this, player.UserIDString)} <color=#ffe479>{suitName}.</color>", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                            }
                        }

                        if (permission.UserHasPermission(player.UserIDString, HTSS_skinSS) == false)
                        {
                            string suitName = suitspace;

                            Player.Message(player, $"{lang.GetMessage("noperm_hazmat_skin", this, player.UserIDString)} <color=#ffe479>{suitName}.</color>", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                        }

                        return;
                    }

                case "nomad":
                    {
                        if (permission.UserHasPermission(player.UserIDString, HTSS_skinNS) == true)//if permision to craft
                        {
                            if (player.GetActiveItem() == null)
                            {
                                Player.Message(player, $"{lang.GetMessage("need_hold_hazmat", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                            }

                            if (!player.GetActiveItem().info.shortname.Contains("hazmatsuit"))
                            {
                                Player.Message(player, $"{lang.GetMessage("need_hold_hazmat", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                                return;
                            }

                            if (player.GetActiveItem().info.shortname.Contains("hazmatsuit"))
                            {
                                if (loaded == false) return;

                                int color = 491263800;//Nomad suit
                                string suitName = suitnomad;


                                player.GetActiveItem().UseItem();
                                ulong unull = 0;

                                Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(color).itemid, 1, unull);
                                itemtogive.name = suitName;
                                if (itemtogive == null) { return; }
                                if (player == null) { return; }
                                player.GiveItem(itemtogive);
                                Player.Message(player, $"{lang.GetMessage("hazmat_skinned", this, player.UserIDString)} <color=#ffe479>{suitName}.</color>", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                            }
                        }

                        if (permission.UserHasPermission(player.UserIDString, HTSS_skinNS) == false)
                        {
                            string suitName = suitnomad;

                            Player.Message(player, $"{lang.GetMessage("noperm_hazmat_skin", this, player.UserIDString)} <color=#ffe479>{suitName}.</color>", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                        }

                        return;
                    }
            }
        }

        #endregion
    }
}

// --- End of file: HazmatSkinChanger.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/horse-storage ---
// --- Original File Path: H/HorseStorage/HorseStorage.cs ---

using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Horse Storage", "Bazz3l", "1.0.5")]
    [Description("Gives horses the ability to carry items")]
    public class HorseStorage : RustPlugin
    {
        #region Fields

        private const string STASH_PREFAB = "assets/prefabs/deployable/small stash/small_stash_deployed.prefab";

        private PluginConfig _config;

        #endregion
        
        #region Config

        protected override void LoadDefaultConfig() => _config = PluginConfig.DefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<PluginConfig>();

                if (_config == null)
                {
                    throw new JsonException();
                }
            }
            catch
            {
                PrintWarning("Loaded default config.");
                
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config, true);

        class PluginConfig
        {
            public bool EnableStorage;
            
            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig
                {
                    EnableStorage = true
                };
            }
        }
        
        #endregion

        #region Oxide Hooks

        void OnEntitySpawned(RidableHorse entity)
        {
            if (!_config.EnableStorage || entity == null) return;

            NextTick(() => {
                if (entity == null) return;

                foreach (StorageContainer child in entity.GetComponentsInChildren<StorageContainer>(true))
                {
                    if (child.name == STASH_PREFAB) return;
                }

                entity.gameObject.AddComponent<AddStorageBox>();
            });
        }
        
        void OnEntityDeath(RidableHorse entity, HitInfo info)
        {
            if (!_config.EnableStorage || entity == null) return;

            entity.GetComponent<AddStorageBox>()?.OnDeath();
        }

        #endregion
        
        #region Component

        class AddStorageBox : MonoBehaviour
        {
            public RidableHorse entity;
            public StashContainer stash1;
            public StashContainer stash2;

            void Awake()
            {
                entity = GetComponent<RidableHorse>();
                stash1 = CreateStorageContainer(new Vector3(0.4f, 1.15f, -0.45f), new Vector3(90.0f, 90.0f, 0.0f));
                stash2 = CreateStorageContainer(new Vector3(-0.4f, 1.15f, -0.45f), new Vector3(90.0f, 270.0f, 0.0f));
            }
            
            public void OnDeath()
            {
                RemoveStorageContainer(stash1);
                RemoveStorageContainer(stash2);
            }

            StashContainer CreateStorageContainer(Vector3 localPosition, Vector3 rotation)
            {
                StashContainer stash = (StashContainer) GameManager.server.CreateEntity(STASH_PREFAB, entity.transform.position);
                if (stash == null) return null;
                
                stash.Spawn();
                stash.SetParent(entity);
                stash.transform.localPosition = localPosition;
                stash.transform.Rotate(rotation);
                stash.SendNetworkUpdateImmediate(true);

                return stash;
            }
            
            void RemoveStorageContainer(StashContainer stash)
            {
                if (stash.IsValid() && !stash.IsDestroyed)
                    stash.DropItems();
            }
        }

        #endregion
    }
}

// --- End of file: HorseStorage.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/horse-seat ---
// --- Original File Path: H/HorseSeat/HorseSeat.cs ---

using UnityEngine;
using Oxide.Core.Configuration; 

namespace Oxide.Plugins
{
    [Info("Horse Seat", "Chokitu", "1.0.3")]
    [Description("Gives horses 2 seats")]
    public class HorseSeat : RustPlugin
    {
        #region Config
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                Enable2Seats = true
            };
        }

        private class PluginConfig
        {
            public bool Enable2Seats;
        }
        #endregion

        #region Oxide
        private void Init() => config = Config.ReadObject<PluginConfig>();

        private void OnEntitySpawned(RidableHorse entity)
        {
            if (entity == null || !config.Enable2Seats)
            {
                return;
            }

             NextTick(() => {
                entity.gameObject.AddComponent<AddSeats>();
            });
        }

        public class AddSeats : MonoBehaviour
        {

             public RidableHorse entity;

               void Awake()
             {
                 entity = GetComponent<RidableHorse>();
                 if (entity == null)
                 {
                     Destroy(this);
                     return;
                 }
                 
                var seat = GameManager.server.CreateEntity("assets/bundled/prefabs/static/chair.invisible.static.prefab", entity.transform.position, new Quaternion(), true);
                 if (seat == null) return;
                 seat.Spawn();
                 seat.SetParent(entity);
                 seat.transform.localPosition = new Vector3(0f, 1.2f, -0.7f);
                 seat.transform.Rotate(new Vector3(0.0f, 0.0f, 0.0f));
                 seat.SendNetworkUpdateImmediate(true);
             }
        }
        #endregion
    }
}


// --- End of file: HorseSeat.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/holiday-loot ---
// --- Original File Path: H/HolidayLoot/HolidayLoot.cs ---

﻿using System;
using Oxide.Core;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core.Configuration;

namespace Oxide.Plugins
{
    [Info("HolidayLoot", "FastBurst", "1.1.7")]
    [Description("Modify the loot tables for the Christmas Presents, Halloween Bags and Easter Eggs")]

    class HolidayLoot : RustPlugin
    {
        private bool Changed;

        #region Data
        private DynamicConfigFile PresentData;
        private DynamicConfigFile PresentData2;
        private DynamicConfigFile PresentData3;
        private DynamicConfigFile HalloweenData2;
        private DynamicConfigFile HalloweenData3;
        private DynamicConfigFile EasterData2;
        private DynamicConfigFile EasterData3;
        private DynamicConfigFile SantaData;
        private StoredData storedData;
        private StoredData storedData2;
        private StoredData storedData3;
        private StoredData HalloweenStoredData2;
        private StoredData HalloweenStoredData3;
        private StoredData EasterStoredData2;
        private StoredData EasterStoredData3;
        private StoredData SantaStoredData;

        private class StoredData
        {
            public List<ItemInfo> lootTable = new List<ItemInfo>();
        }

        private void SaveData()
        {
            storedData.lootTable = smallList;
            storedData2.lootTable = mediumList;
            storedData3.lootTable = largeList;
            HalloweenStoredData2.lootTable = mediumListHalloween;
            HalloweenStoredData3.lootTable = largeListHalloween;
            EasterStoredData2.lootTable = mediumListEaster;
            EasterStoredData3.lootTable = largeListEaster;
            SantaStoredData.lootTable = santaList;


            PresentData.WriteObject(storedData);
            PresentData2.WriteObject(storedData2);
            PresentData3.WriteObject(storedData3);
            HalloweenData2.WriteObject(HalloweenStoredData2);
            HalloweenData3.WriteObject(HalloweenStoredData3);
            EasterData2.WriteObject(EasterStoredData2);
            EasterData3.WriteObject(EasterStoredData3);
            SantaData.WriteObject(SantaStoredData);
        }

        private void LoadData()
        {
            try
            {
                storedData = PresentData.ReadObject<StoredData>();
                storedData2 = PresentData2.ReadObject<StoredData>();
                storedData3 = PresentData3.ReadObject<StoredData>();
                HalloweenStoredData2 = HalloweenData2.ReadObject<StoredData>();
                HalloweenStoredData3 = HalloweenData3.ReadObject<StoredData>();
                EasterStoredData2 = EasterData2.ReadObject<StoredData>();
                EasterStoredData3 = EasterData3.ReadObject<StoredData>();
                SantaStoredData = SantaData.ReadObject<StoredData>();
                smallList = storedData.lootTable;
                mediumList = storedData2.lootTable;
                largeList = storedData3.lootTable;
                mediumListHalloween = HalloweenStoredData2.lootTable;
                largeListHalloween = HalloweenStoredData3.lootTable;
                mediumListEaster = EasterStoredData2.lootTable;
                largeListEaster = EasterStoredData3.lootTable;
                santaList = SantaStoredData.lootTable;
            }
            catch
            {
                Puts("Failed to load data, creating new file");
                storedData = new StoredData();
            }
        }

        private class ItemInfo
        {
            public string itemName;
            public int minItemAmount;
            public int maxItemAmount;
            public Dictionary<string, float> attachments;
            public float chance;
            public int skinID;
        }
        #endregion

        #region Config
        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        private void LoadVariables()
        {
            smallMinItems = Convert.ToInt16(GetConfig("Small Presents", "Min Items", 1));
            smallMaxItems = Convert.ToInt16(GetConfig("Small Presents", "Max Items", 1));
            smallPresentsToUse = Convert.ToInt16(GetConfig("Small Presents", "Num Needed To Unwrap", 1));

            mediumMinItems = Convert.ToInt16(GetConfig("Medium Presents", "Min Items", 3));
            mediumMaxItems = Convert.ToInt16(GetConfig("Medium Presents", "Max Items", 3));
            mediumPresentsToUse = Convert.ToInt16(GetConfig("Medium Presents", "Num Needed To Unwrap", 1));

            largeMinItems = Convert.ToInt16(GetConfig("Large Presents", "Min Items", 5));
            largeMaxItems = Convert.ToInt16(GetConfig("Large Presents", "Max Items", 5));
            largePresentsToUse = Convert.ToInt16(GetConfig("Large Presents", "Num Needed To Unwrap", 1));

            mediumMinBagsItems = Convert.ToInt16(GetConfig("Medium Loot Bag", "Min Items", 3));
            mediumMaxBagsItems = Convert.ToInt16(GetConfig("Medium Loot Bag", "Max Items", 3));
            mediumBagsToUse = Convert.ToInt16(GetConfig("Medium Loot Bag", "Num Needed To Unwrap", 1));

            largeMinBagsItems = Convert.ToInt16(GetConfig("Large Loot Bag", "Min Items", 5));
            largeMaxBagsItems = Convert.ToInt16(GetConfig("Large Loot Bag", "Max Items", 5));
            largeBagsToUse = Convert.ToInt16(GetConfig("Large Loot Bag", "Num Needed To Unwrap", 1));

            mediumMinEggsItems = Convert.ToInt16(GetConfig("Silver Egg", "Min Items", 3));
            mediumMaxEggsItems = Convert.ToInt16(GetConfig("Silver Egg", "Max Items", 3));
            mediumEggsToUse = Convert.ToInt16(GetConfig("Silver Egg", "Num Needed To Unwrap", 1));

            largeMinEggsItems = Convert.ToInt16(GetConfig("Gold Egg", "Min Items", 5));
            largeMaxEggsItems = Convert.ToInt16(GetConfig("Gold Egg", "Max Items", 5));
            largeEggsToUse = Convert.ToInt16(GetConfig("Gold Egg", "Num Needed To Unwrap", 1));

            santaMinItems = Convert.ToInt16(GetConfig("Santa Drop", "Min Items", 6));
            santaMaxItems = Convert.ToInt16(GetConfig("Santa Drop", "Max Items", 12));

            weaponsSpawnWithAmmo = Convert.ToBoolean(GetConfig("General", "Weapons Spawn With Random Ammo", true));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (data.TryGetValue(datavalue, out value)) return value;
            value = defaultValue;
            data[datavalue] = value;
            Changed = true;
            return value;
        }
        #endregion

        #region Vars
        private List<ItemInfo> smallList = new List<ItemInfo>();
        private List<ItemInfo> mediumList = new List<ItemInfo>();
        private List<ItemInfo> largeList = new List<ItemInfo>();
        private List<ItemInfo> mediumListHalloween = new List<ItemInfo>();
        private List<ItemInfo> largeListHalloween = new List<ItemInfo>();
        private List<ItemInfo> mediumListEaster = new List<ItemInfo>();
        private List<ItemInfo> largeListEaster = new List<ItemInfo>();
        private List<ItemInfo> santaList = new List<ItemInfo>();

        private int smallPresentsToUse = 1;
        private int mediumPresentsToUse = 1;
        private int largePresentsToUs